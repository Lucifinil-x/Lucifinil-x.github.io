<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[测试]]></title>
    <url>%2F2020%2F04%2F30%2F%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[操作系统的特征1.并发（执行）： 多个事件交替发生，某一时刻最多发生一个事件2.共享（资源）： 互斥共享和同时共享 互斥共享：一个时间段内只允许一个进程访问该资源 例子： 摄像头只能被qq或微信使用。 同时共享：一个时间段内允许多个进程访问该资源 （都是cpu交替访问） 例子： qq和微信同时发送文件 ，这两个进程交替着访问硬盘资源。 【特征之间的关系】 并发与共享互为存在条件，是最基本的两个特征 3.虚拟： 虚拟技术的空分复用技术（虚拟存储器技术）： 程序需要的内存远大于系统内存；内存不够分内存。 虚拟技术的时分复用技术（虚拟处理器技术）： 实际上只有一个cpu,用户感觉有多个cpu在服务；处理器不够分处理器。 【特征之间的关系】 没有并发性就谈不上虚拟性 4.异步： 多个程序并发执行时，进程的执行走走停停，不可预知每次运行多久停，可能导致运行结果的不确定性。 【特征之间的关系】 只有系统有并发性，才可能导致异步性 操作系统的发展和分类 操作系统的几个发展阶段1.手工操作阶段： 读纸带条； 缺点：人输入速度慢 2.批处理阶段： 单道批处理系统： 读纸带存到磁带上，计算机读取磁带，输出磁带，再到纸带。 缺点：cpu大量时间是在等待输入输出。 多道批处理系统（操作系统正式诞生）： 每次往内存中输入多道程序，并发执行，共享计算机资源。资源利用率大幅提升。 缺点：用户提交完作业后，只能等待计算机处理完成，中间用户不能控制自己的作业执行。 资源利用率大幅提升原因： 输入、计算、输出都在流水线工作，不会等待。 内核态 用户态两种处理器状态：(cpu是处理器)1.用户态： cpu只能执行非特权指令2.核心态： cpu可以执行特权指令，也可以执行非特权指令 PSW程序状态寄存器：标识cpu处理器状态—– 0为用户态，1为核心态两种程序：1.应用程序： 只能执行非特权指令；程序在用户态运行 2.内核程序： 可以执行特权指令，也可以执行非特权指令；程序在核心态运行操作系统功能=内核功能+非内核功能内核： 计算机上配备的底层软件 注：原语是一种特殊的程序，是最接近硬件的部分，原语这种程序的运行具有原子性（一旦执行就会执行完，不会中断）操作系统体系结构 = 企业管理内核 = 企业管理层，负责重要工作（特权指令）； 普通员工只能执行非特权指令。用户态与核心态之间的切换 = 普通员工和管理层之间的工作交接 大内核：效率高，难维护； 比如小企业，管理层管大部分事情 功能都放在内核，核心态运行微内核：效率低，易维护； 比如大企业，管理层管最核心的工作 只有基本功能放在内核，频繁的在核心态和用户态之间切换 中断和异常中断： 中断发生时，cpu立刻从用户态进入核心态，操作系统获得计算机的控制权；当前进程暂停，操作系统根据不同的中断信号进行不同的处理。【有中断才有多道程序并发执行】【中断是cpu从用户态到核心态的唯一途径】 1.内中断：信号来自cpu内部，也称异常；比如指令中断，故障，软件报错2.外中断：信号来自cpu外部；比如外设发出的信号，用户终止进程 系统调用把调用硬件的办法封装成系统调用，供人通过应用程序间接的操作硬件。 系统调用发生在用户态；系统调用的处理发生在核心态。 执行陷入指令会产生内中断，使cpu从用户态立即进入核心态 进程进程的定义，组成，组织方式，特征进程：进程是资源分配、接受调度的基本单位，是进程实体的运行过程。 PCB: 每个进程运行之前，操作系统会配置一个数据结构 PCB（进程控制块），来存储进程的各种信息（程序代码的存放位置，数据段的位置，见图）。和进程管理有关的数据肯定是放在PCB里面的。 进程实体 = 程序段+数据段+PCB； 进程实体是进程需要的数据的集合，它是静态的；进程是进程实体运行的过程，它是动态的。 创建进程 = 创建进程实体中的PCB；撤销进程 = 进程组织方式：用队列或者索引表，下面是队列的用几种指针组织进程（组织PCB）：1.执行指针2.就绪队列指针：优先级高的放在队列头3.阻塞队列指针 进程特征：动态性；并发性；独立性（进程是资源分配、接受调度的基本单位）；异步性（进程的执行走走停停，不可预知每次运行多久停，可能导致运行结果的不确定性。）；结构性。 进程状态为了方便操作系统进行进程的管理分成了五种状态。 三种基本状态：1.运行态running: 占用cpu资源，在cpu上运行2.就绪态ready: 万事俱备，只差cpu.具备运行条件，但没有空闲cpu。(有除了处理机之外的所有需要的资源，一旦获得处理机cpu，立即进入运行态)3.阻塞态/等待态waiting/blocking: 因为某些事件而暂时不能运行 另外两种状态：1.创建态new: 创建进程，操作系统给进程分配资源，初始化PCB2.终止态terminated: 进程从操作系统中撤销，回收资源，撤销PCB 进程状态的转换：主要注意只能是 运行态-&gt;阻塞态-&gt;就绪态 进程控制进程控制: 是实现进程状态之间的转换，用原语实现。 需要做的事情：1.更新PCB信息2.将PCB插入对应的进程状态PCB队列3.回收/分配资源 怎么做上面的三件事情： 用几个原语实现进程控制：原语是一种特殊的程序； 原语采用“关中断和开中断的特权指令”； 执行期间不会被中断，一气呵成；“关中断和开中断指令”的权限非常大，是只能在核心态执行的特权指令（原语在核心态运行）。 相关原语（对进程操作的特权指令）：创建原语，终止原语，阻塞原语，唤醒原语，切换原语。阻塞和唤醒要成对出现 进程通信进程通信： 进程之间的信息交换 线程和多线程模型线程相当于轻量级进程，便于创建销毁。 线程增加了并发度，让qq应用（一个进程）中边聊天边发送文件得以实现。 cpu则服务于进程中的线程。 同一线程中的线程切换不需要切换进程的运行环境，系统开销变小。 多线程模型：1.多对一： 多个用户线程映射到一个内核级线程。 处理机调度调度基础知识调度：选择哪个先调。 作业： 程序、项目。挂起状态：内存不够，不能获得cpu就先掉到外存去，与阻塞状态不同的是阻塞时还是在内存中。 进程调度时机]]></content>
  </entry>
  <entry>
    <title><![CDATA[操作系统原理中文版]]></title>
    <url>%2F2020%2F04%2F24%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%96%87%E7%89%88%2F</url>
    <content type="text"><![CDATA[操作系统的特征1.并发（执行）： 多个事件交替发生，某一时刻最多发生一个事件2.共享（资源）： 互斥共享和同时共享 互斥共享：一个时间段内只允许一个进程访问该资源 例子： 摄像头只能被qq或微信使用。 同时共享：一个时间段内允许多个进程访问该资源 （都是cpu交替访问） 例子： qq和微信同时发送文件 ，这两个进程交替着访问硬盘资源。 【特征之间的关系】 并发与共享互为存在条件，是最基本的两个特征 3.虚拟： 虚拟技术的空分复用技术（虚拟存储器技术）： 程序需要的内存远大于系统内存；内存不够分内存。 虚拟技术的时分复用技术（虚拟处理器技术）： 实际上只有一个cpu,用户感觉有多个cpu在服务；处理器不够分处理器。 【特征之间的关系】 没有并发性就谈不上虚拟性 4.异步： 多个程序并发执行时，进程的执行走走停停，不可预知每次运行多久停，可能导致运行结果的不确定性。 【特征之间的关系】 只有系统有并发性，才可能导致异步性 操作系统的发展和分类 操作系统的几个发展阶段1.手工操作阶段： 读纸带条； 缺点：人输入速度慢 2.批处理阶段： 单道批处理系统： 读纸带存到磁带上，计算机读取磁带，输出磁带，再到纸带。 缺点：cpu大量时间是在等待输入输出。 多道批处理系统（操作系统正式诞生）： 每次往内存中输入多道程序，并发执行，共享计算机资源。资源利用率大幅提升。 缺点：用户提交完作业后，只能等待计算机处理完成，中间用户不能控制自己的作业执行。 资源利用率大幅提升原因： 输入、计算、输出都在流水线工作，不会等待。 内核态 用户态两种处理器状态：(cpu是处理器)1.用户态： cpu只能执行非特权指令2.核心态： cpu可以执行特权指令，也可以执行非特权指令 PSW程序状态寄存器：标识cpu处理器状态—– 0为用户态，1为核心态两种程序：1.应用程序： 只能执行非特权指令；程序在用户态运行 2.内核程序： 可以执行特权指令，也可以执行非特权指令；程序在核心态运行操作系统功能=内核功能+非内核功能内核： 计算机上配备的底层软件内核程序： 实现内核功能的程序，内核功能如下图： 注：原语是一种特殊的程序，是最接近硬件的部分，原语这种程序的运行具有原子性（一旦执行就会执行完，不会中断）操作系统体系结构 = 企业管理内核 = 企业管理层，负责重要工作（特权指令）； 普通员工只能执行非特权指令。用户态与核心态之间的切换 = 普通员工和管理层之间的工作交接 大内核：效率高，难维护； 比如小企业，管理层管大部分事情 功能都放在内核，核心态运行微内核：效率低，易维护； 比如大企业，管理层管最核心的工作 只有基本功能放在内核，频繁的在核心态和用户态之间切换 中断和异常中断： 中断发生时，cpu立刻从用户态进入核心态，操作系统获得计算机的控制权；当前进程暂停，操作系统根据不同的中断信号进行不同的处理。【有中断才有多道程序并发执行】【中断是cpu从用户态到核心态的唯一途径】 1.内中断：信号来自cpu内部，也称异常；比如指令中断，故障，软件报错2.外中断：信号来自cpu外部；比如外设发出的信号，用户终止进程 系统调用把调用硬件的办法封装成系统调用，供人通过应用程序间接的操作硬件。 系统调用发生在用户态；系统调用的处理发生在核心态。 执行陷入指令会产生内中断，使cpu从用户态立即进入核心态 进程进程的定义，组成，组织方式，特征进程：进程是资源分配、接受调度的基本单位，是进程实体的运行过程。 PCB: 每个进程运行之前，操作系统会配置一个数据结构 PCB（进程控制块），来存储进程的各种信息（程序代码的存放位置，数据段的位置，见图）。和进程管理有关的数据肯定是放在PCB里面的。 进程实体 = 程序段+数据段+PCB； 进程实体是进程需要的数据的集合，它是静态的；进程是进程实体运行的过程，它是动态的。 创建进程 = 创建进程实体中的PCB；撤销进程 = 撤销进程实体中的PCB；PCB是进程存在的唯一标志！ 进程组织方式：用队列或者索引表，下面是队列的用几种指针组织进程（组织PCB）：1.执行指针2.就绪队列指针：优先级高的放在队列头3.阻塞队列指针 进程特征：动态性；并发性；独立性（进程是资源分配、接受调度的基本单位）；异步性（进程的执行走走停停，不可预知每次运行多久停，可能导致运行结果的不确定性。）；结构性。 进程状态为了方便操作系统进行进程的管理分成了五种状态。 三种基本状态：1.运行态running: 占用cpu资源，在cpu上运行2.就绪态ready: 万事俱备，只差cpu.具备运行条件，但没有空闲cpu。(有除了处理机之外的所有需要的资源，一旦获得处理机cpu，立即进入运行态)3.阻塞态/等待态waiting/blocking: 因为某些事件而暂时不能运行 另外两种状态：1.创建态new: 创建进程，操作系统给进程分配资源，初始化PCB2.终止态terminated: 进程从操作系统中撤销，回收资源，撤销PCB 进程状态的转换：主要注意只能是 运行态-&gt;阻塞态-&gt;就绪态 进程控制进程控制: 是实现进程状态之间的转换，用原语实现。 需要做的事情：1.更新PCB信息2.将PCB插入对应的进程状态PCB队列3.回收/分配资源 怎么做上面的三件事情： 用几个原语实现进程控制：原语是一种特殊的程序； 原语采用“关中断和开中断的特权指令”； 执行期间不会被中断，一气呵成；“关中断和开中断指令”的权限非常大，是只能在核心态执行的特权指令（原语在核心态运行）。 相关原语（对进程操作的特权指令）：创建原语，终止原语，阻塞原语，唤醒原语，切换原语。阻塞和唤醒要成对出现 进程通信进程通信： 进程之间的信息交换 三种通信： 线程和多线程模型线程相当于轻量级进程，便于创建销毁。 线程增加了并发度，让qq应用（一个进程）中边聊天边发送文件得以实现。 cpu则服务于进程中的线程。 同一线程中的线程切换不需要切换进程的运行环境，系统开销变小。 计算机中的透明是看不见的意思。 多线程模型：1.多对一： 多个用户线程映射到一个内核级线程。2.一对一： 一个用户线程映射到一个内核级线程。2.多对多： n个用户线程映射到m个内核级线程。(n&gt;=m) 处理机调度调度基础知识调度：选择哪个先调。 作业： 程序、项目。挂起状态：内存不够，不能获得cpu就先掉到外存去，与阻塞状态不同的是阻塞时还是在内存中。 三种调度：1.作业调度（高级调度）： 选择作业从外存调入内存并创建进程。2.内存调度（中级调度）： 从挂起队列中选择进程调回内存。3.进程调度（低级调度）： 从就绪队列中选择进程分配cpu。 进程调度时机]]></content>
      <categories>
        <category>记忆性学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[spring cloud 项目]]></title>
    <url>%2F2020%2F04%2F14%2Fspring-cloud-%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[外面点餐系统项目需求 客户端： 针对普通用户，用户登录，用户退出，菜品订购，我的订单 后台管理系统：针对管理员，管理员登录，管理员退出，添加菜品，查询菜品，修改菜品，删除菜品，订单处理，添加用户，查询用户，删除用户 功能拆分 acoount 提供账户服务： 用户和管理员的登录退出 menu 提供菜品服务： crud操作 添加菜品，查询菜品，修改菜品，删除菜品 order 提供订单服务： 添加订单，删除订单，查询订单，处理订单 user 提供管理员对用户的管理服务： crud操作 添加用户，查询用户，删除用户 第一章微服务环境搭建第一步 写pom.xml 添加依赖 没有添加视频中jdk9相关依赖1234567891011&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Finchley.SR2&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; 第二步 项目中创建注册中心模块(一个子项目)： eurekaserver 先修改总项目pom.xml打包方式，不然不能添加maven module123&lt;artifactId&gt;springcloud-take-out-order&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; 写eurekaserver配置以下为未能启动的子项目，现在已经新建了starter项目才能启动，内容添加和下面一致 在总项目中创建maven module，他会出来一个文件夹和一个同名并列的项目，右键文件夹有一个go to project “registration”以下编辑在下面的项目中添加, 会同步到总项目中的同名文件夹（所有文件都同步了，只是文件夹有点多） registration子项目中添加依赖： pom.xml 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 写他的配置文件: application.yml 12345678server: port: 8761eureka: client: service-url: defaultZone: http://localhost:8761/eureka/ register-with-euraka: false #是否注册他自己 fetch-registry: false # 是否导入数据 写启动类： RegServerApplication.java项目为starter项目时，根本不用自己写启动类，自带有 12345678@SpringBootApplication@EnableEurekaServerpublic class RegServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(RegServerApplication.class,args); &#125;&#125; 第三步 子项目configServer第四步 创建服务提供者 子项目orderpom.xml 中有一个视频上是config 我的自动加的的config-server 第五步 测试启动先启动注册中心eureka,配置中心comfig,服务提供者order menu 第二章 创建服务提供者 menu子项目第一步 创建+配置pom 创建时添加依赖：mybatis-spring-boot-starter；spring-boot-starter-web；spring-cloud-starter-config（让他读取配置中心的配置文件）；mysql-connector-java（mysql版本可以写最新的，能兼容老版本）；spring-cloud-starter-netflix-eureka-client（让他在注册中心进行注册，让他成为一个服务） 有mysql mybatis的依赖，需要在配置文件中加入数据库的连接信息在configServer子项目中的menu-dev.yml加mydql信息 第二步 复制order里的bootstrap.yml配置文件 改name123456789spring: application: name: menu profiles: active: dev #这里是整合到在configServer里面的order-dev.yml cloud: config: uri: http://localhost:8762 #configServer的端口号 注意是uri不是url fail-fast: true 第三步 configServer中添加menu的配置文件123456789101112131415161718server: port: 8020spring: application: name: menu datasource: name: orderingsystem url: jdbc:mysql://localhost/orderingsystem?serverTimezone=UTC username: root password: zhangcaiyun driver-class-name: com.mysql.cj.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSourceeureka: client: server-url: defaultZone: http://localhost:8761/eureka/ instance: prefer-ip-address: true 目前问题 http://localhost:8020/menu/index访问不到 http://localhost:8020/访问不到 configServer中配置文件没有连接上 第四步 复制sql语句去数据库中创建+更新表格第五步 menu中关联数据库中的那几张表Menu表entity包中写Menu表格的实体类：Menu1234567891011import lombok.Data;@Datapublic class Menu &#123; private long id; private String name; private double price; private String flavor; &#125; repository包中写Menu的接口（dao层）：MenuRepo 作用：定义操作数据库Menu表格的java方法123456789public interface MenuRepo &#123; public List&lt;Menu&gt; findAll(); //查询全部数据 public int count(); //查询记录条数 public Menu findById(long id); //用主键id查找记录，返回Menu对象，记录都成为Menu对象中的属性值 public void save(Menu menu); public void update(Menu menu); public void delectById(long id);//用主键删掉记录&#125; 用mybtis的Mapper写MenuRepo接口的实现类： Mapper.xml(包括MenuRepo.xml,TypeRepo.xml) 作用：实现作数据库Menu的接口方法的sql语句 resources路径下创建mapping文件夹：在同级文件夹上点击创建folder file configServer中menu-dev配置文件中添加mybtis 1234mybatis: mapper-locations: classpath:/mapping/*.xml type-aliases-package: com.example.demo.entity #提出menu下的entity包; 在mapping的xml文件中就不用再写包名 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.southwind.repository.MenuRepository&quot;&gt; &lt;resultMap id=&quot;menuMap&quot; type=&quot;Menu&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;mid&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;mname&quot;/&gt; &lt;result property=&quot;author&quot; column=&quot;author&quot;/&gt; &lt;result property=&quot;price&quot; column=&quot;price&quot;/&gt; &lt;result property=&quot;flavor&quot; column=&quot;flavor&quot;/&gt; &lt;!-- 映射type --&gt; &lt;association property=&quot;type&quot; javaType=&quot;Type&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;tid&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id=&quot;findAll&quot; resultMap=&quot;menuMap&quot;&gt; select m.id mid,m.name mname,m.price,m.flavor,t.id tid,t.name tname from t_menu m,t_type t where m.tid = t.id order by mid limit #&#123;param1&#125;,#&#123;param2&#125; &lt;/select&gt; &lt;select id=&quot;count&quot; resultType=&quot;int&quot;&gt; select count(*) from t_menu; &lt;/select&gt; &lt;insert id=&quot;save&quot; parameterType=&quot;Menu&quot;&gt; insert into t_menu(name,price,flavor,tid) values(#&#123;name&#125;,#&#123;price&#125;,#&#123;flavor&#125;,#&#123;type.id&#125;) &lt;/insert&gt; &lt;select id=&quot;findById&quot; resultMap=&quot;menuMap&quot;&gt; select id mid,name mname,price,flavor,tid from t_menu where id = #&#123;id&#125; &lt;/select&gt; &lt;update id=&quot;update&quot; parameterType=&quot;Menu&quot;&gt; update t_menu set name = #&#123;name&#125;,price = #&#123;price&#125;,flavor = #&#123;flavor&#125;,tid = #&#123;type.id&#125; where id = #&#123;id&#125; &lt;/update&gt; &lt;delete id=&quot;deleteById&quot; parameterType=&quot;long&quot;&gt; delete from t_menu where id = #&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; 启动类添加注解@MapperScan(“com.example.demo.repository”) 这是mybits的功能，在启动时把mapper.xml文件扫描进容器。容器中注入后就会有MenuRepo接口对象]]></content>
      <categories>
        <category>springboot</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[c语言]]></title>
    <url>%2F2020%2F03%2F24%2Fc%E8%AF%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[字符数组问题 c语言中是没有字符串数组的；而且字符串的本质是字符数组。 strlen() 函数用于计算数组的长度。本质上是计算到’\0’结束。那么当数组中没有存满时计算结果就会出错。则需要在填充数组之后手动加上 A[i]==’\0’;再进行计算。 不能存很多字符串那怎么办呢？输入一个字符串，就遍历这个字符串对应的字符数组。12345char word[90];scanf(&quot;%s&quot;,word);while(word[m]!=&apos;\0&apos;)&#123; m++; &#125; 输入问题scanf输入一串字符不能结束的问题 scanf的结束占位符尚且不知道；而且EOF不能用回车结束 可以换成getchar()，它以回车结束输入12345678910 char A[30];char name;int i=0;while((name= getchar())!=&apos;\n&apos;)&#123; A[i]= name; i++;&#125; scanf输入可以以空格或者回车结束指针传参问题 void reverseAB(int *arr, int a, int b) //注意传数组表示 int countFives(int A[], int num) //注意传数组表示]]></content>
      <categories>
        <category>c语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot踩坑记录]]></title>
    <url>%2F2020%2F03%2F01%2FSpringBoot%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[代码对比完全一致，callback页面404，且控制台不打印 血的教训：所有java包和类放在启动类所在的包里，否则run不运行这些类，但控制台不报错。 报错 BeanFactory 和bean一点关系也没有，原因： mapper映射文件中映射的mapper类的包名少写了一个mapper。而且这是最初没有写错的，是在试着改bug的时候改掉的。 1&lt;mapper namespace=&quot;com.example.demo.mapper.UserMapper&quot;&gt; 一定要先对照代码，特别是xml配置文件！写错没提示。 local网页自动跳转到我印象中没有写的页面toLogin 原本以为是之前运行的项目没关干净，测试了其他项目可以运行，网页跳转没有问题。那么一定是这个项目的代码哪里写错了。 发现并不是controller中的问题，是ShiroConfig类中粘贴代码没删掉拦截和自动跳转toLogin. 整合mybits实现用户登录，连接sql数据库。网页输入时控制台报错 目前正确配置文件的代码：12345678910spring.datasource.driverClassName=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost/springboot_shiro?serverTimezone=UTC //url这里不用写主机ip,不用写3306（3306加上也可以成功运行）spring.datasource.username=root //用户名在sqlyog的客户端里数据库上面写的root@localhost,@前面的就是用户名spring.datasource.password= //密码记在手机里了spring.datasource.type=com.alibaba.druid.pool.DruidDataSourcemybatis.type-aliases-package=com.example.demo.domain 报错 mysql access deny for 找了很久的报错 原因：spring.datasource.url=jdbc:mysql://localhost:3306/test 粘贴代码的时候没有改成自己的数据库名字，改回来就继续报错下面的问题，不过下面的问题都能百度到。 一定要检查代码每个字，在配置文件中写错是没有提示的而且很难发现，昨天的错误就是配置文件中少写了一个包名，报错提示完全和配置文件不沾边。 不知道是不是原因:之前没有添加jdbc的依赖 测试mysql数据库密码：搜索mysql会出来mysql的命令行打开就是要输入password控制台提示：Loading class com.mysql.jdbc.Driver&#39;. This is deprecated. The new driver class iscom.mysql.cj.jdbc.Driver’. 不会影响运行 在总配置文件中修改 报错com.alibaba.druid.pool.DruidDataSource: create connection error druid依赖版本/数据库连接池的包版本需要改成新版本 1234567&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.9&lt;/version&gt;&lt;/dependency&gt;``` 版本修改为： com.alibaba druid 1.1.10 1234- 以后报错还得改成更新版本### 报错The server time zone value &apos;�й���׼ʱ��&apos; is unrecogni- 在MySQL的URL后面加上“?serverTimezone=UTC” ，如下所示： spring.datasource.url=jdbc:mysql://localhost/springboot_shiro?serverTimezone=UTC 123## shiro授权过滤器没用- 键值对集合中只能一个key一个value，具体为什么不行我不知道。 filterMap.put(&quot;/add&quot;, &quot;authc&quot;);//authc必须认证才能访问 filterMap.put(&quot;/update&quot;, &quot;authc&quot;); //授权过滤器，登录过的user在add页面需要拿到add页面的授权才能访问 //在登录后点击添加时，就会进入授权逻辑 filterMap.put(&quot;/add&quot;, &quot;perms[user:add]&quot;);1修改为 filterMap.put(“/test”, “anon”); filterMap.put(“/login”, “anon”); //授权过滤器，登录过的user在add页面需要拿到add页面的授权才能访问 //在登录后点击添加时，就会进入授权逻辑 filterMap.put(“/add”, “perms[user:add]”); filterMap.put(“/*”, “authc”); 123456789101112## 一直标红其他代码没有问题- 删掉，重新自动添加方法就不红了。- 还是爆红，运行了没报错，不报红了## 报错 sql syntax error- sql语句 select xx from 中间没有逗号- 其他的部分大小写- 整数类型写int## 报错 server.port获取不到 ；还没有安全修改办法- 把server.port 改成 server:port @Value(“${server:port}”) private String port;``` 配置文件中 项目名大小写写错了一个 但是就不是配的8080了，变成8080,而且这个页面获取不到端口号 mysql,mybities数据库连接报错 控制台报错If you have database settings to be loaded from a particular profile you may need to activate it (no profiles are curren) 项目启动类上加@SpringBootApplication(exclude={DataSourceAutoConfiguration.class}) 因为menu的数据库配置代码在configServer中，现在还没有连接成功 ，暂时不知道数据库的问题 @Data cannot be resolved to a type 标红 因为没有lombok的包 解决：鼠标移动到标红 选最下面fix project setup 选择lombok的包 这样是在maven仓库中新加入lombok的包，就能在项目中导入包，就好了 报错Unsatisfied dependency expressed through field ‘menuRepo’ 这个是controller类中注入实现接口功能时的报错 检查步奏：1.启动类@MapperScan(“com.xx.xx”)2.pom 3.配置文件[这个不会标红，很多都是这里单词什么的写错了] 还没解决。]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>bug</tag>
        <tag>解决办法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人工智能入门学习]]></title>
    <url>%2F2020%2F02%2F24%2F%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[CSE112 鸡肋，过时，繁杂，背书30% 两次课上考试，80%是以前原题，一个 个人assignment，去年是prolog解决算法问题70% 期末，概念和大题，背书只有这个文件夹里有题的资料，概念总结和当堂测试题目 lecturesweek1 introduction 机器学习和AI技术的功能 Machine learning and Artificial intelligence will be used to analyze the data and provide a better service to human activities. AI covers a wide range of technologies including: image/speech recognization, language processing, user profiling剖析(data visualization), recommandation system. The boundaries between cloud computing and big data becomes blurred.变模糊 intelligent image captioning智能给图片加文字注解 It is evolving to learn from data. 什么是AI AI is the activity that is related to people’s thinking,such as decision making,problem solving, learning. 电脑语音合成 computer speech synthesis translate text to phonetic form week2 week AI &amp; strong AIsimulation of a cognitive process / actually be a mind 4 research perspectivesacting、thinking humanly: dulicate what human brain doesacting、thinking rationally: 取得最大化好处 intelligent agent 智能代理 智能主体agent is an entity that perceives and act OR is a function from percept to act.通过感应器sensor感知perceives环境，通过执行器actuator做出动作action，最大化的达成目标agent= architecture + program 硬件加代码 agent rationality:task environment(PEAS)P: performance measure评判标准 - an objective criterion for success of an agent’s behavior 比如最少的能量干最多的事情E: environment 环境中有什么东西 比如固定的面积 不定的分布量distribution unkown 动作确定的deterministicA: actuators 执行的动作 比如 左转右转 suck吮吸 noOpS: sensors 比如 感知到所在位置和目标在的位置 environment type环境类型真实世界的领域一般都是只能部分观察，不确定性，不静止，不连续 agent type 主体（机器人）类型 解决问题的考虑stateinitial stateactionsgoal testpath cost week3 搜索和prolog 对应北大视频p22 8数码难题：状态：9x9棋盘，8个数字滑块占据一个方块，空格占据最后一个方块初始状态：任意状态动作：空格的移动：上下左右模型转换：空格向左移动=棋子向右移动目标检测：八个棋子在目标位置路径代价：路径的步数，每一步为1代价 8皇后问题：8x8棋盘上放八个皇后，两两不能在同一行同一列同一斜角线上。两种解决办法：1.一个一个放上去 2.任意放再调整位置 图搜索最短路径问题结点扩展 树搜索最短路径问题 通用的树搜索算法结点存储在list，扩展结点，直到找到目标结点 图的宽度优先搜索算法 Breadth Firth：算法complete but 内存expensive算法完整complete:保证算法在有限时间内找到一个解; 需要的时间短不能解决 指数复杂性问题，内存是很大问题。先找完兄弟节点扩展最浅（上面）的扩展结点，同级扩展结点因为先从最上层判断没有就删除，所以用的队列，先进先出 深度优先搜索 Depth first search ：内存cheap but 算法incomplete时间长，空间（需要的内存）小有兄弟结点和子节点时，完全搜索完子节点再回头搜索兄弟节点向下扩展结点，没有找到的话就从内存中删除因为最下面的是新加入判断的，没有就删除，所以用的堆栈，后进先出 一致代价搜索算法UCS Uniform Cost Search = Dijkstra算法？？？(UCS)：扩展的是路径消耗g(n)最小的节点n,用优先队列来实现，对解的路径步数不关心，只关心路径总代价。即使找到目标节点也不会结束，而是再检查新路径是不是要比老路径好，确实好，则丢弃老路径。 启发函数f： f（n）= g（n） Uniform Cost Search是a* 搜索的特例 怎么算长度： 一致代价的长度就等于出发点和某点的可以走通的直线距离（实际线段长度） prolog:描述性语言 week4 几个信息搜索算法总结：A* search最优最有效 DFS : 深度优先 BFD : 宽度优先 Depth limited search (DLS) 深度限制搜索：解释： 在进行深度优先搜索时，每条路径上在到达指定的步数后停止此条路径的搜索。术语： 深度 = d ; 宽度 = b适用情况： 已知解的最大深度； 解有深度范围代码表示： if (depth(node) &lt; depth limit) 才能执行搜索代码 Iterative deepening search (IDS) 迭代深化搜索：每次从头开始，第一次搜两层，第二次从头开始搜三层，第三次从头开始搜四层就是深度搜索 解释： 当宽度很大和深度未知时，不断的进行(DLS) 深度限制搜索，深度限制从0一直向上增加。 特点：时间换空间Trade off time for memory 需要多一点的时间，但可以节约很多内存 算法完整和最优 DLS 和 IDS 对比：Nodes expanded with depth-limited search: 1+b+b2+b3+…+bd-1+bdNodes expanded with iterative deepening search: (d+1)1+(d)b+(d-1)b2+(d-2)b3+…+(2)bd-1+(1)bd IDS is complete and optimal IDS 算法完整和最优；DLS 和 IDS 改进了基础的宽度优先和深度优先搜索技术 Avoiding repeated states 避免重复状态Do not return to the state you have just come fromDo not create paths with cycles in them (do not create a node the same as any ancestor)Do not generate any state that was ever generated before Heuristic search启发式 h(n)解释：基于问题考虑，选择最有可能的路径；一致代价搜索USC是当前结点的路径，启发式搜索是计算剩余路径特点：启发式搜索是信息搜索的核心方法 Greedy search贪婪比如八滑块问题：直接计算需要调整的滑块个数；或者替换错位滑块需要走的直线距离启发函数f：f（n）= h（n）特点：快速；可能找不到解；可能第一步错误；只从当前结点计算，忽略之前的结点重点：未能远谋，不一定是最优长度（最短路径）； 只看期望长度（走横着竖着的格子，曼哈顿距离）；只选择下一个h最小的结点 Greedy first searchgreedy first只扩展hn最小的结点，一路走到头。不会比较，也不看gn.所以，他可能找不到短的路径，叫贪婪搜索 一致代价搜索算法UCS计算！：fn = gn + 0; 计算所有路径的gn,选择其中最短; (uniform cost就是A* 的hn等于0的情况) 当每条路都一样长的时候 ，就= 宽度搜素 A* search计算！：fn = gn + hn；计算所有路径的fn,选择其中最短(走过的路径基本就是最短路径了;其实不是比所有路径，因为没具体到把所有路径都算一遍，只是在看边界节点fn是否小，如果再往下拓展fn比frontier队列里的节点的fn大就会换别的节点) 最优，最小cost path 解释：结合了一致代价和贪婪搜索；注重于已用的成本和到目标的成本；为了最小化代价minimize the overall cost 启发函数f： f（n）=g（n）+h（n）= 开始到n结点的路径成本 + 从n 到目标的最短的解 = 一致代价+贪婪搜索比如8滑块问题， g(n)是空白滑块移动步数， h(n)是要调整的滑块个数 A* 的机制就导致它会比uniform cost更准确一些，然后走过的路径基本就是最短路径了 曼哈顿距离 h 预估距离 某点到终点的 横着走几格，竖着走几格，加起来的距离 可以穿墙斜边长度表示为直角两边的和a+b;不再用根号表示（虽然有误差，但是如果大家都这么算那么就变得比较好比较）算横着走几格，竖着走几格，加起来 实际距离 g 出发点和某点的可以走通的直线距离 斜着14 横着10，有拐点的要算两条直线和 启发式函数h(n)在A* 中的作用 ？？？？？？很有问题 启发式函数可以用来控制A的行为。一种极端情况，如果h(n)是0，则只有g(n)起作用，此时A 算法演变成Dijkstra算法=一致代价搜索，就能保证找到最短路径。 如果h(n)总是比从n移动到目标的代价小（或相等），那么A* 保证能找到一条最短路径。h(n)越小，A* 需要扩展的点越多，运行速度越慢。 如果h(n)正好等于从n移动到目标的代价，那么A* 将只遵循最佳路径而不会扩展到其他任何结点，能够运行地很快。尽管这不可能在所有情况下发生，但你仍可以在某些特 殊情况下让h(n)正好等于实际代价值。只要所给的信息完善，A* 将运行得很完美。 如果h(n)比从n移动到目标的代价高，则A* 不能保证找到一条最短路径，但它可以运行得更快。 另一种极端情况，如果h(n)比g(n)大很多，则只有h(n)起作用，同时A* 算法演变成贪婪最佳优先搜索算法（Greedy Best-First-Search）。 搜索总结迭代深度搜索 一致代价搜索 最优 A搜索 最优 week5 KR 陈述性知识表示，Rule-based Systemsrule-based system 知识 = 规则（rule）的集合 Rule-Based System的结构：rule的集合，fact的集合 Rule-Based System的应用例子expert system：帮助医生用rule来推断诊断 Expert system = inference engine推理机器 + knowledge base + data；传统程序Program = algorithm + data；两者区别很大 knowledge base知识库: 存rule规则（条件） database ： 存fact inference engine推理机器： 将知识库和数据库中的rule和fact联系起来 explanation facilities解释工具： 从rule推理得出结论的过程解释 user interface 用户界面： 用户和专家系统之间交流通信 control scheme已知一些规则，用他们去产生新知识，有前向链接和反向链接两种方法 Forward chaining 前向链接：从fact开始，以fact来找需要用到的rule.(Data-driven search)适用情况：所有fact已知，goal的信息困难，一小部分初始状态，但有大量结论。 Backward chaining 反向链接:从要查找的结论开始，来找需要用到的rule.(Goal-driven search)适用情况： 需要时获取数据（当数据采集成本很高时），容易形成假设/目标（比如医学诊断），少量初始假设/目标 二者区别：前向链接从已知事实开始，然后应用推理规则提取更多数据，然后继续向前移动直到到达目标；然后前向链接从目标开始，并使用推理规则确定后向链接满足目标的事实。前向链接称为数据驱动推理技术，后向链接称为目标驱动推理技术。正向链接称为向下搜索方法，而反向链接称为自上而下搜索方法。前向链采用广度优先搜索策略，后向链采用深度优先搜索策略。正向链接可用于规划、设计过程监控、诊断和分类任务，反向链接可用于分类和诊断任务。前向链接可能类似于穷举搜索，而后向链接则试图避免不必要的推理。在正向链接中，知识库中可能存在各种提问问题；在反向链接中，可能存在较少的提问问题。前向链接检查所有规则，因此速度较慢，而前向链接只检查一些必要的规则，因此速度较快。 prolog语言swing-prolog使用 file-consult 之后一堆error不用管 然后打开xxx.pl文件 就加载上了；在里面输入命令就能用了 prolog语言是陈述性语言，用于描述陈述性知识。可以 表示事实与规则离散数学相关条件概率p = (已发生事件 和 未发生事件 同时发生的概率)/ 已发生事件的概率]]></content>
      <categories>
        <category>记忆性学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[操作系统原理]]></title>
    <url>%2F2020%2F02%2F24%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[CSE108 抽象难学20% 10%是lab的全部assignment 和全部exercise ，没有提到quiz； 10%是四个homework80% 期末考，没有选择，全是大题：概念复述和计算 lecturesweek1 Introduction. Operating Systems Structures. 操作系统做什么 组织 结构 处理 进程管理 内存管理 长期储存管理 安全和保护 计算环境 开发资源处理系统 open-source operating system quiz:1.Multiprogramming of computer system increases CPU utilization 2.Main memory of computer system is known to be volatile 3.Multiprocessor system have advantage of Increased Throughput 4.Multi-processor systems of computer system has advantage of reliability 5.To start an I/O operation device driver loads appropriate register into is said to be Device Controller 6.Processor is often referred to Central Processing Unit 7.Cache memory is intended to provide memory access Fastest 8.Another type of multiple-CPU system is the Clustered System集群系统 9.The systems which allows only one process execution at a time, are called uniprogramming systems 单程序设计系统 10.What is operating system? b. link to interface the hardware and application programs c. system service provider to the application programs d. collection of programs that manages hardware resources 11.OS is responsible for transferring data to I/O devices 12.Symmetric multiprocessing architecture of computer system uses shared Buses &amp; Memory 13.In a multi-programming environment : the processor executes more than one process at a time 14.Environment for execution of programs is provided by operating system 15.One that is not a type of multiprocessor of computer system is single core week2 Process概念 concept 进程是什么，进程和程序的关系：进程是正在执行的程序，必须按顺序执行一个进程是一个活动的实体 active entity / 一个程序program是一个被动的实体 passive entity.当可执行文件加载进内存的时候，程序就变成进程。 操作系统执行多种程序：批处理系统 batch system – 批处理系统，又名批处理操作系统。批处理是指用户将一批作业提交给操作系统后就不再干预，由操作系统控制它们自动运行。这种采用批量处理作业技术的操作系统称为批处理操作系统。批处理操作系统分为单道批处理系统和多道批处理系统。批处理操作系统不具有交互性，它是为了提高CPU的利用率而提出的一种操作系统。 分时系统 time-shared system – user programs/tasks分时系统是指允许多个用户同时共享计算机资源的操作系统。系统必须通过CPU切换来执行多个任务 内核线程和用户线程用户线程指不需要内核支持而在用户程序中实现的线程，其不依赖于操作系统核心，用户进程利用线程库提供创建、同步、调度和管理线程的函数来控制用户线程。用户线程不需要用户态/核心态切换，速度快，操作系统内核不知道多线程的存在，因此一个线程阻塞将使得整个进程（包括它的所有线程）阻塞。由于这里的处理器时间片分配是以进程为基本单位，所以每个线程执行的时间相对减少为了在操作系统中加入线程支持，采用了在用户空间增加运行库来实现线程，用户线程是不能被操作系统所感知的。内核线程和用户线程都有自己的优势和缺点，一般配合使用 进程控制块PCB process control block 是什么：PCB是一种存储数据的数据结构。又被称作 进程的上下文context。每个进程都是由它自己的PCB控制。它自己的PCB都驻留在主内存中。所有进程的PCB展示在一个链表中。PCB在多程序环境中很重要，捕获同时运行程序的信息。 PCB关联的组件，PCB里存了些什么：进程状态：程序计数器： 指向（在任何）进程中执行的下一条指令的地址。寄存器信息： 与进程相关的各种寄存器调度信息： 是用于设置管理 进程的优先级的。内存管理信息： 分配给进程的内存记账accounting信息： 存储CPU的利用率，进程执行时间，启动的时钟时间，时间限制IO状态信息： 分配给处理器的IO设备，打开文件的列表 特征 调度 scheduling（设置管理 进程的优先级）进程调度器scheduler： 从内存中选择准备执行的进程，将CPU分配给它。1.短期调度器：选择下一个执行的进程并分配CPU2.长期（或job）调度器： 选择哪些放到准备队列中。控制内存中进程的数量。3.中期调度器：程序多了，需要减少的时候。就从内存中删掉程序，存到硬盘上。从硬盘上返回继续执行swapping 调度队列scheduling queues: 1.job队列–系统中所有进程的集合 2.ready队列： 准备，等待着被执行的进程的集合 3.设备对象：等待IO设备的进程的集合 进程大概分为： I0-bound(多IO少计算) ； CPU-bound(多计算少IO) context switch 上下文切换：CPU切换进程通过它。保存旧进程状态，加载新进程状态。 操作 系统必须提供一下机制mechanism:process creation; process termination 进程创造机制： 父进程创造子进程，形成进程树。资源共享选项： 1.父子共享所有资源 2.子共享父资源的一个分支 3.父子不共享资源执行选项： 1.父子同时执行 2. 子结束后父执行 进程终止机制：进程执行最后一条语句，然后操作系统通过系统调用exit()删掉它。父进程可以通过系统调用abort()关掉子进程。 进程间通信 interprocess communication IPC 进程分为：1.独立进程independent： 互不影响 2.合作进程cooperating： 可以互相影响. 进程之间需要交互 可以合作的原因：信息共享、计算加速、模块modularity、方便 共享内存 shared memory一个内存区域region由合作进程共享，可以读写入数据。 例子：复制粘贴，由操作系统加密。两种缓冲器区buffer可以使用：1.无界缓冲区unbounded-buffer：无大小限制 2.有界缓冲区bounded-buffer：有固定大小 消息传递（系统） message passing各个进程之间通过操作系统完成传递。 进程1封装信息（格式化）给OS，OS再把它给进程2。有两个操作：send(); operations(). 直接/间接communication: P-&gt;Q / P-&gt;mailbox-&gt;Q同步/异步communication：blocking/ non-blocking week3 Threadsquiz:1.__ is an entity corresponding to a user job or application that owns resources such as memory and open files.process 2.A process having multiple threads of control implies ___a. it can do more than one task at a time  3.If multiple threads are concurrently searching through a database and one thread returns the result then the remaining threads must be :cancelled 4.Because the kernel thread management is done by the Operating System itself :kernel threads are slower to create than user threads内核线程的创建速度比用户线程慢 5.Termination of the process terminates ___all threads within the process 6.If the kernel is single threaded, then any user level thread performing a blocking system call will:cause the entire process to block even if the other threads are available to run如果内核是单线程的，那么执行阻塞系统调用的任何用户级线程都将： 使整个进程阻塞，即使其他线程可以运行 7.The model in which one kernel thread is mapped to many user-level threads is called ___Many to One model 8.A thread is also called ___Light Weight Process(LWP) 9.A process can be ___both single threaded and multithreaded 一个进程可以单或多线程 10.The register context and stacks of a thread are deallocated when the thread:terminated当线程终止，线程的寄存器上下文和堆栈被释放 11.Multithreading on a multi – CPU machine ___increases concurrency 增加并发性 12.Resource sharing helps:a. share the memory and resources of the process to which the threads belong. b. reduce the address space that a process could potentially use c. an application have several different threads of activity all within the same address spacea、 共享线程所属进程的内存和资源。b、 减少进程可能使用的地址空间c、 一个应用程序有几个不同的活动线程，它们都在同一个地址空间内 13.下面都是对的b. Related kernel level threads can be scheduled on different processors in a multiprocessor systemc. Context switch time is longer for kernel level threads than for user level threadsd. User level threads do not need any hardware support 14.When a web page is loading, and the user presses a button on the browser to stop loading the page :the thread loading the page is cancelled 15.A thread shares its resources (like data section, code section, open files) with ___other threads that belong to the same process week4 Process Synchronization同步quiz:1.Select the correct statements regarding mutex lock to prevent race conditiona process must acquire the lock before entering a critical section;it releases the lock when it exits the critical section 2.Process synchronization can be done on __both hardware and software level 3.Which of the following Multithreading model also allows multiple threads to run in parallel on multiprocessorsOne to One model 4.What state does Thread enter in when it has been created and started?Running 5.A semaphore is a shared integer variable __大于等于0 6.Which of the following Multithreading model has action “creating a user thread requires creating the corresponding kernel thread”.One to One model 7.A Race condition refers to _____A situation where several processes access and manipulate the same data concurrently 8.What is valid point about threadThread are subdivision of Process. One or more Threads runs in the context of process. Threads can execute any part of process. And same part of process can be executed by multiple Threads 9.Peterson’s solution is restricted to ____ processes that alternate execution between their critical sections and remainder sections两个 10.Mutual exclusion can be provided by the __both mutex locks and binary semaphores 11.We use the mutex lock to protect critical regions and thus prevent race conditions. The term mutex is short formutual exclusion 12.If a process is executing in its critical section, then no other processes can be executing in their critical section. This condition is called?mutual exclusion 13.A non-preemptive kernel is essentially free from race conditions对的 14.User threadsare supported above the kernel and are managed without kernel support 15.Thread shares with other threads belonging to the same process itscode section and data section 16.Which of the following condition stands true for Mutual Exclusion？If process Pi is executing in its critical section, then no other processes can be executing in their critical sections 17.Which of the following condition stands true for Mutual Exclusion?Which of the following condition stands true for Mutual Exclusion? 18.Which one of the following is a synchronization tool?semaphore 19.Each process has a segment of code, called a ____, in which the process may be changing common variables, updating a table, writing a file, and so oncritical section 20.Kernel level threads are not needed in which of the following situationsTo make thread switching and scheduling fast and efficient week5 CPU Schedulingweek6 CPU Scheduling, Deadlocksweek8 考试week9 Memoryexercise9.2 Who founded the GNU project?Richard Stallman What programming language did Linus Torvalds use to write his Linux kernel?C In which year was the Turing Award (the highest distinction in the IT field) awarded to creators of UNIX and C?1983 Which key do you use to quit the program xmas in WebLinux? You have typed nano in WebLinux, and launched the nano text editor. Now, which of the following should be used to get help inside nano An operating system is the link between:programmer and hardware Why did Linus Torvalds create Linux?because he was frustrated with the proprietary licenses Which of these lines is the command prompt on WebLinux? Which operating system is not a UNIX derivative?Windows What is the pioneering project behind the UNIX operating systemMAC What happens if you run the htop command and then press the ctrl + c keys?this leaves htop and returns to the command prompt Which option of the du command is not available on WebLinux?(du is a command that means Disk Usage) Who are the creators of the UNIX operating system?Dennis Ritchie and Ken Thompson Who did the creators of UNIX work for?Bell Labs With whom did Dennis Ritchie write the book “The C Programming Language”?Brian Kernighan week10 Storage, IOweek11 Virtual Machines, Distributed Systemsweekk12 Protection, Securityweek13 Compilerweek14 考试大三上CSE203 决策计算与语言 10+10ass 80期末 全是小问答题 CSE205 网络 40ass 15考试 45期末 全是小问答题CSE207 软件工程 10+10ass 80期末选修 CSE209 计算机图形学 15+15courwork 70期末 CSE201 数据库设计（非关系数据库，解决数据库并发性）10+10ass 80期末 大三下CSE214 以人为中心的计算 交互界面 GUI 10+15+15report 60期末CSE204 复杂算法 5+5+10ass 80期末CSE210 java进阶 50ass 50期末CSE208 小组工程 100作业 网上资源了解操作系统和作用 作用：1、控制硬件 2、把调用硬件的办法封装成系统调用，供人通过应用程序间接的操作硬件 服务器操作系统：linux(安全稳定免费),windows server 移动设备操作系统：ios,安卓（linux衍生出来的） 虚拟机 是一个软件，可以用来安装一个新的操作系统，如果玩坏了，删掉重新装就好了，不会对现有系统造成任何影响和破坏。 内核如内存管理，多任务，IO的输入输出处理]]></content>
      <categories>
        <category>记忆性学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习]]></title>
    <url>%2F2020%2F02%2F23%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[CSE104 数据结构，介绍基本的数据结构和性质和用法。20% 不是考试，两个assignment写java代码，一定要尽可能的细致，对于每一个可能的样本输入情况都要考虑周全。80% 期末考试，四分之三25道选择题和一道数据结构的大题，大题每年相似度很高。背书课：lecture slides, Q&amp;As, in-class &amp; take-home exercises, assignments 认识数据结构：用来组织和存储数据的集合分类 1.逻辑结构分类: 按照数据元素之间的关系分类 抽象 集合结构：元素之间没有关系 线性结构 ：元素之间一对一的关系，如链表 树形结构：一对多的关系， 图形结构：多对多的关系 2.物理结构分类： 逻辑结构真正在计算机上存储的方式 顺序结构： 连续的内存地址带着索引查找容易 用索引，插入删除难 链式结构： 内存单元可以是不连续的，数据单元之间用指针指向链接查找难 用遍历， 插入删除容易 链表队列异常图论树树的定义 树是n个有限结点组成的一个具有层次关系的集合 术语：1.结点的度：结点下面一排上有几个子节点2.叶/终端结点： 无子节点的节点3.节点的层次：节点在第几排4.树的度：树的度=节点的度的最大值（子节点最多的节点的度）5.森林：去掉根节点6.子节点：A的直接前驱是B，A是B的子节点7.父节点：A的直接前驱是B，B是A的父/双亲节点8.双亲节点：两个节点的父节点相同 二叉树 二叉树中每个节点最多两个子节点；两个分叉 满二叉树： 每一层的节点数达到最大值（每个节点都有两个子节点） 完全二叉树： 每一层结点放满再放下一层；也就是说叶节点只会出现在最后一层或次下层。 用链表实现 二叉查找树 结点Node类 1234567891011121314151617public class Node&lt;Key,Value&gt; &#123; //存储键 public Key key; //用键找值 private Value value; public Node left; public Node right; public Node(Key key, Value value, Node left, Node right) &#123; this.key = key; this.value = value; this.left = left; this.right = right; &#125;&#125; 二叉树类：添加结点；以键查找结点；以键删除结点；查找二叉树中最小键；查找二叉树中最大键 [特点] 1.所有的方法都有同名重载方法：前面的是传入根节点的入口函数，后面是传入子节点的会使用递归的函数。 子树=结点下面所有结点123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166public class BinaryTree&lt;Key extends Comparable&lt;Key&gt;, Value &gt; &#123; //以后要用键来排序 //记录根节点 private Node root; //记录树中元素个数 private int N; //内部类 private class Node&#123; private Key key; private Value value; private Node left; //左节点 private Node right;//右节点 public Node(Key key, Value value, Node left, Node right) &#123; this.key = key; this.value = value; this.left = left; this.right = right; &#125; &#125; // 获取树中元素的个数 public int size()&#123; return N; &#125; //向树中添加元素键值对,第一次添加根节点 public void put(Key key, Value value)&#123; root = put(root, key, value); //添加根节点，返回赋值给树 根节点;此时x=null &#125; //向指定的子树x添加键值对，并且返回添加元素后的新树 public Node put(Node x,Key key, Value value)&#123; //1.如果x结点的子树为空,把添加的键值对作为x节点的子节点 if(x == null)&#123; N++; //节点个数+1 return new Node(key, value, null , null); //无左右子节点 &#125; //2.如果x节点的子树不为空 //2.1比较x结点的键和添加的key大小 //2.1.1如果key &lt; x结点的键，则继续找x结点的左子树 //2.1.2如果key &gt; x结点的键，则继续找x结点的右子树 //2.1.3如果key = x节点的键，则用添加的value替换x节点的原值. int cmp = key.compareTo(x.key); if(cmp&lt;0)&#123; //2.1.1 //这里是从x的左子节点下面插入键值对；完毕后将新的子树返回给x的左子节点 x.left = put(x.left, key, value); //递归调用只想它干了什么;这里会一直向下找直到找到子树为null时，创建新节点 &#125;else if(cmp&gt;0)&#123; //2.1.2 //这里是从x的右子节点下面插入键值对；完毕后将新的子树返回给x的右子节点 x.right = put(x.right, key, value); &#125;else&#123; //2.1.3 x.value = value; &#125; return x; //返回更新后的节点x信息 &#125; //用键找值 public Value get(Key key)&#123; return get(root, key);// 从根节点开始找 &#125; //从指定子树x中，用键找值 public Value get(Node x, Key key)&#123; //1.x树为null,没有找到 返回null就行 if(x == null)&#123; return null; &#125; //2.x不为null ,就要进行x树下面的键比较 （和上面添加方法的代码结构一样） int cmp = key.compareTo(x.key); if(cmp&lt;0)&#123; //2.1.1 键小与节点找左子树 return get(x.left, key); //这里是不仅要找，然后找了之后要返回找到的子树结点 &#125;else if(cmp&gt;0)&#123; //2.1.2 键大找右子树 return get(x.right, key); &#125;else&#123; //2.1.3 相等就找到了，返回键对应的值 return(x.value); &#125; &#125; //删除键值对结点。这是一个比较麻烦的操作，删除一个之后，要找一个结点来替换删除的节点 //因为左子树都小于右子树，新节点需要比左子树大，比右子树小。所以在右子树中找最左的节点（右子树中最小的节点） public void delete(Key key)&#123; delete(root, key); //入口，先从根节点开始判断删不删 &#125; //删除指定节点树x的键值对，返回新子树 public Node delete(Node x, Key key)&#123; //1.x树为null 安全检查 if(x ==null)&#123; return null; &#125; //2.x树不为null,就要进行x树下面的键比较 （和上面添加方法的代码结构一样） int cmp = key.compareTo(x.key); if(cmp&lt;0)&#123; //2.1键小找左子树,只是找相同的键 没有删 x.left = delete(x.left, key); //一直沿着左向下找 &#125;else if(cmp&gt;0)&#123; //2.2键大找右子树 x.right = delete(x.right, key); //一直沿着右向下找 &#125;else&#123; //2.3如果key = x结点的键，做真正的删除动作，删除x结点 N --; //元素个数-1,只要到了这一步先减个数 //我们要用右子树的最小结点替换x //1.如果x结点没有右子树,只需要让x的左子树成为x，这样是顺次，因为上一排的一定比下一排的键大 if(x.right == null)&#123; return x.left; &#125; //2.如果x结点没有左子树,只需要让x的右子树成为x ,这样是顺次，因为上一排的一定比下一排的键大 if(x.left == null)&#123; return x.right; &#125; //3.左右子树都不为空，找右子树的最小结点：找x右子树 左子树 左子树。。。一直到左子树的最后一个 Node minNode = x.right; //找到x右子树 while(minNode.left != null)&#123; //如果还有左子树的话，就还没有到左边的最后一个 minNode = minNode.left; // 找左子树 &#125; //删除最小结点：x右子树的左子树最后一个 Node n = x.right; while(n.left != null)&#123; if(n.left.left == null)&#123; //这时候n结点是左边倒数第二个结点，那么n.left就是最后一个结点，删除它 n.left = null; &#125;else&#123;//n结点没有到左边倒数第二个结点时，让n向下走一位 n = n.left; &#125; &#125; // 用最小结点minNode替换x: minNode连接左右结点和父结点 minNode.left = x.left; minNode.right = x.right; x = minNode; //绑定父结点，因为是递归调用。我也不懂记住就完了 //2.3else&#123;&#125;结束 &#125; return x; &#125; //查找整个树中最小的键 public Key min()&#123; return min(root).key; &#125; //找指定子树x中最小键所在的节点 = x子树的最左的那个节点 private Node min(Node x)&#123; if(x.left != null)&#123; return min(x.left); //返回更新x结点 &#125;else&#123; return x; &#125; &#125; //查找整个树中最大的键 public Key max()&#123; return max(root).key; &#125; //查找指定子树x中最大键的结点:最右边 private Node max(Node x)&#123; if(x.right != null)&#123; return max(x.right); &#125;else&#123; return x; &#125; &#125; &#125; 二叉树的基础遍历 - 深度优先 前中后顺序是指根节点放进队列的顺序 深度遍历的全用递归 算法特点在https://lucifinil-x.github.io/2020/02/24/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/#more 前序遍历 步奏： 1.把当前节点key放进队列 2.找到当前节点的左子树，不为空，递归遍历左子树 3.找到当前节点的左子树，不为空，递归遍历右子树 顺序特点：一层一层的来。先加根节点，再加下一层左根节点，再加下一层右根节点。遍历以上步奏 在BinaryTree类中添加代码 123456789101112131415161718192021222324252627282930//前序遍历：获取整个树中的所有的键,存在队列keys中 Ergodic：遍历 public Queue&lt;Key&gt; preErgodic()&#123; Queue&lt;Key&gt; keys = new Queue&lt;&gt;(); preErgodic(root, keys); return keys; &#125; //获取指定树x的所有键，并放到keys队列中。 //前序遍历就是先从左树开始向下，先把左子树的键放在队列再把右子树的键放在队列。 //因为是递归完成，所以只需要考虑一个二叉树的小分支 public void preErgodic(Node x, Queue&lt;Key&gt; keys)&#123; //x可能为null，代表的子树为空，直接返回 if(x == null)&#123; return; &#125; //把x结点的键放入队列keys keys.enqueue(x.key); //递归遍历x的左子树 //递归之前先判断有没有左子树 if(x.left !=null)&#123; preErgodic(x.left, keys); &#125; //递归遍历x的右子树 //递归之前先判断有没有右子树 if(x.right !=null)&#123; preErgodic(x.right, keys); &#125; &#125; 中序遍历 - 比较重要 步奏： 1.找到当前节点的左子树，如果不为空，递归遍历左子树 2.把当前节点key放进队列中 3.找到当前节点的右子树，如果不为空，递归遍历左子树 顺序特点： 键从小到大排列。 先加最下面最左边（最小键），再右边最小键，再加节点。 1234567891011121314151617181920212223242526272829//中序遍历 public Queue&lt;Key&gt; midErgodic()&#123; Queue&lt;Key&gt; keys = new Queue&lt;&gt;(); midErgodic(root, keys); return keys; &#125; public void midErgodic(Node x, Queue&lt;Key&gt; keys)&#123; //x可能为null，代表的子树为空，直接返回 if(x == null)&#123; return; &#125; //递归遍历x的左子树 //递归之前先判断有没有左子树 if(x.left !=null)&#123; midErgodic(x.left, keys); &#125; //把x结点的键放入队列keys keys.enqueue(x.key); //递归遍历x的右子树 //递归之前先判断有没有右子树 if(x.right !=null)&#123; midErgodic(x.right, keys); &#125; &#125; 后序遍历 步奏： 1.找到当前节点的左子树，如果不为空，递归遍历左子树 2.找到当前节点的右子树，如果不为空，递归遍历左子树 3.把当前节点key放进队列中 1234567891011121314151617181920212223242526272829//后序遍历 public Queue&lt;Key&gt; afterErgodic()&#123; Queue&lt;Key&gt; keys = new Queue&lt;&gt;(); afterErgodic(root, keys); return keys; &#125; public void afterErgodic(Node x, Queue&lt;Key&gt; keys)&#123; //x可能为null，代表的子树为空，直接返回 if(x == null)&#123; return; &#125; //递归遍历x的左子树 //递归之前先判断有没有左子树 if(x.left !=null)&#123; afterErgodic(x.left, keys); &#125; //递归遍历x的右子树 //递归之前先判断有没有右子树 if(x.right !=null)&#123; afterErgodic(x.right, keys); &#125; //把x结点的键放入队列keys keys.enqueue(x.key); &#125; 二叉树的高级遍历 - 层序遍历 - 广度优先 步奏：1.定义两个队列，分别存储树中的键和树中的结点2.结点队列加入根节点3.while循环（当结点队列不为空）： 从结点队列中取出一个结点，将这个结点的key加入键队列； 如果当前结点的左子结点不为空，把左子结点放进结点队列；如果当前结点的右子结点不为空，把右子结点放进结点队列 顺序特点：每一层从左到右 1234567891011121314151617181920212223//层序遍历，所有键 public Queue&lt;Key&gt; layerErgodic() throws InterruptedException&#123; //定义两个队列，分别存储树中的键和树中的结点 Queue&lt;Key&gt; keys = new Queue&lt;&gt;(); Queue&lt;Node&gt; nodes = new Queue&lt;&gt;(); //先放根节点 nodes.enqueue(root); //循环，结束条件为队列中没有元素 while(! nodes.isEmpty())&#123; //从队列中取出一个结点 Node n = nodes.dequeue(); keys.enqueue(n.key); //有无左子 if(n.left != null)&#123; nodes.enqueue(n.left); &#125; //有无右子 if(n.right != null)&#123; nodes.enqueue(n.right); &#125; &#125; return keys; &#125; 二叉树的最大深度问题 - 树有几层 深度遍历,关于递归调用中 变量的初始化在递归调用之前，每次都是递归调用时候停顿，所以每次返回值是递归调用下面的ruturn值，所以不会再执行初始化的赋值。1234567891011121314151617181920212223242526//获取整个树的最大深度 - 几层 public int maxDepth()&#123; return maxDepth(root); &#125; public int maxDepth(Node x)&#123; //安全 if(x == null)&#123; return 0; &#125; int max = 0; int maxLeft = 0; int maxRight = 0; //计算x结点左子树最大深度 if(x.left != null)&#123; maxLeft = maxDepth(x.left); &#125; //计算x结点左子树最大深度 if(x.right != null)&#123; maxRight = maxDepth(x.right); &#125; //取上面两个中大的值+1 max = maxLeft&gt;maxRight ? maxLeft+1 : maxRight+1; return max; &#125; 排序算法的消费贪婪算法的lecturesL1 abstraction Huffman编码https://blog.csdn.net/qinglongzhan/article/details/80983492 encapsulation 空间效率 时间效率 静态数据结构：创建的时候就固定了大小/内存空间，如:数组不会内存分配溢出，不能添加空间。必须保证有足够大的容量，可能装不下，可能浪费空间时间效率好 动态数据结构：在运行中可以删减大小/内存空间，如:集合、链表不需要知道具体大小，合理运用内存空间，添加内存会浪费时间空间效率好 L2 使用java 集合库 线性collection 层次collection 有哪些 有哪些库： util(集合的，数组的) io swing/awt Collection子类接口：List 有序集合 子类：ArrayList LinkedList vectorSet 无序无重复集合 子类： HashSet TreeSetQueue 有序集合 队列尾添加，队列头出Map 键值对 子类： HashMap TreeMap 接口特征，怎么样使用接口 parameterised typr泛型 ArrayList 的方法： 增删改查和属性 都是在本子上有的 L3 使用集合Collection 和list 和 迭代器 和泛型L4 Bag? Set Stack MapL5 使用Map, 队列和优先队列]]></content>
      <categories>
        <category>记忆性学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[算法学习]]></title>
    <url>%2F2020%2F02%2F23%2F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[CSE102 算法基础，介绍基础排序算法、查询算法、图论、p与np问题、算法思想（分治、动规、贪心）。20% 两个assignment算法题6-7周，12-13周，基本是套路题目，只要按照一些固定的步奏就能写出来，越详细越好。80% 期末考试，四分之三选择题和四分之一两道算法大题。分治和动规的思想必考。可能会考前几年的原题。 lecturesweek1 算法分析，数学归纳法 什么是算法algorithem: 根据一定的条件，对数据进行计算，得到需要的结果；程序=input+algorithem+output 算法分析：对于一个算法，我们首要关注的是它的时间复杂度，其次是空间复杂度，以及输出是否为最优或是否接近最优。 二分查找的步奏 算法分析：1、正确性 2、时间复杂度 3、空间复杂度（需要的内存空间） 4、算法优化 数学归纳法Induction: 他是一个分析技术,只能用于自然数。步奏： 1、Base case: 证k=0时，it is true. 2、Induction step: 设it is true for k=n. 3. 证it is true for k=n+1. week2 伪代码写法 程序=数据结构+算法 计算x的n次方：算法：1、set变量p=1 2、执行n次p=p * x 3、输出结果p伪代码： p=1; for i=1 to n do p=p* x; output p 伪代码写法：1、if else: 12345if ... then abs=aelse abs=-aoutput abs 2、 for loop: 1234567input nsum=0for i=1 to n dobegin sum=sum+iendoutput sum 3、 while loop: 123456789input nsum=0i=1while i&lt;=n dobegin sum=sum+i i=i+1endoutput sum 4、repeat until（do while） 123456sum=0repeat ask for a number sum=sum+numberuntil (user wants to stop)output sum 伪代码练习，一题三解 n个数中找最小数：比较次数 n-1. (三个人握手两次) week3思想###Divide and Conquer 分治思想把难以解决的大问题分解成几个子问题，找到求出这几个子问题的解法后，再找到合适的方法，把它们组合成求整个问题的解法。 Complexity 复杂度 分析算法的时间复杂度分析 关心核心计算操作次数和输入规模n的关系： 函数函数图像比较结论：1.随着输入规模n的增大，和n的最高次项相乘的常数可以忽略2.n的次方多，随着n变大，结果增长会特别快3.增长函数： n^3 &gt; n^2 &gt; ln(n) &gt; log(n) 这个底数多少趋势都差不多&gt; 1 n的最高次幂越小，算法效率越高 算法的空间复杂度分析 基本数据类型内存占用 (字节byte)byte 1 ,short 2, int 4, long 8, float 4, double 8, boolean 1, char 2 计算机访问内存方式都是一次一个字节 java的对象占用内存：1.一个引用变量占8byte Date date = new Date();中的date2.创建的一个对象占用的内存= 对象内部信息内存 + 对象本身头信息16byte3.如果对象一共占的内存不是8的倍数，那么会自动扩充到8的倍数4.数组对象占用 = 16头信息 + 4长度 + 4 * n个填充 一般java都是做服务器的，内存挺大，这些小的都不需要估算。一般对于算法都是分析时间复杂度 Efficiency追求两个目的：1、花最少的时间完成需求 2、占用最少的内存空间完成需求 Big-O 大O标记法–算法时间复杂度表示方法 时间空间通用 执行次数–大O表示3次– O(1)n+3次–O(n)2n^2+2次–O(n^2) 最高次项相乘的常数可以忽略2n^2+2n+2次–O(n^2) 常见的大O次数 从低到高 常数阶：O(1) 对数阶：O(logn)比如 2^x =100, x=log100 底数忽略 单次循环体 线性阶：O(n) 循环套循环 平方阶：O（n^2） 循环套循环套循环 立方阶：O(n^3) ？网上的 指worse-case下的时间复杂度。比如f(n)=13n^3+7nlogn的复杂度是O(n^3)，或者O(n^k)（k&gt;=3） Ω(n)和Θ(n)：前者是best-case下的时间复杂度。比如，f(n)=13n^3+7nlogn的复杂度是Ω(n^3)，或者Ω(n^2)，Ω(n)，Ω(1)等；后者是average-case下的时间复杂度，是O标记法与Ω标记法的结合：比如，f(n)=13n^3+7nlogn的复杂度是Θ(n^3)。 Sorting 排序实现comparable接口的对象 实际上比较常见的是对对象进行排序，比如对商品对象进行价格排序。那么在这些对象的类中就要提供自定义的排序规则，通过实现comparable接口完成。我们排序的对象就是实现了Comparable接口的对象12345678910111213141516171819Studnet implements Comparable&lt;Student&gt;: public int compareTo(Student o) &#123; return this.getAge()-o.getAge(); &#125;Test:Comparable c =getmax(s1,s2); //c不是student对象，是comparable对象,不能用student的方法System.out.println(c); public static Comparable getmax(Comparable a,Comparable b)&#123; //这个是为了拿到对象 int result = a.compareTo(b); if(result&gt;0)&#123; return a; &#125; else &#123; return b; &#125; &#125; Selection/Bubble/insertion 选择排序/冒泡排序/插入排序这三个排序都很相似，时间复杂度都是 O(n^2); 适用于元素少的排序 Bubble冒泡排序API设计： 12345678910111213141516171819202122232425public class 冒泡排序 &#123; public static void sort(Comparable [] a)&#123; for(int i= a.length-1; i&gt;0; i--)&#123; for(int j=0; j&lt;i;j++)&#123; //每层递减 if(greater(a[j], a[j+1]))//如果前比后大就交换 &#123; exchange(a, j, j+1); &#125; &#125; &#125; &#125; private static boolean greater(Comparable a, Comparable b)&#123; return a.compareTo(b)&gt;0; &#125; private static void exchange(Comparable [] a, int i, int j)&#123; Comparable temp; temp = a[i]; a[i]= a[j]; a[j] = temp; &#125; &#125; 测试类： 12345public static void main(String[] args) &#123; Integer [] arr=&#123;4,5,6,3,2,1,2&#125;;//Integer这个包装类就有实现Comparable接口 冒泡排序.sort(arr);//要传实现了Comparable接口的对象 System.out.println(Arrays.toString(arr)); &#125; 算法分析：1.最坏情况为逆序：{6,5,4,3,2,1}2.核心代码为sort循环中的比较和交换3.比较次数为：n-1 + n-2 + …. + 1 = n^2/2 - n/2两两比较，次数逐层递减4.交换次数为：n-1 + n-2 + …. + 1 = n^2/2 - n/2最坏情况两两都要交换5.总执行次数=比较次数+交换次数 = n^2 - n6.时间复杂度：O(n^2); 所以冒泡排序适用于元素少的排序 Selection 选择排序 排序原理：选择最小元素防在第一位。选择次小元素放在第二位。。。。 过程:1.假设0索引的元素是min; 向后一位比较，小元素所在索引变成min; 遍历完之后拿到最小元素min所在的索引 2.将min索引的值与0索引的值交换3.第一次从索引0开始，第二次从索引1开始。。。。最后从倒数第二个索引开始。 Seclection API设计 1234567891011121314151617181920212223242526public class Seclection &#123; public static void sort(Comparable [] a)&#123; for(int i=0; i&lt;=a.length-2; i++)&#123; int minIndex=i; //这个变量记录最小元素所在的索引，先默认为第一位i for(int j= i+1; j&lt;a.length;j++)&#123; //j会与minIndex比较，j最后是最后一位元素的索引 if(greater(a[minIndex], a[j]))&#123; minIndex = j; &#125; &#125; //内层for循环完成后交换两值 exchange(a, i, minIndex);// i索引为每次的最小值位置 &#125; &#125; private static boolean greater(Comparable a, Comparable b)&#123; return a.compareTo(b)&gt;0; &#125; private static void exchange(Comparable [] a, int i, int j)&#123; Comparable temp; temp = a[i]; a[i]= a[j]; a[j] = temp; &#125; &#125; 测试类：同上 12345public static void main(String[] args) &#123; Integer [] arr =&#123;6,7,2,3,5,2,1,8,3,5&#125;; Seclection.sort(arr); System.out.println(Arrays.toString(arr)); &#125; 算法分析： 1.最坏情况为逆序：{6,5,4,3,2,1}2.核心代码为sort循环中的比较和交换3.比较次数为：n-1 + n-2 + …. + 1 = n^2/2 - n/2两两比较，次数逐层递减4.交换次数为：n-1 最后一次不需要交换，其他都交换一次，也是外层循环次数5.总执行次数=比较次数+交换次数 = n^2/2 - n/2 - 16.时间复杂度：O(n^2); 所以选择排序适用于元素少的排序 Insertion 插入排序 排序原理：从第二个数开始，比较第二和第一，将小的排在前面；从第三个数开始，比较第三和第二，需要交换的话还要再第二比较第一，不需要交换就继续比较第四和第三。。。 Insertion API设计 1234567891011121314151617181920212223242526public class Insertion &#123; public static void sort(Comparable [] a)&#123; for(int i=1; i&lt;a.length; i++)&#123; //从第二个数向前比较 for(int j=i; j&gt;0;j--)&#123; //一个一个向前面一个元素比较，如果前面的数大，就两两交换。比较到第一个数 if(greater(a[j-1], a[j]))&#123; exchange(a, j-1,j); &#125; else&#123; break; //只会结束内层循环。如果这个数比上一个大时，它就比前面的都大，因为前面的数都是排序好的 &#125; &#125; &#125; &#125; private static boolean greater(Comparable a, Comparable b)&#123; return a.compareTo(b)&gt;0; &#125; private static void exchange(Comparable [] a, int i, int j)&#123; Comparable temp; temp = a[i]; a[i]= a[j]; a[j] = temp; &#125;&#125; 算法分析： 1.最坏情况为逆序：{6,5,4,3,2,1}2.核心代码为sort循环中的比较和交换3.比较次数为：n-1 + n-2 + …. + 1 = n^2/2 - n/2两两比较，次数逐层递减4.交换次数为：n-1 + n-2 + …. + 1 = n^2/2 - n/2 最坏情况每次都要交换5.总执行次数=比较次数+交换次数 = n^2 - n6.时间复杂度：O(n^2); 所以插入排序适用于元素少的排序 Merge-sort 归并排序 先分组再合并； 分组叫分，合并叫治 分治思想的典型应用先把数组对半拆分到最小，而后两两比较排序后合并，重复这一步骤直至整个数组排序完成 在每个递归步骤中，划分每个子列表最多需要O(n)时间；合并每个级别中的所有列表最多也需要O(n)时间；递归需要的次数最多为O(log n)次。因此，MergeSort的运行时间为O(n log n)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class Merge &#123; private static Comparable [] assist; private static boolean less(Comparable a, Comparable b)&#123; return a.compareTo(b)&lt;0; &#125; //对数组a中的元素进行排序,入口函数 public static void sort(Comparable [] a)&#123; //初始化辅助数组assist assist = new Comparable[a.length]; //定义一个hi变量，一个lo变量，分别记录数组中最小的索引和最大的索引 int lo=0; int hi=a.length-1; //调用下面的sort方法，从索引lo到索引hi的元素的排序 sort(a,lo,hi); &#125; private static void sort(Comparable [] a,int lo, int hi)&#123; //这个就是递归分到最小组1个的情况 //安全性检测 if(hi&lt;=lo)&#123; return; &#125; //对lo-hi索引之间的数组分成2个组 int mid = lo+(hi-lo)/2; //中位索引，5-9的中位是7 分成567；89 //分别对分好的每一组数据进行排序 sort(a,lo,mid); sort(a,mid+1,hi); //递归完毕，再吧排好的这2个组组合起来，归并 merge(a, lo, mid, hi); &#125; //归并两组数据并进行排序：通过指针遍历比较两组数据，将每次比较的小值填充进辅助数组 private static void merge(Comparable [] a, int lo, int mid,int hi)&#123; //定义三个指针 int i=lo; int p1=lo; //5 int p2=mid+1; //8 //遍历小数组，移动p1 p2指针，比较对应索引处的值，找出小的值，放到辅助数组的对应索引处 while(p1&lt;=mid &amp;&amp; p2&lt;=hi)&#123; //p1和p2都没越界的时候遍历，一个指针遍历完就停止 if(less(a[p1], a[p2]))&#123; assist[i++] = a[p1++]; //p1小，放完p1之后，向右移动p1指针 &#125;else&#123; assist[i++] = a[p2++]; //p2小，放完p2之后，向右移动p1指针 &#125; &#125; //如果p1没有走完，就顺序移动p1指针，把对应元素放到辅助数组对应的索引处 while(p1&lt;=mid)&#123; //如果走完的话p1就会大于mid assist[i++] = a[p1++]; &#125; //如果p2没有走完，就顺序移动p2指针，把对应元素放到辅助数组对应的索引处 while(p2&lt;=hi)&#123; assist[i++] = a[p2++]; &#125; //将辅助数组中填充的元素拷贝到原数组中 for(int index=lo; index&lt;=hi; index++)&#123; a[index]=assist[index]; &#125; &#125; &#125; 算法分析： 1.数组拆分 + 归并： 比如8个元素的数组：2^3=8. 每次除以2，他就会拆3次，也就是log8次。 拆到第k层，就会有2^k个子数组，每个子数组的长度为2^(3-k)；拆2次，就要4个子数组，每个子数组长度是2。 子数组有多长，最多就需要比较多少次。 那么归并最多需要比较次数= 层数 * 每层比较次数= 层数 * 每层子数组长度 = 3* （2^3） 2.n个元素的数组的归并时间复杂度= log2(n) * [2^(log2 n)] = log2(n) * n= O(nlogn) —大O标记法：去掉底数 因为n&gt;logn所以归并排序比上面三种排序n^2要小。 3.归并排序的缺点： 需要用到辅助数组，导致空间复杂度提升，是典型的以空间换时间的操作。 Count sorting 计数排序 步奏: 1.一串数字中max-min+1取得这串整数的范围k2.遍历一串数字，遍历到的数字-min的值对应到数组count[k]的下标，其值加一。 3.遍历数组count[k]，输出每个的值，重复值数次。123456789101112131415161718192021222324252627282930313233public static int[] countSort(int[] array) &#123; //1.得到数列的最大值与最小值，并算出差值d int max = array[0]; int min = array[0]; for (int i = 1; i &lt; array.length; i++) &#123; if (array[i] &gt; max) &#123; max = array[i]; &#125; if(array[i] &lt; min) &#123; min = array[i]; &#125; &#125; //2.创建统计数组并计算统计对应元素个数 int d = max - min; int[] countArray = new int[d + 1]; for (int i = 0; i &lt; array.length; i++) &#123; countArray[array[i] - min]++; //厉害.. &#125; //3.统计数组变形，后面的元素等于前面的元素之和 //看不懂要干嘛 int sum = 0; for (int i = 0; i &lt; countArray.length; i++) &#123; sum += countArray[i]; countArray[i] = sum; &#125; //4.倒序遍历原始数组，从统计数组找到正确位置，输出到结果数组 int[] sortedArray = new int[array.length]; for (int i = array.length - 1; i &gt; 0; i--) &#123; sortedArray[countArray[array[i] - min] - 1] = array[i]; countArray[array[i] - min]--; &#125; return sortedArray; &#125; https://www.cnblogs.com/kyoner/p/10604781.html 如果原始数列的规模是N，最大最小整数的差值是M，由于代码中第1、2、4步都涉及到遍历原始数列，运算量都是N，第3步遍历统计数列，运算量是M，所以总体运算量是3N+M，去掉系数，时间复杂度是O(N+M)。 至于空间复杂度，如果不考虑结果数组，只考虑统计数组的话，空间复杂度是O(M)。 -两大局限性：1.当数列最大最小值差距过大时，并不适用于计数排序比如给定20个随机整数，范围在0到1亿之间，此时如果使用计数排序的话，就需要创建长度为1亿的数组，不但严重浪费了空间，而且时间复杂度也随之升高。 2.当数列元素不是整数时，并不适用于计数排序正是由于这两大局限性，才使得计数排序不像快速排序、归并排序那样被人们广泛适用。 它的复杂度为Ο(n+k)（其中k是整数的范围），它适用于一定范围的整数排序。在取值范围不是很大的情况下，它的性能在某些情况甚至快于任何比较排序算法O(nlogn)，例如快速排序、归并排序。 QuickSort 快速排序分治思想的另一种应用 遍历整个数组，将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小。然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 快速排序过程：初数组默认找第一个元素作为分组的分界值；把比分界元素小的放分界元素左边；大的放右边。 左子祖和右子组进行以上的递归：分界分组，递归，直到一组只有两个及以下元素。将有序的子组按照分界元素为中心，组合成新的数组，递归。 如何切分分组：左指针在第二个元素索引，右指针在最后一个元素再后一位的索引。左向右走，找比第一个大的元素；右向左走，找比第一个小的元素。找到后，左右元素交换位置。直到左指针=右指针，这时候这个元素和第一个元素交换位置。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class Quick &#123; private static boolean less(Comparable a, Comparable b)&#123; return a.compareTo(b)&lt;0; &#125; private static void exchange(Comparable [] a, int i, int j)&#123; Comparable temp; temp = a[i]; a[i]= a[j]; a[j] = temp; &#125; public static void sort(Comparable [] a)&#123; //入口函数 int lo=0; int hi=a.length-1; sort(a,lo,hi); //第一次对a数组中所有元素进行排序 &#125; private static void sort(Comparable [] a,int lo, int hi)&#123; //安全性检测 if(hi&lt;=lo)&#123; return; &#125; //对数组中lo索引到hi索引处的元素进行分组（分成左子组和右子组） int partition = partition(a,lo,hi); //分组函数,返回分界值在新子数组中所在的索引 //让左子组有序 sort(a,lo,partition-1); //让右子组有序 sort(a,partition+1,hi); &#125; //分组函数,返回分界值在新子数组中所在的索引 private static int partition(Comparable [] a, int lo,int hi)&#123; Comparable key = a[lo];//key是第一个元素 //定义两个左右指针， int left =lo; int right = hi+1; //切分 while(true)&#123; //右指针左移，找到一个比分界值小的元素，停止 while(less(key, a[--right]))&#123; if(right == lo)&#123; break; &#125; &#125; //左指针右移，找到一个比分界值大的元素，停止 while(less(a[++left], key))&#123; if(left == hi)&#123; break; &#125; &#125; //判断 如果左指针大于右指针，证明元素扫描完毕，结束循环; 如果不是，则交换左右元素 if(left &gt;= right)&#123;//必须是大于等于，不然会指针越界 break; &#125;else&#123; exchange(a, left, right); &#125; &#125; //当左大于等于右时结束循环，交换分界值右和第一个值,因为右指针值代表小值，与第一个交换 exchange(a, lo, right); return right; &#125;&#125; 算法分析：快速排序不是等分，所以需要分为1.最优情况：O(nlogn)2.最坏情况：O(n^2)3.平均情况：O(nlogn) 以上排序的稳定性比较 ricky总结（2,4）Tree 最少两个子代，最多四个子代 每个子代最多三个key 储存了n个item的(2,4) tree的高度是Θ(logn) Search、insertion和deletion的复杂度都是O(logn)，其中search是从上向下(top-down)，insertion和deletion是自底向上(bottom-up) Priority Queue 优先队列 和普通的队列相比，是最高级先出 通过堆实现优先级的筛选 Heap 堆 可以理解为用数组实现的二叉树 除了根节点，每个节点的key值都大于等于父代的key值 堆的插入：新节点首先加入到该二叉堆最后的一个节点，依据最小堆的定义，自底向上，递归调整。 堆的删除：二叉堆的删除一般只讨论如何删除堆顶元素。方法是最后一个节点替换到根节点，然后自顶向下，递归调整。 Heap-Sorting：堆排序算法对有着n个可比较项的序列S进行排序，所需时间为O(nlogn)。自底向上构建具有n个元素的堆需要O(nlogn)时间，并且从堆中提取n个元素（以递增顺序）需要O(nlogn)时间。 Experimental analysis：运行时间对输入大小的依赖性，需要对样本输入适当选择，并进行适当数量的测试。缺陷在于必须先实现算法、必须在有限的输入和同一硬件软件的条件下进行实验。 Theoretical analysis：相比上一种分析方法，可以考虑所有的输入；可以比较多个算法的效率（与硬件环境无关）；可以通过伪代码来研究算法。 伪代码： high-level description 更结构化的描述 自然语言与编程语言的混合 Computational Model 计算模型：通过计算primitive operations的数量来估计算法的复杂度。 primitive operations：比如赋值、比较大小、条件判断、返回值等。 SearchingBinary- searching 二分查找StringsearchingAlignment/LCS 校准Graph/Combinatory]]></content>
      <categories>
        <category>记忆性学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[常见问题&解决办法&小技巧]]></title>
    <url>%2F2020%2F02%2F21%2F%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95-%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[杀端口占用 输入win+R快捷键，输入cmd，打开命令行窗口 netstat -ano|findstr 8080 taskkill /f /t /im 监听号 eclipse使用 eclipse里创建的html文件编辑内容要右键openwith。 重启springboot项目前要在控制台那里点红色方框关闭上一次的启动，不然就会出现端口占用，启动失败。 窗口文件右键close可以全部关掉 快捷键：alt shift s 添加getter setter toStringctrl shift o 添加删除包Ctrl+Shift+f 自动对齐 怎么没用alt / 补全代码main + alt / 主函数 github仓库托管代码 教程https://blog.csdn.net/hc_ttxs/article/details/79375788 ssh密匙之前blog的时候就有了，不用再添加。在本地文件夹git-repo为本地仓库，将代码添加进这个文件夹，右键git bush here,按照git命令提交。 我用的是http: https://github.com/Lucifinil-x/community-sringboot.git 提交本地代码命令 数据库，mysql,sqlyog 在表中更改了数据要右键更改保存。 不认识的单词 Toggle navigation：切换导航Toggle navigation 替换成名字 路西斐尔的尼伯龙根 placeholder：占位符搜索框里的灰体字]]></content>
      <categories>
        <category>应用使用要点</category>
      </categories>
      <tags>
        <tag>bug</tag>
        <tag>解决办法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot学习]]></title>
    <url>%2F2020%2F02%2F19%2Fspringboot%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[注解@XXX的理解 spring引入注解，让注解与java bean紧密结合，减少了配置文件（.xml文件）的体积，增加了java bean的可读性和内聚性。 @Autowired注解：自动找和注入组件类、接口实现类，接着就能用他们了 1.自动注入java类，@Autowired注解回去寻找一个java bean组件（@Bean是给spring容器中添加组件，函数返回值添加进容器中） @Autowired private UserRepository userRepository; 如果bean定义给去掉了，spring容器找不到就会抛出异常。如果不想抛出异常，找不到就认为这个属性为null的话：required值设置 false @Autowired（required = false） private UserRepository userRepository; 但其实没有@Bean也能找到并且注入一个接口，而且直接可以调用实现接口的子类的方法 2.自动注入java接口的实现类： 比如：接口Car;实现类A implements Car;实现类B implements Car; @Service public class CarFactory { @Autowired @Qualifier(&quot;B&quot;) //两个实现类，指明调用B类的carName方法 private Car car; //多态 public String toString() { return car.carName(); } } @Resource注解：根据name和type找和注入组件类、接口实现类，接着就能用他们了 @Servicepublic class Zoo{ @Resource(name = &quot;tiger&quot;) private Tiger tiger; @Resource(type = Monkey.class) private Monkey monkey; public String toString() { return tiger + monkey; }} @Service注解： 声明Zoo.java是一个bean容器，其他类就能够@Autowired把zoo类当做是成员变量来使用; Zoo.java在bean中的id为”zoo”.(类名小写)Thymeleaf模板 Spring Boot 推荐使用 Thymeleaf 来代替 Jsp Thymeleaf 是一款用于渲染 XML/XHTML/HTML5 内容的模板引擎。类似 JSP,它也可以轻易的与 Spring MVC 等 Web 框架进行集成作为 Web 应用的模板引擎。能够直接在浏览器中打开并正确显示模板页面，而不需要启动整个 Web 应用。 页面即原型,整个页面直接作为 HTML 文件用浏览器打开，几乎就可以看到最终的效果，这大大解放了前端工程师的生产力，它们的最终交付物就是纯的 HTML/CSS/JavaScript 文件。 从springboot官方文档学习做helloXXX html页面 效果：运行后打开localhost:8080/greeting?name=xyt 这个网页页面就会显示出Hello, xyt! 官方文档https://spring.io/guides/gs/serving-web-content/ resources文件夹下放置静态文件，其中templates里放web文件 目前能够想到的组件，在spring官方文档里都是有的。复制粘贴。 pom.xml里加thymeleaf依赖 12345678910111213141516171819@Controller //允许这个类接收前端的请求public class GreetingController &#123; @GetMapping(&quot;/greeting&quot;) //网址的路径 public String greeting( @RequestParam(name=&quot;name&quot;, //@RequestParam()定义接收参数是什么，网址那里？name=xxx ,这个&quot;name&quot;就会以键值对的方式传到服务端，这样我们就会接收到这个value值。 required=false,没有接收到值也不会报错，默认值为world. required=false, defaultValue=&quot;World&quot;) String name, Model //接收到的值是String类型。这里逗号之前都是第一个参数 model) &#123; model.addAttribute(&quot;name&quot;, name); //model添加&quot;键&quot;值对的属性。Model则将获取到的值传递到这个页面上去显示，spring帮我们注入进去了。 return &quot;greeting&quot;; //return值&quot;greeting&quot;会去template中找同名的html文件:greeting.html，把他渲染成网页。这个需要自己去template中添加。 &#125;&#125; 在application.java的同一级或下一级的@Bean组件都能自动加载入容器中。 eclipse里创建的html文件编辑内容要右键openwith。12345678910&lt;!DOCTYPE HTML&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;title&gt;Getting Started: Serving Web Content&lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;&lt;/head&gt;&lt;body&gt; &lt;p th:text=&quot;&apos;Hello, &apos; + $&#123;name&#125; + &apos;!&apos;&quot; /&gt; //网页显示出Hello,XXX!&lt;/body&gt;&lt;/html&gt; 做社区网站项目第一章 网站网页的功能划分 导航（菜单栏），有很多功能分类：搜索，登录按钮 标签tag列表 话题列表，排序方式：时间倒序、推荐、热门、消灭零回复话题列表元素：发布人、发布时间、评论数、浏览数、回复数、关注数、 热门话题 热门用户 分页 第二章 做社区的菜单栏导航条 用UI框架Bootstrap快速搭建前端的站点。Bootstrap介绍：简洁、直观、强悍的前端开发框架，让web开发更迅速、简单 第一步 下载Bootstrap https://v3.bootcss.com/getting-started/#download下载并将文件粘贴到static文件夹下 第二步 写index.html 写入css,js文件 1234567891011&lt;!DOCTYPE HTML&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;title&gt;路西斐尔的尼伯龙根&lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/bootstrap.min.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/bootstrap-theme.min.css&quot;/&gt; &lt;script src=&quot;js/bootstrap.min.js&quot; type=&quot;application/javascript&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt; 在Bootstrap网页上找到组件页面，找导航条，将代码复制粘贴到index.html中的body中 根据实例中每个框框中的单词，将body中对应的单词改成自己的。 删掉不要的url，icon代码块 第三步 写IndexController.java12345678@Controllerpublic class IndexController &#123; @GetMapping(&quot;/&quot;) //根路径，代表8080就是index.html渲染出来的页面 public String index() &#123; return &quot;index&quot;; &#125;&#125; 第三章 申请github app登录授权 授权登记页面 https://github.com/settings/applications/1228484 第四章 做登录callback，拿到参数第一步 做登录按钮的github授权登录输账号密码页面 GitHub需要的内容文档 https://developer.github.com/apps/building-oauth-apps/authorizing-oauth-apps/ index.html登录那一行加入自己申请过的授权信息 1&lt;li&gt;&lt;a href=&quot;https://github.com/login/oauth/authorize?client_id=51a87c000499eea9d39a&amp;redirect_uri=http://localhost:8080/callback&amp;scope=user&amp;state=1&amp;&quot;&gt;登录&lt;/a&gt;&lt;/li&gt; 在输入密码之后会到callback页面，这时候显示404，因为还没做callback页面。http://localhost:8080/callback?code=57679f8624ad1ef794bd&amp;state=1网址上会显示一串code,之后就需要接收到这个参数code和参数state，用@RequestParam 第二步 做callback页面，接收到callback的code 新建AuthorizeController.java1234@GetMapping(&quot;/callback&quot;) //当他登录后到callback时，就让他跳转回index页面 public String callback( @RequestParam(name=&quot;code&quot;) String code , //第一个参数name为code，第二个为state @RequestParam(name=&quot;state&quot;) String state) &#123; return &quot;index&quot;; 第三步第五章 写配置文件，分离变量数据和固定代码第一步 将文件中的数据值用参数占位，在配置文件中赋值1234@Value(&quot;$&#123;github.client.id&#125;&quot;) //value中为键，他会去配置文件中找对应键的值，且赋值给参数clientId private String clientId;配置文件： github.client.id=51a87c000499eea9d39a //键值对 第六章 登录成功保持登录状态Session 和 Cookie Session:银行账户，账户所有信息都在银行数据库中（服务器就相当于银行） Cookie:银行卡，要操作账户中信息比如余额，需要知道银行卡 第七章 callback页面404，控制台不打印原因高亮！ 所有的文件和包一定要放在启动类/包下面，否则run时是不可能启动这些类的，控制台也不会打印。 springboot和shiro整合-权限管理实战第一章 Controller类1234567891011121314151617181920212223// 第一种getmapping注解 @GetMapping(&quot;/hello&quot;) public String hello() &#123; System.out.println(&quot;UserController.hello()&quot;); return &quot;ok&quot;; &#125; @GetMapping(&quot;/testThymeleaf&quot;) public String testThymeleaf(Model model) &#123; model.addAttribute(&quot;name&quot;,&quot;xyt&quot;); return &quot;test&quot;; &#125;//第二章requestmapping+requestbody @RequestMapping(&quot;/hello&quot;) @ResponseBody public String hello() &#123; System.out.println(&quot;UserController.hello()&quot;); return &quot;ok&quot;; &#125; @RequestMapping(&quot;/testThymeleaf&quot;) public String testThymeleaf(Model model) &#123; model.addAttribute(&quot;name&quot;,&quot;xyt&quot;); return &quot;test&quot;; &#125; @RequestMapping(“/hello”)@ResponseBody是返回字体（将实体类转化为json） @RequestMapping(“/hello”)是返回html 12345@RequestMapping(&quot;/update&quot;) public String update() &#123; System.out.println(&quot;UserController.hello()&quot;); return &quot;/user/update&quot;; &#125; 返回到update.html要加前面的路径。如：return “index”; index.html在trmplates包直接下面如：return “/user/update”;update.html在trmplates包下面user包下面 第二章shiro 核心APISubject: 用户主体 (把操作交给SecurityManager,要关联它)SecurityManager: 安全管理器 （关联Reaml）Realm: Shiro连接数据的桥梁,执行认证和授权。认证中具体实现用户名和密码匹配 第三章 springboot和shiro整合导入shiro和spring整合依赖12345&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt;&lt;/dependency&gt; 编写shiro配置类 @Configurartion 放在启动类子包Shiro子包Shiro中自定义Realm类，继承AuthorizingRealm类，实现认证和授权方法写shiro配置类 创建ShiroFilterFactoryBean对象，@Bean放入spring的环境，上面的方法就可以使用 创建DefaultWebSecurityManager对象，@Bean放入spring的环境 创建Realm对象，@Bean放入spring的环境 1234567891011121314151617181920212223@Configurationpublic class ShiroConfig &#123; @Bean //过滤拦截器 public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier(&quot;securityManager&quot;) DefaultWebSecurityManager securityManager ) &#123; ShiroFilterFactoryBean shiroFilterFactoryBean=new ShiroFilterFactoryBean(); shiroFilterFactoryBean.setSecurityManager(securityManager);//设置关联安全管理器 return shiroFilterFactoryBean; &#125; @Bean(name=&quot;securityManager&quot;) //安全管理器 public DefaultWebSecurityManager getDefaultWebSecurityManager(@Qualifier(&quot;userRealm&quot;)UserRealm userRealm) &#123; //@Qualifier合格者，去根据bean名字查找userRealm对象，拿一个 DefaultWebSecurityManager securityManager =new DefaultWebSecurityManager(); securityManager.setRealm(userRealm); //设置关联realm return securityManager; &#125; @Bean(name= &quot;userRealm&quot;) //执行授权器 public UserRealm getRealm() &#123; return new UserRealm(); &#125;&#125; 使用shiro内置过滤器，可实现页面权限相关的资源拦截 资源拦截逻辑：以键值对集合形式添加各个页面和对应的拦截规则。不同的拦截规则会跳转到（修改过的）不同的页面。authc：跳转到登录页面tologin(tologgin路径是login的html)，点击登录按钮后执行认证逻辑perms：进行授权逻辑，是否匹配perms字符串，不匹配跳转到拦截页面 在过滤拦截器中使用shiro内置过滤器，可以实现页面的拦截，和跳转页面。也可以用不同的过滤器放行一些页面。 常用的过滤器： anon:无需认证（登录）可以访问 authc:必须认证才可以访问 user:如果使用了rememberme的功能可以访问 perms:该资源必须授权资源权限才可以访问 role:该资源必须得到角色授权才可以访问 12345678910111213141516@Bean public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier(&quot;securityManager&quot;) DefaultWebSecurityManager securityManager ) &#123; ShiroFilterFactoryBean shiroFilterFactoryBean=new ShiroFilterFactoryBean(); //设置安全管理器 shiroFilterFactoryBean.setSecurityManager(securityManager); //添加shiro内置过滤器,将链接跳转页面和过滤器以键值对形式，加入hashmap集合 Map&lt;String,String&gt; filterMap = new LinkedHashMap&lt;String,String&gt;(); filterMap.put(&quot;/add&quot;, &quot;authc&quot;);//authc必须认证才能访问 filterMap.put(&quot;/update&quot;, &quot;authc&quot;); //修改跳转登录页面url, 每一个页面都要写一个controller，@RequestMapping对应路径 shiroFilterFactoryBean.setLoginUrl(&quot;/tologin&quot;); //安全管理器中添加集合的拦截，集合中添加的路径会按照键值对设置对应的拦截 shiroFilterFactoryBean.setFilterChainDefinitionMap(filterMap); return shiroFilterFactoryBean; 那么拦截成功就会自动跳转到http://localhost:8080/login，可自己修改跳转登录链接url如上，并且在controller类中写对应的@RequestMapping对应路径，并且写路径的页面html文件。（login.html） filterMap.put(“/test”, “anon”);让首页链接放行，无需认证（登录）可以访问，要注意顺序，这个在前面 filterMap.put(“/*”, “authc”); 这里可以让templates下面的全部资源使用过滤器，虽然他们都是user包下的，但是用根目录 超链接是写在首页test.html中,超链接点过去的跳转链接是写在Controller类中，并且写了return的html文件 12345678910111213&lt;!DOCTYPE HTML&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt; &lt;/meta&gt;&lt;title&gt;测试&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3 th:text=&quot;$&#123;name&#125;&quot;&gt;&lt;/h3&gt;&lt;hr/&gt;进入用户添加功能：&lt;a href=&quot;add&quot;&gt;用户添加&lt;/a&gt;&lt;br/&gt;进入用户更新功能：&lt;a href=&quot;update&quot;&gt;用户更新&lt;/a&gt;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt; 第四章 编写用户登录功能简单设计了一个登录页面login.html（之前的过滤拦截后的跳转页面，也是登录失败的返回页面）1234567891011121314151617&lt;!DOCTYPE HTML&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt; &lt;/meta&gt;&lt;title&gt;登录页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;这是拦截登录页面&lt;h3&gt;登录&lt;/h3&gt;&lt;h3 th:text=&quot;$&#123;msg&#125;&quot; style=&quot;color:red&quot;&gt;&lt;/h3&gt;&lt;form method = &quot;post&quot; action=&quot;login&quot;&gt; 用户名:&lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt;&lt;br/&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 为什么登录前后都用login.html?因为登录失败时model携带的msg信息才会与html中的msg匹配显示出来 点击登录按钮后跳转到login页面,编写login Controller的登录逻辑 接收 输入到login页面的用户名和密码，封装（添加）到token对象，吧token对象发给shiro。try catch判断登录成功或失败；成功返回test首页；失败 用model存储失败信息返回login页面。1234567891011121314151617181920212223//登录按钮后的跳转页面，实现逻辑处理 @RequestMapping(&quot;/login&quot;) //model中存入我们要return回login.html的信息,会吧存在里面的消息带回去，会在msg对应地方打印出错误消息 public String login(String name, String password, Model model) &#123; //使用shiro编写认证操作 //1.获取subject用户主体 Subject subject = SecurityUtils.getSubject(); //2.用token封装用户数据 UsernamePasswordToken token = new UsernamePasswordToken(name,password); //3.执行登录方法,执行过程中要传递用户的token给subject(就是传递给shiro) //如何判断是否信息无误：这段代码无任何异常 //shiro将异常/登录失败分的很清楚：UnknownAccountException e用户名不存在;IncorrectCredentialException密码错误 try &#123; subject.login(token); //无异常，登录成功跳转回首页test.html return &quot;test&quot;; &#125; catch (UnknownAccountException e) &#123; model.addAttribute(&quot;msg&quot;,&quot;用户名不存在&quot;); return &quot;redirect:/tologin&quot;;//重定向，请求到tologin路径,会执行tologin的controller,还是回到login.html &#125;catch(IncorrectCredentialsException e) &#123; model.addAttribute(&quot;msg&quot;, &quot;密码错误&quot;); return &quot;login&quot;;//所以直接回去也可以的 &#125; 编写realm的认证函数中：判断登录信息逻辑12345678910111213141516//执行认证逻辑,Authentication证明,这里接收到的就是controller中提交到shiro的token @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; System.out.println(&quot;认证&quot;); //现在先假设数据库的用户名和密码是 String name = &quot;xyt&quot;; String password = &quot;666&quot;; UsernamePasswordToken thistoken = (UsernamePasswordToken)token; //判断用户名和密码 if(!thistoken.getUsername().equals(name)) &#123; //shiro底层会抛出UnknownAccountException return null; &#125; //密码不需要判断。返回AuthenticationInfo的子类 return new SimpleAuthenticationInfo(&quot;&quot;,password,&quot;&quot;);//提交给login方法的，数据库密码(shiro会自动判断)，shiro的名字 &#125; 第五章 整合mybits实现用户登录认证 MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。 导入mybits相关依赖12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.9&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt; &lt;/dependency&gt; 在mysql sqlyog客户端中建一个数据库springboot_shiro，添加user表 写配置文件12345678910spring.datasource.driverClassName=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost/springboot_shiro?serverTimezone=UTC //url这里不用写主机ip,不用写3306（3306加上也可以成功运行）spring.datasource.username=root //用户名在sqlyog的客户端里数据库上面写的root@localhost,@前面的就是用户名spring.datasource.password= //密码记在手机里了spring.datasource.type=com.alibaba.druid.pool.DruidDataSourcemybatis.type-aliases-package=com.example.demo.domain //扫描包下的实体类 写com.example.demo.domain下的实体类User不加注解,与数据库数据中对应 name,id,password,getter,setter 写com.example.demo.mapper包下两个文件 写Dao: interface UserMapper接口 1234567import com.example.demo.domain.User;public interface UserMapper &#123; //查询 public User findByName(String name);&#125; 写映射文件： UserMapper.xml (一定要和上面的java文件名字一样)。这个文件里放CURD的sql语句,对应着上面接口中的函数实现 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapperPUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.example.demo.mapper.UserMapper&quot;&gt; &lt;select id = &quot;findByName&quot; parameterType=&quot;string&quot; resultType=&quot;User&quot;&gt; SELECT `id`, `name`, `password` //可以随意大小写，不用加引号 FROM user where name= #&#123;value&#125; //这个是占位符 &lt;/select&gt;&lt;/mapper&gt; 业务包servise 接口类UserService 1234public interface UserService &#123; public User findByName(String name);&#125; 实现类UserServiceImpl：来实现mapper接口，要加注解@Service 123456789101112131415@Servicepublic class UserServiceImpl implements UserService&#123; //注入Mapper接口 @Autowired private UserMapper userMapper; @Override //实现UserService的函数，参数传给userMapper的函数 public User findByName(String name) &#123; return userMapper.findByName(name); &#125;&#125; 修改启动类加上注解@MapperScan(“com.example.demo.mapper”)扫描mapper接口所在的包 在controller中注入业务123//注入业务 @Autowired private UserService userService; 在realm中注入业务，修改认证逻辑（去数据库中匹配用户名和密码）12345678910111213141516171819202122232425 //注入业务 @Autowired private UserService userService; //执行认证逻辑,Authentication证明,这里接收到的就是controller中提交到shiro的token @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; System.out.println(&quot;认证&quot;);// //现在先假设数据库的用户名和密码是// String name = &quot;xyt&quot;;// String password = &quot;666&quot;; UsernamePasswordToken thistoken = (UsernamePasswordToken)token; //现在已经连接了mysql数据库，写好了查询函数。然后这里就用获取到的name去找对应的password com.example.demo.domain.User user = userService.findByName(thistoken.getUsername()); //判断用户名和密码 if(user==null) &#123; return null;//shiro底层会抛出UnknownAccountException &#125; //密码不需要判断。返回AuthenticationInfo的子类 return new SimpleAuthenticationInfo(&quot;&quot;,user.getPassword(),&quot;&quot;);//提交给login方法的，数据库密码(shiro会自动判断)，shiro的名字 &#125;&#125; 第六章 整合mybits实现用户登录授权shiroconfig添加内置授权过滤/拦截器 perms： 该资源必须得到资源权限才可以访问1234567891011121314151617181920212223242526 @Bean public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier(&quot;securityManager&quot;) DefaultWebSecurityManager securityManager ) &#123; ShiroFilterFactoryBean shiroFilterFactoryBean=new ShiroFilterFactoryBean(); //设置安全管理器 shiroFilterFactoryBean.setSecurityManager(securityManager); //添加shiro内置过滤器,将链接跳转页面和过滤器以键值对形式，加入hashmap集合 Map&lt;String,String&gt; filterMap = new LinkedHashMap&lt;String,String&gt;();// filterMap.put(&quot;/add&quot;, &quot;authc&quot;);//authc必须认证才能访问// filterMap.put(&quot;/update&quot;, &quot;authc&quot;); filterMap.put(&quot;/test&quot;, &quot;anon&quot;); filterMap.put(&quot;/login&quot;, &quot;anon&quot;); //授权过滤器，登录过的user在add页面需要拿到add页面的授权才能访问 //在登录后点击添加时，就会进入授权逻辑 filterMap.put(&quot;/add&quot;, &quot;perms[user:add]&quot;); filterMap.put(&quot;/*&quot;, &quot;authc&quot;); //修改拦截的跳转登录页面url, 每一个页面都要写一个controller，@RequestMapping对应路径 shiroFilterFactoryBean.setLoginUrl(&quot;/tologin&quot;); //设置未授权的拦截页面：没有拿到某页面授权去访问某页面会跳转到/unAuth shiroFilterFactoryBean.setUnauthorizedUrl(&quot;/unAuth&quot;); //安全管理器中添加集合，以上设置的键值对拦截功能生效 shiroFilterFactoryBean.setFilterChainDefinitionMap(filterMap); return shiroFilterFactoryBean; reaml中写资源授权逻辑 逻辑：拦截过滤器添加了perms授权拦截，点到add页面就会进入授权逻辑。在进行授权逻辑时，就拿到了这个字符串，对应config那边的规则perms[user:add]，字符串匹配，授权完成，可访问正常add页面；若在授权逻辑中没有拿到相同字符串，被拦截，跳转unAuth页面。123456789@Overrideprotected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection arg0) &#123; System.out.println(&quot;执行授权逻辑&quot;); //资源授权 SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(); //添加授权字符串,在进行授权逻辑时，就拿到了这个字符串，对应config那边perms[user:add]，字符串匹配，授权完成，可访问 info.addStringPermission(&quot;user:add&quot;); return info; &#125; 改造上面的授权编码，让perms字符串更加灵活 在数据库中添加每个用户的perms 修改了表的结构，就要修改对应的实体类User结构,添加perms属性 我们需要取出数据库中的perms，需要在mapper接口中新定义一个根据id就能查找user对象的方法，然后在映射文件中写出对应的sql查询语句（相当于写出了这个具体函数方法） 在service接口中添加相同的方法 对应的在UserServiceImpl中实现这个方法：这里是调用mapper里写的sql函数return userMapper.findById(id); 第七章 thymeleaf和shiro标签整合使用导入thymleaf扩展坐标 加入扩展依赖 123456&lt;!-- thymel对shiro的扩展坐标 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.theborakompanioni&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-shiro&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt; &lt;/dependency&gt; shiroconfig中配置shiro的dialect(方言)，用于thymeleaf和 shiro标签配合使用 1234@Bean //交给spring容器 public ShiroDialect getShiroDialect() &#123; return new ShiroDialect(); &#125; 想要对于已登录用户，test主页只显示用户拿到授权的跳转超链接 修改test.html,将超链接部分加入包裹起来，并且加入shiro的permisson字符串但是这样在未登录情况也会判断授权字符串 1234567&lt;div shiro:hasPermission=&quot;user:add&quot;&gt;进入用户添加功能：&lt;a href=&quot;add&quot;&gt;用户添加&lt;/a&gt;&lt;br/&gt;&lt;/div&gt;&lt;div shiro:hasPermission=&quot;user:update&quot;&gt;进入用户更新功能：&lt;a href=&quot;update&quot;&gt;用户更新&lt;/a&gt;&lt;br/&gt;&lt;/div&gt; 继续加入，加在上面那些代码的上面。意思是：”url”，点登陆会超链接跳转到/tologin路径 1&lt;a href=&quot;tologin&quot;&gt;登录&lt;/a&gt; 此项目代码资源-eclipse链接：https://pan.baidu.com/s/1n8oLFCNfRk90kYmhNBAnBg提取码：o470 注：此外需要mysql中的同名数据库和表 14天黑马头条项目###]]></content>
      <categories>
        <category>springboot</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java考试复习总结]]></title>
    <url>%2F2019%2F12%2F24%2Fjava%E8%80%83%E8%AF%95%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[单词提取 encapsulation 封装 length 有g //另：数组求长度 xxx.length; 字符串求长度 xxx.length(); mantissa 小数部分 基础知识数据类型（整数都有一位是表示正负符号位） byte:1byte; short:2byte; int:4byte; long:8byte float:4byte(整数1byte,小数点后最多7位); double:8byte(整数10位，小数点后最多15位) char:2byte boolean:至少1byte 去年考试题目1.1 Message:Variables: messageText, sender, sendTime, readprivate String messageText; private String sender; private LocalDateTime sendTime; private boolean read;Constructor: Message(String messageText, String sender, LocalDateTime sendTime, boolean read ){ this.messageText = messageText; this.sender = sender; this.sendTime = sendTime; this.read = read; }Encapsulation：public void setMessageText(String messageText) //set，get,小写，后面第一个字母大写{ this.messageText = messageText; } public String getMessageText() { return this.messageText; } public String toString() { //if() return sender + &quot;send&quot; + messageText + &quot;at&quot; + sendTime.toString() + &quot;read or not:&quot; + read; } 1.2 public static void main(String[] args) { double[] numbers= new double[10]; fillArray( numbers); printArray( numbers); System.out.println(“The minimum value is:”+ findMinimum(numbers)); reverseArray( numbers); printArray( numbers); } //fill the array with double values / /use a Scanner to get input from the keyboard public static void fillArray ( double[] toFill) { Scanner s = new Scanner(System.in); //double temp; for(int i= 0; i&lt; toFill.length; i++) { toFill[i] = Double.parseDouble(s.nextLine()); //重点：String转成其他类型不能直接（double）xxx转换； 只能用Xxx.parseXxx(String); 注意Integer.parseInt(String); } } //print the contents of the array to the console, showing the index and value of //each element on a new line public static void printArray(double[] toPrint) { for(int i= 0; i&lt; toPrint.length; i++) { System.out.println(toPrint[i]); } } ///reverse the array. Do not need to display public static void reverseArray(double[] toReverse) { double [] temp = new double[toReverse.length]; //重点:新建数组不确定长度时 xxx.length //double [] temp = toReverse; //重点:建立和传入参数相同的数组时 不能用次方法（这种方法会让新建的副本数组跟随原数组变化而变化(后面要将原数组翻转，会改变源数组的值),只能先遍历出原数组的内容赋值到新数组中，再进行原数组改变值） int j = toReverse.length -1; for(int i= 0; i&lt; toReverse.length; i++) { temp[i]= toReverse[i]; } for(int i= 0; i&lt; toReverse.length; i++) { toReverse[i]= temp[j]; j--; } } //return the minimum value of the array public static double findMinimum(double[] array) { double minimum = 0 ; double temp; for(int i= 0; i&lt; array.length -1; i++) { temp = array[i]; if(temp &gt; array[i+1]) { minimum = array[i+1]; } else if(i==0) //重点：只需要考虑第一次 { minimum =temp; } } return minimum; }]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[计算机系统]]></title>
    <url>%2F2019%2F12%2F22%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[CSE101 Q and A 内容###计算机系统4层体系结构 用户代码，软件，操作系统，硬件 （前二为程序员，用户层面） 硬件 硬件举例： CPU，内存，硬盘hard disk, 键盘， 屏幕display screen 操作系统 将硬件系统的功能带出来 操作系统包围住硬件系统的好处： 易于编程，保护系统，公平和效率使用系统 组成成分 输入，输出，内存，CPU CPU ALU 中央处理器 central processing unit 进行计算和其他操作 运算器 arithmetic logical unit ALU 和 control unit 是CPU两个主要元件 处理器processor（CPU）遵循软件的指令处理数据 CPU只能执行加载进内存的指令 内存 系统内存 储存着CPU处理，存取的数据 次要存储： 硬盘hard disk, CD, DVD 系统内存中存储着 程序和数据 program and data ，由二进制表示的 接上，其中计算机知道哪里读取指令，哪里读取数据，虽然指令和数据都是二进制 输入输出设备 输入设备： 鼠标，键盘，扫描器Scanner 另：输入硬件设备将数据翻译成计算机能处理的形式 输出设备： 显示器Monitor, 扬声器Speaker, 打印机Printer WIMP 和 OS 主要是输入和输出设备： window, icon, menu, pointer （大概是电脑界面点击图标的意思） WIMP是操作系统OS在四十年中最重要的革新 操作系统OS需要分配公平的被保护的资源： 因为多线程容易死结deadlock, 同时保护硬件（用户不合理操作时） OS支持多任务操作时的功能： 内存管理，安全，分配CPU给每个程序 OS提供访问给网络设备facility: 通过API应用程序界面 ，例如socket interface 普通用途机器有OS特殊用途机器没有OS，只能高效率的做特定的事情 学习层面 程序运行时，计算机内部和程序底层–汇编 分层分区的好处 易于理解，易于设计，易于改变 服务器 Servers 通过 web-network-cloud 服务器是专门用于存储大量PC上数据和程序的工作平台 Dumb terminal:哑终端，一切程序交给主机做，主机不能做任何处理 向下兼容 Downward Compatibility 新软件能在旧硬件上运行 高速集成电路硬件描述语言- VHDL摩尔律 电路大小缩减一半 几个不同的注重 科学计算—Computation 计算 商业计算—Data 数据 个人计算机—Interaction 交互 Input-Process-Output模型 是数字电脑的基础结构 软件编程控制着Process 硬件，软件，（被操作的）数据 ，这三个原件实施Input-Process-Output模型 和 von Neumann 模型 其中von Neumann 模型是 Input-Process-Output模型 中的Process部分Process部分: Processor（应该是CPU） 和 Memory 互相连接传递数据interconnect CPU的读取速度快于主内存，也就是说主内存的速度不快，会拖慢整体交换链接数据的速度，CPU读取速度再快也没有用 von Neumann的机器中 数据和指令 共享同一内存 混合存放 Harvard结构 将数据和程序分离开存储提高了传输速率transfer rate 和生产力throughput但是数据和指令需要单独的存储器single reservoir像是指令缓存instruction cache 数据缓存data cache 指令集instruction set 没有指令标准 standard instruction 对于特殊用途的机器，指令集instruction set通常是固定的 高级编程语言HLL 优势： 用户友好， 编程方便 举例： java c c++ python 程序编译过程 Edit 变成HLL — Compile变成二进制对象文件 —-Link 变成可执行文件 —- Load 最后运行 Compiler编译器: HLL变成机成机器码 Assembler汇编器： 机器指令助记符变成二进制 另：汇编器将标签和内存地址链接在一起 Interpreter解释器： HLL指令解码decode变成中间代码Intermediate code,还是会变成机器码解释器在程序切换快，程序运行快，程序转移到另外平台上时比编译器更好用 Inline assembler内联汇编器： 可以在汇编段中调用c程序库中的函数 用户使用计算机时内部的工作流程 用户使用计算机系统算题的一般流程: ①通过系统操作员建立帐号，取得使用权。帐号既用于识别并保护用户的文件(程序和数据)，也用于系统自动统计用户使用资源的情况(记帐，付款)。 ②根据要解决的问题，研究算法，选用合适的语言，编写源程序，同时提供需处理的数据和有关控制信息。 ③把②的结果在脱机的专用设备上放入软磁盘，建立用户文件(也可在联机终端上进行，直接在辅助存储器中建立文件，此时第四步省去)。 ④借助软盘机把软盘上用户文件输入计算机，经加工处理，作为一个作业，登记并存入辅助存储器。 ⑤是要求编译。操作系统把该作业调入主存储器，并调用所选语言的编译程序，进行编译和连接(含所调用的子程序)，产生机器可执行的目标程序，存入辅助存储器。 ⑥要求运算处理。操作系统把目标程序调入主存储器，由中央处理器运算处理，结果再存入辅助存储器。 ⑦运算结果由操作系统按用户要求的格式送外部设备输出。 计算机内部工作(④~⑦)是在操作系统控制下的一个复杂过程。通常，一台计算机中有多个用户作业同时输入，它们由操作系统统一调度，交错运行。但这种调度对用户是透明的，一般用户无需了解其内部细节。 用户可用一台终端，交互式的控制③⑦的进行(分时方式);也可委托操作员完成③⑦，其中④~⑦是计算机自动进行的(批处理方式)。批处理方式的自动化程度高，但用户不直观，无中间干预。分时方式用户直观控制，可随时干预纠错，但自动化程度低。现代计算机系统大多提供两种方式，由用户选用。 代码分享方法 资源水平的子程序， 宏程序库macro libraries（问题： 谁维护，谁拥有） 预先翻译，可再定址的二进制库 动态库，动态link 库library 库可以link到程序代码，但不能修改 对于动态库，动态link有一个事实标准de-facto standard : Microsoft active 数据单位 bit,byte encode编码ASCII表用了7bit = 2的七次方大小表示一位，第一位表示正负 256bytes数据 可以存入 8bit system 内存地址从0000到00FF ： 1byte* (F16+F1)= 1516+151=256 bytes可以存入16bit system 内存地址从0000到007F ：2byte（716+F1）= 2（716+151）=256 bytes 编码表 ASCII表一位=1byte=8bit;1010 0101 1111 1000 = 16bytes 二进制文件一位=1bit; 1010 0101 1111 1000 = 16bits = 2bytes ASCII表最常用，EBCDIC现在已经不用了，被替代了 ASCII表不能编码除了英语和一些欧洲国家语言之外的字符 ASCII表分为字符和指令字符 printing and control characters 对于不同的表，编码速度没有差异 IEEE754 标准是最广泛使用的浮点转换二进制计算的标准 octal notation 是八进制声明变量时 告诉编译器预留内存空间 告诉编译器变量类型 线 bus 地址线，数据线，控制线 bus线的速度达不到（不匹配）CPU和内存交换的速度,就会让整体速度拖慢 bus一次一条线只能传一项item数据 协处理器coprocessor math, graphic 数学和图像应用程序 微处理器microprocessor 处理接收到的大量信息 存在于计算器，手机，平板，手表，MP3，照相机中 系统时钟system clock 系统时钟控制了所有计算机操作的执行速度 文件系统执行任务时的资源消耗 CPU时间资源，内存，硬盘空间 CPU time, memory, disk space 机器循环machine cycle 重要，注意是指令 过程： 获取指令–解码指令–执行–存储结果 main steps: fetch instruction–decode instruction–execute–store RISE CISE RISE的指令描述简单， CISE指令描述字多 processors that support fewer instructions than do SISC chips 指令执行寄存器 IP,IR,MAR,MBR 不同指令的获取fetch语句是相同的 不同指令的执行execute语句不同 CPU状态标志符Flag Zero flag： 为0，zf=1 Sign flag: 为负数 首位1， sf=1 Carry flag： 产生进位或退位为，cf=1 Overflow flag: 溢出， of=1 EFlage: CMP AL,BL (AL-BL) D flag: direction of processing O flag: Arithmetic overflow error 这些flag在指令执行之后才标记 CMP 后会改变flag，不是check 指令 Pentium奔腾指令集的指令从1到15字节的宽度（不确定），来加速指令解码 指令包含三个： 操作指令，操作数的数据类型，操作数的地址和结果 机器指令用不同的字段Distinct bit field来编码所需的操作内容 寄存器和寄存器之间的运算是最快的 函数 printf: 先进栈的最后打印出来 push顺序：先数字-再占位符-最后句子 call函数时：把EIP（指令指针）中的地址push到栈中， 再把函数地址放进EIP ret时： pop出最后存入栈的地址，放入EIP中 栈的框架下储存的数据类型： 子程序的参数，ret地址，EBP栈指针，局部变量 BCD码：将十进制的每一位0-9的数字转换成四位的二进制码 BCD码：将十进制的每一位0-9的数字转换成四位的二进制码 321的BCD码： 0011 0010 0001 321的二进制码： 101000001 1 byte(8bit)只能表示0-99（99就是 1111 1111） BCD的经济性不如二进制码binary（位数更多）， BCD计算更复杂， 但BCD和字符见的转换更加容易； 二进制表示更容易理解，BCD更容易理解用于某些业务应用程序 2’s complement 补码 正数补码不改变 负数（符号位1）补码： 符号位不变，其余位取反后加一 2’s complement会有溢出的情况： 两个整数相加变成负数 赞成者Pros: 基于two-state technology 易于实现 反对者Cons: 对于人难以理解 带符号整数相加会发生溢出怎么办： 用of sign检测:相加前后的of应该相同，如果不同就溢出了（不太清楚，可能是相加后同为负数或整数） 带符号整数减法是加法的另一种形式，同样也会溢出。加法溢出，减法溢出 10’s complementary convention十进制补充约定 n位数字表示为10’s complementary convention 是基于模module 10 十进制的互补表示: 0到499表示0到499， 500到999表示-500到-1 （-一千减x） 同样有溢出： 347+230= 577大于499溢出 ，577= -（1000-577）=-423 基础类型的bit大小: -2^(x-1 bit次方) 到 2^(x-1 bit次方)-1, 都要去掉符号位 byte: 8bit ,1byte short: 16bit ,2byte , -2^15到2^15 -1 long: 64bit ,8byte int: 32bit ,4byte IEEE754 1bit正负 8bit指数 23bit小数有效位数 ，不存小数点 把二进制小数 变成十进制小数：指数8位- 128+1 = 8位-10000000（2^7，8位）+1 = 整数 ，Excess-127格式小数23位： 1.xxxxxxxx （不用转换）计算 2^指数*1.xxxxxx NaN规范：指数位127，小数位不是0，此时NaN(not a number) 其他看不懂：单精度指数过剩excess notation 127;双精度指数过剩excess notation 1023 数据存储器 寄存器register（8bit,在CPU中） 到 缓存cache 到 内部内存main memory（RAM,ROM） 到 硬盘disk 越来越慢，空间越来越大，价格越来越便宜； 寄存器最快最小最贵 数据获取access的方法：顺序存储sequential storage会减慢数据检索retrieval的进程 Main memory 计算机内部，断电消失 RAM随时存取储存器：分两个DRAM动态，SRAM静态 ROM只读存储器 Cache高速缓存存储器 独立保存，断电不消失 硬盘 : 检索硬盘副本显示到屏幕上，如果检索之后不被修改，源文件不会被覆盖 光盘 ： 读道track U盘 电路combinational组合 sequential数列 logic circuits 组合逻辑电路没有记忆区memory ，数列逻辑电路有记忆区 卷子中的待解决问题 —今年只有选择题和汇编无问答 What is the mechanism being used to pass parameters to the C library function Answer the following questions based on IEEE 754 standard.(4marks each)a) What is the largest positive number represented by IEEE 754 single-precision format?b) What is the encoding of the number -123.625 in IEEE 754 single-precision format?c) What is the smallest normalisedpositive number represented by IEEE 754 single-precision format? 内联汇编 _asm{} 记住：push一次esp+4; 每次call完结算前面push次数， add esp,4n xchg交换值指令： xchg eax, [sei+4] 至少要有一个寄存器 调用： call printf ,call scanf_s 遍历数组存首地址 lea esi, intArray循环中 add eax, [esi]add esi, 4 mov esi, 0循环中 add eax, intArray[esi]inc esi]]></content>
      <categories>
        <category>记忆性学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[游戏和开源项目学习]]></title>
    <url>%2F2019%2F11%2F27%2F%E6%B8%B8%E6%88%8F%E5%92%8C%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[初心 想先做像页游那样的游戏，任务在家园里移动。感觉是可以实现的。]]></content>
  </entry>
  <entry>
    <title><![CDATA[mySQL]]></title>
    <url>%2F2019%2F09%2F14%2FmySQL%2F</url>
    <content type="text"><![CDATA[19.9.14安装 mysql5.7安装以及配置环境（注意：官网安装非常慢，打开迅雷复制官网下载网址链接下载安装）https://www.bilibili.com/video/av66542221 19.9.15 语句超级容易输错单词,有无s什么的….. 19.9.16 感觉有点枯燥呢，加油]]></content>
      <categories>
        <category>数据库sql</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[学习计划与心得]]></title>
    <url>%2F2019%2F09%2F14%2F%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92%E4%B8%8E%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[19.9.14 希望每天保持八小时的有效学习时间，坚持记录笔记，多任务学习 英语老老实实背单词 文件要装好 19.9.16 效率挺低的完全没办法做到做任务学习 19.9.17 备考雅思单词：会认与会写。 A4纸折八列，写单词和意思 ，折起来背 19.9.29 很久没有记录了，平时真的没什么时间，英语也很差，代码经常出问题，还是缺少练习 20.2.23 小匠笔记：学东西一定要先看官方网址文档。最开始学东西先用起来，不要死磕，之后多用就会了 创建包来隔离不同的业务 参数多于两个就要把他封装成对象 全部文件/包放在启动类所在包下面 初了解一个应用，一定去看它的官方文档]]></content>
      <categories>
        <category>学习计划</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java基础记录；java全栈开发（从入门到入坟）的笔记]]></title>
    <url>%2F2019%2F09%2F13%2Fjava%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[安装 安装netbeans8.2 IDE 和jdk1.8.0 百度云传不了，放在u盘里的 注意如果netbeans出错了就把相关文件夹删干净（360强力删除）之后重装，会省时省力很多。 19.9.13数组定义数组 int [] arr = new int []{1,2,3,4,5};int [] arr = {1,2,3,4,5}; 自定义函数要写在主类class Main里，public static void main 的下面；数组作为自定义函数的参数时要写括号：public static int add(arr[])；main函数里调用自定义函数时参数只用写数组名（此时调用数组第一个数据的地址）： add(arr) ；而且调用函数的返回值用一个变量装载一下 ：int b = add(arr) 各种功能都写成函数再调用，不要写在主函数里 改变数组的自定义函数：返回类型为void（改变指针） 表 数组可以作为表： 当数据之间存在对应关系时，通过一方可以查询到另外一方。ex: 通过数组的索引查表（查找数组中的内容）,(这样比switch if 条件判断方便) 数组选择排序 从第一个依次向后比较，替换第一个；在从第二个依次向后比较，替换第二个….（小数向前挪动）12345678910111213141516171819202122232425262728293031323334353637 public class Main &#123; public static void main(String[] args) &#123; int arr[] =&#123;12,9,23,77,12,34&#125;; rank(arr); printArr(arr); &#125; public static void rank(int []arr ) &#123; for(int a =0; a&lt;arr.length-1; a++) &#123; for(int b = a+1; b&lt;=arr.length -1; b++) &#123; if(arr[a]&gt; arr[b]) &#123; int temp= arr[a]; arr[a]= arr[b]; arr[b]= temp; &#125; &#125; &#125; return ; &#125; public static void printArr( int arr[]) &#123; for(int x=0; x&lt; arr.length; x++) &#123; if(x == arr.length -1) System.out.println(arr[x]); else System.out.print(arr[x] + &quot;,&quot;); &#125; return; &#125;&#125; 数组冒泡排序 1-2比，2-3比，3-4比…(将每次比较的大值放在后面再和下一个数比较)，再重复1-2比，2-3比..1234567891011121314public static void rank(int []arr ) &#123; for(int a = 0; a&lt; arr.length-1; a++) &#123; for(int b = 0; b&lt;arr.length-1-a; b++) //【-a】这里为了实现每一次横向比较时，比较的次数都会随着横向比较次数的增加而递减（因为每次横向排序的末尾最后一个一定是最大的数，所以下一次横向比较时不再比较最后一个数） &#123; if(arr[b]&gt;arr[b+1]) &#123; int temp = arr[b]; arr[b]=arr[b+1]; arr[b+1]=temp; &#125; &#125; return ; &#125; &#125; 代码抽取 以上两个排序中的交换数组中数字位置部分的代码块重复，可自定义一个新功能，再调用（如冒泡排序中： swap(arr, b, b+1);）,方便使用提高复用性123456public static void swap(int arr[], int a, int b) //注意未知的都是参数： 数组不知道，交换位的角标不知道 &#123; int temp = arr[a]; arr[a]= arr[b]; arr[b] = temp; &#125; 使用程序包 以上数组排序功能都可在程序包内（需要自己下载），开发时直接import程序包，再调用就可以，不要自己写功能 19.9.14数组普遍查找 普遍查找数组中元素(遍历数组)，返回值为int(角标):return x；如果没有此元素，return -1 (代表不存在的情况) 二分查找 1、定义min、max、mid角标；2、比较mid和查找数据大小： 数据大，min=mid+1;数据小, max=mid-1; 3、循环；4、循环中判断查找的数据是否存在(存在条件max min之间有距离：min &lt;= max) 或者判断存在条件作为while循环条件，会更加简洁1234567891011121314151617181920212223242526272829public static void main(String[] args) &#123; int arr[] =&#123;9,12,15,24,36,41,59,68&#125;; rank(arr); int a =binarySearch(arr, 41); System.out.println(&quot;第&quot;+(a+1)+&quot;个是:&quot;+arr[a]); &#125; public static int binarySearch(int arr[], int key) &#123; int min, max, mid; min=0; max = arr.length -1; mid = (min + max)/2; while(arr[mid] != key) &#123; if(arr[mid]&lt; key) &#123; min = mid +1; mid = (min + max)/2; &#125; else if(arr[mid]&gt; key) &#123; max = mid -1; mid = (min + max)/2; &#125; //判断查找元素是否存在 if(max&lt;min) return -1; &#125; return mid; &#125; 19.9.18面向对象 对象：属性（数值，是变量）+ 行为（功能，是函数） 19.9.29数组 创建功能：传入数组参数，返回数组参数主函数中 &gt; + String arr[] = new String[6];public static String[] change (String [] arr) //定义中类型和参数都有括号 return arr; //返回值无括号主函数中接收返回值时直接 &gt; + String name [] = change(arr) //调用传值无括号 Scanner 首先在package 下面加上 import java.util.Scanner; Scanner a = new Scanner(System.in);int num = a.nextInt(); Scanner b = new Scanner(System.in);String name = b.nextLine();可见： 先用一个创建的对象接收输入的值，再定义一个新的变量 接收输入对象 改变类型之后的值 2019.10.5private static private不可以和static同时用 private：对象的属性，构造函数； 对象的行为(功能函数)一般用public让调用者调用？ static:静态不能访问非静态（静态随类先加载） 单例模式———创建本类中对象饿汉式：一上来就创建对象 class Teacher{ private String name; private static Teacher single = new Teacher(“xx”);//创建本类中对象 private Teacher(String name) //private构造函数以及函数都不可以被调用，只能在类中调用，也就是说当private 属性和行为和构造函数时，都要设置相应的public函数 {this.name = name;} //记得加this. 表示此对象中的属性 public static Teacher build() { return single;} //主函数中调用此public函数完成对象a的指向 本类中创建的对象（单例） public String getname() {return single.name;} } public static void main(String[] args) {Teacher a = Teacher.build(); System.out.println(a.getname()); } 懒汉式：先创建对象指针，再在创建单例函数中创建对象（开辟空间），使用构造函数 class Teacher{ private String name; private Teacher(String name) {this.name = name;} private static Teacher single = null; //一定注意指针先赋值为空指针 public static Teacher build(String name) { single = new Teacher(name);return single; //返回已经构建好的对象指针？ } public String getname() {return single.name;}} public static void main(String[] args) {Teacher a = Teacher.build(&quot;xx&quot;); System.out.println(a.getname()); }]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>bug</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客文章编辑格式]]></title>
    <url>%2F2019%2F09%2F09%2F%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E7%BC%96%E8%BE%91%E6%A0%BC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[插入格式插入链接 超链接： []链接名+()网址Lucifinil’s blog 自动链接： &lt;&gt;网页地址Lucifinil’s blog https://lucifinil-x.github.io/ 插入图片 !+[]图片名+()网址 或()/next主题文件夹下/images/图片名 字体效果 斜体字体: * * 中添加文字 加粗字体: ** ** 中添加文字 斜体加粗字体： * * 中添加文字 横线分行 加上横线 : 三个 - 再回车后加内容 引用 单行引用: ``中加内容 多行引用： 三个点中加内容或代码块 123456多行引用： &lt;html&gt; &lt;head&gt; &lt;title&gt;我是标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt; &lt;/html&gt; 引用文章 : &gt; +内容 隐藏 隐藏内容需阅读全文: ““（自由设置）或在主题config里 设置123auto_excerpt:enable: truelength: 50]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>格式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lucifinil的博客计划~]]></title>
    <url>%2F2019%2F09%2F07%2Flucifinil%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[搭建就做了好几天，还有一些主题优化没有成功和待完成的~~ 未成功 添加背景图片 背景及点击动态 添加字数检索和阅读时间 待完成 添加live 2d看板娘 改变字体 添加扫码关注的公众号图片 在github上备份博客 注意事项 每周将博客文章上传更新至百度云备份 每天坚持把心得学习内容总结成笔记更新博客文章 写博客用的软件 sublime text, 在d盘]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[搭建博客]]></title>
    <url>%2F2019%2F09%2F07%2F%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[404问题和网页加载出来没有框架的问题 删除blog主文件下的第一个xxx.git文件夹（可用360强力删除） 修改回上一步之前修改的内容： 比如在config里本来是有#隐藏的文件路径， 实际上next主题并没有生成这个路径。 那么把自己新建的文件删除 把#在config里加回去 blog主文件夹下右键打开 git bash here hexo clean,hexo g,hexo s 三部曲 /c/Users/A/AppData/Roaming/npm/hexo: line 12: node: command not found 环境变量是在操作系统中一个具有特定名字的对象，它包含了一个或者多个应用程序所将使用到的信息。例如Windows和DOS操作系统中的path环境变量，当要求系统运行一个程序而没有告诉它程序所在的完整路径时，系统除了在当前目录下面寻找此程序外，还应到path中指定的路径去找。用户通过设置环境变量，来更好的运行进程。环境变量一般是指在操作系统中用来指定操作系统运行环境的一些参数，比如临时文件夹位置和系统文件夹位置等。 搜索控制面板 ——&gt; 系统 ——&gt; 高级系统设置 ——&gt; 环境变量 ——&gt; 下面的框系统变量里 Path编辑： 本机系统自带的：%SystemRoot%\system32;%SystemRoot%;%SystemRoot%\System32\Wbem; 自己需要添加的：D:\blog\node_modules\hexo\binD:\MinGW\MinGW\binC:\Program Files\nodejsD:\blog\node_modules\hexo\binC:\Program Files\MySQL\MySQL Server 5.7\bin （mysql的与hexo无关） 千万不能自己写一个path将系统自带的覆盖掉，覆盖了就自己先添加系统的。 4000端口占用 打开cmd 查询占用：netstat -aon|findstr “4000” 查看对应占用进程：tasklist|findstr “xxxx” 杀掉对应进程：taskkill /f /t /im node.exe 然后关掉cmd会出现git bash hexo s虽然搭建成功 但是无法用ctrl+c退出 右上角关闭之后再hexo s虽然报错端口占用 但是本地网页已经更新 本地页面更新，但部署的网页不更新？ 可能原因1（不用）：4000 端口占用 localhost:4000 端口被占用，可执行 hexo s -p 5000 修改成5000 端口 可能原因2（基本都是这个）： 刷新问题 网页输入网址或f5刷新，hexo g, hexo s, hexo d多来几遍 解决步奏【高亮！】： hexo g, hexo s生成本地4000页面，右上角关闭，hexo d，进入网页，没有刷新，按F5刷新，就出来了 YAMLException: end of the stream or a document separator is expected at line 4, column 13: 更新失败，博客上直接没有这篇文章 原因：hexo博客规则改了，之前catpgories可以放几个，选择只能写一个了；catogories: xxx 之间要加空格，而且不能用 -xxx 修改了所有没更新出来的文章分类那里，都只分一个类了]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>bug</tag>
        <tag>解决办法</tag>
        <tag>搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F09%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
