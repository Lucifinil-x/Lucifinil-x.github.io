<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2020下半年学习计划]]></title>
    <url>%2F2020%2F08%2F27%2F2020%E4%B8%8B%E5%8D%8A%E5%B9%B4%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[1.leedcode每日一题写暴力解和另外一解，总结2.150单词每日预计十月底结束雅思单词，每日清晨背 3.前端html,css,js,jQuery,bootstrap每个周期三天学完 4.javaweb框架spring,springmvc,mybatis,springboot 5.java面试力扣java内存模型，GC,线程安全，线程池Arraylist,hashmap数据结构数据库索引原理，innodb特点springIOC AOP笔试算法题 冒泡排序，二分查找，二叉树三种遍历]]></content>
  </entry>
  <entry>
    <title><![CDATA[2020-9月leedcode]]></title>
    <url>%2F2020%2F08%2F27%2F2020-9%E6%9C%88leedcode%2F</url>
    <content type="text"><![CDATA[8.27 1.两数之和 题目：给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 初解：用时十多分钟，提交错误两次，n2暴力 问题：返回值为数组，这里不是先给你声明的数组，返回值需要自己new数组； 初解改进：返回数组可以直接return new int[]{i,j}; 数组大括号中可以用参数12345678910111213141516171819class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int i=0; int j; int len = nums.length; for(i=0;i&lt;len-1;i++)&#123; for(j=i+1;j&lt;=len-1;j++) &#123; if(nums[i]+nums[j]==target)&#123; int []twoSum=new int[2]; twoSum[0]=i; twoSum[1]=j; return twoSum; &#125; &#125; &#125; return null; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[微信小程序]]></title>
    <url>%2F2020%2F08%2F15%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[小程序特点用户体验1.体量小无需下载app2.微信特殊技术，控件用的是一些系统原生的组件，流畅。3.打开小程序时，代码已经存储在手机里了，做页面跳转不需要请求服务器。 开发者1.ios,安卓平台兼容。2.小程序开发是web开发技术，一般两个月时间。3.公众号也是跨平台，但是功能有限。 运营1.微信用户基数大。2.微信扫一扫就能进入小程序。 小程序开发的应用轻量级别：web多，app少1.工具类：打卡，外卖，共享单车2.咨询类：微博，新闻3.电商类：拼多多4.小游戏 前置技能html,js,css]]></content>
  </entry>
  <entry>
    <title><![CDATA[idea使用]]></title>
    <url>%2F2020%2F08%2F03%2Fidea%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[快捷键ctrl + / 注释标签名字 + table 自动补全标签必填项 例：h1 + table 补全成闭合标签]]></content>
  </entry>
  <entry>
    <title><![CDATA[html]]></title>
    <url>%2F2020%2F07%2F18%2Fhtml%2F</url>
    <content type="text"><![CDATA[初识html1.什么是html？ 超文本标记语言 Hyper Text Markerup Language 2.超文本包括：文字、图片、音频、视频、动画。 3.现在用的版本html5+css3 4.html5特性提供新的网页功能，不需要安装插件就能用网页播放视频，使用网页动态渲染图标、图形、图形动画 5.html5的优势各个浏览器都支持html5,相当于天然的依靠浏览器就能跨平台(java跨平台用的是jvm) 6.浏览器浏览器就是智能的IDE,它会智能的解析html代码 W3C标准1.W3CWorld Wide Web Consortium(万维网联盟)Web技术领域的国际中立性技术标准机构 2.W3C标准结构化标准语言(html,xml)表现性标准语言(css)行为标准(dom文档对象模型,ecmascript JS的规范) 网页基本信息,html结构1.DOCTYPE 123&lt;!-- DOCTYPE:告诉浏览器，我们使用的是html规范 --&gt;&lt;!DOCTYPE html&gt; 2.html 总标签html代码写在html标签内部 3.head 头部标签head代表网页头部 3.1 meta标签meta描述性标签，它用来描述我们网站的一些信息meta一般用来做SEO(搜索引擎优化,对网站进行内部及外部的调整优化，改进网站在搜索引擎中的关键词自然排名) 1234&lt;!--meta描述性标签，它用来描述我们网站的一些信息--&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;keywords&quot; content=&quot;学习网站&quot;&gt; &lt;meta name=&quot;description&quot; content=&quot;每日学习打卡&quot;&gt; 3.2 title标签title网页标题 4.body标签body代表网页主体，我们写的东西都在body里 网页基本标签h1 h2 h3 几级标题p 分段，展示一行内容br/ 换行，段落无间距，单标签hr/ 水平线标签，单标签strong 粗体，标签内文字变成粗体 em 斜体，标签内文字变成斜体 特殊符号： &amp; ; 1234&amp;nbsp; 空格&amp;gt; 大于&amp;lt; 小于&amp;copy;版权所有xxx 版权符号 图像标签 img1.常见的图像格式JPGGIFPNGBMP 2.img标签参数 1&lt;img src=&quot;路径&quot; alt=&quot;失败文字&quot; title=&quot;悬停文字&quot; width=&quot;宽度&quot; height=&quot;高度&quot;&gt; src必填: 图片地址 相对路径/绝对路径 相对路径：相对于当前html文件的路径，../ 返回上一级的文件夹 ../../返回两级文件夹 alt必填: 图片加载失败时显示的文字 title 鼠标悬停显示的文字 width 图片宽度，可以加变量参数 hight 图片高度 其他的图片属性空格之后idea有提示 超链接标签 a1.普通链接-通过文字/图片跳转页面1.跳转页面超链接标签参数 1&lt;a href=&quot;链接路径&quot; target=&quot;链接在哪个窗口打开&quot;&gt;链接文本或图像&lt;/a&gt; href必填 target:_ blank 链接在新标签页打开_ self 链接在当前页面打开(不写target,默认为self) 2.文字超链接 1&lt;a href=&quot;https://bns.qq.com/&quot; target=&quot;_blank&quot;&gt;跳转剑灵&lt;/a&gt; 3.图片超链接(内置图片标签) 123&lt;a href=&quot;https://bns.qq.com/&quot;&gt; &lt;img src=&quot;../../source/image/&#123;0CD3A208-38C5-D227-DB52-F9A1DB0C7D73&#125;.png&quot; alt=&quot;龙族幻想&quot; title=&quot;零&quot;&gt;&lt;/a&gt; 2.锚链接-通过页面中的超链接定位到页面的具体位置锚链接实现页面中跳转定位的两个要素：1.锚标记 12&lt;!--name的属性TOP作为锚链接的标记，顶部是在页面显示的文字--&gt;&lt;a name=&quot;TOP&quot;&gt;顶部&lt;/a&gt; 2.跳转链接 12&lt;!--链接处为#+锚标记--&gt;&lt;a href=&quot;#TOP&quot;&gt;回到顶部&lt;/a&gt; 使用场景：1.本页面内部定位2.定位到另外页面的具体位置(锚标记位置) 12&lt;!-- 超链接+#+链接页面的锚标记--&gt;&lt;a href=&quot;链接标签.html#DOWN&quot; target=&quot;_blank&quot;&gt;跳转链接&lt;/a&gt; 3.功能性链接-打开邮箱/添加qq之类邮件链接 href=”mailto:邮箱名字” 添加qq qq推广官网复制代码 123&lt;a target=&quot;_blank&quot; href=&quot;http://wpa.qq.com/msgrd?v=3&amp;uin=&amp;site=qq&amp;menu=yes&quot;&gt; &lt;img border=&quot;0&quot; src=&quot;http://wpa.qq.com/pa?p=2::53&quot; alt=&quot;点击联系我qq&quot; title=&quot;点击联系我qq&quot;/&gt;&lt;/a&gt; 行内元素和块元素1.行内元素元素都在一行中显示2.块元素每个元素分行显示 列表1.有序列表(1 2 3 4) ol 2.无序列表(点) ul 3.自定义列表(无序号和点，有列表名称) dl 12345678910111213141516171819202122232425&lt;!--有序标签,应用：试卷，问答--&gt;&lt;ol&gt; &lt;li&gt;c&lt;/li&gt; &lt;li&gt;运维&lt;/li&gt; &lt;li&gt;前端&lt;/li&gt;&lt;/ol&gt;&lt;hr/&gt;&lt;!--无序列表,应用：导航，侧边栏--&gt;&lt;ul&gt; &lt;li&gt;c&lt;/li&gt; &lt;li&gt;java&lt;/li&gt; &lt;li&gt;前端&lt;/li&gt;&lt;/ul&gt;&lt;hr/&gt;&lt;!--自定义列表,dl标签，dt列表名称，dd列表选项。应用：网站底部--&gt;&lt;dl&gt; &lt;dt&gt;自定义列表&lt;/dt&gt; &lt;dd&gt;java&lt;/dd&gt; &lt;dd&gt;python&lt;/dd&gt; &lt;dd&gt;运维&lt;/dd&gt; &lt;dt&gt;位置&lt;/dt&gt; &lt;dd&gt;成都&lt;/dd&gt;&lt;/dl&gt; 表格 table table标签：单元格 table； 边框 border 行 tr列 td； td标签中跨行 rowspan； td标签中跨列 colspan 1234567891011121314151617181920212223&lt;table border=&quot;1px&quot; &gt; &lt;tr&gt; &lt;td colspan=&quot;3&quot;&gt;学生成绩&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td rowspan=&quot;2&quot;&gt;狂神&lt;/td&gt; &lt;td&gt;语文&lt;/td&gt; &lt;td&gt;100&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;数学&lt;/td&gt; &lt;td&gt;100&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td rowspan=&quot;2&quot;&gt;秦涫&lt;/td&gt; &lt;td&gt;语文&lt;/td&gt; &lt;td&gt;100&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;数学&lt;/td&gt; &lt;td&gt;100&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 媒体元素 标签：音频 audio 视频 video src:资源路径controls:控制条autoplay:自动播放 12&lt;video src=&quot;../../source/video/xxx.mp4&quot; controls autoplay&gt;&lt;/video&gt;&lt;audio src=&quot;../../source/video/xxx.mp3&quot; controls autoplay&gt;&lt;/audio&gt; 网页结构header 标题头部区域内容(页面中一块区域)footer 标记脚部区域内容(页面中一块区域) section web页面中一块独立区域article 独立的文章内容aside 相关内容或应用(侧边栏) nav 导航类辅助内容 iframe内联框架在一个网页里面嵌套另外一个成形的页面 123&lt;!--内联框架标签iframe可以作为容器，下面锚链接打开的页面就会出现在 锚标记的位置；本来是放置的百度的页面，点击跳转 新页面会覆盖百度--&gt;&lt;iframe src=&quot;https://www.baidu.com/?tn=62095104_28_oem_dg&quot; name=&quot;baidu&quot; frameborder=&quot;0&quot; width=&quot;1000px&quot; height=&quot;3000px&quot;&gt;&lt;/iframe&gt;&lt;a href=&quot;我的第一个网页.html&quot; target=&quot;baidu&quot;&gt;点击跳转&lt;/a&gt; 表单post和get提交表单 form form标签action: 表单提交的位置，可以是网站，也可以是一个请求处理地址method: post,get 两种提交方式 input标签：文本输入框type: 框内输入的类型(比如text,password，submit,reset),会根据类型显示不同，默认为textname: 自定义文本框控件的名字value: 初始值，type为radio时必须指定一个值size: 表单元素(文本框)的初始长度maxlength: type为text或password时，输入的最大字符数checked: type为radio或checkbox时，指定按钮是否被选中 1234567891011&lt;form action=&quot;我的第一个网页.html&quot; method=&quot;post&quot;&gt; &lt;h2&gt;注册&lt;/h2&gt; &lt;p&gt; 名字：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;/p&gt; &lt;p&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;passw&quot;&gt; &lt;/p&gt; &lt;input type=&quot;submit&quot;&gt; &lt;input type=&quot;reset&quot;&gt;&lt;/form&gt; 提交方式 get post get方式提交：我们可以在表单提交位置的那个网页url中看到我们提交的信息。不安全，高效。 post方式提交：url中没有参数信息。比较安全，传输大文件。post的信息在 右键审查元素-network-点击name下的码-headers-from data-这里能看到提交的名字和密码。 键值对提交：name=”” + value=””/标签中间的内容； form表单内容单选框，多选框，按钮 radio单选框标签是input type=”radio” 的一个单选标签，需要写type,value(单选框的值),name(name相同的进行分组，可以进行单选,提交的信息只会交一组中的一个)，标签后的文字checked默认选择1234&lt;p&gt; 性别：&lt;input type=&quot;radio&quot; value=&quot;boy&quot; name=&quot;gender&quot; checked&gt; 男 &lt;input type=&quot;radio&quot; value=&quot;girl&quot; name=&quot;gender&quot;&gt;女&lt;/p&gt; checkbox多选框标签type=”checkbox”需要写value,name,后面的文字用name进行分组checked默认选择123456&lt;p&gt;爱好： &lt;input type=&quot;checkbox&quot; value=&quot;sleep&quot; name=&quot;hobby&quot; checked&gt;睡觉 &lt;input type=&quot;checkbox&quot; value=&quot;sleep&quot; name=&quot;hobby&quot;&gt;写代码 &lt;input type=&quot;checkbox&quot; value=&quot;sleep&quot; name=&quot;hobby&quot;&gt;聊天 &lt;input type=&quot;checkbox&quot; value=&quot;sleep&quot; name=&quot;hobby&quot;&gt;游戏&lt;/p&gt; 按钮和图片点击有个提交效果，因为input标签是写在form表单标签中的，有一个提交给网页的动作。 1234&lt;p&gt; &lt;input type=&quot;button&quot; name=&quot;anniu&quot; value=&quot;点击变长&quot;&gt; &lt;input type=&quot;image&quot; src=&quot;../../source/image/&#123;0CD3A208-38C5-D227-DB52-F9A1DB0C7D73&#125;.png&quot;&gt;&lt;/p&gt; 下拉框 select 下拉框标签option 下拉框元素选择标签 123456789 &lt;p&gt;下拉框： &lt;select name=&quot;列表名称&quot;&gt; &lt;option value=&quot;china&quot;&gt;中国&lt;/option&gt; &lt;option value=&quot;America&quot;&gt;美国&lt;/option&gt; &lt;option value=&quot;rth&quot; selected&gt;瑞士&lt;/option&gt;&lt;!-- selected默认选择--&gt; &lt;option value=&quot;india&quot;&gt;印度&lt;/option&gt; &lt;/select&gt; &lt;/p&gt; textarea 可填写文本域标签 123&lt;p&gt;可填写文本域： &lt;textarea name=&quot;文本域&quot; id=&quot;&quot; cols=&quot;50&quot; rows=&quot;30&quot;&gt;填文本，可拉动&lt;/textarea&gt;&lt;/p&gt; input type=”file”提交选择文件域 1234 &lt;p&gt;提交选择文件域 &lt;input type=&quot;file&quot; name=&quot;文件域&quot;&gt;&lt;!-- &lt;input type=&quot;button&quot; name=&quot;长传&quot; value=&quot;上传&quot;&gt;--&gt; &lt;/p&gt; input标签 邮箱、url、数字的自动验证、滑块、搜索框 123456789101112131415&lt;p&gt;邮箱自动验证 &lt;input type=&quot;email&quot; name=&quot;邮件&quot;&gt;&lt;/p&gt;&lt;p&gt;url自动验证 &lt;input type=&quot;url&quot; name=&quot;网址&quot;&gt;&lt;/p&gt;&lt;p&gt;数字验证/商品数量： &lt;input type=&quot;number&quot; name=&quot;num&quot; max=&quot;100&quot; min=&quot;0&quot; step=&quot;10&quot;&gt;&lt;/p&gt;&lt;p&gt;滑块/音量大小 &lt;input type=&quot;range&quot; name=&quot;voice&quot; min=&quot;0&quot; max=&quot;100&quot; step=&quot;1&quot;&gt;&lt;/p&gt;&lt;p&gt;搜索框： &lt;input type=&quot;search&quot; name=&quot;搜索&quot; &gt;&lt;/p&gt; 表单的应用标签中的权限： readonly 只读，无法修改(文本框) checked 默认勾选(单/多选) disabled 禁用 hidden 隐藏域(隐藏框)，虽然框还在那个位置但是不能输入value,但是可以默认写value,也可以提交 label标签:label标签用id指向文本框，增强鼠标可用性/鼠标移动到前面的文字就可以落到文本框中 1234&lt;p&gt;label标签用id指向文本框，增强鼠标可用性/鼠标移动到前面的文字就可以落到文本框中 &lt;label for=&quot;mark&quot;&gt;你点我试试&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;mark&quot;&gt;&lt;/p&gt; 表单初级验证验证作用：在前端进行验证，减轻压力，保证数据的安全性 常用方式(写在标签中)： placeholder=”xxx” 提示信息xxx(用在文本框中) required 表单不能为空，提交时候会提示(用在文本框中) pattern 正则表达式，正确格式 1234正则表达式去百度：常用的正则表达式 &lt;p&gt;正则表达式判断邮箱正确 &lt;input type=&quot;text&quot; name=&quot;自定义邮箱&quot; pattern=&quot;：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$&quot;&gt; &lt;/p&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[背单词]]></title>
    <url>%2F2020%2F07%2F18%2F%E8%83%8C%E5%8D%95%E8%AF%8D%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[一些基础和vueblog细节]]></title>
    <url>%2F2020%2F07%2F05%2F%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E5%92%8Cvueblog%E7%BB%86%E8%8A%82%2F</url>
    <content type="text"><![CDATA[HashMap hashmap在jdk1.7和jdk1.8版本的区别 数据结构不同： 1.7中的HashMap是数组+链表的结构 1.8中的HashMap是数组+链表+红黑树的结构 链表插入方式不同： 1.7使用的是头插法,头插法在进行扩容时存在线程安全问题导致链表死循环 1.8使用的是尾插法 扩容后重新计算索引的方式不同： 1.7将会使用扩容后的大小重新与hash计算索引 1.8会判断之前hash中需要加入计算索引位置是0还是1，是0则保持原位，1则在现在索引的基础上加上新增的容量则是计算后的索引 什么时候创建数组？为什么？数组是在map.put(key,value )的时候创建的。数组并不是在new HashMap对象的时候创建的,因为创建对象就会在堆内存里占用连续的内存空间 数组+链表的结构怎么存放键值对数据？Put进键值对时，是在hashmap的16格(0-15)中加入键值对，当新加入的键值对所在的数组格子位置里有值的时候，就会和格子里的键值对形成链表，这个叫做hash冲突。数组查询时间复杂度是O(1),链表查询复杂度是O(n).所以要提高查询效率，就要减少链表的长度，当数组容量使用超过16x0.75时，就会进行数组扩容，减少hash冲突，提高查询效率。 什么时候引入红黑树？是为了什么？当链表长度大于8时，如果数组容量超过64，数组格子里的链表结构转换为红黑树如果数组容量小于64，只会进行数组扩容引入红黑树为了增加查询效率时间复杂度变成对数阶O(log2n) 怎么确定键值对在数组中的位置？key的hash值与数组最大索引进行与运算 hashmap存储过程=hashmap的工作原理？ 根据key计算一个hash值 在put时判断数组是否存在，如果不存在调用resize()创建默认容量为16的数组 key的hash值与数组最大索引进行位运算(与运算)，确定node在数组中的位置 判断该位置是否有元素，如果没有元素，会新建一个node放在该位置；如果有元素，判断key是否完全相同，吧原来的node赋值给一个变量 此时再判断该node的位置是红黑树还是链表 如果是红黑树，以红黑树的方式将node放在红黑树上(特别的二叉树) 如果是链表，尾插法：遍历链表，将node放在最后一位 放完以后，就要判断当链表长度大于8时，如果数组容量超过64，数组格子里的链表结构转换为红黑树；如果数组容量小于64，只会进行数组扩容 返回被覆盖的值 判断整个数组是否需要扩容 hashmap的扩容为什么每次都是2次幂？减少hash碰撞 hashmap的线程安全问题发生在哪个阶段？线程安全问题产生的原因：多个线程访问同一个资源。发生在put放值(链表/红黑树放结点)进行判断的时候，p.next=newNode().多个线程都进来了，newNode()在赋值的时候就会漏点。 如何解决线程安全问题？concurrentHashMap就是使用锁分段技术专门用来实现线程安全的底层采用分段的数组+链表实现，线程安全。ConcurrentHashMap是使用了锁分段技术来保证线程安全的。 锁分段技术：首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。 位运算有哪些？左移 0011-&gt;0110右移 0110-&gt;0011或运算 一真则真与运算 一假则假按位取反 1变0异或运算 相同为0 不同为1 apache shiro shiro是什么？shiro是强大且易用的java安全框架，执行 身份验证(登录)、授权、会话管理、密码学。 shiro的六大作用是什么？ Authentication 认证 -用户登录 Authorization 授权 -给用户哪些权限 Cryptography 安全数据加密 Session Managment 会话管理 Web intergration web 系统集成 Interations 集成其他的应用 -比如集成spring/缓存框架redis shiro的核心API(接口/是都需要重写的函数！)都是什么？有什么作用？ Subject: 用户主体 (把操作交给SecurityManager,要关联它) SecurityManager: 安全管理器 （关联Reaml） Realm: Shiro连接数据的桥梁,shiro想要查询数据库/配置文件获取用户信息，这些事情都要靠realm来完成。realm中执行认证和授权。认证中具体实现用户名和密码匹配 以上shiro三个API之间的关系？ Subject关联SecurityManager,SecurityManager关联Realm SecurityManager关联Realm：DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(accountRealm); SecurityManager关联Subject：关联函数：A.setB 如：securityManager.setSubjectDAO(subjectDAO); 怎么整合shiro-redis-springboot? 导shiro-redis-springboot依赖和jwt工具包和hutool工具包 写shiro的配置类ShiroConfig： 让shiro的权限数据和会话信息存在redis中，引入了redisSessionDAO、redisCacheManagersecurityManager.setSessionManager(sessionManager.setSessionDAO(redisSessionDAO));//简写securityManager.setCacheManager(redisCacheManager);//配置redis缓存 重写SessionManager和DefaultWebSecurityManager，关闭shiro自带的session方式，这样用户就不再能通过session方式登录shiro。后面将采用jwt凭证登录。DefaultWebSecurityManager中Subject关联SecurityManager,SecurityManager关联Realm。 所有的路由都需要经过JwtFilter这个过滤器，然后判断请求头中是否含有jwt的信息，有就登录，没有就跳过。跳过之后，有Controller中的shiro注解进行再次拦截，比如@RequiresAuthentication，这样控制权限访问。 写shiro进行登录或者权限校验的逻辑类AccountRealm：重写3个方法，分别是：supports：为了让realm支持jwt的凭证校验doGetAuthorizationInfo：权限校验doGetAuthenticationInfo：登录认证校验 -拿到需要验证的token，解析token拿到用户id,根据id去拿到用户对象，判断用户状态。将登陆成功的用户对象中的信息复制到profile对象中，然后返回一个登录成功(已认证)的用户信息载体对象SimpleAuthenticationInfo)(shiro里的) 用户登录信息-Session-shiro-redis小小总结：用户登录信息存放在Session中；Session被shiro管理；shiro的信息(权限数据、会话管理信息)存放在redis中。 将shiro内部构建展示出来，上面这些连接变成了：用户登录信息-Session-subject-securitymanager-redis-realm-mysql jwt jwt的构成 = 加密header+加密payload+加密signature 这三个拼在一起的字符串 头部（header)：声明类型，这里是jwt；声明加密的算法。 载荷（payload, 存放有效信息类似于飞机上承载的物品)：标准中注册的声明；公共的声明；私有的声明 签证（signature)：用header中声明加密的算法对(加密后的header+加密后的payload+secret)组合加密 认为jwt=token 用户登录和请求的流程用户使用用户名密码来请求服务器服务器进行验证用户的信息服务器通过验证发送给用户一个token客户端存储token，并在每次请求时附送上这个token值服务端验证token值，如果验证通过就会返回相应的资源(给接口)这个token必须要在每次请求时传递给服务端，它应该保存在请求头里 项目中是用的jwt凭证登录。 jwt不需要在服务端保存会话信息Session, 用户信息ession保存在客户端 每次请求校验，通过服务端的私钥和过期时间(定义在yml里面)来校验合法性 项目中的jwtUtil是jwt的工具类。四个注解：@Slf4j -为类提供一个 属性名为log 的 log4j 日志对象，调用打印日志@Data -提供类所有属性的 getting 和 setting 方法，此外还提供了equals、canEqual、hashCode、toString 方法@Component -组件@ConfigurationProperties(prefix = “example.demo.jwt”) -外部化配置，在配置文件/配置类外面写配置相关的。这里绑定和验证一些外部属性（.Properties文件中example.demo.jwt下面配置的三个属性） 三个属性：header expire secret. 三个方法： 生成jwttoken: 那三个组成拼起来的字符串 获取jwttoken的信息： 解析jwt 判断token是否过期： 过期时间before当前时间-&gt;过期-&gt;返回true 在AccountRealm中使用了工具类就是要先注入这个类@Autowired，就不用new对象了。 Cookie和Session 两个数据存放在哪里？cookie数据存放在客户的浏览器上；session数据放在服务器上。 cookie的特点和限制是什么？ cookie不是很安全，因为别人可以分析存放在本地的COOKIE并进行COOKIE欺骗。 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。 两个数据里能存什么？cookie里只能存放字符串；session里能存放任何类型的数据，如字符串、集合、类、对象。 用户能看见吗？cookie对用户可见；session对用户不可见(透明) 有效期的差别？ 比如浏览器上百度账号登录信息长期有效？cookie可以容易的达到登录信息长期有效，只要把有效期设为很大的数字；session不能长期有效，容易导致服务器的内存溢出。比如说我们项目使用jwt设置了有效期7天。 并发访问的用户多的时候，用哪个来追踪用户会话？用cookie。因为一个用户就会产生一个session/cookie. session存在服务器端，产生的session量过大会消耗大量的内存。 cookie存在客户端，不占用服务器端的资源，一个用户手里拿一个cookie。所以像百度这种只能用cookie来存储用户的登录信息，用cookie来追踪用户会话。 为什么百度贴吧、百度云盘、百度搜索都可以共用我的登录信息呢(不用重复登录)？因为cookie支持跨域名访问，以“.biaodianfu.com”为后缀的一切域名均能够访问该Cookie。但是session就不支持跨域名访问，如果用session,都要重新登录。 session在服务器端由谁来管理？存在哪里？session由shiro来管理，shiro六大作用之一就是Session会话管理。在ShiroConfig(shiro配置类)中就有会话管理对应的函数-SessionManager. MySQL 分布式数据库是什么？分布式数据库是指数据在物理上分布而逻辑上集中管理的数据库系统。 MySQL 群集是什么？MySQL 群集是一种技术。MySQL群集技术在分布式数据库系统中为MySQL数据提供了冗余特性，增强了安全性，使得单个MySQL服务器故障不会对系统产生巨大的负面效应，系统的稳定性得到保障。 MySQL 群集作用白话：MySQL群集技术让分布式数据库系统稳定性得到保障，(因为它为mysql数据增加安全性，)所以当单个mysql服务器故障时，分布式数据库系统不会产生巨大影响 MySQL 群集的三种结点有什么用？ 管理结点：能对结点进行关闭启动等操作，能监视结点状态。 数据结点：存数据。 SQL结点： 对外提供SQL功能。]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue]]></title>
    <url>%2F2020%2F07%2F02%2Fvue%2F</url>
    <content type="text"><![CDATA[新建项目 注意：新建的项目里只有创建项目时勾选的依赖(vue ui中查看)，需要其他插件的话，要在项目路径下面使用命令行安装(很简单) 新建vue项目：左侧-任务-serve-运行-输出(点击查看)-App ready 想要新建项目的话需要点左下角的小房子或者左下角的文件夹，选择要放置新项目的文件夹。 输入项目名称(不能有中文)-手动配置项目-选择功能Bable,Router,Vuex-创建-创建项目，不保存预设 打开eclipse-file-导入项目 启动vue项目 cmd到项目路径 d: cd D:\vue学习练习\vue-1然后 npm run serve vuelog博客思路技术栈 后端： SpringBoot Mybatis Plus shiro redis hibernate validator jwt 前端：vue element-ui axios 博客功能 用户登录 用户退出 blog主页列表(element-ui样式) blog详情页(md格式展示) blog编辑/发表(markdown格式mavon-editor编辑器) 技术对应作用 SpringBoot：基础框架，在未来易拓展，适合微服务化体系 Mybatis Plus：让项目能完成基本的增删改查操作，节省大量时间 Shiro：作为权限(验证)，使用简单配置简单 Redis: 会话等信息需要共享,Redis是现在主流的缓存中间件，适合项目 jwt: json web token因为前后端分离，所以使用jwt作为用户身份凭证 devtools：项目的热加载重启插件 lombok：简化代码的插件工具vueelement-uiaxiosmavon-editormarkdown-itgithub-markdown-css vue前端 vue整合element-ui axios(命令行安装) 页面：登录页面，博客列表页面，博客详情页面，博客编辑页面 前端路由权限拦截 判断哪些路由需要权限（/add /edit）meta: { requireAuth: true}, 路由前置拦截axios在发起请求之前有一个前置拦截判断该路由的meta里信息如果是true的话就需要权限，然后判定有无token。如果有Token就跳转到下一个路由 next（）；如果没有token-&gt;跳转到login界面 但是项目中没有用跳转用的是禁止，直接访问没有跳转到login 为了让这个错误弹窗能运用到所有的地方，所以我对axios做了个后置拦截器，就是返回数据时候，如果结果的code或者status不正常，那么就有对应的弹窗提示。 登录页面-登录逻辑 前端页面提示需要输入用户名和密码 前端页面提交时axios发起请求(axios发起请求的时候都会有一个域名/当前页面url) 后端进行密码校验，如果正常，生成jwt，返回给用户 从返回的结果请求头中获取到token的信息，然后使用store提交token和用户信息的状态。完成操作之后，我们跳转到到了/blogs路由，即博客列表页面。 存储token，用的是localStorage; 存储用户信息，我们用的是sessionStorage。 博客列表页面 页面头部我们需要把用户的信息展示出来，因为很多地方都用到这个模块，所以我们把页面头部的用户信息单独抽取出来作为一个组件。 头部的用户信息，应该包含三部分信息：id，头像、用户名，而这些信息我们是在登录之后就已经存在了sessionStorage。因此，我们可以通过store的getters获取到用户信息。 上面代码created()中初始化用户的信息，通过hasLogin的状态来控制登录和退出按钮的切换，以及发表文章链接的disabled，这样用户的信息就能展示出来了。 退出逻辑：在methods中有个logout()方法，逻辑比较简单，直接访问/logout，因为之前axios.js中我们已经设置axios请求的baseURL，所以这里我们不再需要链接的前缀了哈。因为是登录之后才能访问的受限资源，所以在header中带上了Authorization。返回结果清除store中的用户信息和token信息，跳转到登录页面。 项目综述SpringBoot+vue的博客项目基本功能：用户登录页面，用户退出，blog主页列表(element-ui样式)， blog详情页(markdown格式展示)，blog编辑/发表(markdown格式mavon-editor编辑器)使用技术：SpringBoot作为基础框架，Mybatis Plus：让项目能完成基本的增删改查操作，省去自己写mapper、service, Shiro：权限校验、登录认证，Redis: 储存shiro的权限数据和会话信，jwt: 作为前后端分离的用户身份凭证；vue项目使用：element-ui，axios，mavon-editor，markdown-it，github-markdown-css功能逻辑：使用用户名密码登录axios发起请求，后端进行密码校验，如果正常，生成jwt，返回给用户。从返回的结果请求头中获取并提交token的信息跳转到blog主页列表。如果异常，全局异常捕获，页面弹窗异常信息。Blog主页做了页面头部将用户的信息展示出来，element-ui时间线样式做列表，还有分页。Blog详情页使用插件markdown-it将markdown格式的内容渲染展示出来。使用mavon-editor编辑器进行blog的编辑，点击按钮提交表单。 vue快速入门vue特点 页面由数据生成，函数中用this.xxx修改数据,在展示模板中使用的元素会同步更新。 data:{}中像结构体那样写数据用,隔开 最后一个属性不加, 数据xxx: 值 xxx:function(){}中写java代码 每行用;隔开 最后一行也要写; 标签意思href=”” 超链接span 区域br 换行li 有序列表ul 无序列表div 区块 .vue文件template - 展示模板 html代码script - 导入组件，写数据，写函数(挂载到template内部id)style - css样式 (挂载到template内部id) 基本结构的作用script里面写的是js语法，var app = new Vue({ })这里面写模板语法，吧数据渲染到上面的内容里Vue对象里面能渲染的是el挂载的元素标签内部 括号内：el:”#app”, 这个是告诉当前Vue对象他要管理的是div id=”app” div 之间的对象。data:{ }里放要渲染上去的数据，数据名与 div div中的数据名命中 data:{}数据对象Vue中用到的数据定义在data中data中可以写复杂类型的数据：字符串，数组，结构体 123456message: &quot;hello&quot;, school:&#123; name:&quot;黑马程序员&quot;, mobile:&quot;400800&quot; &#125;,compus:[&quot;北京校区&quot;,&quot;上海校区&quot;,&quot;深圳校区&quot;] 本地应用Vue指令内容绑定，事件绑定Vue指令：v-text v-html v-on基础 v-text:绑定文本 123&lt;h2 v-text=&quot;info+&apos;!&apos;&quot;&gt;深圳&lt;/h2&gt; //这里只会打印出&quot;info+&apos;!&apos;&quot;，h2标签里的深圳就被覆盖掉了&lt;h2&gt;啦啦啦&#123;&#123;message&#125;&#125;&lt;/h2&gt;//这里只会部分替换掉&#123;&#123;&#125;&#125;中的内容 v-html:绑定html结构的字符串，显示成html格式的。 12345678910111213&lt;div id=&quot;app&quot;&gt; &lt;h2 v-html=&quot;content&quot;&gt;深圳&lt;/h2&gt; 深圳不显示&lt;/div&gt;&lt;script&gt;var app = new Vue(&#123; el:&quot;#app&quot;, data:&#123; content:&quot;&lt;a href=&apos;https://lucifinil-x.github.io/&apos;&gt;我的博客&lt;/a&gt;&quot; //html语言，href是吧后面的内容变成跳转超链接 &#125; &#125;)&lt;/script&gt; v-on:为元素绑定事件, v-on:动作=”函数名” 123456789101112131415161718192021222324&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;演示指令&quot; v-on:click=&quot;doIt&quot;&gt; //按钮绑定click事件，做doIt:function()&#123;&#125; &lt;input tyep=&quot;button&quot; value=&quot;演示简写指令&quot; @click=&quot;doIt&quot;&gt; //v-on：可以简写为@ 后面的不变 &lt;input type=&quot;button&quot; value=&quot;双击事件+函数&quot; @dblclick=&quot;doIt&quot;&gt; //dblclick双击才弹窗 &lt;h2 @click=&quot;changeFood&quot;&gt;&#123;&#123;food&#125;&#125;&lt;/h2&gt; //没有超链接的文字也可以点，food值会更新&lt;/div&gt;&lt;script&gt;var app = new Vue(&#123; el:&quot;#app&quot;, methods:&#123; doIt:function()&#123; alert(&quot;做It&quot;); //alter是弹窗显示字符串 &#125;, changeFood:function()&#123; this.food+=&quot;好好吃&quot;; //console.log(this.food); &#125; &#125;&lt;/script&gt; 显示切换，属性绑定Vue指令：v-show v-if v-bind v-show:根据表达值的真假，切换元素的显示和隐藏(操作样式)频繁切换的元素用v-showv-show=”” 这里面的值最终转换成布尔值，true元素显示，false隐藏 1234567891011121314151617181920212223242526&lt;div id=&quot;vue_det&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;切换显示&quot; @click=&quot;change&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;切换显示2&quot; @click=&quot;addage&quot;&gt; &lt;img v-show=&quot;isShow&quot; src=&quot;https://s1.ax1x.com/2020/06/07/t29ldg.md.png&quot; alt=&quot;&quot;&gt; &lt;img v-show=&quot;age&gt;=18&quot; src=&quot;https://s1.ax1x.com/2020/06/07/t29ldg.md.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:&apos;#vue_det&apos;, data:&#123; isShow:false, age=17 &#125;, methods:&#123; change:function()&#123; this.isShow=!this.isShow; &#125;, addage:function()&#123; this.age++; &#125; &#125; &#125;) &lt;/script&gt; v-if:根据表达值的真假，切换元素的显示和隐藏(操纵dom元素)不频繁切换的元素用v-if 1234 &lt;input type=&quot;button&quot; value=&quot;切换显示&quot; @click=&quot;change&quot;&gt; &lt;p v-if=&quot;isShow&quot;&gt;黑马&lt;/p&gt;&lt;p v-show=&quot;isShow&quot;&gt;黑马11&lt;/p&gt; v-bind:设置元素的属性(都写在元素的内部) 1234&lt;img v-bind:src=&quot;imgsrc&quot; alt=&quot;&quot; v-bind:title=&quot;titlesrc+&apos;!!&apos;&quot;&gt; //title是鼠标移上去的提示&lt;br&gt;&lt;img :src=&quot;imgsrc&quot; alt=&quot;&quot;&gt; //可以省略v-bind &lt;img :src=&quot;imgsrc&quot; alt=&quot;&quot; v-bind:class=&quot;isActive?&apos;active&apos;:&apos;&apos;&quot; @click=&quot;toggleActive&quot;&gt; 这里的&apos;active&apos;是style样式 列表循环，表单元素绑定Vue指令：v-for v-on补充 v-model v-for:根据数据生成列表结构 123&lt;li v-for=&quot;(it,index) in arr&quot;&gt;&#123;&#123;index+1&#125;&#125;黑马程序员校区：&#123;&#123;it&#125;&#125;&lt;/li&gt; v-model: 数据双向绑定 12&lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt;&lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; 小黑记事本1.新增：生成列表结构(v-for 字符串数组) ，获取用户输入(v-model 双向绑定)，回车 新增数据(v-on .enter 添加数据) 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;body&gt; &lt;section id=&quot;小黑记事本&quot;&gt; &lt;header class=&quot;header&quot;&gt; &lt;h1&gt;小黑记事本&lt;/h1&gt; &lt;input v-model=&quot;inputValue&quot; v-on:keyup.enter=&quot;add&quot; autofocus=&quot;autofocus&quot; autocomplete=&quot;off&quot; placeholder=&quot;请输入任务&quot; class=&quot;newtodo&quot;&gt; &lt;/header&gt; &lt;section class=&quot;main&quot;&gt; &lt;ul class=&quot;todolist&quot;&gt; &lt;li class=&quot;todo&quot; v-for=&quot;(item,index) in list&quot;&gt; &lt;div class=&quot;view&quot;&gt; &lt;span class=&quot;index&quot;&gt;&#123;&#123;index+1&#125;&#125;.&lt;/span&gt; &lt;label&gt;&#123;&#123;item&#125;&#125;&lt;/label&gt; &lt;button class=&quot;destory&quot;&gt;&lt;/button&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/section&gt; &lt;footer class=&quot;footer&quot;&gt; &lt;/footer&gt; &lt;/section&gt; &lt;footer class=&quot;info&quot;&gt; &lt;/footer&gt;&lt;script&gt;var app = new Vue(&#123; el: &quot;#小黑记事本&quot;, data: &#123; list:[&quot;写代码&quot;,&quot;吃饭饭&quot;,&quot;睡觉觉&quot;], inputValue:&quot;好好学习，天天向上&quot; &#125;, methods:&#123; add:function()&#123; this.list.push(this.inputValue); &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt; 2.删除： 点击按钮删除指定内容(v-on splice 索引) 123456789101112131415161718192021222324252627282930313233343536373839404142434445 &lt;section id=&quot;小黑记事本&quot;&gt; &lt;header class=&quot;header&quot;&gt; &lt;h1&gt;小黑记事本&lt;/h1&gt; &lt;input v-model=&quot;inputValue&quot; v-on:keyup.enter=&quot;add&quot; autofocus=&quot;autofocus&quot; autocomplete=&quot;off&quot; placeholder=&quot;请输入任务&quot; class=&quot;newtodo&quot;&gt; &lt;/header&gt; &lt;section class=&quot;main&quot;&gt; &lt;ul class=&quot;todolist&quot;&gt; &lt;li class=&quot;todo&quot; v-for=&quot;(item,index) in list&quot;&gt; &lt;div class=&quot;view&quot;&gt; &lt;span class=&quot;index&quot;&gt;&#123;&#123;index+1&#125;&#125;.&lt;/span&gt; &lt;label&gt;&#123;&#123;item&#125;&#125;&lt;/label&gt; &lt;button class=&quot;destory&quot; @click=&quot;remove(index)&quot;&gt;&lt;/button&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/section&gt; &lt;footer class=&quot;footer&quot;&gt; &lt;/footer&gt; &lt;/section&gt; &lt;footer class=&quot;info&quot;&gt; &lt;/footer&gt;&lt;script&gt;var app = new Vue(&#123; el: &quot;#小黑记事本&quot;, data: &#123; list:[&quot;写代码&quot;,&quot;吃饭饭&quot;,&quot;睡觉觉&quot;], inputValue:&quot;好好学习，天天向上&quot; &#125;, methods:&#123; add:function()&#123; this.list.push(this.inputValue); &#125;, remove:function()&#123; console.log(&quot;删除&quot;); console.log(index); this.list.splice(index,1); &#125; &#125; &#125;)&lt;/script&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Postman使用]]></title>
    <url>%2F2020%2F07%2F01%2FPostman%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[使用 左上角New-Request 填写Request name, 下面选择一个文件夹或者Creat Folder 初次使用需要在下图位置添加键值对Content-Type application/json，不然会有utf-8的报错 Body中写username和password进行测试，选择raw和JSOPN。链接左侧选择POST，然后Send。具体信息在Param中查看]]></content>
  </entry>
  <entry>
    <title><![CDATA[vueblog的bug解决]]></title>
    <url>%2F2020%2F07%2F01%2Fvueblog%E7%9A%84bug%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[15-2login提交404login.vue中用axios post请求传参的时候提交浏览器显示404 not found 12345678910111213141516171819202122232425262728293031323334methods: &#123; submitForm(formName) &#123; this.$refs[formName].validate((valid) =&gt; &#123; if (valid) &#123; const _this = this var params = new URLSearchParams(); this.$axios.post(&apos;/login&apos;, this.ruleForm).then(res =&gt; &#123; console.log(res.data) const jwt = res.headers[&apos;authorization&apos;] const userInfo = res.data.data // 把数据共享出去 _this.$store.commit(&quot;SET_TOKEN&quot;, jwt) _this.$store.commit(&quot;SET_USERINFO&quot;, userInfo) // 获取 console.log(_this.$store.getters.getUser) _this.$router.push(&quot;/blogs&quot;) &#125;) &#125; else &#123; console.log(&apos;error submit!!&apos;); return false; &#125; &#125;); &#125;, resetForm(formName) &#123; this.$refs[formName].resetFields(); &#125; &#125; &#125; 解决 vue项目中的代码没有任何问题 404的问题是出在后端的项目上 首先用POSTMAN测试后端的login有没有问题(/login需要200操作成功)。使用POSTMAN步奏指路：https://lucifinil-x.github.io/2020/07/01/Postman%E4%BD%BF%E7%94%A8/ 配置文件application.yml中少写了shiro-redis,需要补上如下(这里的host数值是固定的)： 1234567891011121314151617181920mybatis-plus: mapper-locations: classpath*:/mapper/**Mapper.xmlserver: port: 8081//这里有提示倒是没问题shiro-redis: enabled: true redis-manager: host: 127.0.0.1:6379//这里没有com.example.demo,不然就登录400base64-encoded secret key cannot be null or empty.example.demo: jwt: # 加密秘钥 secret: f4e2e52034348f86b67cde581c0f9eb5 # token有效时长，7天，单位秒 expire: 604800 header: Authorization 并且在pom.xml中添加： 12345&lt;dependency&gt; &lt;groupId&gt;org.crazycake&lt;/groupId&gt; &lt;artifactId&gt;shiro-redis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.2.1&lt;/version&gt;&lt;/dependency&gt; 这里最主要的是项目demo的前缀没写全example.demo: 检查这里非常重要，同样要检查resources-mapper下面两个xml，util-jwtUtils.java POSTMAN登录测试的时候，密码正确但触发”密码不正确”(密码和用户名是和数据库中匹配的没有问题)。用户名正确没有这种问题。原因：controller-AccountController.java中用了加密函数SecureUtil.md5，一边加了密一边没加密,equal一直为false.123if(!user.getPassword().equals(SecureUtil.md5(loginDto.getPassword())))&#123; return Result.fail(&quot;密码不正确&quot;); &#125; 改成： 123if(!user.getPassword().equals(loginDto.getPassword()))&#123; return Result.fail(&quot;密码不正确&quot;); &#125; 修改以上的地方再进行POSTMAN的登录测试就可以200操作成功了。然后在后端项目运行的状态下运行vue项目/login就可以顺利提交跳转到blogs页面没有404啦。(而且后端的localhost和vue的localhost不用一样) 15-3blogs页面的退出连接400不能到login页面 页面Could not get a resource from the pool后端控制台redis connection fail远程连接不上 我以为是yml里的shiro-redis有问题，检查了pom.xml，没有问题。 是因为没有安装redis,没有运行redis,也没有访问服务器到127.0.0.1:6379 安装指路：https://www.runoob.com/redis/redis-install.html 我安装到C:\redis 打开cmd2命令行cd到 C:\redis 然后运行 redis-server.exe redis.windows.conf 打开cmd3命令行cd到 C:\redis 然后运行 redis-cli.exe -h 127.0.0.1 -p 6379 就能连接到redis远程服务端127.0.0.1:6379 回到blogs页面点退出连接就能回到login页面 注意：这两个cmd要一直打开不然又要400 17 Blogs.vue提示：[vue/valid-v-for] Custom elements in iteration require ‘v-bind:key’ directives. 1&lt;el-timeline-item :timestamp=&quot;blog.created&quot; placement=&quot;top&quot; v-for=&quot;blog in blogs&quot;&gt; 意思是v-for循环缺少键值对的key解决： 在v-for后面加 :key=’blog’ 这里的key就是 前面的 xx in blogs 1&lt;el-timeline-item :timestamp=&quot;blog.created&quot; placement=&quot;top&quot; v-for=&quot;blog in blogs&quot; :key=&apos;blog&apos;&gt; 修改之后页面控制台报错有红；不改页面没事，项目有红 改项目名字吓死我了，一片红 还是不要轻易改好了。做好备份 安装位置相关 element-ui: vue项目的根目录 mavon-editor: vue项目的根目录 node.js: d盘 redis: d盘 lombok插件jar包： eclipse.exe的根目录，附带ini最后两行 md样式插件： vue项目的根目录 windows powershell: c盘 errorError creating bean with name ‘UserController’https://blog.csdn.net/qq_38701478/article/details/88808628?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase 我的问题是/vueblog/src/main/java/com/example/demo/config/MybatisPlusConfig.java复制过来没有改@MapperScan(“com.example.demo.mapper”) 教训：不要质疑代码生成器给的类的注解。 另外注意：UserService类上不加注解；UserServiceImpl类上加@Service注解 还有一个问题是application.yml中dataSource不应该加之前写的type http://localhost:8080/user/index 查询出来空白{}他的有id=1的信息格式。这个项目里没找到index.html AccountRealm.java里的爆红 user.getstatus()爆红：the method is not defined for the type User. 首先user类中是没有这个函数的。这个东西是应该在lombok里面。 在eclipse和，maven仓库里搜索lombok,找到文件夹中的jar包，安装路径选择eclipse.exe所在的文件夹路径。 重要的是安装之后eclipse.exe所在的文件夹的ini文件最后一行自动添加了一行，这时候eclipse直接打不开了。 删除最后一行换成这两行 javaagent:lombok.jar Xbootclasspath/a:lombok.jar log.info()爆红：这是日志输出的函数，需要导入import lombok.extern.slf4j.Slf4j;，在类名上面加@Slf4j注解。 特别恶心的是eclipse有时候爆红消不掉，明明没有错/已经改好了。比如log爆红，需要剪切导入的包再粘贴一遍就好了。 他妈的，今天eclipse又卡不开了 ，删掉了昨天加的两行 打开eclipse之后又出现爆红，关掉再开运行出错 选中当前项目，右击“项目”→选择Properties，在弹出的对话框左侧列表中选择Java Build Path，如下图所示：选择Add External JARs，就可以逐个添加第三方引用jar包。 加了最新的jar没用 那些get()set()方法其实就是gettersetter,手动在User类中添加；lombok就是简化这些简单的函数 无法启动因为路径有中文 安装之后再次启动依旧爆红！ 因为eclipse不能自动刷新import的包，必须手动刷新！ 删除import的lombok保存，再粘贴保存！ 有些本身函数是调用另外一个类的，需要在另外那个类中刷新 第二天eclipse又打不开。ini文件删掉最后两行在保存在粘贴在保存就能打开 要认证后才能访问 在UserController的index页面上面添加注解@RequiresAuthentication(要认证后才能访问的接口)再启动项目，就会看到页面上的全局异常抛出的信息1&#123;&quot;code&quot;:401,&quot;msg&quot;:&quot;The current Subject is not authenticated. Access denied.&quot;,&quot;data&quot;:null&#125; 注解/包cannot resoloved to a type 因为eclipse没有下载相关maven包。 点fix project set up选择然后ok 就会下载了包然后import进来 启动失败a bean BlogService could not be found. 就是BlogService找不到 找不到因为没找到这个bean. 说明注解有问题：我的BlogServiceIpl实现类上面没加@Service 另外注意@Service只加在实现类上面，service类加这个注解没有用，不用加任何注解。 eclipse中加入vue插件 安装报错Unable to read repository at http://downloads.genuitec.com/downloads/products/codemix/updates/cm20200407/plugins/pack.core.win_3.6.0.202001241725.jar 原因：网络不稳定 问题的解决方法是：直接把上面的连接放入浏览器直接下载，或放入下载工具进行下载好。 再把下载好的文件放入eclipse的安装目录下的plugins文件夹下。再重新安装，问题就解决了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue-vueblog]]></title>
    <url>%2F2020%2F06%2F30%2Fvue-vueblog%2F</url>
    <content type="text"><![CDATA[启动vue项目 cmd到项目路径 d: cd D:\vue博客项目\vueblog然后 npm run serve 启动顺序 vueblog后端springbootapp cmd1命令行启动vue前端项目 cmd2命令行 cd C:\redis 然后运行 redis-server.exe redis.windows.conf (两行不要复制漏了) cmd3命令行 cd C:\redis 然后运行 redis-cli.exe -h 127.0.0.1 -p 6379 就能连接到redis远程服务端127.0.0.1:6379(注意是两个cmd! cmd23要一直打开) 安装位置相关 element-ui: vue项目的根目录 mavon-editor: vue项目的根目录 node.js: d盘 redis: d盘 lombok插件jar包： eclipse.exe的根目录，附带ini最后两行 md样式插件： vue项目的根目录 windows powershell: c盘 前期准备当前文件夹中打开windows powershellc窗口 注意 只是右键是看不到这个的，要用shift+右键 但是直接这样就报错：无法加载文件 C:\Users\A\AppData\Roaming\npm\vue.ps1，因为在此系统上禁止运行脚本 需要修改权限。搜素powershell,然后执行：set-ExecutionPolicy RemoteSigned；查看执行策略：get-ExecutionPolicy vue ui没反应 查看vue的命令列表中没有ui这个命令 vue -h 必须要安装3.0以上的，老师给的代码安装的是2.9 1.$npm uninstall vue-cli -g //卸载vue-cli旧版本2.$npm install -g @vue/cli //安装新版本3.$npm vue -V //查看版本3.vue -h //查看vue cli安装的版本中有什么命令 解决博客https://blog.csdn.net/Demo__/article/details/89404235 和vue相关的依赖插件都可以在执行vue ui后的localhost页面中查看 新建vue项目：左侧-任务-serve-运行-输出(点击查看)-App ready 想要新建项目的话需要点左下角的小房子或者左下角的文件夹，选择要放置新项目的文件夹。 输入项目名称(不能有中文)-手动配置项目-选择功能Bable,Router,Vuex-创建-创建项目，不保存预设 eclipse中加入vue插件 安装中途报错暂停Unable to read repository at http://downloads.genuitec.com/downloads/products/codemix/updates/cm20200407/plugins/pack.core.win_3.6.0.202001241725.jar 原因：网络不稳定，没有下载下来 问题的解决方法是：直接把上面的连接放入浏览器直接下载，或放入下载工具进行下载好。 再把下载好的文件放入eclipse的安装目录下的plugins文件夹下。eclipse中workplace搜索vue再重新安装，问题就解决了。 eclipse导入已经创建好的vue项目 file-openproject 然后看看能不能识别vue element-ui安装 控制台vue项目文件夹路径下cnpm install element-ui –save 项目中main.js 导入依赖之后就可以在项目中全局复制使用elementui的组件代码 vue主要写的东西是些什么 components 页面html 公共区域需要抽取出来的 router 路由/网址路径 跳转到哪个组件/页面 views 页面开发 store-xxx.js 数据管理的地方所有组件都监听store中的内容，通过这里面的内容更新之后会通知每一个组件，达到每个组件数据之间的同步(更新)。 app.vue 入口组件这个里面的Home About按钮点击时没有刷新页面，只是将router-view里的标签切换了。比如说点击home按钮时， 1&lt;router-link to=&quot;/&quot;&gt;Home&lt;/router-link&gt; | 会在router-index.js找到path: ‘/‘， 123456 const routes = [&#123; path: &apos;/&apos;, name: &apos;Home&apos;, component: Home&#125;, 然后把对应的组件Home添加展示到app.vue中的这个标签里。 1&lt;router-view/&gt; vue是只有一个页面的，Header是顶部框不变的部分，下面的view是切换的不一样的页面展示(每个view要展示Header的话需要header的import文件路径，并且写上Header标签) .vue文件标签(直接写标签显示不出来) template：模板里面必须有一个div标签作为他的主标签(只能是单个元素，所有元素只能放在单个元素里面)， script：放样式 注释 用//注释 ctrl shift c全部注释 routerimport 所有页面组件12import Vue from &apos;vue&apos;import VueRouter from &apos;vue-router&apos; 1import Login from &apos;../views/Login.vue&apos; path细节 要编辑需要传过来一个id,这里加: blogId就会作为一个参数，页面就会获取到这个参数 1path: &apos;/blog/:blogId/edit&apos;, path为/blog/:blogId’的这个结构体要放在/blog/:blogId/edit的前面因为路径较短 注意path:/blog/add一定放在path: ‘/blog/:blogId’之前，因为add和:blogId是有可能匹配上的。如果add放在blogId后面，访问add的时候会先路由到blogId里面而不是add里面。 写.vue页面Login.vue 1.选择第一种element的布局容器：上下布局head和main 写在template-div标签里面，之后都在el-header，el-main标签中填充内容。 1234&lt;el-container&gt; &lt;el-header&gt;Header&lt;/el-header&gt; &lt;el-main&gt;Main&lt;/el-main&gt;&lt;/el-container&gt; 2.选择复制element的布局容器中给的样式style,分条装在el-header或者el-main标签里面 12345678&lt;el-container&gt; &lt;el-header&gt; 这里写标题/放图片，可以调整图片的位置距离上方的高度 &lt;/el-header&gt; &lt;el-main&gt;Main&lt;/el-main&gt;&lt;/el-container&gt; 3.Form表单和验证规则(如果不填名字密码，在下方会有提示) 只要用户名 密码 提交框(登录 重置) Header.vue Header: 头部栏，写在这个vue里的都是头部栏里能看能点的东西 最上面 h3: 最上面的标题 div-block: 标题下面的那个图片参数：size:图片大小；src：user里的图片信息；div标签：图片下面的一行字(用户名) 头像下面的三个能跳转的链接 主标签div class=”maction” 主页el-link:超链接标签； herf：跳转到的路径el-divider:分开主页、发布文章、登录/退出的分割线； direction:分割线的方向(这里用的垂直) 发表文章span: 状态标签，这里没东西 可以不写el-link:超链接标签； 链接的属性(名称-会对应不同的颜色)； herf：跳转到的路径 : disabled: 不能跳转的情况；el-divider:分开主页、发布文章、登录/退出的分割线； direction:分割线的方向(这里用的垂直) 登录/退出span v-show:展示登录还是退出的条件登录： el-link:超链接标签； type:链接的属性(名称-会对应不同的颜色)； herf：跳转到的路径退出： el-link:超链接标签； type:链接的属性(名称-会对应不同的颜色)； @clink:这里是对应一个方法(写在下面的script标签里) scriptmethods 这里写的是退出里的@clink=”logout”的方法。简而言之：删掉用户信息，再回写除了密码之外的信息。这里我们用的是jwt,后端的jwt是无状态的，没有存到redis里进行状态的处理。所有这里的退出可以直接把localstore里的信息删掉就行了，可以不请求后端。如果后端的jwt token信息是有状态的，就需要去请求后端(用axios发起请求)。而且后端的Logout是需要授权的，这里就需要对headers进行配置，添加token信息(通过localstore获取)1heards:&#123;&quot;Authorization&quot;: Localstoreage.getItem(&quot;token&quot;) &#125; 后端需要删除token信息和清除state状态信息，调用后端的REMOVE_INFO方法。然后用router跳转到/login界面。清除之后要创建新的用户信息，写方法created():如果用户名不为空的时候，进行用户名、头像、登录状态的回写。 blog.vue]]></content>
  </entry>
  <entry>
    <title><![CDATA[面试准备-java]]></title>
    <url>%2F2020%2F06%2F23%2F%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87-java%2F</url>
    <content type="text"><![CDATA[String判断指向地址or值 只要记住一点！编译期决定 -&gt; 一定指向常量池运行时决定(且不是intern()) -&gt; 一定指向堆 编译期进入常量池： String a = “123”; “1”+”2”+”3”;运行期堆上分配： String b = new String(“123”); a+a+a;a==b判断的是指向的对象的地址，虽然a b对象的值相同，但是a指向常量池中对象的地址，b指向堆内存上对象的地址。 123456System.out.println(a == b); //falseSystem.out.println(a ==&quot;1&quot;+&quot;2&quot;+&quot;3&quot;);//trueString s1=&quot;1&quot;;String s2=&quot;2&quot;;String s3=&quot;3&quot;;System.out.println(a ==s1+s2+s3);//false a在常量池，s1+s2+s3是运行时堆上分配 final Stirng s1 = “1”;final是类可被继承(函数不能重写)，变量不可被修改；这时的编译期s1指向的就是常量池中的”1”. 12345String s0=&quot;12&quot;;final String s1 = &quot;1&quot;; //常量池String s2=&quot;2&quot;+s1; //直接常量池System.out.println(s0 == s2);//true 常量池==常量池System.out.println(s0 == &quot;1&quot;+s1);//true String s1 = new String(“abc”);s1.intern()会去常量池中找相同值的对象，如果有返回常量池地址,没有a==b返回false. 1234String a = &quot;123&quot;; //常量池String b = new String(&quot;123&quot;); //堆System.out.println(a == b); //falseSystem.out.println(a == b.intern()); //true 常量池==常量池 Validate验证器闲话 我认为我现在面对的是各个主体之间错综复杂的关系。我需要用逻辑去找到各个主体之间的联系与怎样联系。再找到主体之间的起始通路与终点。就像是容器中的组件，一个连接另一个，一个注入另一个。好的文章通过(作者的逻辑)带着我们从始到终，解释个体之间的联系。 HashMap hashmap在jdk1.7和jdk1.8版本的区别 数据结构不同： 1.7中的HashMap是数组+链表的结构 1.8中的HashMap是数组+链表+红黑树的结构 链表插入方式不同： 1.7使用的是头插法,头插法在进行扩容时存在线程安全问题导致链表死循环 1.8使用的是尾插法 扩容后重新计算索引的方式不同： 1.7将会使用扩容后的大小重新与hash计算索引 1.8会判断之前hash中需要加入计算索引位置是0还是1，是0则保持原位，1则在现在索引的基础上加上新增的容量则是计算后的索引 什么时候创建数组？为什么？数组是在map.put(key,value )的时候创建的。数组并不是在new HashMap对象的时候创建的,因为创建对象就会在堆内存里占用连续的内存空间 数组+链表的结构怎么存放键值对数据？Put进键值对时，是在hashmap的16格(0-15)中加入键值对，当新加入的键值对所在的数组格子位置里有值的时候，就会和格子里的键值对形成链表，这个叫做hash冲突。数组查询时间复杂度是O(1),链表查询复杂度是O(n).所以要提高查询效率，就要减少链表的长度，当数组容量使用超过16x0.75时，就会进行数组扩容，减少hash冲突，提高查询效率。 什么时候引入红黑树？是为了什么？当链表长度大于8时，如果数组容量超过64，数组格子里的链表结构转换为红黑树如果数组容量小于64，只会进行数组扩容引入红黑树为了增加查询效率时间复杂度变成对数阶O(log2n) 怎么确定键值对在数组中的位置？key的hash值与数组最大索引进行与运算 hashmap存储过程=hashmap的工作原理？ 根据key计算一个hash值 在put时判断数组是否存在，如果不存在调用resize()创建默认容量为16的数组 key的hash值与数组最大索引进行位运算(与运算)，确定node在数组中的位置 判断该位置是否有元素，如果没有元素，会新建一个node放在该位置；如果有元素，判断key是否完全相同，吧原来的node赋值给一个变量 此时再判断该node的位置是红黑树还是链表 如果是红黑树，以红黑树的方式将node放在红黑树上(特别的二叉树) 如果是链表，尾插法：遍历链表，将node放在最后一位 放完以后，就要判断当链表长度大于8时，如果数组容量超过64，数组格子里的链表结构转换为红黑树；如果数组容量小于64，只会进行数组扩容 返回被覆盖的值 判断整个数组是否需要扩容 hashmap的扩容为什么每次都是2次幂？减少hash碰撞 hashmap的线程安全问题发生在哪个阶段？线程安全问题产生的原因：多个线程访问同一个资源。发生在put放值(链表/红黑树放结点)进行判断的时候，p.next=newNode().多个线程都进来了，newNode()在赋值的时候就会漏点。 如何解决线程安全问题？concurrentHashMap就是使用锁分段技术专门用来实现线程安全的底层采用分段的数组+链表实现，线程安全。ConcurrentHashMap是使用了锁分段技术来保证线程安全的。 锁分段技术：首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。 位运算有哪些？左移 0011-&gt;0110右移 0110-&gt;0011或运算 一真则真与运算 一假则假按位取反 1变0异或运算 相同为0 不同为1 同步 cynchronized关键字保证同步，同步代码块和同步函数的区别？同步函数: 用this作锁，因为函数必须被对象调用；线程任务只需要一个同步时可以用。同步代码块： 任意对象作锁；线程任务需要多个同步 时，必须用不同的锁来区分。 所以同步代码块比较常用。 饿汉式和懒汉式饿汉式不会有多线程并发问题，在类创建的同时就已经创建好一个静态的对象供系统使用,以后不在改变。懒汉式在线程任务中new对象，并发访问就有安全隐患，应该加入同步机制解决安全问题。 一个线程不能多次start，会报错.IllegalThreadStateException redis redis是什么？redis是内存数据库(key-value 非关系型 没有SQL)，存放经常被访问的数据(热数据)。缓存中间件(有redisCacheManager)单进程单线程模型的KV数据库。value的类型：string,list,hash,set,sorted set.但是规避set操作，会影响性能 redis可以拦截一部分请求，降低接触mysql的频率 在你的项目中redis是如何运用的？ 目前我的项目里整合了shiro-redis，为之后的集群和负载均衡(mysql数据库系统不会因为单个崩溃而崩溃)做准备。但是目前项目很简单，数据量也比较少，还没有做集群和负载均衡。 现在是用redis来存储shiro的权限数据和会话信息(Session会话管理是shiro的作用之一，体现在ShiroConfig中的SessionManager函数)。 磁盘寻址：毫秒级别，慢内存寻址：纳秒级别，快文件存储是线性的，文件读取就要把文件从头开始全部读一遍。文件读取是全量IO,磁盘IO. 磁盘IO:百兆级别100mb 缓存击穿请求缓存中没有但数据库中有的同一条数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据解决：一般不解决 缓存穿透(击穿和雪崩的本质)用户一直发起请求查找缓存(redis)和数据库中都没有的数据,导致每次请求都要mysql数据库中查找，流量大的时候mysql数据库就挂了解决1：布隆过滤器，用一定的(拦截)错误率换取空间解决2：查询的value返回null,存在redis中 缓存雪崩redis缓存中不同数据大批量到过期时间，去数据库中查询，就崩了解决：缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。设置热点数据永远不过期。二级缓存 apache shiro shiro是什么？shiro是强大且易用的java安全框架，执行 身份验证(登录)、授权、会话管理、密码学。 shiro的六大作用是什么？ Authentication 认证 -用户登录 Authorization 授权 -给用户哪些权限 Cryptography 安全数据加密 Session Managment 会话管理 Web intergration web 系统集成 Interations 集成其他的应用 -比如集成spring/缓存框架redis shiro的核心API(接口/是都需要重写的函数！)都是什么？有什么作用？ Subject: 用户主体 (把操作交给SecurityManager,要关联它) SecurityManager: 安全管理器 （关联Reaml） Realm: Shiro连接数据的桥梁,shiro想要查询数据库/配置文件获取用户信息，这些事情都要靠realm来完成。realm中执行认证和授权。认证中具体实现用户名和密码匹配 以上shiro三个API之间的关系？ Subject关联SecurityManager,SecurityManager关联Realm SecurityManager关联Realm：DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(accountRealm); SecurityManager关联Subject：关联函数：A.setB 如：securityManager.setSubjectDAO(subjectDAO); 怎么整合shiro-redis-springboot? 导shiro-redis-springboot依赖和jwt工具包和hutool工具包 写shiro的配置类ShiroConfig： 让shiro的权限数据和会话信息存在redis中，引入了redisSessionDAO、redisCacheManagersecurityManager.setSessionManager(sessionManager.setSessionDAO(redisSessionDAO));//简写securityManager.setCacheManager(redisCacheManager);//配置redis缓存 重写SessionManager和DefaultWebSecurityManager，关闭shiro自带的session方式，这样用户就不再能通过session方式登录shiro。后面将采用jwt凭证登录。DefaultWebSecurityManager中Subject关联SecurityManager,SecurityManager关联Realm。 所有的路由都需要经过JwtFilter这个过滤器，然后判断请求头中是否含有jwt的信息，有就登录，没有就跳过。跳过之后，有Controller中的shiro注解进行再次拦截，比如@RequiresAuthentication，这样控制权限访问。 写shiro进行登录或者权限校验的逻辑类AccountRealm：重写3个方法，分别是：supports：为了让realm支持jwt的凭证校验doGetAuthorizationInfo：权限校验doGetAuthenticationInfo：登录认证校验 -拿到需要验证的token，解析token拿到用户id,根据id去拿到用户对象，判断用户状态。将登陆成功的用户对象中的信息复制到profile对象中，然后返回一个登录成功(已认证)的用户信息载体对象SimpleAuthenticationInfo)(shiro里的) 用户登录信息-Session-shiro-redis小小总结：用户登录信息存放在Session中；Session被shiro管理；shiro的信息(权限数据、会话管理信息)存放在redis中。 将shiro内部构建展示出来，上面这些连接变成了：用户登录信息-Session-subject-securitymanager-redis-realm-mysql jwt jwt的构成 = 加密header+加密payload+加密signature 这三个拼在一起的字符串 头部（header)：声明类型，这里是jwt；声明加密的算法。 载荷（payload, 存放有效信息类似于飞机上承载的物品)：标准中注册的声明；公共的声明；私有的声明 签证（signature)：用header中声明加密的算法对(加密后的header+加密后的payload+secret)组合加密 认为jwt=token 用户登录和请求的流程用户使用用户名密码来请求服务器服务器进行验证用户的信息服务器通过验证发送给用户一个token客户端存储token，并在每次请求时附送上这个token值服务端验证token值，如果验证通过就会返回相应的资源(给接口)这个token必须要在每次请求时传递给服务端，它应该保存在请求头里 项目中是用的jwt凭证登录。 jwt不需要在服务端保存会话信息Session, 用户信息ession保存在客户端 每次请求校验，通过服务端的私钥和过期时间(定义在yml里面)来校验合法性 项目中的jwtUtil是jwt的工具类。四个注解：@Slf4j -为类提供一个 属性名为log 的 log4j 日志对象，调用打印日志@Data -提供类所有属性的 getting 和 setting 方法，此外还提供了equals、canEqual、hashCode、toString 方法@Component -组件@ConfigurationProperties(prefix = “example.demo.jwt”) -外部化配置，在配置文件/配置类外面写配置相关的。这里绑定和验证一些外部属性（.Properties文件中example.demo.jwt下面配置的三个属性） 三个属性：header expire secret. 三个方法： 生成jwttoken: 那三个组成拼起来的字符串 获取jwttoken的信息： 解析jwt 判断token是否过期： 过期时间before当前时间-&gt;过期-&gt;返回true 在AccountRealm中使用了工具类就是要先注入这个类@Autowired，就不用new对象了。 Cookie和Session 两个数据存放在哪里？cookie数据存放在客户的浏览器上；session数据放在服务器上。 cookie的特点和限制是什么？ cookie不是很安全，因为别人可以分析存放在本地的COOKIE并进行COOKIE欺骗。 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。 两个数据里能存什么？cookie里只能存放字符串；session里能存放任何类型的数据，如字符串、集合、类、对象。 用户能看见吗？cookie对用户可见；session对用户不可见(透明) 有效期的差别？ 比如浏览器上百度账号登录信息长期有效？cookie可以容易的达到登录信息长期有效，只要把有效期设为很大的数字；session不能长期有效，容易导致服务器的内存溢出。比如说我们项目使用jwt设置了有效期7天。 并发访问的用户多的时候，用哪个来追踪用户会话？用cookie。因为一个用户就会产生一个session/cookie. session存在服务器端，产生的session量过大会消耗大量的内存。 cookie存在客户端，不占用服务器端的资源，一个用户手里拿一个cookie。所以像百度这种只能用cookie来存储用户的登录信息，用cookie来追踪用户会话。 为什么百度贴吧、百度云盘、百度搜索都可以共用我的登录信息呢(不用重复登录)？因为cookie支持跨域名访问，以“.biaodianfu.com”为后缀的一切域名均能够访问该Cookie。但是session就不支持跨域名访问，如果用session,都要重新登录。 session在服务器端由谁来管理？存在哪里？session由shiro来管理，shiro六大作用之一就是Session会话管理。在ShiroConfig(shiro配置类)中就有会话管理对应的函数-SessionManager. 现在用cookie和session吗？前后端没分离的时候用cookie和session来验证用户的真实性；现在前后端分离了，我们使用shiro这个安全框架来规定用户的操作，使用token和jwt来验证用户的真实性。 mybatis mybatisplus xml文件如何和接口进行绑定？mapper.xml和mapper.java绑定通过xml中的namespace=”xxxx.xxxmapper”mapper.java的路径名 MySQL 分布式数据库是什么？分布式数据库是指数据在物理上分布而逻辑上集中管理的数据库系统。 MySQL 群集是什么？MySQL 群集是一种技术。MySQL群集技术在分布式数据库系统中为MySQL数据提供了冗余特性，增强了安全性，使得单个MySQL服务器故障不会对系统产生巨大的负面效应，系统的稳定性得到保障。 MySQL 群集作用白话：MySQL群集技术让分布式数据库系统稳定性得到保障，(因为它为mysql数据增加安全性，)所以当单个mysql服务器故障时，分布式数据库系统不会产生巨大影响 MySQL 群集的三种结点有什么用？ 管理结点：能对结点进行关闭启动等操作，能监视结点状态。 数据结点：存数据。 SQL结点： 对外提供SQL功能。 mysql的索引是什么？索引的数据结构是什么？索引是数据结构，帮助数据库高效获取数据。数据结构主要支持hash和B+tree.hash不支持范围查询，B+tree支持范围查询。MyISAM和InnoDB两种数据存储引擎都支持hash和B+tree.(MySQL数据库支持多种索引类型，如BTree索引，哈希索引，全文索引等等。) 什么时候简历索引？对应唯一性较高，经常作为查询或者过滤条件或者排序条件的字段，建立索引。对应唯一性较差，频繁更改的字段，不建立索引。 每张表的建立索引的限制？单张表最多对16个字段建立索引 sql语句使得索引失效的情况(索引无法使用)？SARG (Searchable Arguments)操作，因为它通常是指一个特定的匹配，一个值得范围内的匹配或者两个以上条件的AND连接。1、Like语句是否属于SARG取决于所使用的通配符的类型如：name like ‘张%’ ，这就属于SARG而：name like ‘%张’ ,就不属于SARG。原因是通配符%在字符串的开通使得索引无法使用。2、or 会引起全表扫描 Name=’张三’ and 价格&gt;5000 符号SARG，而：Name=’张三’ or 价格&gt;5000 则不符合SARG。使用or会引起全表扫描。3、非操作符、函数引起的不满足SARG形式的语句 不满足SARG形式的语句最典型的情况就是包括非操作符的语句，如：NOT、!=、&lt;&gt;、!&lt;、!&gt;、NOT EXISTS、NOT IN、NOT LIKE等，另外还有函数。下面就是几个不满足SARG形式的例子：ABS(价格)&lt;5000Name like ‘%三’有些表达式，如：WHERE 价格*2&gt;5000sql server也会认为是SARG，SQL SERVER会将此式转化为：WHERE 价格&gt;2500/2但我们不推荐这样使用，因为有时sql server不能保证这种转化与原始表达式是完全等价的。4、IN 的作用相当与OR语句：Select * from table1 where tid in (2,3)和Select * from table1 where tid=2 or tid=3是一样的，都会引起全表扫描，如果tid上有索引，其索引也会失效。5、尽量少用NOT6、exists 和 in 的执行效率是一样的 mysql怎么提高速度的？用分治和索引。分治:将数据分成一格一格的。索引是一个排序的列表，在这个列表中存储着索引的值和包含这个值的数据所在行的物理地址。 mysql的索引类型？1、主键索引：即主索引，根据主键pk_clolum（length）建立索引，不允许重复，不允许空值；ALTER TABLE ‘table_name’ ADD PRIMARY KEY pk_index(‘col’)； 2、唯一索引：用来建立索引的列的值必须是唯一的，允许空值ALTER TABLE ‘table_name’ ADD UNIQUE index_name(‘col’)； 3、普通索引：用表中的普通列构建的索引，没有任何限制ALTER TABLE ‘table_name’ ADD INDEX index_name(‘col’)； 4、全文索引：用大文本对象的列构建的索引ALTER TABLE ‘table_name’ ADD FULLTEXT INDEX ft_index(‘col’)； 5、组合索引：用多个列组合构建的索引，这多个列中的值不允许有空值ALTER TABLE ‘table_name’ ADD INDEX index_name(‘col1’,’col2’,’col3’)； mysql用的存储引擎？MyISAM和InnoDB数据存储引擎 java 面向过程和面向对象 面向过程就是不断的使用函数。 现在将所有的功能/函数进行封装，我们面对的就是封装了功能的对象，这就是面向对象。只要找到了对象，就可以使用对象中的功能。 所有我们在实践的时候，先找到对象以及对象的功能。 如果没有，就自己创建对象并将所需的功能定义到该对象中。 面向对象的好处 面向对象更符合人们思考的习惯。 面向对象就像是指挥者，指挥对象做事情。 面向对象将复杂的问题简单化。 举例： 面试官您就是用面向对象的思想在思考问题。您本身就可以开发项目，但是如果项目比较大，开发周期长。为了提高效率，就需要更多具备能力的人帮助您做事情。这个人就是您需要的对象。您作为指挥者，只需要调用这个对象的开发功能就可以完成项目。 jvm回收机制使用引用计数算法判断对象是否死亡是否应该对这个对象进行回收。(没有引用指向该对象时，对象死亡，计数器为0)垃圾回收算法：标记清除，标记整理，复制算法，分代收集。 标记清除/整理： 每个对象有一个标记位，标记对象存活或者死亡。 清除：清除死亡对象。 整理：整理存活对象，放到另一处空间，清除剩下对象。 复制：内存分为两半，一半内存满了的时候，将存活的对象复制到另外一半内存，清空当前内存。 finalfinal关键字作用【修饰类不可继承，修饰方法不可重写，修饰对象无法重新赋值】 RuntimeException有哪些1， ClassCastException类型强制转换异常Object x = new Integer(0); System.out.println((String)x);当试图将对象强制转换为不是实例的子类时，抛出该异常 2，ArithmeticException算术异常类int a=5/0;一个整数“除以零”时，抛出异常 3, NullPointerException空指针异常类String s=null;int size=s.size();当应用程序试图在需要对象的地方使用 null 时，抛出异常 4, StringIndexOutOfBoundsException“hello”.indexOf(-1);指示索引或者为负，或者超出字符串的大小，抛出异常 5，NegativeArraySizeException数组负下标异常数组大小为负值异常。当使用负数大小值创建数组时抛出该异常String[] ss=new String[-1];如应用程序试图创建大小为负的数组，则抛出异常 6，IllegalArgumentException参数异常抛出的异常表明向方法传递了一个不合法或不正确的参数 7，NumberFormatException数字格式异常当试图将一个String转换为指定的数字类型，而该字符串确不满足数字类型要求的格式时，抛出该异常 8，ArrayIndexOutOfBoundsException数组下标越界异常当使用的数组下标超出数组允许范围时，抛出该异常 9,ClassNotFoundException找不到类异常当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常 10,ArrayStoreException数组存储异常当向数组中存放非数组声明类型对象时抛出 11，NoSuchMethodException 方法未找到异常 12，FileNotFoundException 文件未找到异常 操作系统 线程和进程的区别进程是系统资源分配的基本单位，线程是cpu调度的基本单位。 进程有独立的代码和数据空间，进程之间切换开销较大；同一进程中的线程共享代码和数据空间，线程之间切换较小。 系统在运行的时候会为每个进程分配不同的内存空间；系统不会为线程分配内存，线程之间只能共享资源。 线程是进程的一部分，线程被称为轻量级进程。 线程池是什么线程池，其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源 乐观锁/悲观锁乐观锁：总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。 悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。 CAS：即compare and swap（比较与交换），是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。 网络 get和post的区别get是从服务器上获取数据，post是向服务器传送数据。get的参数可以在url上面看到，post看不到get安全性非常低，post安全性较高。get请求比Post请求效率高，Post请求需要服务器返回100再发送数据处理，Get请求直接是通过URL。 @Getmapping该注解将HTTP Get 映射到 特定的处理方法上 java实现HTTP请求的三种方式java原生HttpURLConnectionapache HttpClient3.1apache httpClient4.5 TCP和UDPTCP：面向连接的安全可靠的传输层协议。客户和服务器交换数据前，必须现在双方之间建立一个TCP连接，之后才能传输数据。并且提供超时重发，丢弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源。慢，效率低。UDP: 面向数据报的不可靠的传输层协议。UDP在传输数据报前不用在客户端和服务器之间建立一个连接，且没有超时重发等机制，所以传输速度很快。只是把数据发送出去，不保证能够到达目的地。快，效率高。 spring IOC AOPSpring拥有两大特性：IoC和AOP。IoC，英文全称Inversion of Control，意为控制反转。AOP，英文全称Aspect-Oriented Programming，意为面向切面编程。 Spring核心容器的主要组件是Bean工厂（BeanFactory），Bean工厂使用控制反转（IoC）模式来降低程序代码之间的耦合度，并提供了面向切面编程（AOP）的实现。 简单来说，Spring是一个轻量级的控制反转（IoC）和面向切面编程（AOP）的容器框架 IOC:控制反转，简单点说，就是创建对象的控制权，被反转到了Spring框架上。通常，我们实例化一个对象时，都是使用类的构造方法来new一个对象，这个过程是由我们自己来控制的，而控制反转就把new对象的工作交给了Spring容器。 AOP:AOP把所有共用代码都剥离出来，单独放置到某个类中进行集中管理，在具体运行时，由容器进行动态织入这些公共代码。]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[文章更新更改备份日志]]></title>
    <url>%2F2020%2F06%2F07%2F%E6%96%87%E7%AB%A0%E6%9B%B4%E6%96%B0%E6%9B%B4%E6%94%B9%E5%A4%87%E4%BB%BD%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[插入本地图片的备份文章 2020-6-7 “算法” 更换为blog中路径的图片，但是大部分的路径是“\”,能在本地显示，不能在网页显示。现在部署的文章换成图片链接，但是备份还未更换。 post到网页的更新文章 2020-6-7 “算法” 全部修改更换路过图床图片链接 2020-6-17 “操作系统”全部修改更换路过图床图片链接 2020-6-17 “人工智能”由于每小时只能上传30张图片，还没有更换图片 使用路过图床添加图片如果你要插入的图片，是一个外部的 src 链接地址，比如该图片存放在 CDN 上，或某某图床上面，那就使用 Markdown 默认的插入图片的方式，方法和插入链接很像，只是前面多了一个感叹号，如下： 1![alt](https://ws3.sinaimg.cn/large/005BYqpgly1g29eohl7qhj31c00u0dkz.jpg) 先在本地备份文件-图片中根据文章名打包图片，然后上传到路过图床对应相册中，再添加进文章。注意相册分类。 https://imgchr.com/lucifinil/albums路过图床网址]]></content>
  </entry>
  <entry>
    <title><![CDATA[测试]]></title>
    <url>%2F2020%2F04%2F30%2F%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[操作系统的特征1.并发（执行）： 多个事件交替发生，某一时刻最多发生一个事件2.共享（资源）： 互斥共享和同时共享 互斥共享：一个时间段内只允许一个进程访问该资源 例子： 摄像头只能被qq或微信使用。 同时共享：一个时间段内允许多个进程访问该资源 （都是cpu交替访问） 例子： qq和微信同时发送文件 ，这两个进程交替着访问硬盘资源。 【特征之间的关系】 并发与共享互为存在条件，是最基本的两个特征 3.虚拟： 虚拟技术的空分复用技术（虚拟存储器技术）： 程序需要的内存远大于系统内存；内存不够分内存。 虚拟技术的时分复用技术（虚拟处理器技术）： 实际上只有一个cpu,用户感觉有多个cpu在服务；处理器不够分处理器。 【特征之间的关系】 没有并发性就谈不上虚拟性 4.异步： 多个程序并发执行时，进程的执行走走停停，不可预知每次运行多久停，可能导致运行结果的不确定性。 【特征之间的关系】 只有系统有并发性，才可能导致异步性 操作系统的发展和分类 操作系统的几个发展阶段1.手工操作阶段： 读纸带条； 缺点：人输入速度慢 2.批处理阶段： 单道批处理系统： 读纸带存到磁带上，计算机读取磁带，输出磁带，再到纸带。 缺点：cpu大量时间是在等待输入输出。 多道批处理系统（操作系统正式诞生）： 每次往内存中输入多道程序，并发执行，共享计算机资源。资源利用率大幅提升。 缺点：用户提交完作业后，只能等待计算机处理完成，中间用户不能控制自己的作业执行。 资源利用率大幅提升原因： 输入、计算、输出都在流水线工作，不会等待。 内核态 用户态两种处理器状态：(cpu是处理器)1.用户态： cpu只能执行非特权指令2.核心态： cpu可以执行特权指令，也可以执行非特权指令 PSW程序状态寄存器：标识cpu处理器状态—– 0为用户态，1为核心态两种程序：1.应用程序： 只能执行非特权指令；程序在用户态运行 2.内核程序： 可以执行特权指令，也可以执行非特权指令；程序在核心态运行操作系统功能=内核功能+非内核功能内核： 计算机上配备的底层软件 注：原语是一种特殊的程序，是最接近硬件的部分，原语这种程序的运行具有原子性（一旦执行就会执行完，不会中断）操作系统体系结构 = 企业管理内核 = 企业管理层，负责重要工作（特权指令）； 普通员工只能执行非特权指令。用户态与核心态之间的切换 = 普通员工和管理层之间的工作交接 大内核：效率高，难维护； 比如小企业，管理层管大部分事情 功能都放在内核，核心态运行微内核：效率低，易维护； 比如大企业，管理层管最核心的工作 只有基本功能放在内核，频繁的在核心态和用户态之间切换 中断和异常中断： 中断发生时，cpu立刻从用户态进入核心态，操作系统获得计算机的控制权；当前进程暂停，操作系统根据不同的中断信号进行不同的处理。【有中断才有多道程序并发执行】【中断是cpu从用户态到核心态的唯一途径】 1.内中断：信号来自cpu内部，也称异常；比如指令中断，故障，软件报错2.外中断：信号来自cpu外部；比如外设发出的信号，用户终止进程 系统调用把调用硬件的办法封装成系统调用，供人通过应用程序间接的操作硬件。 系统调用发生在用户态；系统调用的处理发生在核心态。 执行陷入指令会产生内中断，使cpu从用户态立即进入核心态 进程进程的定义，组成，组织方式，特征进程：进程是资源分配、接受调度的基本单位，是进程实体的运行过程。 PCB: 每个进程运行之前，操作系统会配置一个数据结构 PCB（进程控制块），来存储进程的各种信息（程序代码的存放位置，数据段的位置，见图）。和进程管理有关的数据肯定是放在PCB里面的。 进程实体 = 程序段+数据段+PCB； 进程实体是进程需要的数据的集合，它是静态的；进程是进程实体运行的过程，它是动态的。 创建进程 = 创建进程实体中的PCB；撤销进程 = 进程组织方式：用队列或者索引表，下面是队列的用几种指针组织进程（组织PCB）：1.执行指针2.就绪队列指针：优先级高的放在队列头3.阻塞队列指针 进程特征：动态性；并发性；独立性（进程是资源分配、接受调度的基本单位）；异步性（进程的执行走走停停，不可预知每次运行多久停，可能导致运行结果的不确定性。）；结构性。 进程状态为了方便操作系统进行进程的管理分成了五种状态。 三种基本状态：1.运行态running: 占用cpu资源，在cpu上运行2.就绪态ready: 万事俱备，只差cpu.具备运行条件，但没有空闲cpu。(有除了处理机之外的所有需要的资源，一旦获得处理机cpu，立即进入运行态)3.阻塞态/等待态waiting/blocking: 因为某些事件而暂时不能运行 另外两种状态：1.创建态new: 创建进程，操作系统给进程分配资源，初始化PCB2.终止态terminated: 进程从操作系统中撤销，回收资源，撤销PCB 进程状态的转换：主要注意只能是 运行态-&gt;阻塞态-&gt;就绪态 进程控制进程控制: 是实现进程状态之间的转换，用原语实现。 需要做的事情：1.更新PCB信息2.将PCB插入对应的进程状态PCB队列3.回收/分配资源 怎么做上面的三件事情： 用几个原语实现进程控制：原语是一种特殊的程序； 原语采用“关中断和开中断的特权指令”； 执行期间不会被中断，一气呵成；“关中断和开中断指令”的权限非常大，是只能在核心态执行的特权指令（原语在核心态运行）。 相关原语（对进程操作的特权指令）：创建原语，终止原语，阻塞原语，唤醒原语，切换原语。阻塞和唤醒要成对出现 进程通信进程通信： 进程之间的信息交换 线程和多线程模型线程相当于轻量级进程，便于创建销毁。 线程增加了并发度，让qq应用（一个进程）中边聊天边发送文件得以实现。 cpu则服务于进程中的线程。 同一线程中的线程切换不需要切换进程的运行环境，系统开销变小。 多线程模型：1.多对一： 多个用户线程映射到一个内核级线程。 处理机调度调度基础知识调度：选择哪个先调。 作业： 程序、项目。挂起状态：内存不够，不能获得cpu就先掉到外存去，与阻塞状态不同的是阻塞时还是在内存中。 进程调度时机]]></content>
  </entry>
  <entry>
    <title><![CDATA[操作系统原理中文版]]></title>
    <url>%2F2020%2F04%2F24%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%96%87%E7%89%88%2F</url>
    <content type="text"><![CDATA[概念题高频考点Cache缓存空间很贵，每次只从main memory里取出有用的PCB进程管理器virtual(logical) address &amp; physics address virtual(logical) address:用户看到的，我们假设的physics address：数据在硬盘上实际储存的位置 virtual(logical) address: The user can view the logical address of a program. /The user uses the logical address to access the physical address. / Set of all logical addresses generated by CPU in reference to a program is referred as Logical Address Space. physics address: The user can never view physical address of program /The user can not directly access physical address. /Set of all physical addresses mapped to the corresponding logical addresses is referred as Physical Address. process &amp; threadsfragments 储存碎片化外部碎片：外面东西塞进冰箱没法完整塞进来内部碎片：冰箱分层，一层没塞满 hashed page table把页和页用链表数据结构存储，每一页有一个数据用来指向下一页位置。这样不用存储文件，不用存储所有页码。但是不能从任意地方开始读，不能从中间往上读，但是往下读就很方便。通过目录只能从第一页开始读。 RAIDRAID level0-5都要背 principle of least privilege 最小获知代价？每个进程或用户只需要知道他们需要知道的，如果删除任何一个他们目前已知的东西都会导致他们无法完成任务。 CIA Triad信息安全部分 SecurityConfidentiality 机密性：未授权的用户“不能看”Integrity 完整性：未授权的操作，“不能改”Availability 可用性：授权的用户，可以“一直用”。更新软件之后可以一直用以前的数据。 There are four levels at which a system must be protected: Physical - The easiest way to steal data is to pocket the backup tapes. Also, access to the root console will often give the user special privileges, such as rebooting the system as root from removable media. Even general access to terminals in a computer room offers some opportunities for an attacker, although today’s modern high-speed networking environment provides more and more opportunities for remote attacks. Human - There is some concern that the humans who are allowed access to a system be trustworthy, and that they cannot be coerced into breaching security. However more and more attacks today are made via social engineering, which basically means fooling trustworthy people into accidentally breaching security. Phishing involves sending an innocent-looking e-mail or web site designed to fool people into revealing confidential information. E.g. spam e-mails pretending to be from e-Bay, PayPal, or any of a number of banks or credit-card companies. Dumpster Diving involves searching the trash or other locations for passwords that are written down. ( Note: Passwords that are too hard to remember, or which must be changed frequently are more likely to be written down somewhere close to the user’s station. ) Password Cracking involves divining users passwords, either by watching them type in their passwords, knowing something about them like their pet’s names, or simply trying all words in common dictionaries. ( Note: “Good” passwords should involve a minimum number of characters, include non-alphabetical characters, and not appear in any dictionary ( in any language ), and should be changed frequently. Note also that it is proper etiquette to look away from the keyboard while someone else is entering their password. ) Operating System - The OS must protect itself from security breaches, such as runaway processes ( denial of service ), memory-access violations, stack overflow violations, the launching of programs with excessive privileges, and many others. Network - As network communications become ever more important and pervasive in modern computing environments, it becomes ever more important to protect this area of the system. ( Both protecting the network itself from attack, and protecting the local system from attacks coming in through the network. ) This is a growing area of concern as wireless communications and portable devices become more and more prevalent. Deadlock造成死锁条件4个缺一不可：Mutual Exclusion:一个资源同时只能被一个进程使用Hold and Wait:得不到资源的进程就会挂起No preemption:一个进程执行完毕会释放他拥有的资源Circular wait:循环，A等B,B等C,C等A 哲学家就餐问题 Starvation五个人圆桌吃饭，五个餐具，只有左右手都有餐具才会吃饭。不然就不吃，会饿死。解决办法：只有左右手能拿到餐具才会拿起餐具，不然都不拿餐具。 计算题多练 保证一分不丢 page frames 物理页面1.FIFO LRU OPR replacement 例题：字符串a b c d a d demanded page with 3 frames,求出现多少次page faults(帧上数据改变)（缺页中断） FIFO first in first out :一共三帧（三个格子装字符，满了就要把先装进来的踢出去），每次用分号隔开，每次对应题目上字符串一个字符进来。a(改变); a b（改变）; a b c（改变）; d b c(踢掉a换成d 改变)； d a c(踢掉b换成a 改变)； d a c(d有了，不改变)。所以一共改变5次。 LRU least recent use技巧为找前面次数最少且最远的： 三层帧都满了时，踢掉这时候要加进来的字符的前面 找字符串里离当前进来字符前面最后出现的（都一样/没出现的时候，默认踢掉最先进来的）这种字符串和FIFO情况是一样的。a; a b; a b c; d b c; d a c; d a c. OPR optimal page replacement技巧找当前需要加进来的页面的后面“访问页面”次数最远出现的踢掉：三层帧都满了时a; a b ; a b c; a d c(d后面没有bc先踢b); a d c; a d c. 练习题1： 7,0,3,1,3,5,3,4,6,5 三帧FIFO：7(√)；7 0(√)；7 0 3(√)； 1 0 3(√)；1 0 3;1 5 3(√)；1 5 4(√)；6 5 4(√)；6 5 4.所以是7次page faults occur. LRU（看前面，找字符串里当前进来最远的）: 7(√)；7 0(√)；7 0 3(√)；1 0 3(√)；1 0 3；1 5 3(√ 0最远踢掉)；1 5 3；4 5 3(√ 1次数比3小=最远)；4 6 3(√ 4和5都只有一次，5比4远踢掉)；4 6 5(√ 视频里说3最远？？？迷惑？？是最远啊但是出现次数多啊，而且之前怎么不先踢3 要踢1？？).所以是次page faults occur. OPR: 2.易错点头三次都要算，变化做标记。 3.对比 scheduling algorithms调度算法Process进程 Burst time运行时间 Arrival time出现时间没有给Arrival time出现时间，默认全部一起出现。Gantt chart甘特图: 用于计算的左右下标图就是正规的甘特图 0.时间关系 时间下标全部从0秒开始 用格子左右下标计算(间隔时间直接做减法，右下标-左下标，开始执行的左下标-上次停止执行的右下标) 等待时间waiting time = 开始执行时间(左下标)-到达时间(表格上数据) + 之后的开始执行时间(左下标)-上次停止时间(右下标)； （ 也就是说到达的那个秒数如果没有立即执行（别的p在执行）是算在等待时间+1s.） 等待时间=周转时间-运行时间 周转时间rurn around time = 运行完成时间(右下标) - 到达时间(表格上数据) 求的是平均时间，都要除以总进程数量 response time反应时间 = 第一次运行时间(左下标)-到达时间(表格上) throughput吞吐量生产量 = 所有进程的执行时间/进程数量 1.FCFS first come first serve先来的先运行P1,P2,P3顺序，P1先运行，P2等待P1运行完再运行，P2等待时间=P1运行时间 2.shortest job first先运行最短的计算平均等待时间：每个进程等待时间是他之前先运行的进程运行时间总和 3.shortest remaining time first先执行剩余需要执行时间最短的图要画好 一秒一秒的分析 当前秒数执行哪一个进程 当前秒数完了这个进程还剩多少秒。 下面表格为每个时间段执行的进程和时间；进程等待时间 = 进程开始执行的秒数-Arrival time；如果一个进程被打断多次需要分段考虑等待时间。 4.round robin每个依次执行相同时间Priority 优先执行顺序，优先1然后2 Time quantum = 5,每个依次执行5秒。画好格子图 正在执行的进程，执行时间，剩余时间。每个p的等待时间=开始执行时间下标-上次结束执行时间下标 5.priority scheduling按照给出的优先级别顺序执行优先级别1234，优先执行1-2-3-4. sale state 银行家问题 判断是否安全关键词解释process(P1 P2 P3)：进程,理解为工厂source type(A B C): ABC各自的资源数量，理解为三种不同的工人的总数量request source by P1: P1请求的资源,理解为P1需要增加的工人，如果available&gt;request就可以吧request加在P1的allocate中，同样的p1的need会动态减少max: 每个P最多容纳的资源，安全运行需要的资源，理解为每个工厂最多容纳每种工人数量，工厂要运作需要的工人数量allocate: 已分配的资源，理解为现在工厂里已有的工人need: max-allocate,理解为工厂满员还需要的工人available: 工人总数-allocate,理解为除去每个工厂里已经有的工人，剩下空闲的工人数量 第一步通过给出的source，allocate，max写出need，available 第二步拿着现在的available去找能够满足的need，也就是说能够满足need的P第一个执行； 然后会释放第一个执行完毕的allocate资源，那么此时的available=初始的available+已执行P的初始allocate。拿着现在的available去找能够满足的need，也就是说下一个能够满足need的P第二个执行。。。。同上如果拿着的available能够最终执行完所有P ,那么the system is in safe time in time T.如果拿着的available一个p的need都不够，那么就false. two-level-page相关概念fragment碎片:1.外部碎片：进程在操作系统中需要内存空间，就像是把东西放进冰箱，如果冰箱没有分层，东西乱放就会产生间隙。当我们需要再15mb的东西到冰箱里时，冰箱里只有10+10mb的小间隙是不能完整的放进15mb的东西(进程)的，这个进程不能连续的放在一个地方，此时就会产生外部碎片。2.内部碎片：比如把18mb的进程放进一层5mb大小的操作系统，就需要4层，但是放不满，多了2mb空隙，此时就会产生内部碎片。 page页：把操作系统分层，就像是把冰箱分层放东西，比如一个格子5mb大小。 outer page table(一阶list): 像是存放很多本书，书名的合集page table(二阶list): 像是存放每本书的首页和末尾页memory: 存放书的地方，每本书的首页和末尾页指向memory中的内存地址 two-level-page题把解题过程背下来pagesize=4096byte=4x1024byte=4kb这个是每个实体大小每页page大小= 2^10x每个实体大小=1024x4kb=4mb一共要存8+12=20mb需要20/4=5页二阶list如果这里除不尽，保留小数。 levels of page table题目Consider a system using multilevel paging scheme. The page size is 1 MB. The memoryis byte addressable and virtual address is 64 bits long. The page table entry size is 4 bytes.Find: How many levels of page table will be required? Give the divided physical address and virtual address. 第一问解答：按照这个比这做 Given条件 • Virtual Address = 64 bits • Page size = 1 MB • Page table entry size = 4 bytes 1.求Number of Bits in Frame Number We have, Page table entry size= 4 bytes = 32 bits Thus, Number of bits in frame number = 32 bits Number of Frames in Main Memory We have, Number of bits in frame number = 32 bits Number of frames in main memory = 2^32 frames 2的32次方 Size of main memory = Total number of frames x Frame size = 2^32 x 1 MB = 2^52 B (1 MB=2^20B) Thus, Number of bits in physical address = 52 bits Number of Bits in Page Offset We have, Page size = 1 MB = 2^20 B Thus, Number of bits in page offset = 20 bits Alternatively, Number of bits in page offset = Number of bits in physical address – Number of bits in frame number = 52 bits – 32 bits = 20 bits disk schedulinghttps://www.gatevidyalay.com/disk-scheduling-disk-scheduling-algorithms/六种调度和例题 基本词汇sector: 部门，扇形，指光盘的最小存储单元cluster: 群，聚集，指多个sector拼在一起track: 道，指光盘的一圈 disk queue: 数字队列，数组 1.FCFSqueue:98,183,37,122 head start at 53读取顺序就是53 98 183 57 122 2.shortest time seek first类似贪心算法，每次选择与自己差值最小的，先把序列中从小到大排序，然后沿着一个方向选择queue:98, 183, 41, 122, 14, 124, 65, 67 head start at 53读取顺序就是53-65-67-41-14-98-122-124-183Total head movements incurred while servicing these requests的计算与例题一致。 3.SCAN (LOCK)往一个方向读，向小moving down或向大moving up到最外，才能回头。。queue:98, 183, 41, 122, 14, 124, 65, 67 head start at 53读取顺序就是53-65-67-98-122-124-183-199(向大到最大)-41-14(向小到最小) 4.C-SCAN往一个方向读，然后到0，再从0向一个方向读98, 183, 41, 122, 14, 124, 65, 67.从53读取顺序就是53-65-67-98-122-124-183-199-0-14-41 5.C-LOCK往一个方向读，然后到剩下的最小数，再向一个方向读98, 183, 41, 122, 14, 124, 65, 67.从53读取顺序就是53-65-67-98-122-124-183-14-41 6.例题Consider a disk queue with requests for I/O to blocks on cylinders 98, 183, 41, 122, 14, 124, 65, 67. The FCFS scheduling algorithm is used. The head is initially at cylinder number 53. The cylinders are numbered from 0 to 199. The total head movement (in number of cylinders) incurred while servicing these requests is ___. 53，98, 183, 41, 122, 14, 124, 65, 67. Total head movements incurred while servicing these requests = (98 – 53) + (183 – 98) + (183 – 41) + (122 – 41) + (122 – 14) + (124 – 14) + (124 – 65) + (67 – 65) = 45 + 85 + 142 + 81 + 108 + 110 + 59 + 2 = 632 linked scheme - mapping address这个就是用指针把每一页的首尾连接起来，这样就相当于冰箱分层了，不存在外部碎片了。注意：最后一个block pointer(页尾格指针)不用指向下一页但是要留出来页尾格指针位置，是空的 题目the block size is 512 words, 每个entry of index table 占用1 word.(页指针) 地址在635109理解： level-1 index page有512个实体，level-2也有512个实体，但是最后一个实体放指针。指向在level-1的位置。1.求index table 的block number： 在第几个level-1级别的书页上:635109/(512x511)=2 取整数部分 求displacement into block of index page：先求第一问除法的余数是111845，然后111845/512=218 取整数部分 求displacement into block of file: 111845%512=229 取余数部分 用逻辑地址求物理地址&lt;0,430&gt;: 0是号码，430是给出的数据表格上length用来求段offset的极限：[0到length-1],只要430小于等于length-1就不会触发陷阱。那么这个物理地址=表格上的base+430 c语言解答题lab13 链表，link librarylab 14 make file ,threadlab15 race condition ,pthread,mutex设计题非常难，但熟记并且理解流程图一样拿分 one-time padECBCBCOFB操作系统的特征1.并发（执行）： 多个事件交替发生，某一时刻最多发生一个事件 2.共享（资源）： 互斥共享和同时共享 互斥共享：一个时间段内只允许一个进程访问该资源 例子： 摄像头只能被qq或微信使用。 同时共享：一个时间段内允许多个进程访问该资源 （都是cpu交替访问） 例子： qq和微信同时发送文件 ，这两个进程交替着访问硬盘资源。 【特征之间的关系】 并发与共享互为存在条件，是最基本的两个特征 3.虚拟： 虚拟技术的空分复用技术（虚拟存储器技术）： 程序需要的内存远大于系统内存；内存不够分内存。 虚拟技术的时分复用技术（虚拟处理器技术）： 实际上只有一个cpu,用户感觉有多个cpu在服务；处理器不够分处理器。 【特征之间的关系】 没有并发性就谈不上虚拟性 4.异步： 多个程序并发执行时，进程的执行走走停停，不可预知每次运行多久停，可能导致运行结果的不确定性。 【特征之间的关系】 只有系统有并发性，才可能导致异步性 操作系统的发展和分类 操作系统的几个发展阶段1.手工操作阶段： 读纸带条； 缺点：人输入速度慢 2.批处理阶段： 单道批处理系统： 读纸带存到磁带上，计算机读取磁带，输出磁带，再到纸带。 缺点：cpu大量时间是在等待输入输出。 多道批处理系统（操作系统正式诞生）： 每次往内存中输入多道程序，并发执行，共享计算机资源。资源利用率大幅提升。 缺点：用户提交完作业后，只能等待计算机处理完成，中间用户不能控制自己的作业执行。 资源利用率大幅提升原因： 输入、计算、输出都在流水线工作，不会等待。 内核态 用户态两种处理器状态：(cpu是处理器)1.用户态： cpu只能执行非特权指令2.核心态： cpu可以执行特权指令，也可以执行非特权指令 PSW程序状态寄存器：标识cpu处理器状态—– 0为用户态，1为核心态两种程序：1.应用程序： 只能执行非特权指令；程序在用户态运行 2.内核程序： 可以执行特权指令，也可以执行非特权指令；程序在核心态运行操作系统功能=内核功能+非内核功能内核： 计算机上配备的底层软件内核程序： 实现内核功能的程序，内核功能如下图： 注：原语是一种特殊的程序，是最接近硬件的部分，原语这种程序的运行具有原子性（一旦执行就会执行完，不会中断）操作系统体系结构 = 企业管理内核 = 企业管理层，负责重要工作（特权指令）； 普通员工只能执行非特权指令。用户态与核心态之间的切换 = 普通员工和管理层之间的工作交接 大内核：效率高，难维护； 比如小企业，管理层管大部分事情 功能都放在内核，核心态运行微内核：效率低，易维护； 比如大企业，管理层管最核心的工作 只有基本功能放在内核，频繁的在核心态和用户态之间切换 中断和异常中断： 中断发生时，cpu立刻从用户态进入核心态，操作系统获得计算机的控制权；当前进程暂停，操作系统根据不同的中断信号进行不同的处理。【有中断才有多道程序并发执行】【中断是cpu从用户态到核心态的唯一途径】 1.内中断：信号来自cpu内部，也称异常；比如指令中断，故障，软件报错2.外中断：信号来自cpu外部；比如外设发出的信号，用户终止进程 系统调用把调用硬件的办法封装成系统调用，供人通过应用程序间接的操作硬件。 系统调用发生在用户态；系统调用的处理发生在核心态。 执行陷入指令会产生内中断，使cpu从用户态立即进入核心态 进程进程的定义，组成，组织方式，特征进程：进程是资源分配、接受调度的基本单位，是进程实体的运行过程。 PCB: 每个进程运行之前，操作系统会配置一个数据结构 PCB（进程控制块），来存储进程的各种信息（程序代码的存放位置，数据段的位置，见图）。和进程管理有关的数据肯定是放在PCB里面的。 进程实体 = 程序段+数据段+PCB； 进程实体是进程需要的数据的集合，它是静态的；进程是进程实体运行的过程，它是动态的。 创建进程 = 创建进程实体中的PCB；撤销进程 = 撤销进程实体中的PCB；PCB是进程存在的唯一标志！ 进程组织方式：用队列或者索引表，下面是队列的用几种指针组织进程（组织PCB）：1.执行指针2.就绪队列指针：优先级高的放在队列头3.阻塞队列指针 进程特征：动态性；并发性；独立性（进程是资源分配、接受调度的基本单位）；异步性（进程的执行走走停停，不可预知每次运行多久停，可能导致运行结果的不确定性。）；结构性。 进程状态为了方便操作系统进行进程的管理分成了五种状态。 三种基本状态：1.运行态running: 占用cpu资源，在cpu上运行2.就绪态ready: 万事俱备，只差cpu.具备运行条件，但没有空闲cpu。(有除了处理机之外的所有需要的资源，一旦获得处理机cpu，立即进入运行态)3.阻塞态/等待态waiting/blocking: 因为某些事件而暂时不能运行 另外两种状态：1.创建态new: 创建进程，操作系统给进程分配资源，初始化PCB2.终止态terminated: 进程从操作系统中撤销，回收资源，撤销PCB 进程状态的转换：主要注意只能是 运行态-&gt;阻塞态-&gt;就绪态 进程控制进程控制: 是实现进程状态之间的转换，用原语实现。 需要做的事情：1.更新PCB信息2.将PCB插入对应的进程状态PCB队列3.回收/分配资源 怎么做上面的三件事情： 用几个原语实现进程控制：原语是一种特殊的程序； 原语采用“关中断和开中断的特权指令”； 执行期间不会被中断，一气呵成；“关中断和开中断指令”的权限非常大，是只能在核心态执行的特权指令（原语在核心态运行）。 相关原语（对进程操作的特权指令）：创建原语，终止原语，阻塞原语，唤醒原语，切换原语。阻塞和唤醒要成对出现 进程通信interprocess communication IPC进程通信： 进程之间的信息交换 三种通信：1.共享存储shared memory： 设置一个共享空间；互斥的访问共享空间；用数据结构（存取要完全符合这个数据结构）/ 基于存储区的共享（内存中画出一块共享存储区，没有严格要求）2.管道通信pipe： 一个管道只能单向传输，双向要两个管道；各进程互斥访问；没写满不能读，没读空不能写；3.消息传递message passing：进程通过操作系统提供的“发送消息/接收消息”两个原语进行数据交换；直接通信（消息挂到接收方队列中）/间接通信（消息先发送到信箱）。 线程和多线程模型线程相当于轻量级进程，便于创建销毁。 线程增加了并发度，让qq应用（一个进程）中边聊天边发送文件得以实现。 cpu则服务于进程中的线程。 线程是cpu调度的基本单位；进程是资源分配的基本单位。 同一进程中的线程切换（并发）不需要切换进程的运行环境，系统开销变小。同一进程中的线程共享进程的资源。线程几乎不拥有资源，只拥有极少量的资源（线程控制块TCB、寄存器信息、堆栈等）。 计算机中的透明是看不见的意思。 用户级线程（User-Level Thread, ULT）:线程切换可以在用户态下即可完成， 无需操作系统干预。内核级线程（Kernel-Level Thread, KLT）: 内核级线程的管理工作由操作系统内核完成。线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。 内核级线程才是cpu分配的单位。多线程模型：1.多对一： 多个用户线程映射到一个内核级线程。 优点：进程管理开销小，效率高； 缺点：一个（用户）线程被堵塞，一个进程中所有线程被堵塞，并发度低。 2.一对一： 一个用户线程映射到一个内核级线程。 优点：进程管理开销大； 缺点：一个线程对应一个内核线程，分配到多核cpu并行执行，单个线程不影响其他线程，并发度高。 2.多对多： n个用户线程映射到m个内核级线程。(n&gt;=m) 集二者之所长。 CPU调度调度基础知识调度：选择哪个进程分配cpu。(注意：线程是cpu调度的基本单位) 作业： 程序、项目。挂起状态suspend：内存不够，暂时不执行，不能获得cpu的进程就先掉到外存去，与阻塞状态不同的是阻塞时还是在内存中。 三种调度：（低级高频发生，高级低频发生）1.作业调度（高级调度）： 选择作业从外存调入内存并创建进程。2.内存调度（中级调度）： 选择进程从挂起队列中调回内存。3.进程调度（低级调度）： 选择进程从就绪队列中分配cpu。 进程调度（低级调度）时机（什么时候可以/不可以 分配cpu）广义的进程调度： 选择一个进程+一个进程让出cpu,另一个进程占用cpu =选择一个进程+进程切换。 什么时候需要进程调度： 1.主动放弃 2.被动放弃什么时候不能进程调度： 1.处理中断时 2.在内核程序临界区中 3.原语 临界资源： 只能一个进程使用的资源临界区： 访问临界资源的那段代码内核程序临界区： 访问内核数据结构的代码， 进程调度的方式：1.非剥夺调度方式（非抢占式）： 只允许进程主动放弃cpu; 主动：终止/主动进入阻塞态。2.剥夺调度方式（抢占式）： 操作系统可以剥夺当前进程的cpu。 cpu分配给更紧迫的进程。 适合实时、分时操作系统。 进程切换与进程调度的区别进程切换： 一个进程让出cpu,另一个进程占用cpu. 保存原来进程PCB中的数据，恢复新的进程PCB中的数据。 所以进程切换是有时间代价的，如果频繁的进程切换/调度，系统的效率会降低。（时间花在切换上，执行进程的时间减少）。狭义的进程调度： 从就绪队列中选择一个要运行的进程.广义的进程调度： 选择一个进程+进程切换。 CPU利用率CPU利用率= cpu忙碌的时间/总时间 进程同步，进程异步，进程互斥 p17进程异步：程序并发运行，并发必然导致异步性。cpu切换执行进程的顺序，次序，执行到多少是不可预知的。进程同步：两个或多个进程需要按照一定的执行顺序来完成一个任务是，就需要达到进程同步，有顺序的执行。 资源共享方式：1.互斥共享：qq用了摄像头，微信就不能用2.同时共享：b站用了播放器，龙族同时可以用播放器 进程互斥实现代码：do{ entry section; 进入区 若可以访问临界资源就上锁 critial section; 临界区 访问临界资源（只能被一个进程访问的资源）的代码 exit section; 退出区 解锁临界资源 remainder section; 剩余区 做其他的处理} 进程互斥软件实现方法：1.单标志法：未被空闲让进2.双标志法：解决忙则等待，违背空闲让进和有限等待，造成死锁flag[1]=true;while(flag[2]);3.Peterson算法：主动争取，主动谦让，检查地方是否想进，自己是否谦让。如果双方都想进入临界区，可以进程1主动让进程2先进入临界区。cpu切换时，有很多种排列组合会导致每个进程运行到第三行代码是turn值不一样。while等待条件一个不满足就能进入临界区。P1进程：flag[1]= true //自己想进临界区turn=1; //不让while(flag[2] &amp;&amp; turn==1);P2进程：flag[2]= true //自己想进临界区turn=0; //不愿意while(flag[1] &amp;&amp; turn==0);//循环等待代码：当对方想进，愿意让出 进程互斥硬件实现方法：1.disable interrupt关中断：关中断；//不允许当前进程被中断、切换临界区；开中断；2.test and set指令：用硬件实现，不能中断while(TSL(&amp;lock)) //检查上锁临界区；lock = false; //解锁剩余区；3.swap指令：和TSL差不多 剩下的没写完的课程图片：https://imgchr.com/album/UAUbT]]></content>
      <categories>
        <category>记忆性学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[spring cloud 项目]]></title>
    <url>%2F2020%2F04%2F14%2Fspring-cloud-%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[外面点餐系统项目需求 客户端： 针对普通用户，用户登录，用户退出，菜品订购，我的订单 后台管理系统：针对管理员，管理员登录，管理员退出，添加菜品，查询菜品，修改菜品，删除菜品，订单处理，添加用户，查询用户，删除用户 功能拆分 acoount 提供账户服务： 用户和管理员的登录退出 menu 提供菜品服务： crud操作 添加菜品，查询菜品，修改菜品，删除菜品 order 提供订单服务： 添加订单，删除订单，查询订单，处理订单 user 提供管理员对用户的管理服务： crud操作 添加用户，查询用户，删除用户 第一章微服务环境搭建第一步 写pom.xml 添加依赖 没有添加视频中jdk9相关依赖1234567891011&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Finchley.SR2&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; 第二步 项目中创建注册中心模块(一个子项目)： eurekaserver 先修改总项目pom.xml打包方式，不然不能添加maven module123&lt;artifactId&gt;springcloud-take-out-order&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; 写eureka server配置以下为未能启动的子项目，现在已经新建了starter项目才能启动，内容添加和下面一致 在总项目中创建maven module，他会出来一个文件夹和一个同名并列的项目，右键文件夹有一个go to project “registration”以下编辑在下面的项目中添加, 会同步到总项目中的同名文件夹（所有文件都同步了，只是文件夹有点多） registration子项目中添加依赖： pom.xml 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 写他的配置文件: application.yml 12345678server: port: 8761eureka: client: service-url: defaultZone: http://localhost:8761/eureka/ register-with-euraka: false #是否注册他自己 fetch-registry: false # 是否导入数据 写启动类： RegServerApplication.java项目为starter项目时，根本不用自己写启动类，自带有 12345678@SpringBootApplication@EnableEurekaServerpublic class RegServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(RegServerApplication.class,args); &#125;&#125; 第三步 子项目configServer第四步 创建服务提供者 子项目orderpom.xml 中有一个视频上是config 我的自动加的的config-server 第五步 测试启动先启动注册中心eureka,配置中心comfig,服务提供者order menu 第二章 创建服务提供者 menu子项目第一步 创建+配置pom 创建时添加依赖：mybatis-spring-boot-starter；spring-boot-starter-web；spring-cloud-starter-config（让他读取配置中心的配置文件）；mysql-connector-java（mysql版本可以写最新的，能兼容老版本）；spring-cloud-starter-netflix-eureka-client（让他在注册中心进行注册，让他成为一个服务） 有mysql mybatis的依赖，需要在配置文件中加入数据库的连接信息在configServer子项目中的menu-dev.yml加mydql信息 第二步 复制order里的bootstrap.yml配置文件 改name123456789spring: application: name: menu profiles: active: dev #这里是整合到在configServer里面的order-dev.yml cloud: config: uri: http://localhost:8762 #configServer的端口号 注意是uri不是url fail-fast: true 第三步 configServer中添加menu的配置文件123456789101112131415161718server: port: 8020spring: application: name: menu datasource: name: orderingsystem url: jdbc:mysql://localhost/orderingsystem?serverTimezone=UTC username: root password: zhangcaiyun driver-class-name: com.mysql.cj.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSourceeureka: client: server-url: defaultZone: http://localhost:8761/eureka/ instance: prefer-ip-address: true 目前问题 http://localhost:8020/menu/index访问不到 http://localhost:8020/访问不到 configServer中配置文件没有连接上 第四步 复制sql语句去数据库中创建+更新表格第五步 menu中关联数据库中的那几张表Menu表entity包中写Menu表格的实体类：Menu1234567891011import lombok.Data;@Datapublic class Menu &#123; private long id; private String name; private double price; private String flavor; &#125; repository包中写Menu的接口（dao层）：MenuRepo 作用：定义操作数据库Menu表格的java方法123456789public interface MenuRepo &#123; public List&lt;Menu&gt; findAll(); //查询全部数据 public int count(); //查询记录条数 public Menu findById(long id); //用主键id查找记录，返回Menu对象，记录都成为Menu对象中的属性值 public void save(Menu menu); public void update(Menu menu); public void delectById(long id);//用主键删掉记录&#125; 用mybtis的Mapper写MenuRepo接口的实现类： Mapper.xml(包括MenuRepo.xml,TypeRepo.xml) 作用：实现作数据库Menu的接口方法的sql语句 resources路径下创建mapping文件夹：在同级文件夹上点击创建folder file configServer中menu-dev配置文件中添加mybtis 1234mybatis: mapper-locations: classpath:/mapping/*.xml type-aliases-package: com.example.demo.entity #提出menu下的entity包; 在mapping的xml文件中就不用再写包名 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.southwind.repository.MenuRepository&quot;&gt; &lt;resultMap id=&quot;menuMap&quot; type=&quot;Menu&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;mid&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;mname&quot;/&gt; &lt;result property=&quot;author&quot; column=&quot;author&quot;/&gt; &lt;result property=&quot;price&quot; column=&quot;price&quot;/&gt; &lt;result property=&quot;flavor&quot; column=&quot;flavor&quot;/&gt; &lt;!-- 映射type --&gt; &lt;association property=&quot;type&quot; javaType=&quot;Type&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;tid&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id=&quot;findAll&quot; resultMap=&quot;menuMap&quot;&gt; select m.id mid,m.name mname,m.price,m.flavor,t.id tid,t.name tname from t_menu m,t_type t where m.tid = t.id order by mid limit #&#123;param1&#125;,#&#123;param2&#125; &lt;/select&gt; &lt;select id=&quot;count&quot; resultType=&quot;int&quot;&gt; select count(*) from t_menu; &lt;/select&gt; &lt;insert id=&quot;save&quot; parameterType=&quot;Menu&quot;&gt; insert into t_menu(name,price,flavor,tid) values(#&#123;name&#125;,#&#123;price&#125;,#&#123;flavor&#125;,#&#123;type.id&#125;) &lt;/insert&gt; &lt;select id=&quot;findById&quot; resultMap=&quot;menuMap&quot;&gt; select id mid,name mname,price,flavor,tid from t_menu where id = #&#123;id&#125; &lt;/select&gt; &lt;update id=&quot;update&quot; parameterType=&quot;Menu&quot;&gt; update t_menu set name = #&#123;name&#125;,price = #&#123;price&#125;,flavor = #&#123;flavor&#125;,tid = #&#123;type.id&#125; where id = #&#123;id&#125; &lt;/update&gt; &lt;delete id=&quot;deleteById&quot; parameterType=&quot;long&quot;&gt; delete from t_menu where id = #&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; 启动类添加注解@MapperScan(“com.example.demo.repository”) 这是mybits的功能，在启动时把mapper.xml文件扫描进容器。容器中注入后就会有MenuRepo接口对象 之前的问题shared dev连不上我觉得是在创建项目的时候没有勾选DeveloperTool-DecTools]]></content>
      <categories>
        <category>springboot</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[c语言]]></title>
    <url>%2F2020%2F03%2F24%2Fc%E8%AF%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[字符数组问题 c语言中是没有字符串数组的；而且字符串的本质是字符数组。 strlen() 函数用于计算数组的长度。本质上是计算到’\0’结束。那么当数组中没有存满时计算结果就会出错。则需要在填充数组之后手动加上 A[i]==’\0’;再进行计算。 不能存很多字符串那怎么办呢？输入一个字符串，就遍历这个字符串对应的字符数组。12345char word[90];scanf(&quot;%s&quot;,word);while(word[m]!=&apos;\0&apos;)&#123; m++; &#125; 输入问题scanf输入一串字符不能结束的问题 scanf的结束占位符尚且不知道；而且EOF不能用回车结束 可以换成getchar()，它以回车结束输入12345678910 char A[30];char name;int i=0;while((name= getchar())!=&apos;\n&apos;)&#123; A[i]= name; i++;&#125; scanf输入可以以空格或者回车结束指针传参问题 void reverseAB(int *arr, int a, int b) //注意传数组表示 int countFives(int A[], int num) //注意传数组表示]]></content>
      <categories>
        <category>c语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot踩坑记录]]></title>
    <url>%2F2020%2F03%2F01%2FSpringBoot%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[代码对比完全一致，callback页面404，且控制台不打印 血的教训：所有java包和类放在启动类所在的包里，否则run不运行这些类，但控制台不报错。 报错 BeanFactory 和bean一点关系也没有，原因： mapper映射文件中映射的mapper类的包名少写了一个mapper。而且这是最初没有写错的，是在试着改bug的时候改掉的。 1&lt;mapper namespace=&quot;com.example.demo.mapper.UserMapper&quot;&gt; 一定要先对照代码，特别是xml配置文件！写错没提示。 local网页自动跳转到我印象中没有写的页面toLogin 原本以为是之前运行的项目没关干净，测试了其他项目可以运行，网页跳转没有问题。那么一定是这个项目的代码哪里写错了。 发现并不是controller中的问题，是ShiroConfig类中粘贴代码没删掉拦截和自动跳转toLogin. 整合mybits实现用户登录，连接sql数据库。网页输入时控制台报错 目前正确配置文件的代码：12345678910spring.datasource.driverClassName=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost/springboot_shiro?serverTimezone=UTC //url这里不用写主机ip,不用写3306（3306加上也可以成功运行）spring.datasource.username=root //用户名在sqlyog的客户端里数据库上面写的root@localhost,@前面的就是用户名spring.datasource.password= //密码记在手机里了spring.datasource.type=com.alibaba.druid.pool.DruidDataSourcemybatis.type-aliases-package=com.example.demo.domain 报错 mysql access deny for 找了很久的报错 原因：spring.datasource.url=jdbc:mysql://localhost:3306/test 粘贴代码的时候没有改成自己的数据库名字，改回来就继续报错下面的问题，不过下面的问题都能百度到。 一定要检查代码每个字，在配置文件中写错是没有提示的而且很难发现，昨天的错误就是配置文件中少写了一个包名，报错提示完全和配置文件不沾边。 不知道是不是原因:之前没有添加jdbc的依赖 测试mysql数据库密码：搜索mysql会出来mysql的命令行打开就是要输入password控制台提示：Loading class com.mysql.jdbc.Driver&#39;. This is deprecated. The new driver class iscom.mysql.cj.jdbc.Driver’. 不会影响运行 在总配置文件中修改 报错com.alibaba.druid.pool.DruidDataSource: create connection error druid依赖版本/数据库连接池的包版本需要改成新版本 1234567&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.9&lt;/version&gt;&lt;/dependency&gt;``` 版本修改为： com.alibaba druid 1.1.10 1234- 以后报错还得改成更新版本### 报错The server time zone value &apos;�й���׼ʱ��&apos; is unrecogni- 在MySQL的URL后面加上“?serverTimezone=UTC” ，如下所示： spring.datasource.url=jdbc:mysql://localhost/springboot_shiro?serverTimezone=UTC 123## shiro授权过滤器没用- 键值对集合中只能一个key一个value，具体为什么不行我不知道。 filterMap.put(&quot;/add&quot;, &quot;authc&quot;);//authc必须认证才能访问 filterMap.put(&quot;/update&quot;, &quot;authc&quot;); //授权过滤器，登录过的user在add页面需要拿到add页面的授权才能访问 //在登录后点击添加时，就会进入授权逻辑 filterMap.put(&quot;/add&quot;, &quot;perms[user:add]&quot;);1修改为 filterMap.put(“/test”, “anon”); filterMap.put(“/login”, “anon”); //授权过滤器，登录过的user在add页面需要拿到add页面的授权才能访问 //在登录后点击添加时，就会进入授权逻辑 filterMap.put(“/add”, “perms[user:add]”); filterMap.put(“/*”, “authc”); 123456789101112## 一直标红其他代码没有问题- 删掉，重新自动添加方法就不红了。- 还是爆红，运行了没报错，不报红了## 报错 sql syntax error- sql语句 select xx from 中间没有逗号- 其他的部分大小写- 整数类型写int## 报错 server.port获取不到 ；还没有安全修改办法- 把server.port 改成 server:port @Value(“${server:port}”) private String port;``` 配置文件中 项目名大小写写错了一个 但是就不是配的8080了，变成8080,而且这个页面获取不到端口号 mysql,mybities数据库连接报错 控制台报错If you have database settings to be loaded from a particular profile you may need to activate it (no profiles are curren) 项目启动类上加@SpringBootApplication(exclude={DataSourceAutoConfiguration.class}) 因为menu的数据库配置代码在configServer中，现在还没有连接成功 ，暂时不知道数据库的问题 @Data cannot be resolved to a type 标红 因为没有lombok的包 解决：鼠标移动到标红 选最下面fix project setup 选择lombok的包 这样是在maven仓库中新加入lombok的包，就能在项目中导入包，就好了 报错Unsatisfied dependency expressed through field ‘menuRepo’ 这个是controller类中注入实现接口功能时的报错 检查步奏：1.启动类@MapperScan(“com.xx.xx”)2.pom 3.配置文件[这个不会标红，很多都是这里单词什么的写错了] 还没解决 代码生成器运行报错：Access denied for user ‘root’@’localhost’ (using password: YES) 一定是密码错误 原因：代码生成器中没有改mysql的密码。只改了用户名和数据库名。 Error creating bean with name ‘xxxxxController’https://blog.csdn.net/qq_38701478/article/details/88808628?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase 我的问题是/vueblog/src/main/java/com/example/demo/config/MybatisPlusConfig.java复制过来没有改@MapperScan(“com.example.demo.mapper”) 教训：不要质疑代码生成器给的类的注解。 另外注意：UserService类上不加注解；UserServiceImpl类上加@Service注解]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>bug</tag>
        <tag>解决办法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人工智能入门学习]]></title>
    <url>%2F2020%2F02%2F24%2F%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[CSE112 鸡肋，过时，繁杂，背书只有30% 注意过程md-视图-搜索 或者 大纲-最上面有搜索栏word-开始-最右第一行-查找 ppt-开始-最右第一行-查找； ppt只能找下一个 pdf-搜索-小箭头-打开完整的Arc搜索 lecturesweek1 introduction 机器学习和AI技术的功能 Machine learning and Artificial intelligence will be used to analyze the data and provide a better service to human activities. AI covers a wide range of technologies including: image/speech recognization, language processing, user profiling剖析(data visualization), recommandation system. The boundaries between cloud computing and big data becomes blurred.变模糊 intelligent image captioning智能给图片加文字注解 It is evolving to learn from data. 什么是AI AI is the activity that is related to people’s thinking,such as decision making,problem solving, learning. 电脑语音合成 computer speech synthesis translate text to phonetic form week2 intelligent agent智能体，环境，问题 week AI &amp; strong AIstrong AI: 无意识，无认知能力，用于完成一个具体任务week AI: 有思维，像人 4 research perspectivesacting、thinking humanly: dulicate what human brain doesacting、thinking rationally: 取得最大化好处 intelligent agent 智能体 智能体是什么：一个可以感知并且做出动作的实体 agent= architecture + program 硬件（sensor,actuator）加代码 详细定义：agent is an entity that perceives and act OR is a function from percept to act. 通过感应器sensor感知perceives环境，通过执行器actuator做出动作action，最大化的达成目标 agent rationality:合理性task environment(PEAS)任务环境规范P: performance measure评判标准 - an objective criterion for success of an agent’s behavior 比如最少的能量干最多的事情E: environment 环境中有什么东西 比如固定的面积 不定的分布量distribution unkown 动作确定的deterministicA: actuators动作器 执行的动作 比如 左转右转 suck吮吸 noOpS: sensors感受器 比如 感知到所在位置和目标在的位置environment type环境类型： 1.Fully/Partially observable 传感器在所有时间点都可以获得环境的 完整/部分 状态。2.Single/Muti agent y一个环境中有 一个/多个 智能体。3.Deterministic确定的/Stochastic随机的 环境的一个状态由当前环境和智能体决定。/不能决定4.Episodic片段的/Sequential连续的 智能体的前后动作没有影响/有影响。5.Static/Dynamic 环境不随智能体改变。 /环境随智能体改变。6.Discrete离散的/Continuous连续的 感知和行为都是数量有限且定义明确的。 /数量无限 (最难的环境类型)真实世界的领域一般都是只能部分观察，不确定性，不静止，不连续Partially observable, stochastic, sequential, dynamic, continuous, and multi -agent. 重点：通过不同的环境设计不同的智能体。 agent type 主体（机器人）类型1.Table-Driven agent函数表驱动智能体 在函数表中查看当前感知，以找到最优动作2.Simple Reflex Agent简单反射智能体 Rule-based基于规则的,根据当前环境去匹配规则作出动作3.Model-Based Reflex agent基于模式的反射智能体 有一个外部环境模型Model of world。 感知历史的内部模型(像是有记忆的)，反射出当前无法预测的方面。 可以处理部分可观测的环境。4.Goal-based agent基于目标的智能体 选择通向目标的动作，考虑未来。takes future into account5.Utility-Based agent基于效用的智能体 两条路一条更便宜一条更快，用Utility function来计算效用值a utility value，从而选择更加高效的动作。6.Learning agent学习智能体 不断地修改智能体的决定机制，来提升效绩。 允许在未知环境中使用 学习是这个系统构建的方法。 Supervsied learning监督学习 Unsupervised learning非监督学习 Reinforcement learning强化学习：不断积累数据 ttl2 题目关键词 Turing Test图灵测试：判断是人还是机器。 agent定义，上面也有写。 rational agent定义：one that does the right thing. percept sequence感知序列：Everything that the agent has perceived so far. A simple reflex agent定义 环境和智能体匹配的题(1) Which type of agent is characterized with an internal state of the environment?Model-Based Reflex(2) What is the characterization of a static environment?静态环境特点The environment does not change while an agent is deliberating.(3) What type of environment is the most challenging for agents?Partially observable, stochastic, sequential, dynamic, continuous, and multi -agent.(4) Which type of intelligent agent takes future into account?Goal-based agents.(5) A cleaning agent goes from room to room, making sure not to clean the same room twice. What type of agent is this? And why?Model-based reflex agent, which remembers the past percepts(6) Discuss the important advantages of endowing an agent with learning capabilitiesLearning is essential for unknown environments；Learning is useful as a system construction method；Learning modifies the agent’s decision mechanisms to improve its performance。和上面学习智能体叙述一样。 解决问题 解决问题的考虑stateinitial stateactionsgoal testpath cost 问题求解的种类1.单一状态问题2.无传感器问题3.应急问题4.探索类问题 week3 搜索和prologAbstraction 抽象抽象：忽视无关细节 树搜索 通过搜索算法扩展 后续结点。 通用的树搜索算法结点存储在list，扩展结点，直到找到目标结点 搜索策略（如何选择下一个结点），四个“性质” 1.完整性Completeness:有限时间内总能找到一个解 2.时间复杂性Time complexity:生成的节点数量 3.空间复杂性Space complexity:内存中结点的最大数量 4.最优性Optimality:是否总可以找到最优解 8数码难题 状态：9x9棋盘，8个数字滑块占据一个方块，空格占据最后一个方块 初始状态：任意状态 动作：空格的移动：上下左右 模型转换：空格向左移动=棋子向右移动 目标检测：八个棋子在目标位置 路径代价：路径的步数，每一步为1代价 g(n)=已经移动砖块的次数 h(n)=当前错位砖块的个数 8皇后问题 8x8棋盘上放八个皇后，两两不能在同一行同一列同一斜角线上。 两种解决办法：1.一个一个放上去 2.任意放再调整位置 g(n)=到当前结点的距离 h（n）=到目标的直线距离 无信息搜索Uninformed search strategies无信息搜索1–图的宽度优先搜索算法 Breadth First 算法complete 但 内存expensive算法完整complete:保证算法在有限时间内找到一个解; 需要的时间短不能解决 指数复杂性问题，内存是很大问题。 先找完兄弟节点扩展最浅（上面）的扩展结点，同级扩展结点因为先从最上层判断没有就删除，所以用的队列，先进先出 空间复杂度：O(bm) 空间复杂度=内存中结点的最大数量(上面有提到)=一层b个结点，m层就是mb个 宽度优先搜索是统一成本搜索的一种特殊情况；当所有路径代价相同时，统一成本=宽度优先。 宽度优先搜索是完整的算法complete,但它不是最优optimal. 无信息搜索2–深度优先搜索 Depth first search 内存cheap but 算法incomplete时间长，空间（需要的内存）小 有兄弟结点和子节点时，完全搜索完子节点再回头搜索兄弟节点向下扩展结点，没有找到的话就从内存中删除因为最下面的是新加入判断的，没有就删除，所以用的堆栈，后进先出 空间复杂度：O(b^s bs) 最坏到s层 无信息搜索3–一致代价搜索算法UCS Uniform Cost Search = Dijkstra算法 宽度优先搜索是统一成本搜索的一种特殊情况；当所有路径代价相同时，统一成本=宽度优先。 统一成本搜索是无信息搜索的一种。 (UCS)：扩展的是路径消耗g(n)最小的节点n,用优先队列来实现，对解的路径步数不关心，只关心路径总代价。即使找到目标节点也不会结束，而是再检查新路径是不是要比老路径好，确实好，则丢弃老路径。 启发函数f： f（n）= g（n） Uniform Cost Search是a* 搜索的特例 怎么算长度： 一致代价的长度就等于出发点和某点的可以走通的直线距离（实际线段长度） prolog:描述性语言ttl3题目关键词 the stages of problem solving：1.formulates a goal and a problem. 指定目标和问题2.Search for a sequence of actions that would solve the problem，executes the actions one at a time. 搜索路径序列3.When this is complete, it formulates another goal and starts over.当问题解决目标达成后，制定下一个目标，再重复。 formulate problem制定问题:决定目标、状态、行动 optimal solution最优解： lowest path cost最小代价 好的抽象的properties财产：1.create an approximate, simplified, model建模(近似的简化的)2.retain all important details保留重要细节 状态和搜索结点的区别：state：physical configuration物理配置、布局node： 存储结点信息的数据结构 树搜索和图搜索的区别：扩展状态/ 图搜索是更一般的方法More general approach 宽度优先搜索和深度优先搜索区别Depth-first search always expands the deepest node in the current frontier of the search tree. The search proceeds immediately to the deepest level of the search tree, where the nodes have no successors. As those nodes are expanded, they are dropped from the frontier, so then the search “backs up” to the next deepest node that still has unexplored successors.Breadth-first search is a simple strategy in which the root node is expanded first, then all the successors of the root node are expanded next, then their successors, and so on. In general, all the nodes are expanded at a given depth in the search tree before any nodes at the next level are expanded. 对于BFS，space complexity空间复杂度问题更严重，内存空间需要更多。 BFS: Space complexity; DFS: Time complexity could be of a more serious issue. 食人族问题 和 水壶问题 week4 几个信息搜索算法总结：A* search最优最有效 DFS : 深度优先 BFD : 宽度优先 Depth limited search (DLS) 深度限制搜索 解释： 在进行深度优先搜索时，每条路径上在到达指定的步数后停止此条路径的搜索。 术语： 深度 = d ; 宽度 = b 适用情况： 已知解的最大深度； 解有深度范围 代码表示： if (depth(node) &lt; depth limit) 先判断小于深度限制，才能执行搜索代码。 Iterative deepening search (IDS) 迭代加深搜索 每次从头开始，第一次搜一层，第二次从头开始搜二层，第三次从头开始搜三层就是多次深度限制搜索，每次从头再来。 解释： 当宽度很大和深度未知时，不断的进行(DLS) 深度限制搜索，深度限制从0一直向上增加。 特点：时间换空间Trade off time for memory 用更多的时间，去节约很多内存空间。每次从头搜索时，会重新生成上一次生成过的节点。 迭代深化的深度优先搜索比宽度优先搜索占用更少的存储空间，但其渐近运行速度同样快。 IDS算法完整和最(更)优 时间复杂度: 𝑂(𝑏𝑑)—the same as BFS. 空间复杂度: O(bd). DLS 和 IDS 对比Nodes expanded with depth-limited search: 1+b+b2+b3+…+bd-1+bdNodes expanded with iterative deepening search: (d+1)1+(d)b+(d-1)b2+(d-2)b3+…+(2)bd-1+(1)bd IDS is complete and optimal IDS 算法完整和最优；DLS 和 IDS 改进了基础的宽度优先和深度优先搜索技术 Avoiding repeated states 避免重复状态Do not return to the state you have just come fromDo not create paths with cycles in them (do not create a node the same as any ancestor)Do not generate any state that was ever generated before Heuristic search启发式 h(n) 解释：基于问题考虑，选择最有可能的路径；一致代价搜索USC是当前结点的路径，启发式搜索是计算剩余路径 特点：启发式搜索是信息搜索的核心方法 Greedy search贪婪 比如八滑块问题：直接计算需要调整的滑块个数；或者替换错位滑块需要走的直线距离 启发函数f：f（n）= h（n） 特点：快速；可能找不到解；可能第一步错误；只从当前结点计算，忽略之前的结点 重点：未能远谋，不一定是最优长度（最短路径）； 只看期望长度（走横着竖着的格子，曼哈顿距离）；只选择下一个h最小的结点 Greedy first search greedy first只扩展hn最小的结点，一路走到头。不会比较，也不看gn. 所以，他可能找不到短的路径，叫贪婪搜索 一致代价搜索算法UCS 计算！：fn = gn + 0; 计算所有路径的gn,选择其中最短; (uniform cost就是A* 的hn等于0的情况) A* search A * 是一种典型的启发式搜索，是信息搜索的一种informed search strategy，是best-first search的一种。 计算！：fn = gn + hn；计算所有路径的fn,选择其中最短(走过的路径基本就是最短路径了;其实不是比所有路径，因为没具体到把所有路径都算一遍，只是在看边界节点fn是否小，如果再往下拓展fn比frontier队列里的节点的fn大就会换别的节点) 最优！，最小cost path 解释：结合了一致代价和贪婪搜索；注重于已用的成本和到目标的成本；为了最小化代价minimize the overall cost 启发函数f： f（n）=g（n）+h（n）= 开始到n结点的路径成本 + 从n 到目标的最短的解 = 一致代价+贪婪搜索比如8滑块问题， g(n)是空白滑块移动步数， h(n)是要调整的滑块个数 A* 的机制就导致它会比uniform cost更准确一些，然后走过的路径基本就是最短路径了 曼哈顿距离 h预估距离 某点到终点的 横着走几格，竖着走几格，加起来的距离 可以穿墙 斜边长度表示为直角两边的和a+b;不再用根号表示（虽然有误差，但是如果大家都这么算那么就变得比较好比较） 算横着走几格，竖着走几格，加起来 实际距离 g出发点和某点的可以走通的直线距离 斜着14 横着10，有拐点的要算两条直线和 启发式函数h(n)在A* 中的作用启发式函数可以用来控制A的行为。一种极端情况，如果h(n)是0，则只有g(n)起作用，此时A 算法演变成Dijkstra算法=一致代价搜索，就能保证找到最短路径。 如果h(n)总是比从n移动到目标的代价小（或相等），那么A* 保证能找到一条最短路径。h(n)越小，A* 需要扩展的点越多，运行速度越慢。 如果h(n)正好等于从n移动到目标的代价，那么A* 将只遵循最佳路径而不会扩展到其他任何结点，能够运行地很快。尽管这不可能在所有情况下发生，但你仍可以在某些特 殊情况下让h(n)正好等于实际代价值。只要所给的信息完善，A* 将运行得很完美。 如果h(n)比从n移动到目标的代价高，则A* 不能保证找到一条最短路径，但它可以运行得更快。 另一种极端情况，如果h(n)比g(n)大很多，则只有h(n)起作用，同时A* 算法演变成贪婪最佳优先搜索算法（Greedy Best-First-Search）。 ttl4 关键词智能体 智能体的 environment is accessible：If an agent’s sensory apparatus gives it access to the complete state of the environment如果一个特工的感觉器官能让他进入环境的完整状态， environment effectively accessible：detect all aspects that are relevant to the choice of action. A successor function定义(状态转换函数)：is a description of possible actions, a set of operators. 是对可能操作的描述，是一组运算符。It is a transformation function on a state representation, which converts it into another state。它是状态表示的转换函数，将其转换为另一个状态。后继函数定义了状态之间的可访问性关系。 BFS IDS UCS A IDS对比BFS:迭代深化的深度优先搜索比宽度优先搜索占用更少的存储空间，但其渐近运行速度同样快。 宽度优先搜索是统一成本搜索的一种特殊情况；当所有路径代价相同时，统一成本=宽度优先。 宽度优先搜索是完整的算法complete,但它不是最优optimal. 统一成本搜索是无信息搜索的一种。 A * 是一种典型的启发式搜索，是信息搜索的一种informed search strategy，是best-first search的一种。 解释深化迭代IDS怎么工作 特定的搜索策略已经完成=guaranteed to find a solution when there is one. BFS完成条件：As long as the shallowest goal node is at some finite depth d, breadth-first search will eventually find it after generating all shallower nodes (provided the branching factor b is finite), i.e. guarantee the completeness.只要最浅的目标节点位于某个有限的深度d，广度优先搜索将在生成所有较浅的节点（前提是分支因子b是有限的）之后最终找到它，即保证完整性。 BFS是最优的条件： if the path cost is a nondecreasing function of the depth of the node.路径代价是节点深度的非递减函数。 A* 搜素 A* 搜素和贪婪搜索的区别：Greedy-first search: f (n) = h(n). A* search: f (n) = g(n) + h(n). A* 搜素在什么条件下产生最优解(去年期末):1.h(n) be an admissible heuristic.h（n）是一个可容许的启发式2.consistency (or sometimes monotonicity)一致性（或有时是单调性); monotonicity is required only for applications of A* to graph search. 单调性用于图搜索。 admissible heuristic可容许的启发式什么意思：1.never overestimates the cost to reach the goal.永远不会高估达到目标的成本2.解释：Because g(n) is the actual cost to reach it along the current path, and f (n) = g(n) + h(n), we have as an immediate consequence that f (n) never overestimates the true cost of a solution along the current path through n.因为g（n）是沿着当前路径到达它的实际成本，而f（n）=g（n）+h（n），我们的直接结果是f（n）永远不会高估沿着当前路径通过n的解的实际成本。 选择哪个搜索，路径题过程怎么写 当（a）有一个大的搜索空间，（b）解的深度未知，（c）需要一个最优解，并且（d）有一个一致的可容许启发式算法可用时，首选A* 。 浅层，首选DFS 无限分支，首选IDS 如果结点代价=结点所在层数，BFS,UCS,DIS是最优。 DIS路径分层写：L0 A, L1 ABCD, L2 ABEFCG Greedy (只看h)：和A,UCS一样，每次选结点都是在所有能够扩展出的节点中选直到选完。不是一条通路。而且注意题目上说谁是goal,走到goal就结束。 A图路径题 和一致成本选择扩展点一样。 结点扩展过程怎么写 搜索总结迭代深度搜索一致代价搜索 最优 A搜索 最优 宽度搜索 week5、6 KR 知识表示，Rule-based Systems知识分类1.Facts陈述性知识：Male(x)2.Rules程序性知识/函数：Father(x,y)3.Control Strategy: meta-level元知识(自身表示知识)，super knowledge. 元知识Meta-knowledge is knowledge about knowledge. 元知识是知识本身。For example, knowledge about how an expert system makes decisions would be considered meta-knowledge.例如，关于如何专家系统做出的决策被认为是元知识。 元知识的例子：methods of planning, modelling, tagging, learning and every modification of a domain knowledge.元知识的例子是规划、建模、标记、学习和领域知识的每次修改的方法。 不同知识level1.知识水平knowledge level:描述与模型无关的内容2.逻辑水平logical level:KR模型中表示事实的陈述3.实施水平implementation level:表示知识被编译的方式 六种知识表示方法1.propositional logic命题逻辑2.Rule-based system 规则系统–Expert system3.Semantic Networks语义网络4.Frame5.Bayesian networks贝叶斯网络6.Knowlwdge graph知识图 rule-based system规则系统 形式：condition -! action: if条件 then 动作 知识 = 规则（rule）的集合 Rule-Based System的结构，重要组件(ttl5)：rule的集合，fact的集合，a rule fire. 专家系统，基于规则系统 什么是专家系统：An expert system is a computing system that is capable of expressing and reasoning about some domain of knowledge.专家系统是一个能够表达和推理的计算系统关于某个知识领域。 Rule-Based System的应用例子medical expert system：帮助医生用rule来推断诊断 专家系统优点(用医生专家系统来举例)：1) the knowledge for patient diagnosis;患者诊断的知识2) the diagnosis, i.e. provide prescription;诊断，即提供处方3) knowledge accumulation, i.e. learning new experience from patient cases.知识积累，即从患者案例中学习新经验 Expert system结构为 inference engine推理机器接口引擎，将知识库和数据库中的rule和fact联系起来 knowledge base知识库（规则的集合），规则为if then结构 database数据库，存储fact,对应if部分 explanation facilities解释机制：允许用户查询推理过程，从rule推理得出结论的过程解释 user interface用户接口、界面， 用户和专家系统之间交流通信 inference engine定义：The inference engine carries out the reasoning whereby the expert system reaches a solution. It links the rules given in the knowledge base with the facts provided in the database. 传统程序和专家系统区别很大：Program = algorithm + data；For example, the expert system is often designed to be able to solve problems or provide advice in a specific domain, whereas the general software systems are relatively less domain-driven。专家系统通常被设计成能够解决在一个特定领域中的问题或提供建议，而一般的软件系统是相对较少的领域驱动。 control scheme控制方案-前后链 已知一些规则，用他们去获得新知识(rule的集合)，有前向链接和反向链接两种方法 Forward chaining 前向链接：从事实推到结论。从fact开始，以fact来找需要用到的rule.(Data-driven search)适用情况：所有fact已知，goal的信息困难，一小部分初始状态，但有大量结论。 Backward chaining 后向链从(需证)结论推到前提(事实)。从要查找的结论，来找需要用到的rule.(Goal-driven search)适用情况：需要时获取数据（当数据采集成本很高时），容易形成假设/目标结论（比如医学诊断），少量factprolog使用后向链 二者区别：前向链接从已知事实开始，然后应用推理规则提取更多数据，然后继续向前移动直到到达目标；然后前向链接从目标开始，并使用推理规则确定后向链接满足目标的事实。前向链接称为数据驱动推理技术，后向链接称为目标驱动推理技术。正向链接称为向下搜索方法，而反向链接称为自上而下搜索方法。前向链采用广度优先搜索策略，后向链采用深度优先搜索策略。正向链接可用于规划、设计过程监控、诊断和分类任务，反向链接可用于分类和诊断任务。前向链接可能类似于穷举搜索，而后向链接则试图避免不必要的推理。在正向链接中，知识库中可能存在各种提问问题；在反向链接中，可能存在较少的提问问题。前向链接检查所有规则，因此速度较慢，而后向链接只检查一些必要的规则，因此速度较快。Forward chaining as the name suggests, start from the known facts and move forward by applying inference rules to extract more data, and it continues until it reaches to the goal, whereas backward chaining starts from the goal, move backward by using inference rules to determine the facts that satisfy the goal. The following points are helpful to better understand the difference between to two approaches:Forward chaining is called a data-driven inference technique, whereas backward chaining is called a goal-driven inference technique.Forward chaining is known as the down-up approach, whereas backward chaining is known as a top-down approach.Forward chaining uses breadth-first search strategy, whereas backward chaining uses depth-first search strategy.Forward chaining can be like an exhaustive search, whereas backward chaining tries to avoid the unnecessary path of reasoning.Forward chaining is slow as it checks for all the rules, whereas backward chaining is fast as it checks few required rules only. 规则和问题的特性，pdf中Semantic Networks语义网络 定义： 1.用图表示知识2.结点表示事实/概念，箭头表示概念之间的关系3.继承4.联系link:and/or/not/推导/相等图差不多就那么回事。 ttl5关键词 什么是knowledge: justified true belief.if you believesomething for an unassailable good reason, and if it is actually true, then you know it.正当的真实信念。如果你相信一个无可争辩的好理由，如果它是真的，那么你知道它。 什么类型的知识可以分类: Facts, rules and control strategies. 在人工智能中，我们需要讨论哪些不同层次的知识:Knowledge level, logical level and implementation level. 人工智能中，为什么没有选择自然语言：it is too ambiguous for automated reasoning and without clear semantics.它对于自动推理来说太模糊了，而且没有清晰的语义。 一个合适的KR方案的理想特性是什么：Representational adequacy; Inferential adequacy; Inferential efficiency; Well-definedsyntax &amp; semantics Naturalness.表征充分性；推理充分性；推理效率；定义明确的语法和语义自然。 rule-based system重要组件： A collection of rules; A collection of facts; A rule fires if a fact matches the condition of the rule. 什么是专家系统：An expert system is a computing system that is capable of expressing and reasoning about some domain of knowledge.专家系统是一个能够表达和推理的计算系统关于某个知识领域。 专家系统和一般软件系统的区别：For example, the expert system is often designed to be able to solve problems or provide advice in a specific domain, whereas the general software systems are relatively less domain-driven。专家系统通常被设计成能够解决在一个特定领域中的问题或提供建议，而一般的软件系统是相对较少的领域驱动。 ttl6关键词 什么是专家系统，比如说生产系统：The production system model (one basic expert system type) is based on the idea that humans solve problems by applying their knowledge (expressed as production rules) to a given problem represented by problem-specific information.生产系统模型（一种基本的专家系统类型）是基于这样一种思想，即人类通过将其知识（表示为生产规则）应用于由特定问题信息表示的给定问题来解决问题。 Why is knowledge acquisition often referred to as the ES ‘bottleneck’?为什么知识获取常常被称为ES的“瓶颈”？：Due to the difficulty in useful information extraction/retrieval. There are over a trillion pages of information on the Web, almost all of it in natural language, An agent that wants to do knowledge acquisition needs to understand (at least partially) the ambiguous, messy languages that humans use.因为有用信息的提取/检索困难。网络上有超过一万亿页的信息，几乎都是自然语言的，一个想要获取知识的代理需要理解（至少部分地）人类使用的模糊、混乱的语言。 前后链题：IF green THEN walka) the antecedent前因 of this rule? greenb) the consequent后因 of this rule? walkc) Which part of the rule will be matched against the working memory规则的哪个部分将与工作内存匹配？前因用于向前链接；后因用于向后链接。 Q9前后链推理题，用表格表示推理过程，值得注意的是后链是给出fact A,去找IF B THEN A，然后得到fact B,去找IF C THEN B…都是用结论找IF的fact ES(专家系统)可能犯的错误：Depending on the employment of different conflict resolution strategy, the expert system may make different decision with respect to the same query. However, there could only be one ground truth. This is one of the major challenges for expert system design till nowadays: just like human beings, we can make similar mistakes when there are options to choose. Also similar to human, the success rate for an expert system in decision-making can never be 100% given infinite amount data, i.e. it will eventually make mistake(s) while data increasing.根据使用不同的冲突解决策略，专家系统可能对同一查询做出不同的决策。然而，只有一个基本事实。这是目前专家系统设计面临的主要挑战之一：就像人类一样，在有选择的时候也会犯类似的错误。与人类相似，专家系统在决策中的成功率永远不可能是100%，也就是说，在数据不断增长的情况下，专家系统最终会犯错误。 AI主要问题，怎么管理：1）对于医学专家系统来说，成功诊断率是一回事，获得医患双方的信任是另一个更具挑战性的课题，这基本上甚至与技术无关。2） 如果军用人工智能或半人工智能系统，如无人机失去控制或被恐怖分子控制，潜在的损害可能比人类严重得多。 W7、8 命题逻辑和KR中的应用命题逻辑W8、9 propositional reasoning命题推理等价公式Normal Forms范式定义：逻辑形式正确，语法不同的式子。CNF:conjunctive normal form. CNF只用∧连接，括号中是另外那个符号：(A ⋁ C) ∧ (¬B ⋁ C) 重要的英语单词 disjunction：析取 或 ∨ conjunction：合取 和 ∧ conjunctive normal form.CNF只用∧连接，括号中是另外那个符号：(A ⋁ C) ∧ (¬B ⋁ C) 计算律 真值表 化简不出来立马换成真值表Let P, Q and R be three atomic prepositional assertions. Let X denote (P v Q) → R and Y denote (P → R) v (Q → R). Which one of the following is a tautology? Select one: a. ¬ Y → X b. X → Y c. X ≡ Y d. Y → X B是永真，画不出来立马上真值表！注意不要漏点 propositional language then = only if = → “if Paola is happy, then she paints a picture” = “Paola is happy only if she paints a picture” ​ 都是p→q; ​ “Carlo comes to the party only if Angelo and Bruno do not come” ​ C → ¬A ∧ ¬B if and only if = ↔ “Davide comes to the party if and only if Carlo comes and Angelo doesn’t come” ​ D ↔ (C ∧ ¬A) , but, = ∧ “Carlo comes to the party provided that Davide doesn’t come, but, if Davide comes, then Bruno doesn’t come” (¬D → C) ∧ (D → ¬B) neither A nor B = ¬A ∧ ¬B “Either Aldo is Italian and Bob is English, or neither Aldo is Italian nor Bob is English” (A ∧ B) ∨ (¬A ∧ ¬B) is that = →“A necessary condition for Angelo coming to the party, is that, if Bruno and Carlo aren’t coming, Davide comes”A → (¬B ∧ ¬C → D) 以上所有组合题目“Angelo, Bruno and Carlo come to the party if and only if Davide doesn’t come, but, if neither Angelo nor Bruno come, then Davide comes only if Carlo comes”(A ∧ B ∧ C ↔ ¬D) ∧ (¬A ∧ ¬B → (D → C) ttl8关键词Q8 用inference rules证明，排序 (很长的过程，慢慢分解开) 必考！！Assume that the following sentences are in our Knowledge Base (~A denotes the negation of A):~A~A =&gt; ~B ^ ~C~B =&gt; ~D ^ ~E~C =&gt; D v E v FUsing the inference rules that we studied in class for propositional logic, prove that “F is true”. When you derive F, specify exactly the sequence of inference rules that youused Q10 自然语言翻译成一元谓词与命题连接词 ttl9关键词 单选题Propositional logic uses syntax to stand for statements and:The relationships between statements disjunction：析取 ∨ 只有一个错的，全部的是对的 conjunction：合取 ∧ W9和10ppt一样？？satisfiable可满足的valid/tautologous有效的，还有另外三个可满足的是：there exists at least one interpretation for which the sentence is true.至少一个是真的。 The sentence is satisfied by at least one truth assignment. We say that a sentence is satisfiable if and only if it is valid or contingent. 有效valid/tautologous的是：it is true under all possible interpretations in all possible worlds.所有都为真，都满足。always true另外三个：falsifiable： if and only if it is unsatisfiable or contingent. contingent：有真有假 if and only if When the expression is sometimes true and sometimes false. unsatisfiable/Inconsistent: if and only if it is not satisfied by any truth assignment.用真值表，所有情况都是错的always false If a formula a is a valid then ¬a is unsatisfiable. entailment蕴含KB |= alpha if and only if (KB ⇒ alpha) is validKB |= alpha if and only if (KB ∧¬ alpha) is unsatisfiable KB |= a就是KB →a永真就是KB：¬KB⋁a永真，KB∧¬a永假 NNF：negation normal form 能移进括号里的¬全部移进 例子(¬ A ⋁ B) ∧ ¬ C CNF:conjunctive normal form. CNF 只用∧连接，括号中是另外那个符号：(A ⋁ C) ∧ (¬B ⋁ C) 例子(p ⋁ q) ∧ r ∧ (¬ p ⋁ ¬ r ⋁ s) is in CNF.¬(p ⋁ q) ∧ r ∧ (¬ p ⋁ ¬ r ⋁ s) is not in CNF.(p ⋁ q) ∧ r ∧( p →(¬ r ⋁ s) ) is not in CNF. ttl10转化成CNF格式Q7 ^-Elimination Modus Ponens 还不明白 必看W11 有效的命题推理KR的命题推理CNF=conjunctive normal form形式 A1^A2^…^An Resolution分解用分解的方式来命题推理 定义：分解是命题逻辑与一阶逻辑的证明方法 用法：判断一个公式 前提：我们可以将任意命题逻辑转化为等价的分句形式(clausal form) Resolution in FOL(FOL是谓词逻辑)详细内容：https://www.javatpoint.com/ai-resolution-in-first-order-logic Unification：联合两句同一证明 Resolution： 消解，有效地操作合取范式或子句范式 Clause: Disjunction of literals (an atomic sentence) is called a clause. It is also known as a unit clause.几个literal用∨连接称为子句。它也被称为单元子句 第一步：把英语句子写成FOL(谓词逻辑) 第二步：把FOL转写成CNF形式（换掉→，¬写进括号中，改变量名字保证变量不重复） 第三步：把Λ两边的语句分开，V连接的不变food(Apple) Λ food(vegetables)分解成food(Apple)和food(vegetables) 第四步(存疑)：否定要证明的语句要证明j. likes(John, Peanuts).否定它¬likes(John, Peanuts) 第五步：把以上列出的语句进行两两V连接，¬P ∨ Q 连接 P ∨ R=Q ∨ R（消掉了R） 分句形式(clausal form)literal: p 非p Order of Quantifiers量词顺序量词顺序不一致会改变意思！ Assume P(x,y) is (x + y = 10).1.任意x 存在y P(x,y) domain: real numbers “For all real numbers x there is a real number y such that x + y = 10.” True (y = 10 - x) 存在y 任意x P(x,y) domain: real numbers “There is a real number y such that for all real numbers x, x + y = 10.” FalseSo, 任意x 存在y P(x,y) and 存在y 任意x P(x,y) are not logically equivalent.ttl11把句子翻译成命题逻辑 w12 看到p46First-Order Logic (Predicate Logic)Universal QuantifierExistential QuantifierNested QuantifiersOrder of Quantifiers量词顺序量词顺序不一致会改变意思！ Assume P(x,y) is (x + y = 10).1.任意x 存在y P(x,y) domain: real numbers “For all real numbers x there is a real number y such that x + y = 10.” True (y = 10 - x) 存在y 任意x P(x,y) domain: real numbers “There is a real number y such that for all real numbers x, x + y = 10.” FalseSo, 任意x 存在y P(x,y) and 存在y 任意x P(x,y) are not logically equivalent.ttl12句子和逻辑互相翻译 w13Well-Formed Formula WFF不是所有句子都能代表谓词逻辑 检查表达式是否为WFF的一种方法是试着用英语说出来。如果你能把它翻译成正确的英语句子，那么它就是一个WFF。 WFF的条件： w13 p8 WFF例子 free and boundfree: 没有量词约束 p(x) ∧ q(x) bound:量词约束 ∀x · (p(x) ⇒ q(x)) p(x) ∧ ∃x · q(x)：p(x) free ∃x · q(x)bound ttl13用resolution rule证明prolog语言 W3 pptprolog语言是陈述性语言，用于描述陈述性知识。可以 表示事实与规则 swing-prolog使用 file-consult 之后一堆error不用管 然后打开xxx.pl文件 就加载上了；在里面输入命令就能用了 语句 定义rule:grandparent(X,Z):- parent(X,Y),parent(Y,Z).mother(X,Y):- parent(X,Y), female(X). 运行查询：?- mother(cathy,ian).true.% Who is Lucy’s parent??- parent(X,lucy).X = ian 函数sum2squares(X, Y, Result) :- square(X, X2), square(Y, Y2), Result is X2+Y2. Matching &amp; Backtracking W6MatchMatch:triangle(point(1,1), A, point(2,3)) = triangle(X, point(4,Y), point(2,Z)). match by:一一匹配，匹配成功就运行body,否则找下一个同名函数triangle = trianglepoint(1,1) = XA = point(4,Y)point(2,3) = point(2,Z) The resulting instantiation is:X = point(1,1)A = point(4,Y)Z = 3 BacktrackingProlog从上到下遍历事实/规则，试图找到匹配的规则或事实。但它会跟踪它的目的地，当任何事情失败时，它会返回并重试它证明的最后一个目标，然后在程序的后面用事实/规则找到另一种证明它的方法。 下面是匹配Bird x 是谁，先x=leo,去满足animal和hasFeather,发现不满足，就回溯到让x=tweety…:animal(leo).animal(tweety).animal(percy).animal(peter).hasFeathers(percy).hasFeathers(peter).bird(X) :- animal(X), hasFeathers(X).bird(freddy). ?- bird(B).Matches with head of first rule.Tries to satisfy animal(B).Matches animal(leo).Tries to satisfy hasFeathers(leo).Fails, so backtracks to try animal(B) again.Matches animal(percy).Tries hasFeathers(percy).Succeeds, so bird(B) succeeds/B = percy ;Going back and trying later animal facts (fails for “tweety”):B = peter;And trying later “bird” fact:B = freddy. 离散数学相关条件概率p = (已发生事件 和 未发生事件 同时发生的概率)/ 已发生事件的概率]]></content>
      <categories>
        <category>记忆性学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[操作系统原理]]></title>
    <url>%2F2020%2F02%2F24%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[CSE108 抽象难学80% 期末考，没有选择，全是大题：概念复述和计算概念题40+计算题40+设计题20 lecturesweek1 Introduction. Operating Systems Structures. 操作系统做什么 组织 结构 处理 进程管理 内存管理 长期储存管理 安全和保护 计算环境 开发资源处理系统 open-source operating system quiz:1.Multiprogramming of computer system increases CPU utilization 2.Main memory of computer system is known to be volatile 3.Multiprocessor system have advantage of Increased Throughput 4.Multi-processor systems of computer system has advantage of reliability 5.To start an I/O operation device driver loads appropriate register into is said to be Device Controller 6.Processor is often referred to Central Processing Unit 7.Cache memory is intended to provide memory access Fastest 8.Another type of multiple-CPU system is the Clustered System集群系统 9.The systems which allows only one process execution at a time, are called uniprogramming systems 单程序设计系统 10.What is operating system? b. link to interface the hardware and application programs c. system service provider to the application programs d. collection of programs that manages hardware resources 11.OS is responsible for transferring data to I/O devices 12.Symmetric multiprocessing architecture of computer system uses shared Buses &amp; Memory 13.In a multi-programming environment : the processor executes more than one process at a time 14.Environment for execution of programs is provided by operating system 15.One that is not a type of multiprocessor of computer system is single core week2 Process概念 concept 进程是什么，进程和程序的关系：进程是正在执行的程序，必须按顺序执行一个进程是一个活动的实体 active entity / 一个程序program是一个被动的实体 passive entity.当可执行文件加载进内存的时候，程序就变成进程。 操作系统执行多种程序：批处理系统 batch system – 批处理系统，又名批处理操作系统。批处理是指用户将一批作业提交给操作系统后就不再干预，由操作系统控制它们自动运行。这种采用批量处理作业技术的操作系统称为批处理操作系统。批处理操作系统分为单道批处理系统和多道批处理系统。批处理操作系统不具有交互性，它是为了提高CPU的利用率而提出的一种操作系统。 分时系统 time-shared system – user programs/tasks分时系统是指允许多个用户同时共享计算机资源的操作系统。系统必须通过CPU切换来执行多个任务 内核线程和用户线程用户线程指不需要内核支持而在用户程序中实现的线程，其不依赖于操作系统核心，用户进程利用线程库提供创建、同步、调度和管理线程的函数来控制用户线程。用户线程不需要用户态/核心态切换，速度快，操作系统内核不知道多线程的存在，因此一个线程阻塞将使得整个进程（包括它的所有线程）阻塞。由于这里的处理器时间片分配是以进程为基本单位，所以每个线程执行的时间相对减少为了在操作系统中加入线程支持，采用了在用户空间增加运行库来实现线程，用户线程是不能被操作系统所感知的。内核线程和用户线程都有自己的优势和缺点，一般配合使用 进程控制块PCB process control block 是什么：PCB是一种存储数据的数据结构。又被称作 进程的上下文context。每个进程都是由它自己的PCB控制。它自己的PCB都驻留在主内存中。所有进程的PCB展示在一个链表中。PCB在多程序环境中很重要，捕获同时运行程序的信息。 PCB关联的组件，PCB里存了些什么：进程状态：程序计数器： 指向（在任何）进程中执行的下一条指令的地址。寄存器信息： 与进程相关的各种寄存器调度信息： 是用于设置管理 进程的优先级的。内存管理信息： 分配给进程的内存记账accounting信息： 存储CPU的利用率，进程执行时间，启动的时钟时间，时间限制IO状态信息： 分配给处理器的IO设备，打开文件的列表 特征 调度 scheduling（设置管理 进程的优先级）进程调度器scheduler： 从内存中选择准备执行的进程，将CPU分配给它。1.短期调度器：选择下一个执行的进程并分配CPU2.长期（或job）调度器： 选择哪些放到准备队列中。控制内存中进程的数量。3.中期调度器：程序多了，需要减少的时候。就从内存中删掉程序，存到硬盘上。从硬盘上返回继续执行swapping 调度队列scheduling queues: 1.job队列–系统中所有进程的集合 2.ready队列： 准备，等待着被执行的进程的集合 3.设备对象：等待IO设备的进程的集合 进程大概分为： I0-bound(多IO少计算) ； CPU-bound(多计算少IO) context switch 上下文切换：CPU切换进程通过它。保存旧进程状态，加载新进程状态。 操作 系统必须提供一下机制mechanism:process creation; process termination 进程创造机制： 父进程创造子进程，形成进程树。资源共享选项： 1.父子共享所有资源 2.子共享父资源的一个分支 3.父子不共享资源执行选项： 1.父子同时执行 2. 子结束后父执行 进程终止机制：进程执行最后一条语句，然后操作系统通过系统调用exit()删掉它。父进程可以通过系统调用abort()关掉子进程。 进程间通信 interprocess communication IPC 进程分为：1.独立进程independent： 互不影响 2.合作进程cooperating： 可以互相影响. 进程之间需要交互 可以合作的原因：信息共享、计算加速、模块modularity、方便 共享内存 shared memory一个内存区域region由合作进程共享，可以读写入数据。 例子：复制粘贴，由操作系统加密。两种缓冲器区buffer可以使用：1.无界缓冲区unbounded-buffer：无大小限制 2.有界缓冲区bounded-buffer：有固定大小 消息传递（系统） message passing各个进程之间通过操作系统完成传递。 进程1封装信息（格式化）给OS，OS再把它给进程2。有两个操作：send(); operations(). 直接/间接communication: P-&gt;Q / P-&gt;mailbox-&gt;Q同步/异步communication：blocking/ non-blocking week3 Threadsquiz:1.__ is an entity corresponding to a user job or application that owns resources such as memory and open files.process 2.A process having multiple threads of control implies ___a. it can do more than one task at a time  3.If multiple threads are concurrently searching through a database and one thread returns the result then the remaining threads must be :cancelled 4.Because the kernel thread management is done by the Operating System itself :kernel threads are slower to create than user threads内核线程的创建速度比用户线程慢 5.Termination of the process terminates ___all threads within the process 6.If the kernel is single threaded, then any user level thread performing a blocking system call will:cause the entire process to block even if the other threads are available to run如果内核是单线程的，那么执行阻塞系统调用的任何用户级线程都将： 使整个进程阻塞，即使其他线程可以运行 7.The model in which one kernel thread is mapped to many user-level threads is called ___Many to One model 8.A thread is also called ___Light Weight Process(LWP) 9.A process can be ___both single threaded and multithreaded 一个进程可以单或多线程 10.The register context and stacks of a thread are deallocated when the thread:terminated当线程终止，线程的寄存器上下文和堆栈被释放 11.Multithreading on a multi – CPU machine ___increases concurrency 增加并发性 12.Resource sharing helps:a. share the memory and resources of the process to which the threads belong. b. reduce the address space that a process could potentially use c. an application have several different threads of activity all within the same address spacea、 共享线程所属进程的内存和资源。b、 减少进程可能使用的地址空间c、 一个应用程序有几个不同的活动线程，它们都在同一个地址空间内 13.下面都是对的b. Related kernel level threads can be scheduled on different processors in a multiprocessor systemc. Context switch time is longer for kernel level threads than for user level threadsd. User level threads do not need any hardware support 14.When a web page is loading, and the user presses a button on the browser to stop loading the page :the thread loading the page is cancelled 15.A thread shares its resources (like data section, code section, open files) with ___other threads that belong to the same process week4 Process Synchronization同步quiz:1.Select the correct statements regarding mutex lock to prevent race conditiona process must acquire the lock before entering a critical section;it releases the lock when it exits the critical section 2.Process synchronization can be done on __both hardware and software level 3.Which of the following Multithreading model also allows multiple threads to run in parallel on multiprocessorsOne to One model 4.What state does Thread enter in when it has been created and started?Running 5.A semaphore is a shared integer variable __大于等于0 6.Which of the following Multithreading model has action “creating a user thread requires creating the corresponding kernel thread”.One to One model 7.A Race condition refers to _____A situation where several processes access and manipulate the same data concurrently 8.What is valid point about threadThread are subdivision of Process. One or more Threads runs in the context of process. Threads can execute any part of process. And same part of process can be executed by multiple Threads 9.Peterson’s solution is restricted to ____ processes that alternate execution between their critical sections and remainder sections两个 10.Mutual exclusion can be provided by the __both mutex locks and binary semaphores 11.We use the mutex lock to protect critical regions and thus prevent race conditions. The term mutex is short formutual exclusion 12.If a process is executing in its critical section, then no other processes can be executing in their critical section. This condition is called?mutual exclusion 13.A non-preemptive kernel is essentially free from race conditions对的 14.User threadsare supported above the kernel and are managed without kernel support 15.Thread shares with other threads belonging to the same process itscode section and data section 16.Which of the following condition stands true for Mutual Exclusion？If process Pi is executing in its critical section, then no other processes can be executing in their critical sections 17.Which of the following condition stands true for Mutual Exclusion?Which of the following condition stands true for Mutual Exclusion? 18.Which one of the following is a synchronization tool?semaphore 19.Each process has a segment of code, called a ____, in which the process may be changing common variables, updating a table, writing a file, and so oncritical section 20.Kernel level threads are not needed in which of the following situationsTo make thread switching and scheduling fast and efficient week5 CPU Schedulingweek6 CPU Scheduling, Deadlocksweek8 考试week9 Memoryexercise9.2 Who founded the GNU project?Richard Stallman What programming language did Linus Torvalds use to write his Linux kernel?C In which year was the Turing Award (the highest distinction in the IT field) awarded to creators of UNIX and C?1983 Which key do you use to quit the program xmas in WebLinux? You have typed nano in WebLinux, and launched the nano text editor. Now, which of the following should be used to get help inside nano An operating system is the link between:programmer and hardware Why did Linus Torvalds create Linux?because he was frustrated with the proprietary licenses Which of these lines is the command prompt on WebLinux? Which operating system is not a UNIX derivative?Windows What is the pioneering project behind the UNIX operating systemMAC What happens if you run the htop command and then press the ctrl + c keys?this leaves htop and returns to the command prompt Which option of the du command is not available on WebLinux?(du is a command that means Disk Usage) Who are the creators of the UNIX operating system?Dennis Ritchie and Ken Thompson Who did the creators of UNIX work for?Bell Labs With whom did Dennis Ritchie write the book “The C Programming Language”?Brian Kernighan week10 Storage, IOweek11 Virtual Machines, Distributed Systemsweekk12 Protection, Securityweek13 Compilerweek14 考试大三上CSE203 决策计算与语言 10+10ass 80期末 全是小问答题 CSE205 网络 40ass 15考试 45期末 全是小问答题CSE207 软件工程 10+10ass 80期末选修 CSE209 计算机图形学 15+15courwork 70期末 CSE201 数据库设计（非关系数据库，解决数据库并发性）10+10ass 80期末 大三下CSE214 以人为中心的计算 交互界面 GUI 10+15+15report 60期末CSE204 复杂算法 5+5+10ass 80期末CSE210 java进阶 50ass 50期末CSE208 小组工程 100作业 网上资源了解操作系统和作用 作用：1、控制硬件 2、把调用硬件的办法封装成系统调用，供人通过应用程序间接的操作硬件 服务器操作系统：linux(安全稳定免费),windows server 移动设备操作系统：ios,安卓（linux衍生出来的） 虚拟机 是一个软件，可以用来安装一个新的操作系统，如果玩坏了，删掉重新装就好了，不会对现有系统造成任何影响和破坏。 内核如内存管理，多任务，IO的输入输出处理]]></content>
      <categories>
        <category>记忆性学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习]]></title>
    <url>%2F2020%2F02%2F23%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[CSE104 数据结构，介绍基本的数据结构和性质和用法。20% 不是考试，两个assignment写java代码，一定要尽可能的细致，对于每一个可能的样本输入情况都要考虑周全。80% 期末考试，四分之三25道选择题和一道数据结构的大题，大题每年相似度很高。背书课：lecture slides, Q&amp;As, in-class &amp; take-home exercises, assignments 认识数据结构：用来组织和存储数据的集合分类 1.逻辑结构分类: 按照数据元素之间的关系分类 抽象 集合结构：元素之间没有关系 线性结构 ：元素之间一对一的关系，如链表 树形结构：一对多的关系， 图形结构：多对多的关系 2.物理结构分类： 逻辑结构真正在计算机上存储的方式 顺序结构： 连续的内存地址带着索引查找容易 用索引，插入删除难 链式结构： 内存单元可以是不连续的，数据单元之间用指针指向链接查找难 用遍历， 插入删除容易 链表队列队列实现先进先出，用单链表实现进队出队 by node的添加删除改变连接 优先队列(priority queue) 可以将优先级队列想象为已修改的队列，但是当一个人从队列中获取下一个元素时，将首先检索优先级最高的元素。 最小优先队列(min priority queue)中,查找操作用来搜索优先权最小的元素,删除操作用来删除该元素;对于最大优先队列(max priority queue),查找操作用来搜索优先权最大的元素,删除操作用来删除该元素.优先权队列中的元素可以有相同的优先权,查找与删除操作可根据任意优先权进行. 通常用堆实现 优先队列插入和删除元素的复杂度都是O(log2n)，所以很快 异常图论树树的定义 树是n个有限结点组成的一个具有层次关系的集合 术语：1.结点的度：结点下面一排上有几个子节点2.叶/终端结点： 无子节点的节点3.节点的层次：节点在第几排4.树的度：树的度=节点的度的最大值（子节点最多的节点的度）5.森林：去掉根节点6.子节点：A的直接前驱是B，A是B的子节点7.父节点：A的直接前驱是B，B是A的父/双亲节点8.双亲节点：两个节点的父节点相同 二叉树 二叉树中每个节点最多两个子节点；两个分叉 满二叉树： 每一层的节点数达到最大值（每个节点都有两个子节点） 完全二叉树： 每一层结点放满再放下一层；也就是说叶节点只会出现在最后一层或次下层。 用链表实现 二叉查找树 结点Node类 1234567891011121314151617public class Node&lt;Key,Value&gt; &#123; //存储键 public Key key; //用键找值 private Value value; public Node left; public Node right; public Node(Key key, Value value, Node left, Node right) &#123; this.key = key; this.value = value; this.left = left; this.right = right; &#125;&#125; 二叉树类：添加结点；以键查找结点；以键删除结点；查找二叉树中最小键；查找二叉树中最大键 [特点] 1.所有的方法都有同名重载方法：前面的是传入根节点的入口函数，后面是传入子节点的会使用递归的函数。 子树=结点下面所有结点123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166public class BinaryTree&lt;Key extends Comparable&lt;Key&gt;, Value &gt; &#123; //以后要用键来排序 //记录根节点 private Node root; //记录树中元素个数 private int N; //内部类 private class Node&#123; private Key key; private Value value; private Node left; //左节点 private Node right;//右节点 public Node(Key key, Value value, Node left, Node right) &#123; this.key = key; this.value = value; this.left = left; this.right = right; &#125; &#125; // 获取树中元素的个数 public int size()&#123; return N; &#125; //向树中添加元素键值对,第一次添加根节点 public void put(Key key, Value value)&#123; root = put(root, key, value); //添加根节点，返回赋值给树 根节点;此时x=null &#125; //向指定的子树x添加键值对，并且返回添加元素后的新树 public Node put(Node x,Key key, Value value)&#123; //1.如果x结点的子树为空,把添加的键值对作为x节点的子节点 if(x == null)&#123; N++; //节点个数+1 return new Node(key, value, null , null); //无左右子节点 &#125; //2.如果x节点的子树不为空 //2.1比较x结点的键和添加的key大小 //2.1.1如果key &lt; x结点的键，则继续找x结点的左子树 //2.1.2如果key &gt; x结点的键，则继续找x结点的右子树 //2.1.3如果key = x节点的键，则用添加的value替换x节点的原值. int cmp = key.compareTo(x.key); if(cmp&lt;0)&#123; //2.1.1 //这里是从x的左子节点下面插入键值对；完毕后将新的子树返回给x的左子节点 x.left = put(x.left, key, value); //递归调用只想它干了什么;这里会一直向下找直到找到子树为null时，创建新节点 &#125;else if(cmp&gt;0)&#123; //2.1.2 //这里是从x的右子节点下面插入键值对；完毕后将新的子树返回给x的右子节点 x.right = put(x.right, key, value); &#125;else&#123; //2.1.3 x.value = value; &#125; return x; //返回更新后的节点x信息 &#125; //用键找值 public Value get(Key key)&#123; return get(root, key);// 从根节点开始找 &#125; //从指定子树x中，用键找值 public Value get(Node x, Key key)&#123; //1.x树为null,没有找到 返回null就行 if(x == null)&#123; return null; &#125; //2.x不为null ,就要进行x树下面的键比较 （和上面添加方法的代码结构一样） int cmp = key.compareTo(x.key); if(cmp&lt;0)&#123; //2.1.1 键小与节点找左子树 return get(x.left, key); //这里是不仅要找，然后找了之后要返回找到的子树结点 &#125;else if(cmp&gt;0)&#123; //2.1.2 键大找右子树 return get(x.right, key); &#125;else&#123; //2.1.3 相等就找到了，返回键对应的值 return(x.value); &#125; &#125; //删除键值对结点。这是一个比较麻烦的操作，删除一个之后，要找一个结点来替换删除的节点 //因为左子树都小于右子树，新节点需要比左子树大，比右子树小。所以在右子树中找最左的节点（右子树中最小的节点） public void delete(Key key)&#123; delete(root, key); //入口，先从根节点开始判断删不删 &#125; //删除指定节点树x的键值对，返回新子树 public Node delete(Node x, Key key)&#123; //1.x树为null 安全检查 if(x ==null)&#123; return null; &#125; //2.x树不为null,就要进行x树下面的键比较 （和上面添加方法的代码结构一样） int cmp = key.compareTo(x.key); if(cmp&lt;0)&#123; //2.1键小找左子树,只是找相同的键 没有删 x.left = delete(x.left, key); //一直沿着左向下找 &#125;else if(cmp&gt;0)&#123; //2.2键大找右子树 x.right = delete(x.right, key); //一直沿着右向下找 &#125;else&#123; //2.3如果key = x结点的键，做真正的删除动作，删除x结点 N --; //元素个数-1,只要到了这一步先减个数 //我们要用右子树的最小结点替换x //1.如果x结点没有右子树,只需要让x的左子树成为x，这样是顺次，因为上一排的一定比下一排的键大 if(x.right == null)&#123; return x.left; &#125; //2.如果x结点没有左子树,只需要让x的右子树成为x ,这样是顺次，因为上一排的一定比下一排的键大 if(x.left == null)&#123; return x.right; &#125; //3.左右子树都不为空，找右子树的最小结点：找x右子树 左子树 左子树。。。一直到左子树的最后一个 Node minNode = x.right; //找到x右子树 while(minNode.left != null)&#123; //如果还有左子树的话，就还没有到左边的最后一个 minNode = minNode.left; // 找左子树 &#125; //删除最小结点：x右子树的左子树最后一个 Node n = x.right; while(n.left != null)&#123; if(n.left.left == null)&#123; //这时候n结点是左边倒数第二个结点，那么n.left就是最后一个结点，删除它 n.left = null; &#125;else&#123;//n结点没有到左边倒数第二个结点时，让n向下走一位 n = n.left; &#125; &#125; // 用最小结点minNode替换x: minNode连接左右结点和父结点 minNode.left = x.left; minNode.right = x.right; x = minNode; //绑定父结点，因为是递归调用。我也不懂记住就完了 //2.3else&#123;&#125;结束 &#125; return x; &#125; //查找整个树中最小的键 public Key min()&#123; return min(root).key; &#125; //找指定子树x中最小键所在的节点 = x子树的最左的那个节点 private Node min(Node x)&#123; if(x.left != null)&#123; return min(x.left); //返回更新x结点 &#125;else&#123; return x; &#125; &#125; //查找整个树中最大的键 public Key max()&#123; return max(root).key; &#125; //查找指定子树x中最大键的结点:最右边 private Node max(Node x)&#123; if(x.right != null)&#123; return max(x.right); &#125;else&#123; return x; &#125; &#125; &#125; 二叉树的基础遍历 - 深度优先 前中后顺序是指根节点放进队列的顺序 深度遍历的全用递归 算法特点在https://lucifinil-x.github.io/2020/02/24/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/#more 前序遍历 步奏： 1.把当前节点key放进队列 2.找到当前节点的左子树，不为空，递归遍历左子树 3.找到当前节点的左子树，不为空，递归遍历右子树 顺序特点：一层一层的来。先加根节点，再加下一层左根节点，再加下一层右根节点。遍历以上步奏 在BinaryTree类中添加代码 123456789101112131415161718192021222324252627282930//前序遍历：获取整个树中的所有的键,存在队列keys中 Ergodic：遍历 public Queue&lt;Key&gt; preErgodic()&#123; Queue&lt;Key&gt; keys = new Queue&lt;&gt;(); preErgodic(root, keys); return keys; &#125; //获取指定树x的所有键，并放到keys队列中。 //前序遍历就是先从左树开始向下，先把左子树的键放在队列再把右子树的键放在队列。 //因为是递归完成，所以只需要考虑一个二叉树的小分支 public void preErgodic(Node x, Queue&lt;Key&gt; keys)&#123; //x可能为null，代表的子树为空，直接返回 if(x == null)&#123; return; &#125; //把x结点的键放入队列keys keys.enqueue(x.key); //递归遍历x的左子树 //递归之前先判断有没有左子树 if(x.left !=null)&#123; preErgodic(x.left, keys); &#125; //递归遍历x的右子树 //递归之前先判断有没有右子树 if(x.right !=null)&#123; preErgodic(x.right, keys); &#125; &#125; 中序遍历 - 比较重要 步奏： 1.找到当前节点的左子树，如果不为空，递归遍历左子树 2.把当前节点key放进队列中 3.找到当前节点的右子树，如果不为空，递归遍历左子树 顺序特点： 键从小到大排列。 先加最下面最左边（最小键），再右边最小键，再加节点。 1234567891011121314151617181920212223242526272829//中序遍历 public Queue&lt;Key&gt; midErgodic()&#123; Queue&lt;Key&gt; keys = new Queue&lt;&gt;(); midErgodic(root, keys); return keys; &#125; public void midErgodic(Node x, Queue&lt;Key&gt; keys)&#123; //x可能为null，代表的子树为空，直接返回 if(x == null)&#123; return; &#125; //递归遍历x的左子树 //递归之前先判断有没有左子树 if(x.left !=null)&#123; midErgodic(x.left, keys); &#125; //把x结点的键放入队列keys keys.enqueue(x.key); //递归遍历x的右子树 //递归之前先判断有没有右子树 if(x.right !=null)&#123; midErgodic(x.right, keys); &#125; &#125; 后序遍历 步奏： 1.找到当前节点的左子树，如果不为空，递归遍历左子树 2.找到当前节点的右子树，如果不为空，递归遍历左子树 3.把当前节点key放进队列中 1234567891011121314151617181920212223242526272829//后序遍历 public Queue&lt;Key&gt; afterErgodic()&#123; Queue&lt;Key&gt; keys = new Queue&lt;&gt;(); afterErgodic(root, keys); return keys; &#125; public void afterErgodic(Node x, Queue&lt;Key&gt; keys)&#123; //x可能为null，代表的子树为空，直接返回 if(x == null)&#123; return; &#125; //递归遍历x的左子树 //递归之前先判断有没有左子树 if(x.left !=null)&#123; afterErgodic(x.left, keys); &#125; //递归遍历x的右子树 //递归之前先判断有没有右子树 if(x.right !=null)&#123; afterErgodic(x.right, keys); &#125; //把x结点的键放入队列keys keys.enqueue(x.key); &#125; 二叉树的高级遍历 - 层序遍历 - 广度优先 步奏：1.定义两个队列，分别存储树中的键和树中的结点2.结点队列加入根节点3.while循环（当结点队列不为空）： 从结点队列中取出一个结点，将这个结点的key加入键队列； 如果当前结点的左子结点不为空，把左子结点放进结点队列；如果当前结点的右子结点不为空，把右子结点放进结点队列 顺序特点：每一层从左到右 1234567891011121314151617181920212223//层序遍历，所有键 public Queue&lt;Key&gt; layerErgodic() throws InterruptedException&#123; //定义两个队列，分别存储树中的键和树中的结点 Queue&lt;Key&gt; keys = new Queue&lt;&gt;(); Queue&lt;Node&gt; nodes = new Queue&lt;&gt;(); //先放根节点 nodes.enqueue(root); //循环，结束条件为队列中没有元素 while(! nodes.isEmpty())&#123; //从队列中取出一个结点 Node n = nodes.dequeue(); keys.enqueue(n.key); //有无左子 if(n.left != null)&#123; nodes.enqueue(n.left); &#125; //有无右子 if(n.right != null)&#123; nodes.enqueue(n.right); &#125; &#125; return keys; &#125; 二叉树的最大深度问题 - 树有几层 深度遍历,关于递归调用中 变量的初始化在递归调用之前，每次都是递归调用时候停顿，所以每次返回值是递归调用下面的ruturn值，所以不会再执行初始化的赋值。1234567891011121314151617181920212223242526//获取整个树的最大深度 - 几层 public int maxDepth()&#123; return maxDepth(root); &#125; public int maxDepth(Node x)&#123; //安全 if(x == null)&#123; return 0; &#125; int max = 0; int maxLeft = 0; int maxRight = 0; //计算x结点左子树最大深度 if(x.left != null)&#123; maxLeft = maxDepth(x.left); &#125; //计算x结点左子树最大深度 if(x.right != null)&#123; maxRight = maxDepth(x.right); &#125; //取上面两个中大的值+1 max = maxLeft&gt;maxRight ? maxLeft+1 : maxRight+1; return max; &#125; 排序算法的消费贪婪算法的lecturesL1 abstraction Huffman编码https://blog.csdn.net/qinglongzhan/article/details/80983492 encapsulation 空间效率 时间效率 静态数据结构：创建的时候就固定了大小/内存空间，如:数组不会内存分配溢出，不能添加空间。必须保证有足够大的容量，可能装不下，可能浪费空间时间效率好 动态数据结构：在运行中可以删减大小/内存空间，如:集合、链表不需要知道具体大小，合理运用内存空间，添加内存会浪费时间空间效率好 L2 使用java 集合库 线性collection 层次collection 有哪些 有哪些库： util(集合的，数组的) io swing/awt Collection子类接口：List 有序集合 子类：ArrayList LinkedList vectorSet 无序无重复集合 子类： HashSet TreeSetQueue 有序集合 队列尾添加，队列头出Map 键值对 子类： HashMap TreeMap 接口特征，怎么样使用接口 parameterised typr泛型 ArrayList 的方法： 增删改查和属性 都是在本子上有的 L3 使用集合Collection 和list 和 迭代器 和泛型L4 Bag? Set Stack MapL5 使用Map, 队列和优先队列]]></content>
      <categories>
        <category>记忆性学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[算法学习]]></title>
    <url>%2F2020%2F02%2F23%2F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[CSE102 算法基础，介绍基础排序算法、查询算法、图论、p与np问题、算法思想（分治、动规、贪心）。期末全选择 lecturesweek1 算法分析，数学归纳法 什么是算法algorithem: 根据一定的条件，对数据进行计算，得到需要的结果；程序=input+algorithem+output 算法分析：对于一个算法，我们首要关注的是它的时间复杂度，其次是空间复杂度，以及输出是否为最优或是否接近最优。 二分查找的步奏 算法分析：1、正确性 2、时间复杂度 3、空间复杂度（需要的内存空间） 4、算法优化 数学归纳法Induction: 他是一个分析技术,只能用于自然数。步奏： 1、Base case: 证k=0时，it is true. 2、Induction step: 设it is true for k=n. 3. 证it is true for k=n+1. week2 伪代码写法 程序=数据结构+算法 计算x的n次方：算法：1、set变量p=1 2、执行n次p=p * x 3、输出结果p伪代码： p=1; for i=1 to n do p=p* x; output p 伪代码写法：1、if else: 12345if ... then abs=aelse abs=-aoutput abs 2、 for loop: 1234567input nsum=0for i=1 to n dobegin sum=sum+iendoutput sum 3、 while loop: 123456789input nsum=0i=1while i&lt;=n dobegin sum=sum+i i=i+1endoutput sum 4、repeat until（do while） 123456sum=0repeat ask for a number sum=sum+numberuntil (user wants to stop)output sum 伪代码练习，一题三解 n个数中找最小数：比较次数 n-1. (三个人握手两次) week3思想Divide and Conquer 分治思想把难以解决的大问题分解成几个子问题，找到求出这几个子问题的解法后，再找到合适的方法，把它们组合成求整个问题的解法。 分治能解决的问题的特征： 问题规模小到一定程度就能容易解决。 问题可以分解为若干个规模较小的相同问题。 子问题的解可以合并到该问题的解。 子问题相互独立。【注】满足1.2.条，不满足3.可以考虑贪心算法或动态规划。 不满足4.用动态规划。 分治法基本步奏： 12345678divide and conquer(p) 递归问题p&#123; if(|p|&lt;= n0) adhoc(p); //问题的规模小到一定程度，直接求解。 divide p into smaller subinstances p1,p2..pk; //分解问题 for(i=1; i&lt;=k;i++) //循环遍历每个子问题，递归调用解决子问题 &#123;yi = divide and conquer(pi);&#125; return merge(y1,y2..yk); //把子问题的解合并为原问题的解&#125; 时间复杂度通用公式：T(n) = 2T(n/2) + 常数n2T(n/2)是分， 常数n是合并算出来是： T(n) = O(nlogn) 动态规划 DP问题 dynamic programming the idea of dynamic programming The basic idea of dynamic programming is to use a table to store the solutions of solved subproblems*. If you face a subproblem again, you just need to take the solution in the table without having to solve it again. Therefore, the algorithms designed by dynamic programming are very effective.*动态规划的基本思想是用一个表来存储求解子问题的解。如果您再次面临子问题，您只需将解决方案放入表中，而不必再次解决它。因此，用动态规划方法设计的算法是非常有效的。(不会像递归重复计算，速度很快) 用最少的硬币拼出27块钱问题 组成部分/步奏 1.最后一步(最优策略中使用的最后一枚银币是ak) 2.化成子问题(最少的硬币拼出更小的面值27-ak) 转移方程-重点 f[x]=min{f[x-1]+1,f[x-5]+1,f[x-7]+1} 初始条件和边界情况 f[0]=0,如果不能拼出Y，f[Y]=正无穷 计算顺序f[0],f[1],f[2]…f[27] 12345678910111213141516171819202122232425//返回几个硬币public int coinChange(int [] A, int M)//A=&#123;2,5,7&#125; //M=27&#123; int [] f = new int [M+1]; //要用到f[0]到f[27] 所以开一个[M+1]的数组 int n = A.length;//number of kind of coins f[0]=0;//initialization int i,j; for(i=1;i&lt;=M;i++)&#123;//1到27 f[0],f[1],f[2]...f[27] f[i] = Integer.MAX_VALUE;//先赋值无穷大，有情况比他好就更改 //last coin A[j] ,f[x]=min&#123;f[x-1]+1,f[x-5]+1,f[x-7]+1&#125; for(j=0;j&lt;n;j++)&#123; if(i&gt;=A[i] &amp;&amp; f[i-A[j]] != Integer.MAX_VALUE)&#123; //这个条件很重要，i大于硬币面额时才有可能拼的出来 f[i] = Math.min( f[i-A[j]] +1 , f[i]) &#125; &#125; &#125; if(f[M] == Integer.MAX_VALUE)&#123; f[M]=-1; &#125; return f[M];&#125; LCS 最长相同子串动态规划给出了递归计算公式，矩阵表格方便记录计算过程和结果。若左边和上面的字符相同，此格子数字=左上角斜着格子+1；不同，此格子数字=max(左边格子，上面格子) Alignment PSA算法 求the optimal global alignment of 两个字符串F(i,j)= max{c1,c2,c3} 算下面三个c,取最大值 C1=F(i-1,j-1) + s(xi, yj )=左上角斜着格子 + s给出矩阵字符对应数 C2=F(i,j-1)+d = 上面格子 + penalty值（会给出） C3=F(i-1,j) +d = 左边格子 + penalty值（会给出） Complexity 复杂度 分析算法的时间复杂度分析 关心核心计算操作次数和输入规模n的关系： 函数函数图像比较结论：1.随着输入规模n的增大，和n的最高次项相乘的常数可以忽略2.n的次方多，随着n变大，结果增长会特别快3.增长函数： n^3 &gt; n^2 &gt; ln(n) &gt; log(n) 这个底数多少趋势都差不多&gt; 1 n的最高次幂越小，算法效率越高 算法的空间复杂度分析 基本数据类型内存占用 (字节byte)byte 1 ,short 2, int 4, long 8, float 4, double 8, boolean 1, char 2 计算机访问内存方式都是一次一个字节 java的对象占用内存：1.一个引用变量占8byte Date date = new Date();中的date2.创建的一个对象占用的内存= 对象内部信息内存 + 对象本身头信息16byte3.如果对象一共占的内存不是8的倍数，那么会自动扩充到8的倍数4.数组对象占用 = 16头信息 + 4长度 + 4 * n个填充 一般java都是做服务器的，内存挺大，这些小的都不需要估算。一般对于算法都是分析时间复杂度 时间复杂度 P/NP/NPC 复杂度分为两个级别：他们后者的复杂度无论如何都远远大于前者 1.多项式级的复杂度 P: 它的规模n出现在底数的位置，如O(1),O(log(n)),O(n^a)等。 ​ 2.非多项式级的复杂度 NP： 它的规模n是指数级别，如O(a^n)和O(n!)型复杂度，它是非多项式级的，其复杂度计算机往往不能承受。 P问题一个问题可以找到一个能在多项式的时间里解决它的算法 NP问题NP问题是指可以在多项式的时间里验证一个解(不要求找出解)。NP问题的另一个定义是，可以在多项式的时间里猜出一个解的问题。但是NP问题在多项式时间内找不到解。比如只要我RP好，猜得准，我一定能在多项式的时间里解决这个问题。我猜到的方案总是最优的，不满足题意的方案也不会来骗我去选它。这就是NP问题。当然有不是NP问题的问题，即你猜到了解但是没用，因为你不能在多项式的时间里去验证它。 Hamilton回路问题根本不可能找到一个正确的算法来解决。这称之为“不可解问题”(Undecidable Decision Problem)。 P≠NP，因为NPC（NP-完全问题）问题的存在 约化 Reducibility ：A问题 约化 B问题 = 解决A的算法虽然简单、复杂度低但解决范围小，解决B的算法虽然难、复杂度高但解决范围广 = B的算法能够代替A的算法 来解决问题 = 可以用问题B的解法解决问题A 约化具有一项重要的性质：约化具有传递性。如果问题A可约化为问题B，问题B可约化为问题C，则问题A一定可约化为问题C。 NPC问题NPC问题满足条件：1.它得是一个NP问题 2.所有的NP问题都可以约化到它 既然所有的NP问题都能约化成NPC问题，那么只要任意一个NPC问题找到了一个多项式的算法，那么所有的NP问题都能用这个算法解决了，NP也就等于P 了。因此，给NPC找一个多项式算法太不可思议了。因此，前文才说，“正是NPC问题的存在，使人们相信P≠NP”。我们可以就此直观地理解，NPC问题目前没有多项式的有效算法，只能用指数级甚至阶乘级复杂度的搜索。 NP-Hard问题满足条件：所有的NP问题都可以约化到它，但不一定是个NP问题。 NP-Hard问题同样难以找到多项式的算法。即使NPC问题发现了多项式级的算法，NP-Hard问题有可能仍然无法得到多项式级的算法。 Efficiency追求两个目的：1、花最少的时间完成需求 2、占用最少的内存空间完成需求 Big-O 大O标记法–算法时间复杂度表示方法 时间空间通用 执行次数–大O表示3次– O(1)n+3次–O(n)2n^2+2次–O(n^2) 最高次项相乘的常数可以忽略2n^2+2n+2次–O(n^2) 常见的大O次数 从低到高 常数阶：O(1) 对数阶：O(logn)比如 2^x =100, x=log100 底数忽略 单次循环体 线性阶：O(n) 循环套循环 平方阶：O（n^2） 循环套循环套循环 立方阶：O(n^3) 指数方：O(2^n) 阶乘：O(n!) ？网上的 指worse-case下的时间复杂度。比如f(n)=13n^3+7nlogn的复杂度是O(n^3)，或者O(n^k)（k&gt;=3） Ω(n)和Θ(n)：前者是best-case下的时间复杂度。比如，f(n)=13n^3+7nlogn的复杂度是Ω(n^3)，或者Ω(n^2)，Ω(n)，Ω(1)等；后者是average-case下的时间复杂度，是O标记法与Ω标记法的结合：比如，f(n)=13n^3+7nlogn的复杂度是Θ(n^3)。 Sorting 排序实现comparable接口的对象 实际上比较常见的是对对象进行排序，比如对商品对象进行价格排序。那么在这些对象的类中就要提供自定义的排序规则，通过实现comparable接口，重写compareTo完成。我们排序的对象就是实现了Comparable接口的对象12345678910111213141516171819Studnet implements Comparable&lt;Student&gt;: public int compareTo(Student o) &#123; return this.getAge()-o.getAge(); &#125;Test:Comparable c =getmax(s1,s2); //c不是student对象，是comparable对象,不能用student的方法System.out.println(c); public static Comparable getmax(Comparable a,Comparable b)&#123; //这个是为了拿到对象 int result = a.compareTo(b); if(result&gt;0)&#123; return a; &#125; else &#123; return b; &#125; &#125; Selection/Bubble/insertion 选择排序/冒泡排序/插入排序这三个排序都很相似，时间复杂度都是 O(n^2); 适用于元素少的排序 Bubble冒泡排序API设计： 12345678910111213141516171819202122232425public class 冒泡排序 &#123; public static void sort(Comparable [] a)&#123; for(int i= a.length-1; i&gt;0; i--)&#123; for(int j=0; j&lt;i;j++)&#123; //每层递减 if(greater(a[j], a[j+1]))//如果前比后大就交换 &#123; exchange(a, j, j+1); &#125; &#125; &#125; &#125; private static boolean greater(Comparable a, Comparable b)&#123; return a.compareTo(b)&gt;0; &#125; private static void exchange(Comparable [] a, int i, int j)&#123; Comparable temp; temp = a[i]; a[i]= a[j]; a[j] = temp; &#125; &#125; 测试类： 12345public static void main(String[] args) &#123; Integer [] arr=&#123;4,5,6,3,2,1,2&#125;;//Integer这个包装类就有实现Comparable接口 冒泡排序.sort(arr);//要传实现了Comparable接口的对象 System.out.println(Arrays.toString(arr)); &#125; 算法分析：1.最坏情况为逆序：{6,5,4,3,2,1}2.核心代码为sort循环中的比较和交换3.比较次数为：n-1 + n-2 + …. + 1 = n^2/2 - n/2两两比较，次数逐层递减4.交换次数为：n-1 + n-2 + …. + 1 = n^2/2 - n/2最坏情况两两都要交换5.总执行次数=比较次数+交换次数 = n^2 - n6.时间复杂度：O(n^2); 所以冒泡排序适用于元素少的排序 Selection 选择排序 排序原理：遍历，选择最小元素防在第一位。遍历，选择次小元素放在第二位。。。。 过程:1.假设0索引的元素是min; 向后一位比较，小元素所在索引变成min; 遍历完之后拿到最小元素min所在的索引 2.将min索引的值与0索引的值交换3.第一次从索引0开始，第二次从索引1开始。。。。最后从倒数第二个索引开始。 Seclection API设计 1234567891011121314151617181920212223242526public class Seclection &#123; public static void sort(Comparable [] a)&#123; for(int i=0; i&lt;=a.length-2; i++)&#123; int minIndex=i; //这个变量记录最小元素所在的索引，先默认为第一位i for(int j= i+1; j&lt;a.length;j++)&#123; //j会与minIndex比较，j最后是最后一位元素的索引 if(greater(a[minIndex], a[j]))&#123; minIndex = j; &#125; &#125; //内层for循环完成后交换两值 exchange(a, i, minIndex);// i索引为每次的最小值位置 &#125; &#125; private static boolean greater(Comparable a, Comparable b)&#123; return a.compareTo(b)&gt;0; &#125; private static void exchange(Comparable [] a, int i, int j)&#123; Comparable temp; temp = a[i]; a[i]= a[j]; a[j] = temp; &#125; &#125; 测试类：同上 12345public static void main(String[] args) &#123; Integer [] arr =&#123;6,7,2,3,5,2,1,8,3,5&#125;; Seclection.sort(arr); System.out.println(Arrays.toString(arr)); &#125; 算法分析： 1.最坏情况为逆序：{6,5,4,3,2,1}2.核心代码为sort循环中的比较和交换3.比较次数为：n-1 + n-2 + …. + 1 = n^2/2 - n/2两两比较，次数逐层递减4.交换次数为：n-1 最后一次不需要交换，其他都交换一次，也是外层循环次数5.总执行次数=比较次数+交换次数 = n^2/2 - n/2 - 16.时间复杂度：O(n^2); 所以选择排序适用于元素少的排序 Insertion 插入排序 排序原理：从第二个数开始，比较第二和第一，将小的排在前面；从第三个数开始，比较第三和第二，需要交换的话还要再第二比较第一，不需要交换就继续比较第四和第三。。。 Insertion API设计 1234567891011121314151617181920212223242526public class Insertion &#123; public static void sort(Comparable [] a)&#123; for(int i=1; i&lt;a.length; i++)&#123; //从第二个数向前比较 for(int j=i; j&gt;0;j--)&#123; //一个一个向前面一个元素比较，如果前面的数大，就两两交换。比较到第一个数 if(greater(a[j-1], a[j]))&#123; exchange(a, j-1,j); &#125; else&#123; break; //只会结束内层循环。如果这个数比上一个大时，它就比前面的都大，因为前面的数都是排序好的 &#125; &#125; &#125; &#125; private static boolean greater(Comparable a, Comparable b)&#123; return a.compareTo(b)&gt;0; &#125; private static void exchange(Comparable [] a, int i, int j)&#123; Comparable temp; temp = a[i]; a[i]= a[j]; a[j] = temp; &#125;&#125; 算法分析： 1.最坏情况为逆序：{6,5,4,3,2,1}2.核心代码为sort循环中的比较和交换3.比较次数为：n-1 + n-2 + …. + 1 = n^2/2 - n/2两两比较，次数逐层递减4.交换次数为：n-1 + n-2 + …. + 1 = n^2/2 - n/2 最坏情况每次都要交换5.总执行次数=比较次数+交换次数 = n^2 - n6.时间复杂度：O(n^2); 所以插入排序适用于元素少的排序 Merge-sort 归并排序 先分组再合并； 分组叫分，合并叫治 分治思想的典型应用先把数组对半拆分到最小，而后两两比较排序后合并，重复这一步骤直至整个数组排序完成 在每个递归步骤中，划分每个子列表最多需要O(n)时间；合并每个级别中的所有列表最多也需要O(n)时间；递归需要的次数最多为O(log n)次。因此，MergeSort的运行时间为O(n log n)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class Merge &#123; private static Comparable [] assist; private static boolean less(Comparable a, Comparable b)&#123; return a.compareTo(b)&lt;0; &#125; //对数组a中的元素进行排序,入口函数 public static void sort(Comparable [] a)&#123; //初始化辅助数组assist assist = new Comparable[a.length]; //定义一个hi变量，一个lo变量，分别记录数组中最小的索引和最大的索引 int lo=0; int hi=a.length-1; //调用下面的sort方法，从索引lo到索引hi的元素的排序 sort(a,lo,hi); &#125; private static void sort(Comparable [] a,int lo, int hi)&#123; //这个就是递归分到最小组1个的情况 //安全性检测 if(hi&lt;=lo)&#123; return; &#125; //对lo-hi索引之间的数组分成2个组 int mid = lo+(hi-lo)/2; //中位索引，5-9的中位是7 分成567；89 //分别对分好的每一组数据进行排序 sort(a,lo,mid); sort(a,mid+1,hi); //递归完毕，再吧排好的这2个组组合起来，归并 merge(a, lo, mid, hi); &#125; //归并两组数据并进行排序：通过指针遍历比较两组数据，将每次比较的小值填充进辅助数组 private static void merge(Comparable [] a, int lo, int mid,int hi)&#123; //定义三个指针 int i=lo; int p1=lo; //5 int p2=mid+1; //8 //遍历小数组，移动p1 p2指针，比较对应索引处的值，找出小的值，放到辅助数组的对应索引处 while(p1&lt;=mid &amp;&amp; p2&lt;=hi)&#123; //p1和p2都没越界的时候遍历，一个指针遍历完就停止 if(less(a[p1], a[p2]))&#123; assist[i++] = a[p1++]; //p1小，放完p1之后，向右移动p1指针 &#125;else&#123; assist[i++] = a[p2++]; //p2小，放完p2之后，向右移动p1指针 &#125; &#125; //如果p1没有走完，就顺序移动p1指针，把对应元素放到辅助数组对应的索引处 while(p1&lt;=mid)&#123; //如果走完的话p1就会大于mid assist[i++] = a[p1++]; &#125; //如果p2没有走完，就顺序移动p2指针，把对应元素放到辅助数组对应的索引处 while(p2&lt;=hi)&#123; assist[i++] = a[p2++]; &#125; //将辅助数组中填充的元素拷贝到原数组中 for(int index=lo; index&lt;=hi; index++)&#123; a[index]=assist[index]; &#125; &#125; &#125; 算法分析： 1.数组拆分 + 归并：比如8个元素的数组：2^3=8. 每次除以2，他就会拆3次，也就是log8次。拆出来一共三层。拆到第k层，就会有2^k个子数组，每个子数组的长度为2^(3-k)；拆2次，就要4个子数组，每个子数组长度是2。 子数组有多长，最多就需要比较多少次。 2^k层=n个数， k = log2(n)那么归并最多需要比较次数= 层数 * 每层比较次数= 层数 * 每层子数组长度 = 3* （2^3） 2.n个元素的数组的归并时间复杂度= log2(n) * [2^(log2 n)] = log2(n) * n= O(nlogn) —大O标记法：去掉底数 因为n&gt;logn所以归并排序比上面三种排序n^2要小。 作业里面的归并排序计算时间复杂度：T(n)= 2(2T(n/4)+n/2)+n= 4T(n/4)+2n= 23 T(n/23) + 3n= 2i T(n/2i) + i* n= 2log n T(n/2log n) + n log n= n T(1) + n log n= O (nlogn) 3.归并排序的缺点： 需要用到辅助数组，导致空间复杂度提升，是典型的以空间换时间的操作。 Count sorting 计数排序 理解步奏：遍历这串数字，出现的数字对应的数组角标（索引）处存的数字加一。遍历数组，角标对应存放的值是多少就输出角标几次。 代码步奏: 1.一串数字中max-min+1取得这串整数的范围k 2.遍历一串数字，遍历到的数字-min的值对应到数组count[k]的下标，其值加一。 3.遍历数组count[k]，输出每个的值，重复值数次。123456789101112131415161718192021222324252627282930313233public static int[] countSort(int[] array) &#123; //1.得到数列的最大值与最小值，并算出差值d int max = array[0]; int min = array[0]; for (int i = 1; i &lt; array.length; i++) &#123; if (array[i] &gt; max) &#123; max = array[i]; &#125; if(array[i] &lt; min) &#123; min = array[i]; &#125; &#125; //2.创建统计数组并计算统计对应元素个数 int d = max - min; int[] countArray = new int[d + 1]; for (int i = 0; i &lt; array.length; i++) &#123; countArray[array[i] - min]++; //厉害.. &#125; //3.统计数组变形，后面的个数元素等于前面的元素个数之和 int sum = 0; for (int i = 0; i &lt; countArray.length; i++) &#123; sum += countArray[i]; countArray[i] = sum; &#125; //4.倒序遍历原始数组，从统计数组找到正确位置，输出到结果数组 int[] sortedArray = new int[array.length]; for (int i = array.length - 1; i &gt; 0; i--) &#123; sortedArray[countArray[array[i] - min] - 1] = array[i]; countArray[array[i] - min]--; &#125; return sortedArray; &#125; https://www.cnblogs.com/kyoner/p/10604781.html 如果原始数列的规模是N，最大最小整数的差值是M，由于代码中第1、2、4步都涉及到遍历原始数列，运算量都是N，第3步遍历统计数列，运算量是M，所以总体运算量是3N+M，去掉系数，时间复杂度是O(N+M)。 至于空间复杂度，如果不考虑结果数组，只考虑统计数组的话，空间复杂度是O(M)。 -两大局限性：1.当数列最大最小值差距过大时，并不适用于计数排序比如给定20个随机整数，范围在0到1亿之间，此时如果使用计数排序的话，就需要创建长度为1亿的数组，不但严重浪费了空间，而且时间复杂度也随之升高。 2.当数列元素不是整数时，并不适用于计数排序正是由于这两大局限性，才使得计数排序不像快速排序、归并排序那样被人们广泛适用。 它的复杂度为Ο(n+k)（其中k是整数的范围），它适用于一定范围的整数排序。在取值范围不是很大的情况下，它的性能在某些情况甚至快于任何比较排序算法O(nlogn)，例如快速排序、归并排序。 QuickSort 快速排序分治思想的另一种应用 遍历整个数组，将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小。然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 快速排序过程：初数组默认找第一个元素作为分组的分界值；把比分界元素小的放分界元素左边；大的放右边。 左子祖和右子组进行以上的递归：分界分组，递归，直到一组只有两个及以下元素。将有序的子组按照分界元素为中心，组合成新的数组，递归。 如何切分分组：左指针在第二个元素索引，右指针在最后一个元素再后一位的索引。左向右走，找比第一个大的元素；右向左走，找比第一个小的元素。找到后，左右元素交换位置。直到左指针=右指针，这时候这个元素和第一个元素交换位置。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class Quick &#123; private static boolean less(Comparable a, Comparable b)&#123; return a.compareTo(b)&lt;0; &#125; private static void exchange(Comparable [] a, int i, int j)&#123; Comparable temp; temp = a[i]; a[i]= a[j]; a[j] = temp; &#125; public static void sort(Comparable [] a)&#123; //入口函数 int lo=0; int hi=a.length-1; sort(a,lo,hi); //第一次对a数组中所有元素进行排序 &#125; private static void sort(Comparable [] a,int lo, int hi)&#123; //安全性检测 if(hi&lt;=lo)&#123; return; &#125; //对数组中lo索引到hi索引处的元素进行分组（分成左子组和右子组） int partition = partition(a,lo,hi); //分组函数,返回分界值在新子数组中所在的索引 //让左子组有序 sort(a,lo,partition-1); //让右子组有序 sort(a,partition+1,hi); &#125; //分组函数,返回分界值在新子数组中所在的索引 private static int partition(Comparable [] a, int lo,int hi)&#123; Comparable key = a[lo];//key是第一个元素 //定义两个左右指针， int left =lo; int right = hi+1; //切分 while(true)&#123; //右指针左移，找到一个比分界值小的元素，停止 while(less(key, a[--right]))&#123; if(right == lo)&#123; break; &#125; &#125; //左指针右移，找到一个比分界值大的元素，停止 while(less(a[++left], key))&#123; if(left == hi)&#123; break; &#125; &#125; //判断 如果左指针大于右指针，证明元素扫描完毕，结束循环; 如果不是，则交换左右元素 if(left &gt;= right)&#123;//必须是大于等于，不然会指针越界 break; &#125;else&#123; exchange(a, left, right); &#125; &#125; //当左大于等于右时结束循环，交换分界值右和第一个值,因为右指针值代表小值，与第一个交换 exchange(a, lo, right); return right; &#125;&#125; 算法分析：快速排序不是等分，所以需要分为1.最优情况：O(nlogn)2.最坏情况：O(n^2)3.平均情况：O(nlogn) 以上各种排序的比较 稳定性比较：（没有截图了） 时间复杂度：Insertion sort, O(n^2)Selection sort, O(n^2)Bubble sort, O(n^2)Merge sort, O(nlog n) Count sorting，O(n+k) k为整数max-min QuickSort, O(nlogn) 评价情况 ricky总结 堆 优先队列（2,4）Tree 最少两个子代，最多四个子代 每个子代最多三个key 储存了n个item的(2,4) tree的高度是Θ(logn) Search、insertion和deletion的复杂度都是O(logn)，其中search是从上向下(top-down)，insertion和deletion是自底向上(bottom-up) Priority Queue 优先队列 和普通的队列相比，是最高级先出 通过堆实现优先级的筛选 Heap 堆 可以理解为用数组实现的二叉树 除了根节点，每个节点的key值都大于等于父代的key值 堆的插入：新节点首先加入到该二叉堆最后的一个节点，依据最小堆的定义，自底向上，递归调整。 堆的删除：二叉堆的删除一般只讨论如何删除堆顶元素。方法是最后一个节点替换到根节点，然后自顶向下，递归调整。 Heap-Sorting：堆排序算法对有着n个可比较项的序列S进行排序，所需时间为O(nlogn)。自底向上构建具有n个元素的堆需要O(nlogn)时间，并且从堆中提取n个元素（以递增顺序）需要O(nlogn)时间。 Experimental analysis：运行时间对输入大小的依赖性，需要对样本输入适当选择，并进行适当数量的测试。缺陷在于必须先实现算法、必须在有限的输入和同一硬件软件的条件下进行实验。 Theoretical analysis：相比上一种分析方法，可以考虑所有的输入；可以比较多个算法的效率（与硬件环境无关）；可以通过伪代码来研究算法。 伪代码： high-level description 更结构化的描述 自然语言与编程语言的混合 Computational Model 计算模型：通过计算primitive operations的数量来估计算法的复杂度。 primitive operations：比如赋值、比较大小、条件判断、返回值等。 SearchingBinary- searching 二分查找 1、定义min、max、mid角标； 2、比较mid和查找数据大小： 数据大，min=mid+1;数据小, max=mid-1; 3、循环； 4、循环中判断查找的数据是否存在(存在条件max min之间有距离：min &lt;= max) 或者判断存在条件作为while循环条件，会更加简洁1234567891011121314151617181920212223242526272829public static void main(String[] args) &#123; int arr[] =&#123;9,12,15,24,36,41,59,68&#125;;//没排序的先排序 rank(arr); int a =binarySearch(arr, 41); System.out.println("第"+(a+1)+"个是:"+arr[a]); &#125; public static int binarySearch(int arr[], int key) &#123; int min, max, mid; min=0; max = arr.length -1; mid = (min + max)/2; while(arr[mid] != key) &#123; if(arr[mid]&lt; key) &#123; min = mid +1; mid = (min + max)/2; &#125; else if(arr[mid]&gt; key) &#123; max = mid -1; mid = (min + max)/2; &#125; //判断查找元素是否存在 if(max&lt;min) return -1; &#125; return mid; &#125; StringString searchingHorspool’s algorithm匹配串 text模式串 pattern在匹配串中找（能够完全匹配上的）模式串。 shift table： 根据模式串中字母出现位置来标每个字母对应的数字。例如：模式串 P[0..5] =BAOBAB，分成P[0..4]和 最右边的字母.BA0BA B ；P[0..4]中从右向左每个字母第一次出现的位置 和最右边的字母的距离; 没有在模式串中出现的字母，对应的数字是模式串的长度 6. A最先出现，A距离B是1；然后B出现，B距离B是2；然后O出现，O距离B是3. 匹配过程：1.第一种理解（不用shift table）：对于每个文本搜索窗口，将窗口内的最后一个字符（C）与模式串的最后一个字符(c)进行比较。如果相等，则继续从后向前验证其他字符，直到完全相等或者某个字符不匹配。然后，无论匹配与否，都将根据在模式串的下一个出现位置将窗口向右移动。匹配串中的字符模式串中没有的话就移动模式串的长度。 匹配串：abcbcsdxzcxx 模式串：cbcac对齐比较最右字符，再从右到左，b-a不匹配，移动模式串，让模式串中的b和上面的b对齐。若末尾匹配，验证左边一位是否匹配。。。 2.第二种理解（要用shift table）：不匹配的位置b-a时，按照shift table中b（匹配串中b）对应的数字，把模式串向右移动多少位。如果下图第二次移动之后末端对齐了且不匹配，说明匹配串中没有模式串，不需要再进行移动。 AGCCGTGC AGTAA ​ AGTAA searchingAlignment/LCS 校准最优对齐子串/最长相同子串 写在动态规划思想下面。 Graph/Combinatory图的术语 图的DFS,BFSDFS： 先扩展字母小的，一直扩展，每个结点只写一次，如果当前结点的扩展出来的结点已经写出来了，则不扩展当前结点。BFS： 一样的，每个结点不重复写construct tree: 按照原来的图来画DFS BFS的路径。 图的最小生成树图的生成树： 是一棵含有其所有顶点的无环联通子图。图的最小生成树： 这棵树的边的权重的和最小。 生成树的性质 一棵生成树中，连接任意两个顶点都会产生一个环。 从生成树中删除任意一条边，都会得到两颗独立的树。 切分定理 切分： 按照某些规则，把图的所有顶点分成两个 飞空且没有交集的集合。（两个独立的树） 横切边： 连接两个不同集合的边。 切分定理：连接两个独立树的横切边权重最小者必然属于图中的最小生成树。 贪心算法 –计算图的最小生成树算法 用贪心算法找最小生成树的过程：把所有顶点分成两个集合，找相连接两个集合的横切边中最小的； 再分成不同的集合再找最小横切边；直到选出来的最小横切边连接了所有顶点。 无序的切分找横切边，直到连接完。 prim算法 –贪心算法的一种特殊情况 用prim算法找最小生成树的过程：先任意拿一个顶点加入“已选集合” ，其他顶点组成另一个集合；选这两个集合的最小横切边；这个最小横切边连接的顶点放进“已选集合” ； 再继续重复选横切边、加入顶点。 有序的一个一个找顶点之间的横切边。 有可能横切边长度一样的时候，就会有不只一个最小生成树。 Kruskal算法 –贪心算法的一种特殊情况 用kruskal算法找最小生成树的过程：先把图中所有的边存储进最小优先队列，按照大小排序；选第一小的边，连接边的两个顶点；选第二小的边，连接边的两个顶点；直到连接完所有顶点。不能成环，有环就跳过，找下一条边。 最短路径算法们Dijkstra算法 求最短路径要求：边的权值均为非负 怎么做：和一致搜索算法一模一样 设计和时间复杂度：Dijkstra 算法采用贪心算法（Greedy Algorithm）范式进行设计，普通实现的时间复杂度为 O(V2)。 其中 V 为顶点数量，E 为边的数量。 Bellman-Ford算法 求有向图最短路径意思是求从a 到各个顶点的值，次次loop更新其他顶点的值，直到不变/如果有负环 会永远loop(路径经过负环会一直减小，更新) 更新每个顶点的值时，找这个点连接的上一条边 要求：对于带权有向图 G = (V, E)，Bellman-Ford算法能适应一般的情况（即存在负值边的情况). 设计和时间复杂度：Bellman-Ford 算法采用动态规划（Dynamic Programming）进行设计，实现的时间复杂度为 O(V * E)，其中 V 为顶点数量，E 为边的数量。 Floyd-Warshall算法 求有向图或负权的最短路径每次加入一个结点，更新每两点之间通路的最短路径 Backtracking 回溯Subset-Sum Problem子集元素和问题For example: S ={ 3, 5, 6, 7} d=15 What is the state-space?所有满足元素和为d的S的子集 解： 3–5–6=14 错 3–5–7=15 对 3–6–7=16 错 3–7=10 错 5–6–7=18 错 全部列举 Assignment Problem工作分配问题每个人一个job，job列对应的人不能重复 Job 1 Job 2 Job 3 Job 4 Person a 9 2 7 8 Person b 6 4 3 7 Person c 5 8 1 8 Person d 7 6 9 4Lower bound：每行找最小值之和/每列找最小值之和解：用Lower bound的思想，一个人一个人的讨论情况走通路。先讨论 a=9时bcd用Lower bound，bcd就依次选择剩下job中值最小的；a=2时bcd用Lower bound；… 选择上面四个abcd通路最小的继续讨论b=6/4/3/7.直到讨论到d. 对应练习题： TSP问题 用Lower boundlow bound=(每个点出发，选最短的两条边之和)/2low bound要求如果答案有小数向上取整 解：和Assignment Problem工作分配问题一样，用Lower bound的思想，a点出发，固定a-b边(在a、b点选择两条边的时候其中一条一定要是a-b的边，然后在选择剩下较小的边)，找剩下顶点b c d e中较小的两条边; a-c边通路; a-d边通路。对于第一步a-b：固定a-b-c/a-b-d/a-b-e.永远先扩展lb小的 对应练习题：102ttl week11 Q4 二次绕树twice-around-the-tree从A点出发，找最短路径到下一个点，再到下一个点，如果在找下一个点的路径时发现这个路径比上一个点到自己的路径都要长就原路返回A点，选择第二段的路径开始，经过剩下没有经过的点。经过完了直接返回A点。 然后删掉路径中重复的点，计算新路径的长度 Euclidean graph欧几里得图（真实存在的图）两边之和大于第三边 图的应用：拓扑排序 将非顺序的线性结构形成有顺序的结构。 用AOV网可以解决如下问题： 判定工程的可行性，有回路的话 整个工程就无法结束。 确定各项活动在整个工程执行中的先后顺序，先后顺序成为拓扑有序序列。 算法手写怎么分析 涉及递归的算法，手写出树的图，这样清晰明了，返回到哪一步都能看得清楚。]]></content>
      <categories>
        <category>记忆性学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[常见问题&解决办法&小技巧]]></title>
    <url>%2F2020%2F02%2F21%2F%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95-%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[杀端口占用 输入win+R快捷键，输入cmd，打开命令行窗口 netstat -ano|findstr 8080 taskkill /f /t /im 监听号 eclipse使用 eclipse里创建的html文件编辑内容要右键openwith。 重启springboot项目前要在控制台那里点红色方框关闭上一次的启动，不然就会出现端口占用，启动失败。 窗口文件右键close可以全部关掉 双击窗口栏的文件会全屏显示，再双击就还原。 鼠标放在函数名上面就有解释。 Formatter代码格式设置：windows-preferences-找对应的语言 springboot项目运行控制台不显示/打开控制台：windows-showview-console 快捷键：alt shift s 添加getter setter toStringctrl shift o 添加删除包Ctrl+Shift+f 自动对齐(快捷键没有用)，必须选中-Source-Format，vue项目里没有alt / 补全代码main + alt / 主函数ctrl shift c 多行全部备注ctrl 鼠标移到包/类上就有下划线的链接可以跳转 cmd命令行 比如要查看node.js版本：node -v命令需要在node.js的安装文件夹下执行。安装什么的也是在文件夹路径下执安装命令。 先d: 在cd D:\nodejs14.4(复制过去) 打开vueui界面 在vue项目文件夹中shift+邮件+打开powershell ；之后不能关闭powershell 输入vue ui 打开powershell中给的localhost网址 点击左侧任务栏，点击serve,点击运行，查看输出，输出里有此文件夹vue项目的跳转链接. github仓库托管代码 教程https://blog.csdn.net/hc_ttxs/article/details/79375788 ssh密匙之前blog的时候就有了，不用再添加。在本地文件夹git-repo为本地仓库，将代码添加进这个文件夹，右键git bush here,按照git命令提交。 我用的是http: https://github.com/Lucifinil-x/community-sringboot.git 提交本地代码命令 数据库，mysql,sqlyog 在表中更改了数据要右键更改保存。 创建表之后F5刷新当前数据库 不认识的单词 Toggle navigation：切换导航Toggle navigation 替换成名字 路西斐尔的尼伯龙根 placeholder：占位符搜索框里的灰体字]]></content>
      <categories>
        <category>应用使用要点</category>
      </categories>
      <tags>
        <tag>bug</tag>
        <tag>解决办法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot学习/项目]]></title>
    <url>%2F2020%2F02%2F19%2Fspringboot%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[注解@XXX的理解 spring引入注解，让注解与java bean紧密结合，减少了配置文件（.xml文件）的体积，增加了java bean的可读性和内聚性。 @Autowired注解：自动找和注入组件类、接口实现类，接着就能用他们了 1.自动注入java类，@Autowired注解回去寻找一个java bean组件（@Bean是给spring容器中添加组件，函数返回值添加进容器中） @Autowired private UserRepository userRepository; 如果bean定义给去掉了，spring容器找不到就会抛出异常。如果不想抛出异常，找不到就认为这个属性为null的话：required值设置 false @Autowired（required = false） private UserRepository userRepository; 但其实没有@Bean也能找到并且注入一个接口，而且直接可以调用实现接口的子类的方法 2.自动注入java接口的实现类： 比如：接口Car;实现类A implements Car;实现类B implements Car; @Service public class CarFactory { @Autowired @Qualifier(&quot;B&quot;) //两个实现类，指明调用B类的carName方法 private Car car; //多态 public String toString() { return car.carName(); } } @Resource注解：根据name和type找和注入组件类、接口实现类，接着就能用他们了 @Servicepublic class Zoo{ @Resource(name = &quot;tiger&quot;) private Tiger tiger; @Resource(type = Monkey.class) private Monkey monkey; public String toString() { return tiger + monkey; }} @Service注解： 声明Zoo.java是一个bean容器，其他类就能够@Autowired把zoo类当做是成员变量来使用; Zoo.java在bean中的id为”zoo”.(类名小写)Thymeleaf模板 Spring Boot 推荐使用 Thymeleaf 来代替 Jsp Thymeleaf 是一款用于渲染 XML/XHTML/HTML5 内容的模板引擎。类似 JSP,它也可以轻易的与 Spring MVC 等 Web 框架进行集成作为 Web 应用的模板引擎。能够直接在浏览器中打开并正确显示模板页面，而不需要启动整个 Web 应用。 页面即原型,整个页面直接作为 HTML 文件用浏览器打开，几乎就可以看到最终的效果，这大大解放了前端工程师的生产力，它们的最终交付物就是纯的 HTML/CSS/JavaScript 文件。 从springboot官方文档学习做helloXXX html页面 效果：运行后打开localhost:8080/greeting?name=xyt 这个网页页面就会显示出Hello, xyt! 官方文档https://spring.io/guides/gs/serving-web-content/ resources文件夹下放置静态文件，其中templates里放web文件 目前能够想到的组件，在spring官方文档里都是有的。复制粘贴。 pom.xml里加thymeleaf依赖 12345678910111213141516171819@Controller //允许这个类接收前端的请求public class GreetingController &#123; @GetMapping(&quot;/greeting&quot;) //网址的路径 public String greeting( @RequestParam(name=&quot;name&quot;, //@RequestParam()定义接收参数是什么，网址那里？name=xxx ,这个&quot;name&quot;就会以键值对的方式传到服务端，这样我们就会接收到这个value值。 required=false,没有接收到值也不会报错，默认值为world. required=false, defaultValue=&quot;World&quot;) String name, Model //接收到的值是String类型。这里逗号之前都是第一个参数 model) &#123; model.addAttribute(&quot;name&quot;, name); //model添加&quot;键&quot;值对的属性。Model则将获取到的值传递到这个页面上去显示，spring帮我们注入进去了。 return &quot;greeting&quot;; //return值&quot;greeting&quot;会去template中找同名的html文件:greeting.html，把他渲染成网页。这个需要自己去template中添加。 &#125;&#125; 在application.java的同一级或下一级的@Bean组件都能自动加载入容器中。 eclipse里创建的html文件编辑内容要右键openwith。12345678910&lt;!DOCTYPE HTML&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;title&gt;Getting Started: Serving Web Content&lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;&lt;/head&gt;&lt;body&gt; &lt;p th:text=&quot;&apos;Hello, &apos; + $&#123;name&#125; + &apos;!&apos;&quot; /&gt; //网页显示出Hello,XXX!&lt;/body&gt;&lt;/html&gt; 做社区网站项目第一章 网站网页的功能划分 导航（菜单栏），有很多功能分类：搜索，登录按钮 标签tag列表 话题列表，排序方式：时间倒序、推荐、热门、消灭零回复话题列表元素：发布人、发布时间、评论数、浏览数、回复数、关注数、 热门话题 热门用户 分页 第二章 做社区的菜单栏导航条 用UI框架Bootstrap快速搭建前端的站点。Bootstrap介绍：简洁、直观、强悍的前端开发框架，让web开发更迅速、简单 第一步 下载Bootstrap https://v3.bootcss.com/getting-started/#download下载并将文件粘贴到static文件夹下 第二步 写index.html 写入css,js文件 1234567891011&lt;!DOCTYPE HTML&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;title&gt;路西斐尔的尼伯龙根&lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/bootstrap.min.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/bootstrap-theme.min.css&quot;/&gt; &lt;script src=&quot;js/bootstrap.min.js&quot; type=&quot;application/javascript&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt; 在Bootstrap网页上找到组件页面，找导航条，将代码复制粘贴到index.html中的body中 根据实例中每个框框中的单词，将body中对应的单词改成自己的。 删掉不要的url，icon代码块 第三步 写IndexController.java12345678@Controllerpublic class IndexController &#123; @GetMapping(&quot;/&quot;) //根路径，代表8080就是index.html渲染出来的页面 public String index() &#123; return &quot;index&quot;; &#125;&#125; 第三章 申请github app登录授权 授权登记页面 https://github.com/settings/applications/1228484 第四章 做登录callback，拿到参数第一步 做登录按钮的github授权登录输账号密码页面 GitHub需要的内容文档 https://developer.github.com/apps/building-oauth-apps/authorizing-oauth-apps/ index.html登录那一行加入自己申请过的授权信息 1&lt;li&gt;&lt;a href=&quot;https://github.com/login/oauth/authorize?client_id=51a87c000499eea9d39a&amp;redirect_uri=http://localhost:8080/callback&amp;scope=user&amp;state=1&amp;&quot;&gt;登录&lt;/a&gt;&lt;/li&gt; 在输入密码之后会到callback页面，这时候显示404，因为还没做callback页面。http://localhost:8080/callback?code=57679f8624ad1ef794bd&amp;state=1网址上会显示一串code,之后就需要接收到这个参数code和参数state，用@RequestParam 第二步 做callback页面，接收到callback的code 新建AuthorizeController.java1234@GetMapping(&quot;/callback&quot;) //当他登录后到callback时，就让他跳转回index页面 public String callback( @RequestParam(name=&quot;code&quot;) String code , //第一个参数name为code，第二个为state @RequestParam(name=&quot;state&quot;) String state) &#123; return &quot;index&quot;; 第三步第五章 写配置文件，分离变量数据和固定代码第一步 将文件中的数据值用参数占位，在配置文件中赋值1234@Value(&quot;$&#123;github.client.id&#125;&quot;) //value中为键，他会去配置文件中找对应键的值，且赋值给参数clientId private String clientId;配置文件： github.client.id=51a87c000499eea9d39a //键值对 第六章 登录成功保持登录状态Session 和 Cookie Session:银行账户，账户所有信息都在银行数据库中（服务器就相当于银行） Cookie:银行卡，要操作账户中信息比如余额，需要知道银行卡 第七章 callback页面404，控制台不打印原因高亮！ 所有的文件和包一定要放在启动类/包下面，否则run时是不可能启动这些类的，控制台也不会打印。 springboot和shiro整合-权限管理实战第一章 Controller类1234567891011121314151617181920212223// 第一种getmapping注解 @GetMapping(&quot;/hello&quot;) public String hello() &#123; System.out.println(&quot;UserController.hello()&quot;); return &quot;ok&quot;; &#125; @GetMapping(&quot;/testThymeleaf&quot;) public String testThymeleaf(Model model) &#123; model.addAttribute(&quot;name&quot;,&quot;xyt&quot;); return &quot;test&quot;; &#125;//第二章requestmapping+requestbody @RequestMapping(&quot;/hello&quot;) @ResponseBody public String hello() &#123; System.out.println(&quot;UserController.hello()&quot;); return &quot;ok&quot;; &#125; @RequestMapping(&quot;/testThymeleaf&quot;) public String testThymeleaf(Model model) &#123; model.addAttribute(&quot;name&quot;,&quot;xyt&quot;); return &quot;test&quot;; &#125; @RequestMapping(“/hello”)@ResponseBody是返回字体（将实体类转化为json） @RequestMapping(“/hello”)是返回html 12345@RequestMapping(&quot;/update&quot;) public String update() &#123; System.out.println(&quot;UserController.hello()&quot;); return &quot;/user/update&quot;; &#125; 返回到update.html要加前面的路径。如：return “index”; index.html在trmplates包直接下面如：return “/user/update”;update.html在trmplates包下面user包下面 第二章shiro 核心APISubject: 用户主体 (把操作交给SecurityManager,要关联它)SecurityManager: 安全管理器 （关联Reaml）Realm: Shiro连接数据的桥梁,执行认证和授权。认证中具体实现用户名和密码匹配 第三章 springboot和shiro整合导入shiro和spring整合依赖12345&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt;&lt;/dependency&gt; 编写shiro配置类 @Configurartion 放在启动类子包Shiro子包Shiro中自定义Realm类，继承AuthorizingRealm类，实现认证和授权方法写shiro配置类 创建ShiroFilterFactoryBean对象，@Bean放入spring的环境，上面的方法就可以使用 创建DefaultWebSecurityManager对象，@Bean放入spring的环境 创建Realm对象，@Bean放入spring的环境 1234567891011121314151617181920212223@Configurationpublic class ShiroConfig &#123; @Bean //过滤拦截器 public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier(&quot;securityManager&quot;) DefaultWebSecurityManager securityManager ) &#123; ShiroFilterFactoryBean shiroFilterFactoryBean=new ShiroFilterFactoryBean(); shiroFilterFactoryBean.setSecurityManager(securityManager);//设置关联安全管理器 return shiroFilterFactoryBean; &#125; @Bean(name=&quot;securityManager&quot;) //安全管理器 public DefaultWebSecurityManager getDefaultWebSecurityManager(@Qualifier(&quot;userRealm&quot;)UserRealm userRealm) &#123; //@Qualifier合格者，去根据bean名字查找userRealm对象，拿一个 DefaultWebSecurityManager securityManager =new DefaultWebSecurityManager(); securityManager.setRealm(userRealm); //设置关联realm return securityManager; &#125; @Bean(name= &quot;userRealm&quot;) //执行授权器 public UserRealm getRealm() &#123; return new UserRealm(); &#125;&#125; 使用shiro内置过滤器，可实现页面权限相关的资源拦截 资源拦截逻辑：以键值对集合形式添加各个页面和对应的拦截规则。不同的拦截规则会跳转到（修改过的）不同的页面。authc：跳转到登录页面tologin(tologgin路径是login的html)，点击登录按钮后执行认证逻辑perms：进行授权逻辑，是否匹配perms字符串，不匹配跳转到拦截页面 在过滤拦截器中使用shiro内置过滤器，可以实现页面的拦截，和跳转页面。也可以用不同的过滤器放行一些页面。 常用的过滤器： anon:无需认证（登录）可以访问 authc:必须认证才可以访问 user:如果使用了rememberme的功能可以访问 perms:该资源必须授权资源权限才可以访问 role:该资源必须得到角色授权才可以访问 12345678910111213141516@Bean public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier(&quot;securityManager&quot;) DefaultWebSecurityManager securityManager ) &#123; ShiroFilterFactoryBean shiroFilterFactoryBean=new ShiroFilterFactoryBean(); //设置安全管理器 shiroFilterFactoryBean.setSecurityManager(securityManager); //添加shiro内置过滤器,将链接跳转页面和过滤器以键值对形式，加入hashmap集合 Map&lt;String,String&gt; filterMap = new LinkedHashMap&lt;String,String&gt;(); filterMap.put(&quot;/add&quot;, &quot;authc&quot;);//authc必须认证才能访问 filterMap.put(&quot;/update&quot;, &quot;authc&quot;); //修改跳转登录页面url, 每一个页面都要写一个controller，@RequestMapping对应路径 shiroFilterFactoryBean.setLoginUrl(&quot;/tologin&quot;); //安全管理器中添加集合的拦截，集合中添加的路径会按照键值对设置对应的拦截 shiroFilterFactoryBean.setFilterChainDefinitionMap(filterMap); return shiroFilterFactoryBean; 那么拦截成功就会自动跳转到http://localhost:8080/login，可自己修改跳转登录链接url如上，并且在controller类中写对应的@RequestMapping对应路径，并且写路径的页面html文件。（login.html） filterMap.put(“/test”, “anon”);让首页链接放行，无需认证（登录）可以访问，要注意顺序，这个在前面 filterMap.put(“/*”, “authc”); 这里可以让templates下面的全部资源使用过滤器，虽然他们都是user包下的，但是用根目录 超链接是写在首页test.html中,超链接点过去的跳转链接是写在Controller类中，并且写了return的html文件 12345678910111213&lt;!DOCTYPE HTML&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt; &lt;/meta&gt;&lt;title&gt;测试&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3 th:text=&quot;$&#123;name&#125;&quot;&gt;&lt;/h3&gt;&lt;hr/&gt;进入用户添加功能：&lt;a href=&quot;add&quot;&gt;用户添加&lt;/a&gt;&lt;br/&gt;进入用户更新功能：&lt;a href=&quot;update&quot;&gt;用户更新&lt;/a&gt;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt; 第四章 编写用户登录功能简单设计了一个登录页面login.html（之前的过滤拦截后的跳转页面，也是登录失败的返回页面）1234567891011121314151617&lt;!DOCTYPE HTML&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt; &lt;/meta&gt;&lt;title&gt;登录页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;这是拦截登录页面&lt;h3&gt;登录&lt;/h3&gt;&lt;h3 th:text=&quot;$&#123;msg&#125;&quot; style=&quot;color:red&quot;&gt;&lt;/h3&gt;&lt;form method = &quot;post&quot; action=&quot;login&quot;&gt; 用户名:&lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt;&lt;br/&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 为什么登录前后都用login.html?因为登录失败时model携带的msg信息才会与html中的msg匹配显示出来 点击登录按钮后跳转到login页面,编写login Controller的登录逻辑 接收 输入到login页面的用户名和密码，封装（添加）到token对象，吧token对象发给shiro。try catch判断登录成功或失败；成功返回test首页；失败 用model存储失败信息返回login页面。1234567891011121314151617181920212223//登录按钮后的跳转页面，实现逻辑处理 @RequestMapping(&quot;/login&quot;) //model中存入我们要return回login.html的信息,会吧存在里面的消息带回去，会在msg对应地方打印出错误消息 public String login(String name, String password, Model model) &#123; //使用shiro编写认证操作 //1.获取subject用户主体 Subject subject = SecurityUtils.getSubject(); //2.用token封装用户数据 UsernamePasswordToken token = new UsernamePasswordToken(name,password); //3.执行登录方法,执行过程中要传递用户的token给subject(就是传递给shiro) //如何判断是否信息无误：这段代码无任何异常 //shiro将异常/登录失败分的很清楚：UnknownAccountException e用户名不存在;IncorrectCredentialException密码错误 try &#123; subject.login(token); //无异常，登录成功跳转回首页test.html return &quot;test&quot;; &#125; catch (UnknownAccountException e) &#123; model.addAttribute(&quot;msg&quot;,&quot;用户名不存在&quot;); return &quot;redirect:/tologin&quot;;//重定向，请求到tologin路径,会执行tologin的controller,还是回到login.html &#125;catch(IncorrectCredentialsException e) &#123; model.addAttribute(&quot;msg&quot;, &quot;密码错误&quot;); return &quot;login&quot;;//所以直接回去也可以的 &#125; 编写realm的认证函数中：判断登录信息逻辑12345678910111213141516//执行认证逻辑,Authentication证明,这里接收到的就是controller中提交到shiro的token @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; System.out.println(&quot;认证&quot;); //现在先假设数据库的用户名和密码是 String name = &quot;xyt&quot;; String password = &quot;666&quot;; UsernamePasswordToken thistoken = (UsernamePasswordToken)token; //判断用户名和密码 if(!thistoken.getUsername().equals(name)) &#123; //shiro底层会抛出UnknownAccountException return null; &#125; //密码不需要判断。返回AuthenticationInfo的子类 return new SimpleAuthenticationInfo(&quot;&quot;,password,&quot;&quot;);//提交给login方法的，数据库密码(shiro会自动判断)，shiro的名字 &#125; 第五章 整合mybits实现用户登录认证 MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。 导入mybits相关依赖12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.9&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt; &lt;/dependency&gt; 在mysql sqlyog客户端中建一个数据库springboot_shiro，添加user表 写配置文件12345678910spring.datasource.driverClassName=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost/springboot_shiro?serverTimezone=UTC //url这里不用写主机ip,不用写3306（3306加上也可以成功运行）spring.datasource.username=root //用户名在sqlyog的客户端里数据库上面写的root@localhost,@前面的就是用户名spring.datasource.password= //密码记在手机里了spring.datasource.type=com.alibaba.druid.pool.DruidDataSourcemybatis.type-aliases-package=com.example.demo.domain //扫描包下的实体类 写com.example.demo.domain下的实体类User不加注解,与数据库数据中对应 name,id,password,getter,setter 写com.example.demo.mapper包下两个文件 写Dao: interface UserMapper接口 1234567import com.example.demo.domain.User;public interface UserMapper &#123; //查询 public User findByName(String name);&#125; 写映射文件： UserMapper.xml (一定要和上面的java文件名字一样)。这个文件里放CURD的sql语句,对应着上面接口中的函数实现 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapperPUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.example.demo.mapper.UserMapper&quot;&gt; &lt;select id = &quot;findByName&quot; parameterType=&quot;string&quot; resultType=&quot;User&quot;&gt; SELECT `id`, `name`, `password` //可以随意大小写，不用加引号 FROM user where name= #&#123;value&#125; //这个是占位符 &lt;/select&gt;&lt;/mapper&gt; 业务包servise 接口类UserService 1234public interface UserService &#123; public User findByName(String name);&#125; 实现类UserServiceImpl：来实现mapper接口，要加注解@Service 123456789101112131415@Servicepublic class UserServiceImpl implements UserService&#123; //注入Mapper接口 @Autowired private UserMapper userMapper; @Override //实现UserService的函数，参数传给userMapper的函数 public User findByName(String name) &#123; return userMapper.findByName(name); &#125;&#125; 修改启动类加上注解@MapperScan(“com.example.demo.mapper”)扫描mapper接口所在的包 在controller中注入业务123//注入业务 @Autowired private UserService userService; 在realm中注入业务，修改认证逻辑（去数据库中匹配用户名和密码）12345678910111213141516171819202122232425 //注入业务 @Autowired private UserService userService; //执行认证逻辑,Authentication证明,这里接收到的就是controller中提交到shiro的token @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; System.out.println(&quot;认证&quot;);// //现在先假设数据库的用户名和密码是// String name = &quot;xyt&quot;;// String password = &quot;666&quot;; UsernamePasswordToken thistoken = (UsernamePasswordToken)token; //现在已经连接了mysql数据库，写好了查询函数。然后这里就用获取到的name去找对应的password com.example.demo.domain.User user = userService.findByName(thistoken.getUsername()); //判断用户名和密码 if(user==null) &#123; return null;//shiro底层会抛出UnknownAccountException &#125; //密码不需要判断。返回AuthenticationInfo的子类 return new SimpleAuthenticationInfo(&quot;&quot;,user.getPassword(),&quot;&quot;);//提交给login方法的，数据库密码(shiro会自动判断)，shiro的名字 &#125;&#125; 第六章 整合mybits实现用户登录授权shiroconfig添加内置授权过滤/拦截器 perms： 该资源必须得到资源权限才可以访问1234567891011121314151617181920212223242526 @Bean public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier(&quot;securityManager&quot;) DefaultWebSecurityManager securityManager ) &#123; ShiroFilterFactoryBean shiroFilterFactoryBean=new ShiroFilterFactoryBean(); //设置安全管理器 shiroFilterFactoryBean.setSecurityManager(securityManager); //添加shiro内置过滤器,将链接跳转页面和过滤器以键值对形式，加入hashmap集合 Map&lt;String,String&gt; filterMap = new LinkedHashMap&lt;String,String&gt;();// filterMap.put(&quot;/add&quot;, &quot;authc&quot;);//authc必须认证才能访问// filterMap.put(&quot;/update&quot;, &quot;authc&quot;); filterMap.put(&quot;/test&quot;, &quot;anon&quot;); filterMap.put(&quot;/login&quot;, &quot;anon&quot;); //授权过滤器，登录过的user在add页面需要拿到add页面的授权才能访问 //在登录后点击添加时，就会进入授权逻辑 filterMap.put(&quot;/add&quot;, &quot;perms[user:add]&quot;); filterMap.put(&quot;/*&quot;, &quot;authc&quot;); //修改拦截的跳转登录页面url, 每一个页面都要写一个controller，@RequestMapping对应路径 shiroFilterFactoryBean.setLoginUrl(&quot;/tologin&quot;); //设置未授权的拦截页面：没有拿到某页面授权去访问某页面会跳转到/unAuth shiroFilterFactoryBean.setUnauthorizedUrl(&quot;/unAuth&quot;); //安全管理器中添加集合，以上设置的键值对拦截功能生效 shiroFilterFactoryBean.setFilterChainDefinitionMap(filterMap); return shiroFilterFactoryBean; reaml中写资源授权逻辑 逻辑：拦截过滤器添加了perms授权拦截，点到add页面就会进入授权逻辑。在进行授权逻辑时，就拿到了这个字符串，对应config那边的规则perms[user:add]，字符串匹配，授权完成，可访问正常add页面；若在授权逻辑中没有拿到相同字符串，被拦截，跳转unAuth页面。123456789@Overrideprotected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection arg0) &#123; System.out.println(&quot;执行授权逻辑&quot;); //资源授权 SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(); //添加授权字符串,在进行授权逻辑时，就拿到了这个字符串，对应config那边perms[user:add]，字符串匹配，授权完成，可访问 info.addStringPermission(&quot;user:add&quot;); return info; &#125; 改造上面的授权编码，让perms字符串更加灵活 在数据库中添加每个用户的perms 修改了表的结构，就要修改对应的实体类User结构,添加perms属性 我们需要取出数据库中的perms，需要在mapper接口中新定义一个根据id就能查找user对象的方法，然后在映射文件中写出对应的sql查询语句（相当于写出了这个具体函数方法） 在service接口中添加相同的方法 对应的在UserServiceImpl中实现这个方法：这里是调用mapper里写的sql函数return userMapper.findById(id); 第七章 thymeleaf和shiro标签整合使用导入thymleaf扩展坐标 加入扩展依赖 123456&lt;!-- thymel对shiro的扩展坐标 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.theborakompanioni&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-shiro&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt; &lt;/dependency&gt; shiroconfig中配置shiro的dialect(方言)，用于thymeleaf和 shiro标签配合使用 1234@Bean //交给spring容器 public ShiroDialect getShiroDialect() &#123; return new ShiroDialect(); &#125; 想要对于已登录用户，test主页只显示用户拿到授权的跳转超链接 修改test.html,将超链接部分加入div包裹起来，并且加入shiro的permisson字符串但是这样在未登录情况也会判断授权字符串 1234567&lt;div shiro:hasPermission=&quot;user:add&quot;&gt;进入用户添加功能：&lt;a href=&quot;add&quot;&gt;用户添加&lt;/a&gt;&lt;br/&gt;&lt;/div&gt;&lt;div shiro:hasPermission=&quot;user:update&quot;&gt;进入用户更新功能：&lt;a href=&quot;update&quot;&gt;用户更新&lt;/a&gt;&lt;br/&gt;&lt;/div&gt; 继续加入，加在上面那些代码的上面。意思是：”url”，点登陆会超链接跳转到/tologin路径 1&lt;a href=&quot;tologin&quot;&gt;登录&lt;/a&gt; 此项目代码资源-eclipse链接：https://pan.baidu.com/s/1n8oLFCNfRk90kYmhNBAnBg提取码：o470 注：此外需要mysql中的同名数据库和表 14天黑马头条项目太难了 博客项目vueblog项目文档：https://juejin.im/post/5ecfca676fb9a04793456fb8vueblog代码仓库：https://github.com/MarkerHub/vueblog 连接数据库application.yml注意1：url: jdbc:mysql://localhost/orderingsystem?serverTimezone=UTC和url: jdbc:mysql://localhost:3306/vueblog?useUnicode=true&amp;useSSL=false&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai目前都没有问题，以前用的都是前者。注意2：代码生成器中要修改对应的数据库连接 1234567891011# DataSource Configspring: datasource: name: vueblog driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/vueblog?useUnicode=true&amp;useSSL=false&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai username: root password: zhangcaiyunmybatis-plus: mapper-locations: classpath*:/mapper/**Mapper.xml 代码生成器(mybatis plus) 运行CodeGenerator(java project),输入连接的数据库中已存在的表名。就会自动生成config,entity,mapper,service相关代码文件。 注意1:与idea不同，eclipse生成代码成功之后不会更新列表中的文件。但是本地仓库中已经生成对应路径的代码文件。需要删除项目，再重新加载。 注意2：与idea不同，eclipse项目的包名路径不同，需要修改代码生成器中的路径，如下：修改projectPath(本地项目路径)，pc.setParent(“com.example.demo”)（生成代码放在启动类的下级包中）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116package com.example.demo;import com.baomidou.mybatisplus.core.exceptions.MybatisPlusException;import com.baomidou.mybatisplus.core.toolkit.StringPool;import com.baomidou.mybatisplus.core.toolkit.StringUtils;import com.baomidou.mybatisplus.generator.AutoGenerator;import com.baomidou.mybatisplus.generator.InjectionConfig;import com.baomidou.mybatisplus.generator.config.*;import com.baomidou.mybatisplus.generator.config.po.TableInfo;import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;import com.baomidou.mybatisplus.generator.engine.FreemarkerTemplateEngine;import java.util.ArrayList;import java.util.List;import java.util.Scanner;// 演示例子，执行 main 方法控制台输入模块表名回车自动生成对应项目目录中public class CodeGenerator &#123; /** * &lt;p&gt; * 读取控制台内容 * &lt;/p&gt; */ public static String scanner(String tip) &#123; Scanner scanner = new Scanner(System.in); StringBuilder help = new StringBuilder(); help.append(&quot;请输入&quot; + tip + &quot;：&quot;); System.out.println(help.toString()); if (scanner.hasNext()) &#123; String ipt = scanner.next(); if (StringUtils.isNotEmpty(ipt)) &#123; return ipt; &#125; &#125; throw new MybatisPlusException(&quot;请输入正确的&quot; + tip + &quot;！&quot;); &#125; public static void main(String[] args) &#123; // 代码生成器 AutoGenerator mpg = new AutoGenerator(); // 全局配置 GlobalConfig gc = new GlobalConfig(); String projectPath = &quot;D:/eclipse项目/vueblog&quot;;//System.getProperty(&quot;user.dir&quot;); gc.setOutputDir(projectPath + &quot;/src/main/java&quot;);// gc.setOutputDir(&quot;D:\\test&quot;); gc.setAuthor(&quot;关注公众号：MarkerHub&quot;); gc.setOpen(false); // gc.setSwagger2(true); 实体属性 Swagger2 注解 gc.setServiceName(&quot;%sService&quot;); mpg.setGlobalConfig(gc); // 数据源配置 DataSourceConfig dsc = new DataSourceConfig(); dsc.setUrl(&quot;jdbc:mysql://localhost:3306/vueblog?serverTimezone=UTC&quot;); // dsc.setSchemaName(&quot;public&quot;); dsc.setDriverName(&quot;com.mysql.cj.jdbc.Driver&quot;); dsc.setUsername(&quot;root&quot;); dsc.setPassword(&quot;zhangcaiyun&quot;); mpg.setDataSource(dsc); // 包配置 PackageConfig pc = new PackageConfig(); pc.setModuleName(null); pc.setParent(&quot;com.example.demo&quot;); mpg.setPackageInfo(pc); // 自定义配置 InjectionConfig cfg = new InjectionConfig() &#123; @Override public void initMap() &#123; // to do nothing &#125; &#125;; // 如果模板引擎是 freemarker String templatePath = &quot;/templates/mapper.xml.ftl&quot;; // 如果模板引擎是 velocity // String templatePath = &quot;/templates/mapper.xml.vm&quot;; // 自定义输出配置 List&lt;FileOutConfig&gt; focList = new ArrayList&lt;&gt;(); // 自定义配置会被优先输出 focList.add(new FileOutConfig(templatePath) &#123; @Override public String outputFile(TableInfo tableInfo) &#123; // 自定义输出文件名 ， 如果你 Entity 设置了前后缀、此处注意 xml 的名称会跟着发生变化！！ return projectPath + &quot;/src/main/resources/mapper/&quot; + &quot;/&quot; + tableInfo.getEntityName() + &quot;Mapper&quot; + StringPool.DOT_XML; &#125; &#125;); cfg.setFileOutConfigList(focList); mpg.setCfg(cfg); // 配置模板 TemplateConfig templateConfig = new TemplateConfig(); templateConfig.setXml(null); mpg.setTemplate(templateConfig); // 策略配置 StrategyConfig strategy = new StrategyConfig(); strategy.setNaming(NamingStrategy.underline_to_camel); strategy.setColumnNaming(NamingStrategy.underline_to_camel); strategy.setEntityLombokModel(true); strategy.setRestControllerStyle(true); strategy.setInclude(scanner(&quot;表名，多个英文逗号分割&quot;).split(&quot;,&quot;)); strategy.setControllerMappingHyphenStyle(true); strategy.setTablePrefix(&quot;m_&quot;); mpg.setStrategy(strategy); mpg.setTemplateEngine(new FreemarkerTemplateEngine()); mpg.execute(); &#125;&#125; Error creating bean with name ‘UserController’https://blog.csdn.net/qq_38701478/article/details/88808628?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase 我的问题是/vueblog/src/main/java/com/example/demo/config/MybatisPlusConfig.java复制过来没有改@MapperScan(“com.example.demo.mapper”) 教训：不要质疑代码生成器给的类的注解。 另外注意：UserService类上不加注解；UserServiceImpl类上加@Service注解 还有一个问题是application.yml中dataSource不应该加之前写的type http://localhost:8080/user/index 查询出来空白{}他的有id=1的信息格式。这个项目里没找到index.html AccountRealm.java里的爆红 user.getstatus()爆红：the method is not defined for the type User. 首先user类中是没有这个函数的。这个东西是应该在lombok里面。 在eclipse和，maven仓库里搜索lombok,找到文件夹中的jar包，安装路径选择eclipse.exe所在的文件夹路径。 重要的是安装之后eclipse.exe所在的文件夹的ini文件最后一行自动添加了一行，这时候eclipse直接打不开了。 删除最后一行换成这两行 javaagent:lombok.jar Xbootclasspath/a:lombok.jar log.info()爆红：这是日志输出的函数，需要导入import lombok.extern.slf4j.Slf4j;，在类名上面加@Slf4j注解。 特别恶心的是eclipse有时候爆红消不掉，明明没有错/已经改好了。比如log爆红，需要剪切导入的包再粘贴一遍就好了。 他妈的，今天eclipse又卡不开了 ，删掉了昨天加的两行 打开eclipse之后又出现爆红，关掉再开运行出错 选中当前项目，右击“项目”→选择Properties，在弹出的对话框左侧列表中选择Java Build Path，如下图所示：选择Add External JARs，就可以逐个添加第三方引用jar包。 加了最新的jar没用 那些get()set()方法其实就是gettersetter,手动在User类中添加；lombok就是简化这些简单的函数 无法启动因为路径有中文 安装之后再次启动依旧爆红！ 因为eclipse不能自动刷新import的包，必须手动刷新！ 删除import的lombok保存，再粘贴保存！ 有些本身函数是调用另外一个类的，需要在另外那个类中刷新 第二天eclipse又打不开。ini文件删掉最后两行在保存在粘贴在保存就能打开 要认证后才能访问 在UserController的index页面上面添加注解@RequiresAuthentication(要认证后才能访问的接口)再启动项目，就会看到页面上的全局异常抛出的信息1&#123;&quot;code&quot;:401,&quot;msg&quot;:&quot;The current Subject is not authenticated. Access denied.&quot;,&quot;data&quot;:null&#125; 注解/包cannot resoloved to a type 因为eclipse没有下载相关maven包。 点fix project set up选择然后ok 就会下载了包然后import进来 启动失败a bean BlogService could not be found. 就是BlogService找不到 找不到因为没找到这个bean. 说明注解有问题：我的BlogServiceIpl实现类上面没加@Service 另外注意@Service只加在实现类上面，service类加这个注解没有用，不用加任何注解。 当前文件夹中打开windows powershellc窗口 注意 只是邮件是看不到这个的，要用shift+右键 但是直接这样就报错：无法加载文件 C:\Users\A\AppData\Roaming\npm\vue.ps1，因为在此系统上禁止运行脚本 需要修改权限。搜素powershell,然后执行：set-ExecutionPolicy RemoteSigned；查看执行策略：get-ExecutionPolicy vue ui没反应 查看vue的命令列表中没有ui这个命令 vue -h 必须要安装3.0以上的，老师给的代码安装的是2.9 1.$npm uninstall vue-cli -g //卸载vue-cli旧版本2.$npm install -g @vue/cli //安装新版本3.$npm vue -V //查看版本3.vue -h //查看vue cli安装的版本中有什么命令 解决博客https://blog.csdn.net/Demo__/article/details/89404235 eclipse中加入vue插件 安装报错Unable to read repository at http://downloads.genuitec.com/downloads/products/codemix/updates/cm20200407/plugins/pack.core.win_3.6.0.202001241725.jar 原因：网络不稳定 问题的解决方法是：直接把上面的连接放入浏览器直接下载，或放入下载工具进行下载好。 再把下载好的文件放入eclipse的安装目录下的plugins文件夹下。再重新安装，问题就解决了。 eclipse导入已经创建好的vue项目 file-openproject 然后看看能不能识别vue(可以) vue主要写的东西是些什么 components 页面html 公共区域需要抽取出来的 router 路由/网址路径 跳转到哪个组件/页面 views 页面开发 store-xxx.js 数据管理的地方所有组件都监听store中的内容，通过这里面的内容更新之后会通知每一个组件，达到每个组件数据之间的同步(更新)。 app.vue 入口组件这个里面的Home About按钮点击时没有刷新页面，只是将router-view里的标签切换了。比如说点击home按钮时， 1&lt;router-link to=&quot;/&quot;&gt;Home&lt;/router-link&gt; | 会在router-index.js找到path: ‘/‘， 123456 const routes = [&#123; path: &apos;/&apos;, name: &apos;Home&apos;, component: Home&#125;, 然后把对应的组件Home添加展示到app.vue中的这个标签里。 1&lt;router-view/&gt; element-ui安装 控制台vue项目文件夹路径下cnpm install element-ui –save 项目中main.js 导入依赖之后就可以在项目中全局复制使用elementui的组件代码 启动vue项目 eclipse里添加的cmd不能跳转中文路径 run npm serve报错启动不了 直接cmd到项目路径然后 npm run serve神他妈奇的eclipse,下次绝壁换idea 安装axios axios是一个基于 promise 的 HTTP 库，这样我们进行前后端对接的时候，使用这个工具可以提高我们的开发效率。 axios是在这个vueblog根目录下面进行安装的 写组件 编写页面，新建vue文件：new-other-codeMix-vue file 不需要home和about，删掉 vuelog博客思路技术栈 后端： SpringBoot Mybatis Plus shiro redis hibernate validator jwt 前端：vue element-ui axios 博客功能 用户登录 用户退出 blog主页列表(element-ui样式) blog详情页(md格式展示) blog编辑/发表(markdown格式mavon-editor编辑器) 技术对应作用 SpringBoot：基础框架，在未来易拓展，适合微服务化体系 Mybatis Plus：让项目能完成基本的增删改查操作，节省大量时间 Shiro：作为权限(验证)，使用简单配置简单 Redis: 会话等信息需要共享,Redis是现在主流的缓存中间件，适合项目 jwt: json web token因为前后端分离，所以使用jwt作为用户身份凭证 devtools：项目的热加载重启插件 lombok：简化代码的插件工具 vueelement-uiaxiosmavon-editormarkdown-itgithub-markdown-css 开发步奏java后端 SpringBoot整合Mybatis Plus(导入mybatis-plus-boot-starter依赖) 利用Mybatis Plus进行代码生成. (导入mybatis-plus-generator依赖)涉及到代码生成，导入freemarker页面模板引擎依赖：spring-boot-starter-freemarker。运行CodeGenerator(java project),输入连接的数据库中已存在的表名。就会自动生成config,entity,mapper,service相关代码文件。 整合shiro+redis(导入shiro-redis-spring-boot-starter依赖)整合shiro框架权限会话控制,整合redis会话分享 shiro整合jwt,身份校验前后端分离，，用token jwt身份校验 结果封装Result 实体校验 解决跨域问题(前后端) 开发登录接口(登录退出/login/logout) 开发博客接口(列表发表编辑) vue前端 vue整合element-ui axios(命令行安装) 页面：登录页面，博客列表页面，博客详情页面，博客编辑页面 整合 导依赖 写application.yml配置文件 链接mysql数据库 导包mysql-connector-java 配置文件mysql链接数据库 整合mybatis-plus 导包mybatis-plus-generator,spring-boot-starter-freemarker 配置文件配置myabtis plus的mapper的xml文件的扫描路径 mybatisplus的Config类中开启mapper接口扫描，添加分页插件 mybatis plus官方给我们提供了一个代码生成器，然后我写上自己的参数之后，就可以直接根据数据库表信息生成entity、service、mapper等接口和实现类。 通过@mapperScan注解指定要变成实现类(serviece.impl)的接口所在的包(mapper)，然后包下面的所有接口在编译之后都会生成相应的实现类。PaginationInterceptor是一个分页插件。 mapper.java接口里应该是要写对表格的增删改查，然后返回实体类对象的函数。mapper.xml里应该是写对应mapper.java中函数的sql语句 Service.java接口里应该封装了mapper.java里写的函数ServiceImpl.java类中应该是implements Service接口，重写接口中函数。注入Mapper接口@Autowired private UserMapper userMapper;函数重写中的实现调用mapper.java中的函数return userMapper.findByName(name); 注意只有ServiceImpl.java上面要写注解@Service 而现在整合了mybatisplus之后，以下的类/接口只需要继承mybatisplus中的接口，完全不需要自己写函数。 xxxmapper.java接口里只需要继承Mybayisplus中的接口，导入实体类blogpublic interface BlogMapper extends BaseMapper{} xxxmapper.xml里只需要对应xxxmapper.java的路径名字 xxxService.java接口里只需要继承mybatisplus接口，导入实体类blogpublic interface BlogService extends IService {} xxxServiceImpl.java类里实现接口xxxService，继承mybatisplus接口,导入实体类blog(不写自动注入的注解)public class BlogServiceImpl extends ServiceImpl&lt;BlogMapper, Blog&gt; implements BlogService {} shiro整合jwt考虑到后面可能需要做集群、负载均衡等，所以就需要会话共享，而shiro的缓存和会话信息，我们一般考虑使用redis来存储这些数据，所以，我们不仅仅需要整合shiro，同时也需要整合redis。在开源的项目中，我们找到了一个starter可以快速整合shiro-redis，配置简单，这里也推荐大家使用。而因为我们需要做的是前后端分离项目的骨架，所以一般我们会采用token或者jwt作为跨域身份验证解决方案。所以整合shiro的过程中，我们需要引入jwt的身份验证过程。 登录逻辑分析： 用户用用户名 密码登录 后端进行校验密码，如果正常 就生成jwt-&gt;然后返回给用户，那么用户就能拿到Jwt的身份凭证。 后端进行校验密码，如果异常 就抛出异常-&gt;全局异常捕获 登录成功的用户去访问其他资源受限的接口(链接)时，要带上jwt身份凭证，才知道访问接口的用户是谁。 用户访问后端接口逻辑分析: 访问之前经过jwt的过滤器JwtFilter有jwt:交给shiro登录处理，使用shiro的securityManager进行登录处理。shiro处理过程中,如果异常(过期、秘钥不对)-&gt;抛出异常-&gt;全局异常处理器捕获异常进行拦截-&gt;返回json数据给前端。shiro处理过程中,如果正常-&gt;访问接口xxxController 无jwt:注解过滤(有权限才能用，权限是交给这个注解处理)：接口xxxController中函数头上的@RequiresAuthentication访问接口xxxController无权限-&gt;抛出异常-&gt;全局异常捕获有权限-&gt;访问接口xxxController 导包shiro-redis-spring-boot-starter hutool-all(工具) jjwt ShiroConfig中重写sessionManager securityManager AccountRealm中执行资源授权逻辑和认证逻辑(用户名/密码判断)，获取他的一个权限信息封装成AuthorizationInfo返回给shiroConfigsupports：为了让realm支持jwt的凭证校验doGetAuthorizationInfo：权限校验doGetAuthenticationInfo：登录认证校验 ShiroConfig中：在ShiroFilterChainDefinition中，我们不再通过编码形式拦截Controller访问路径，所有的路由都需要经过JwtFilter这个过滤器，然后判断请求头中是否含有jwt的信息，有就登录，没有就跳过。跳过之后，有Controller中的shiro注解进行再次拦截，比如@RequiresAuthentication，这样控制权限访问。 JwtUtils是个生成和校验jwt的工具类，其中有些jwt相关的密钥信息是从项目配置文件中配置的 AccountProfile：这是为了登录成功之后返回的一个用户信息的载体， JwtFilter:createToken：实现登录，我们需要生成我们自定义支持的JwtTokenonAccessDenied：拦截校验，当头部没有Authorization时候，我们直接通过，不需要自动登录；当带有的时候，首先我们校验jwt的有效性，没问题我们就直接执行executeLogin方法实现自动登录onLoginFailure：登录异常时候进入的方法，我们直接把异常信息封装然后抛出preHandle：拦截器的前置拦截，因为我们是前后端分析项目，项目中除了需要跨域全局配置之外，我们再拦截器中也需要提供跨域支持。这样，拦截器才不会在进入Controller之前就被限制了。 统一结果封装Result @Data 序列化(implements Serilizable)为了前后端对接数据方便。后端返回数据给前端要有一个统一的格式，前端就能知道后端返回的结果数据是正常的还是异常的。如果获取到的是异常的数据，前端就可以弹窗给用户。 code(200/400)，结果消息(操作成功/操作失败)，结果数据 静态方法：接口访问成功会吧数据字段封装成result(new Result对象，吧数据填到对象里)return给前端 全局异常处理捕获异常，返回统一格式的json数据@ExceptionHandler(value = RuntimeException.class)来指定捕获的Exception各个类型异常 ，这个异常的处理，是全局的，所有类似的异常，都会跑到这个地方处理。@ControllerAdvice表示定义全局控制器异常处理，@ExceptionHandler表示针对性异常处理，可对每种异常针对性处理。@Validated 校验错误异常处理 ShiroException：shiro抛出的异常，比如没有权限，用户登录异常IllegalArgumentException：处理Assert的异常MethodArgumentNotValidException：处理实体校验的异常RuntimeException：捕捉其他异常 实体校验entity当我们表单数据提交的时候，前端的校验我们可以使用一些类似于jQuery Validate等js插件实现，而后端我们可以使用Hibernate validatior来做校验。我们使用springboot框架作为基础，那么就已经自动集成了Hibernate validatior。@NotBlank(message = “昵称不能为空”)private String username;@NotBlank(message = “邮箱不能为空”)@Email(message = “邮箱格式不正确”)private String email; UserController:使用@Validated注解方式，如果实体不符合要求，系统会抛出异常，那么我们的异常处理中就捕获到MethodArgumentNotValidException。 跨域问题JwtFilter: 在进入逻辑之前跨域处理preHandle直接在后台进行全局跨域处理CorsConfig 登录/退出接口/login /logout登录的逻辑其实很简答，只需要接受账号密码，然后把用户的id生成jwt，返回给前端，吧jwt放在header里面，在jwt需要延期的时候，不需要再调用另外的接口，而是判断如果header里存在jwt的话，就进行刷新就行了根据用户名去查找密码再匹配 （DTO就是数据传输对象(Data Transfer Object)的缩写。 DTO模式，是指将数据封装成普通的JavaBeans，在J2EE多个层次之间传输。 DTO类似信使，是同步系统中的Message。 该JavaBeans可以是一个数据模型Model。 ） 博客接口/blogs /blog/{id} /blog/edit(@RequiresAuthentication)博客编辑页面是添加和编辑都在这里，根据传过来的id判断，有id就是编辑，无id就是添加 前端路由权限拦截 判断哪些路由需要权限（/add /edit）meta: { requireAuth: true}, 路由前置拦截axios在发起请求之前有一个前置拦截判断该路由的meta里信息如果是true的话就需要权限，然后判定有无token。如果有Token就跳转到下一个路由 next（）；如果没有token-&gt;跳转到login界面 但是项目中没有用跳转用的是禁止，直接访问没有跳转到login 为了让这个错误弹窗能运用到所有的地方，所以我对axios做了个后置拦截器，就是返回数据时候，如果结果的code或者status不正常，那么就有对应的弹窗提示。 登录页面-登录逻辑 前端页面提示需要输入用户名和密码 前端页面提交时axios发起请求(axios发起请求的时候都会有一个域名/当前页面url) 后端进行密码校验，如果正常，生成jwt，返回给用户 从返回的结果请求头中获取到token的信息，然后使用store提交token和用户信息的状态。完成操作之后，我们跳转到到了/blogs路由，即博客列表页面。 存储token，用的是localStorage; 存储用户信息，我们用的是sessionStorage。 博客列表页面 页面头部我们需要把用户的信息展示出来，因为很多地方都用到这个模块，所以我们把页面头部的用户信息单独抽取出来作为一个组件。 头部的用户信息，应该包含三部分信息：id，头像、用户名，而这些信息我们是在登录之后就已经存在了sessionStorage。因此，我们可以通过store的getters获取到用户信息。 上面代码created()中初始化用户的信息，通过hasLogin的状态来控制登录和退出按钮的切换，以及发表文章链接的disabled，这样用户的信息就能展示出来了。 退出逻辑：在methods中有个logout()方法，逻辑比较简单，直接访问/logout，因为之前axios.js中我们已经设置axios请求的baseURL，所以这里我们不再需要链接的前缀了哈。因为是登录之后才能访问的受限资源，所以在header中带上了Authorization。返回结果清除store中的用户信息和token信息，跳转到登录页面。 项目综述SpringBoot+vue的博客项目基本功能：用户登录页面，用户退出，blog主页列表(element-ui样式)， blog详情页(markdown格式展示)，blog编辑/发表(markdown格式mavon-editor编辑器)使用技术：SpringBoot作为基础框架，Mybatis Plus：让项目能完成基本的增删改查操作，省去自己写mapper、service, Shiro：权限校验、登录认证，Redis: 储存shiro的权限数据和会话信息，jwt: 作为前后端分离的用户身份凭证；vue项目使用：element-ui，axios，mavon-editor，markdown-it，github-markdown-css功能逻辑：使用用户名密码登录axios发起请求，后端进行密码校验，如果正常，生成jwt，返回给用户。从返回的结果请求头中获取并提交token的信息跳转到blog主页列表。如果异常，全局异常捕获，页面弹窗异常信息。Blog主页做了页面头部将用户的信息展示出来，element-ui时间线样式做列表，还有分页。Blog详情页使用插件markdown-it将markdown格式的内容渲染展示出来。使用mavon-editor编辑器进行blog的编辑，点击按钮提交表单。 学习经历您好，我2018年进入西交利物浦大学信息与计算科学专业学习至今两年。主要在学校中学习了java,数据结构，算法，mysql数据库，操作系统，离散数学。在项目中使用的springboot，shiro,mybatis，mybatisplus的框架技术和vue和html都是通过看视频看博客自学的 项目项目的话是完整的做过一个springboot和vue的前后端分离的简易博客系统。目前是完成了用户登录页面，用户退出，blog主页列表页面(element-ui样式)， blog详情页(markdown格式展示)，博客的发表和编辑页面。博客详情页面里可以进行blog的编辑，在博客主页列表页面可以进行博客的发表以及用户的退出或者登陆。 后端java的项目里面完成登录接口和博客接口的开发，具体整合了mybatis plus让项目能完成基本的增删改查操作。整合shiro实现用户登录验证和授权，整合redis用来储存shiro的权限数据和会话信息jwt: 作为前后端分离的用户身份凭证；前端的vue项目做了用户登录页面，blog主页列表页面，blog详情页，和博客的发表和编辑页面。具体整合了element-ui和axios,博客的发表编辑页面用的是mavon-editor编辑器，可以让用户在编辑过程中看到发表之后的markdown样式的展示出来的样子。 擅长和主要使用的技术栈有Java编程语言，还熟悉SpringBoot，MyBatis和MyBatisPlus的框架技术，熟练使用mysl的增删改查。掌握html vue的前端开发技术。现在是用的eclipse作为开发工具。]]></content>
      <categories>
        <category>springboot</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java考试复习总结]]></title>
    <url>%2F2019%2F12%2F24%2Fjava%E8%80%83%E8%AF%95%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[单词提取 encapsulation 封装 length 有g //另：数组求长度 xxx.length; 字符串求长度 xxx.length(); mantissa 小数部分 基础知识数据类型（整数都有一位是表示正负符号位） byte:1byte; short:2byte; int:4byte; long:8byte float:4byte(整数1byte,小数点后最多7位); double:8byte(整数10位，小数点后最多15位) char:2byte boolean:至少1byte 去年考试题目1.1 Message:Variables: messageText, sender, sendTime, readprivate String messageText; private String sender; private LocalDateTime sendTime; private boolean read;Constructor: Message(String messageText, String sender, LocalDateTime sendTime, boolean read ){ this.messageText = messageText; this.sender = sender; this.sendTime = sendTime; this.read = read; }Encapsulation：public void setMessageText(String messageText) //set，get,小写，后面第一个字母大写{ this.messageText = messageText; } public String getMessageText() { return this.messageText; } public String toString() { //if() return sender + &quot;send&quot; + messageText + &quot;at&quot; + sendTime.toString() + &quot;read or not:&quot; + read; } 1.2 public static void main(String[] args) { double[] numbers= new double[10]; fillArray( numbers); printArray( numbers); System.out.println(“The minimum value is:”+ findMinimum(numbers)); reverseArray( numbers); printArray( numbers); } //fill the array with double values / /use a Scanner to get input from the keyboard public static void fillArray ( double[] toFill) { Scanner s = new Scanner(System.in); //double temp; for(int i= 0; i&lt; toFill.length; i++) { toFill[i] = Double.parseDouble(s.nextLine()); //重点：String转成其他类型不能直接（double）xxx转换； 只能用Xxx.parseXxx(String); 注意Integer.parseInt(String); } } //print the contents of the array to the console, showing the index and value of //each element on a new line public static void printArray(double[] toPrint) { for(int i= 0; i&lt; toPrint.length; i++) { System.out.println(toPrint[i]); } } ///reverse the array. Do not need to display public static void reverseArray(double[] toReverse) { double [] temp = new double[toReverse.length]; //重点:新建数组不确定长度时 xxx.length //double [] temp = toReverse; //重点:建立和传入参数相同的数组时 不能用次方法（这种方法会让新建的副本数组跟随原数组变化而变化(后面要将原数组翻转，会改变源数组的值),只能先遍历出原数组的内容赋值到新数组中，再进行原数组改变值） int j = toReverse.length -1; for(int i= 0; i&lt; toReverse.length; i++) { temp[i]= toReverse[i]; } for(int i= 0; i&lt; toReverse.length; i++) { toReverse[i]= temp[j]; j--; } } //return the minimum value of the array public static double findMinimum(double[] array) { double minimum = 0 ; double temp; for(int i= 0; i&lt; array.length -1; i++) { temp = array[i]; if(temp &gt; array[i+1]) { minimum = array[i+1]; } else if(i==0) //重点：只需要考虑第一次 { minimum =temp; } } return minimum; }]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[计算机系统]]></title>
    <url>%2F2019%2F12%2F22%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[CSE101 Q and A 内容###计算机系统4层体系结构 用户代码，软件，操作系统，硬件 （前二为程序员，用户层面） 硬件 硬件举例： CPU，内存，硬盘hard disk, 键盘， 屏幕display screen 操作系统 将硬件系统的功能带出来 操作系统包围住硬件系统的好处： 易于编程，保护系统，公平和效率使用系统 组成成分 输入，输出，内存，CPU CPU ALU 中央处理器 central processing unit 进行计算和其他操作 运算器 arithmetic logical unit ALU 和 control unit 是CPU两个主要元件 处理器processor（CPU）遵循软件的指令处理数据 CPU只能执行加载进内存的指令 内存 系统内存 储存着CPU处理，存取的数据 次要存储： 硬盘hard disk, CD, DVD 系统内存中存储着 程序和数据 program and data ，由二进制表示的 接上，其中计算机知道哪里读取指令，哪里读取数据，虽然指令和数据都是二进制 输入输出设备 输入设备： 鼠标，键盘，扫描器Scanner 另：输入硬件设备将数据翻译成计算机能处理的形式 输出设备： 显示器Monitor, 扬声器Speaker, 打印机Printer WIMP 和 OS 主要是输入和输出设备： window, icon, menu, pointer （大概是电脑界面点击图标的意思） WIMP是操作系统OS在四十年中最重要的革新 操作系统OS需要分配公平的被保护的资源： 因为多线程容易死结deadlock, 同时保护硬件（用户不合理操作时） OS支持多任务操作时的功能： 内存管理，安全，分配CPU给每个程序 OS提供访问给网络设备facility: 通过API应用程序界面 ，例如socket interface 普通用途机器有OS特殊用途机器没有OS，只能高效率的做特定的事情 学习层面 程序运行时，计算机内部和程序底层–汇编 分层分区的好处 易于理解，易于设计，易于改变 服务器 Servers 通过 web-network-cloud 服务器是专门用于存储大量PC上数据和程序的工作平台 Dumb terminal:哑终端，一切程序交给主机做，主机不能做任何处理 向下兼容 Downward Compatibility 新软件能在旧硬件上运行 高速集成电路硬件描述语言- VHDL摩尔律 电路大小缩减一半 几个不同的注重 科学计算—Computation 计算 商业计算—Data 数据 个人计算机—Interaction 交互 Input-Process-Output模型 是数字电脑的基础结构 软件编程控制着Process 硬件，软件，（被操作的）数据 ，这三个原件实施Input-Process-Output模型 和 von Neumann 模型 其中von Neumann 模型是 Input-Process-Output模型 中的Process部分Process部分: Processor（应该是CPU） 和 Memory 互相连接传递数据interconnect CPU的读取速度快于主内存，也就是说主内存的速度不快，会拖慢整体交换链接数据的速度，CPU读取速度再快也没有用 von Neumann的机器中 数据和指令 共享同一内存 混合存放 Harvard结构 将数据和程序分离开存储提高了传输速率transfer rate 和生产力throughput但是数据和指令需要单独的存储器single reservoir像是指令缓存instruction cache 数据缓存data cache 指令集instruction set 没有指令标准 standard instruction 对于特殊用途的机器，指令集instruction set通常是固定的 高级编程语言HLL 优势： 用户友好， 编程方便 举例： java c c++ python 程序编译过程 Edit 变成HLL — Compile变成二进制对象文件 —-Link 变成可执行文件 —- Load 最后运行 Compiler编译器: HLL变成机成机器码 Assembler汇编器： 机器指令助记符变成二进制 另：汇编器将标签和内存地址链接在一起 Interpreter解释器： HLL指令解码decode变成中间代码Intermediate code,还是会变成机器码解释器在程序切换快，程序运行快，程序转移到另外平台上时比编译器更好用 Inline assembler内联汇编器： 可以在汇编段中调用c程序库中的函数 用户使用计算机时内部的工作流程 用户使用计算机系统算题的一般流程: ①通过系统操作员建立帐号，取得使用权。帐号既用于识别并保护用户的文件(程序和数据)，也用于系统自动统计用户使用资源的情况(记帐，付款)。 ②根据要解决的问题，研究算法，选用合适的语言，编写源程序，同时提供需处理的数据和有关控制信息。 ③把②的结果在脱机的专用设备上放入软磁盘，建立用户文件(也可在联机终端上进行，直接在辅助存储器中建立文件，此时第四步省去)。 ④借助软盘机把软盘上用户文件输入计算机，经加工处理，作为一个作业，登记并存入辅助存储器。 ⑤是要求编译。操作系统把该作业调入主存储器，并调用所选语言的编译程序，进行编译和连接(含所调用的子程序)，产生机器可执行的目标程序，存入辅助存储器。 ⑥要求运算处理。操作系统把目标程序调入主存储器，由中央处理器运算处理，结果再存入辅助存储器。 ⑦运算结果由操作系统按用户要求的格式送外部设备输出。 计算机内部工作(④~⑦)是在操作系统控制下的一个复杂过程。通常，一台计算机中有多个用户作业同时输入，它们由操作系统统一调度，交错运行。但这种调度对用户是透明的，一般用户无需了解其内部细节。 用户可用一台终端，交互式的控制③⑦的进行(分时方式);也可委托操作员完成③⑦，其中④~⑦是计算机自动进行的(批处理方式)。批处理方式的自动化程度高，但用户不直观，无中间干预。分时方式用户直观控制，可随时干预纠错，但自动化程度低。现代计算机系统大多提供两种方式，由用户选用。 代码分享方法 资源水平的子程序， 宏程序库macro libraries（问题： 谁维护，谁拥有） 预先翻译，可再定址的二进制库 动态库，动态link 库library 库可以link到程序代码，但不能修改 对于动态库，动态link有一个事实标准de-facto standard : Microsoft active 数据单位 bit,byte encode编码ASCII表用了7bit = 2的七次方大小表示一位，第一位表示正负 256bytes数据 可以存入 8bit system 内存地址从0000到00FF ： 1byte* (F16+F1)= 1516+151=256 bytes可以存入16bit system 内存地址从0000到007F ：2byte（716+F1）= 2（716+151）=256 bytes 编码表 ASCII表一位=1byte=8bit;1010 0101 1111 1000 = 16bytes 二进制文件一位=1bit; 1010 0101 1111 1000 = 16bits = 2bytes ASCII表最常用，EBCDIC现在已经不用了，被替代了 ASCII表不能编码除了英语和一些欧洲国家语言之外的字符 ASCII表分为字符和指令字符 printing and control characters 对于不同的表，编码速度没有差异 IEEE754 标准是最广泛使用的浮点转换二进制计算的标准 octal notation 是八进制声明变量时 告诉编译器预留内存空间 告诉编译器变量类型 线 bus 地址线，数据线，控制线 bus线的速度达不到（不匹配）CPU和内存交换的速度,就会让整体速度拖慢 bus一次一条线只能传一项item数据 协处理器coprocessor math, graphic 数学和图像应用程序 微处理器microprocessor 处理接收到的大量信息 存在于计算器，手机，平板，手表，MP3，照相机中 系统时钟system clock 系统时钟控制了所有计算机操作的执行速度 文件系统执行任务时的资源消耗 CPU时间资源，内存，硬盘空间 CPU time, memory, disk space 机器循环machine cycle 重要，注意是指令 过程： 获取指令–解码指令–执行–存储结果 main steps: fetch instruction–decode instruction–execute–store RISE CISE RISE的指令描述简单， CISE指令描述字多 processors that support fewer instructions than do SISC chips 指令执行寄存器 IP,IR,MAR,MBR 不同指令的获取fetch语句是相同的 不同指令的执行execute语句不同 CPU状态标志符Flag Zero flag： 为0，zf=1 Sign flag: 为负数 首位1， sf=1 Carry flag： 产生进位或退位为，cf=1 Overflow flag: 溢出， of=1 EFlage: CMP AL,BL (AL-BL) D flag: direction of processing O flag: Arithmetic overflow error 这些flag在指令执行之后才标记 CMP 后会改变flag，不是check 指令 Pentium奔腾指令集的指令从1到15字节的宽度（不确定），来加速指令解码 指令包含三个： 操作指令，操作数的数据类型，操作数的地址和结果 机器指令用不同的字段Distinct bit field来编码所需的操作内容 寄存器和寄存器之间的运算是最快的 函数 printf: 先进栈的最后打印出来 push顺序：先数字-再占位符-最后句子 call函数时：把EIP（指令指针）中的地址push到栈中， 再把函数地址放进EIP ret时： pop出最后存入栈的地址，放入EIP中 栈的框架下储存的数据类型： 子程序的参数，ret地址，EBP栈指针，局部变量 BCD码：将十进制的每一位0-9的数字转换成四位的二进制码 BCD码：将十进制的每一位0-9的数字转换成四位的二进制码 321的BCD码： 0011 0010 0001 321的二进制码： 101000001 1 byte(8bit)只能表示0-99（99就是 1111 1111） BCD的经济性不如二进制码binary（位数更多）， BCD计算更复杂， 但BCD和字符见的转换更加容易； 二进制表示更容易理解，BCD更容易理解用于某些业务应用程序 2’s complement 补码 正数补码不改变 负数（符号位1）补码： 符号位不变，其余位取反后加一 2’s complement会有溢出的情况： 两个整数相加变成负数 赞成者Pros: 基于two-state technology 易于实现 反对者Cons: 对于人难以理解 带符号整数相加会发生溢出怎么办： 用of sign检测:相加前后的of应该相同，如果不同就溢出了（不太清楚，可能是相加后同为负数或整数） 带符号整数减法是加法的另一种形式，同样也会溢出。加法溢出，减法溢出 10’s complementary convention十进制补充约定 n位数字表示为10’s complementary convention 是基于模module 10 十进制的互补表示: 0到499表示0到499， 500到999表示-500到-1 （-一千减x） 同样有溢出： 347+230= 577大于499溢出 ，577= -（1000-577）=-423 基础类型的bit大小: -2^(x-1 bit次方) 到 2^(x-1 bit次方)-1, 都要去掉符号位 byte: 8bit ,1byte short: 16bit ,2byte , -2^15到2^15 -1 long: 64bit ,8byte int: 32bit ,4byte IEEE754 1bit正负 8bit指数 23bit小数有效位数 ，不存小数点 把二进制小数 变成十进制小数：指数8位- 128+1 = 8位-10000000（2^7，8位）+1 = 整数 ，Excess-127格式小数23位： 1.xxxxxxxx （不用转换）计算 2^指数*1.xxxxxx NaN规范：指数位127，小数位不是0，此时NaN(not a number) 其他看不懂：单精度指数过剩excess notation 127;双精度指数过剩excess notation 1023 数据存储器 寄存器register（8bit,在CPU中） 到 缓存cache 到 内部内存main memory（RAM,ROM） 到 硬盘disk 越来越慢，空间越来越大，价格越来越便宜； 寄存器最快最小最贵 数据获取access的方法：顺序存储sequential storage会减慢数据检索retrieval的进程 Main memory 计算机内部，断电消失 RAM随时存取储存器：分两个DRAM动态，SRAM静态 ROM只读存储器 Cache高速缓存存储器 独立保存，断电不消失 硬盘 : 检索硬盘副本显示到屏幕上，如果检索之后不被修改，源文件不会被覆盖 光盘 ： 读道track U盘 电路combinational组合 sequential数列 logic circuits 组合逻辑电路没有记忆区memory ，数列逻辑电路有记忆区 卷子中的待解决问题 —今年只有选择题和汇编无问答 What is the mechanism being used to pass parameters to the C library function Answer the following questions based on IEEE 754 standard.(4marks each)a) What is the largest positive number represented by IEEE 754 single-precision format?b) What is the encoding of the number -123.625 in IEEE 754 single-precision format?c) What is the smallest normalisedpositive number represented by IEEE 754 single-precision format? 内联汇编 _asm{} 记住：push一次esp+4; 每次call完结算前面push次数， add esp,4n xchg交换值指令： xchg eax, [sei+4] 至少要有一个寄存器 调用： call printf ,call scanf_s 遍历数组存首地址 lea esi, intArray循环中 add eax, [esi]add esi, 4 mov esi, 0循环中 add eax, intArray[esi]inc esi]]></content>
      <categories>
        <category>记忆性学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[游戏和开源项目学习]]></title>
    <url>%2F2019%2F11%2F27%2F%E6%B8%B8%E6%88%8F%E5%92%8C%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[初心 想先做像页游那样的游戏，任务在家园里移动。感觉是可以实现的。]]></content>
  </entry>
  <entry>
    <title><![CDATA[mySQL]]></title>
    <url>%2F2019%2F09%2F14%2FmySQL%2F</url>
    <content type="text"><![CDATA[19.9.14安装 mysql5.7安装以及配置环境（注意：官网安装非常慢，打开迅雷复制官网下载网址链接下载安装）https://www.bilibili.com/video/av66542221 19.9.15 语句超级容易输错单词,有无s什么的….. 19.9.16 感觉有点枯燥呢，加油]]></content>
      <categories>
        <category>数据库sql</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[学习计划与心得]]></title>
    <url>%2F2019%2F09%2F14%2F%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92%E4%B8%8E%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[19.9.14 希望每天保持八小时的有效学习时间，坚持记录笔记，多任务学习 英语老老实实背单词 文件要装好 19.9.16 效率挺低的完全没办法做到做任务学习 19.9.17 备考雅思单词：会认与会写。 A4纸折八列，写单词和意思 ，折起来背 19.9.29 很久没有记录了，平时真的没什么时间，英语也很差，代码经常出问题，还是缺少练习 20.2.23 小匠笔记：学东西一定要先看官方网址文档。最开始学东西先用起来，不要死磕，之后多用就会了 创建包来隔离不同的业务 参数多于两个就要把他封装成对象 全部文件/包放在启动类所在包下面 初了解一个应用，一定去看它的官方文档]]></content>
      <categories>
        <category>学习计划</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java基础记录的笔记]]></title>
    <url>%2F2019%2F09%2F13%2Fjava%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[安装 安装netbeans8.2 IDE 和jdk1.8.0 百度云传不了，放在u盘里的 注意如果netbeans出错了就把相关文件夹删干净（360强力删除）之后重装，会省时省力很多。 19.9.13数组定义数组 int [] arr = new int []{1,2,3,4,5};int [] arr = {1,2,3,4,5};int [] arr = new int [8] 自定义函数要写在主类class Main里，public static void main 的下面；数组作为自定义函数的参数时要写括号：public static int add(arr[])；main函数里调用自定义函数时参数只用写数组名（此时调用数组第一个数据的地址）： add(arr) ；而且调用函数的返回值用一个变量装载一下 ：int b = add(arr) 各种功能都写成函数再调用，不要写在主函数里 改变数组的自定义函数：返回类型为void（改变指针） 表 数组可以作为表： 当数据之间存在对应关系时，通过一方可以查询到另外一方。ex: 通过数组的索引查表（查找数组中的内容）,(这样比switch if 条件判断方便) 数组选择排序 从第一个依次向后比较，替换第一个；在从第二个依次向后比较，替换第二个….（小数向前挪动）12345678910111213141516171819202122232425262728293031323334353637 public class Main &#123; public static void main(String[] args) &#123; int arr[] =&#123;12,9,23,77,12,34&#125;; rank(arr); printArr(arr); &#125; public static void rank(int []arr ) &#123; for(int a =0; a&lt;arr.length-1; a++) &#123; for(int b = a+1; b&lt;=arr.length -1; b++) &#123; if(arr[a]&gt; arr[b]) &#123; int temp= arr[a]; arr[a]= arr[b]; arr[b]= temp; &#125; &#125; &#125; return ; &#125; public static void printArr( int arr[]) &#123; for(int x=0; x&lt; arr.length; x++) &#123; if(x == arr.length -1) System.out.println(arr[x]); else System.out.print(arr[x] + &quot;,&quot;); &#125; return; &#125;&#125; 数组冒泡排序 1-2比，2-3比，3-4比…(将每次比较的大值放在后面再和下一个数比较)，再重复1-2比，2-3比..1234567891011121314public static void rank(int []arr ) &#123; for(int a = 0; a&lt; arr.length-1; a++) &#123; for(int b = 0; b&lt;arr.length-1-a; b++) //【-a】这里为了实现每一次横向比较时，比较的次数都会随着横向比较次数的增加而递减（因为每次横向排序的末尾最后一个一定是最大的数，所以下一次横向比较时不再比较最后一个数） &#123; if(arr[b]&gt;arr[b+1]) &#123; int temp = arr[b]; arr[b]=arr[b+1]; arr[b+1]=temp; &#125; &#125; return ; &#125; &#125; 代码抽取 以上两个排序中的交换数组中数字位置部分的代码块重复，可自定义一个新功能，再调用（如冒泡排序中： swap(arr, b, b+1);）,方便使用提高复用性123456public static void swap(int arr[], int a, int b) //注意未知的都是参数： 数组不知道，交换位的角标不知道 &#123; int temp = arr[a]; arr[a]= arr[b]; arr[b] = temp; &#125; 使用程序包 以上数组排序功能都可在程序包内（需要自己下载），开发时直接import程序包，再调用就可以，不要自己写功能 19.9.14数组普遍查找 普遍查找数组中元素(遍历数组)，返回值为int(角标):return x；如果没有此元素，return -1 (代表不存在的情况) 二分查找 1、定义min、max、mid角标；2、比较mid和查找数据大小： 数据大，min=mid+1;数据小, max=mid-1; 3、循环；4、循环中判断查找的数据是否存在(存在条件max min之间有距离：min &lt;= max) 或者判断存在条件作为while循环条件，会更加简洁1234567891011121314151617181920212223242526272829public static void main(String[] args) &#123; int arr[] =&#123;9,12,15,24,36,41,59,68&#125;; rank(arr); int a =binarySearch(arr, 41); System.out.println(&quot;第&quot;+(a+1)+&quot;个是:&quot;+arr[a]); &#125; public static int binarySearch(int arr[], int key) &#123; int min, max, mid; min=0; max = arr.length -1; mid = (min + max)/2; while(arr[mid] != key) &#123; if(arr[mid]&lt; key) &#123; min = mid +1; mid = (min + max)/2; &#125; else if(arr[mid]&gt; key) &#123; max = mid -1; mid = (min + max)/2; &#125; //判断查找元素是否存在 if(max&lt;min) return -1; &#125; return mid; &#125; 19.9.18面向对象 对象：属性（数值，是变量）+ 行为（功能，是函数） 19.9.29数组 创建功能：传入数组参数，返回数组参数主函数中 &gt; + String arr[] = new String[6];public static String[] change (String [] arr) //定义中类型和参数都有括号 return arr; //返回值无括号主函数中接收返回值时直接 &gt; + String name [] = change(arr) //调用传值无括号 Scanner 首先在package 下面加上 import java.util.Scanner; Scanner a = new Scanner(System.in);int num = a.nextInt(); Scanner b = new Scanner(System.in);String name = b.nextLine();可见： 先用一个创建的对象接收输入的值，再定义一个新的变量 接收输入对象 改变类型之后的值 2019.10.5private static private不可以和static同时用 private：对象的属性，构造函数； 对象的行为(功能函数)一般用public让调用者调用？ static:静态不能访问非静态（静态随类先加载） 单例模式———创建本类中对象饿汉式：一上来就创建对象 class Teacher{ private String name; private static Teacher single = new Teacher(“xx”);//创建本类中对象 private Teacher(String name) //private构造函数以及函数都不可以被调用，只能在类中调用，也就是说当private 属性和行为和构造函数时，都要设置相应的public函数 {this.name = name;} //记得加this. 表示此对象中的属性 public static Teacher build() { return single;} //主函数中调用此public函数完成对象a的指向 本类中创建的对象（单例） public String getname() {return single.name;} } public static void main(String[] args) {Teacher a = Teacher.build(); System.out.println(a.getname()); } 懒汉式：先创建对象指针，再在创建单例函数中创建对象（开辟空间），使用构造函数 class Teacher{ private String name; private Teacher(String name) {this.name = name;} private static Teacher single = null; //一定注意指针先赋值为空指针 public static Teacher build(String name) { single = new Teacher(name);return single; //返回已经构建好的对象指针？ } public String getname() {return single.name;}} public static void main(String[] args) {Teacher a = Teacher.build(&quot;xx&quot;); System.out.println(a.getname()); }]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>bug</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客文章编辑格式]]></title>
    <url>%2F2019%2F09%2F09%2F%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E7%BC%96%E8%BE%91%E6%A0%BC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[插入格式插入链接 超链接： []链接名+()网址Lucifinil’s blog 自动链接： &lt;&gt;网页地址Lucifinil’s blog https://lucifinil-x.github.io/ 插入图片 本地图片：!+[]图片名+()网址 或()/next主题文件夹下/images/图片名 url链接图片： ！名 字体效果 斜体字体: * * 中添加文字 加粗字体: ** ** 中添加文字 斜体加粗字体： * * 中添加文字 横线分行 加上横线 : 三个 - 再回车后加内容 引用 单行引用: ``中加内容 多行引用： 三个点中加内容或代码块 123456多行引用： &lt;html&gt; &lt;head&gt; &lt;title&gt;我是标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt; &lt;/html&gt; 引用文章 : &gt; +内容 隐藏 隐藏内容需阅读全文: ““（自由设置）或在主题config里 设置123auto_excerpt:enable: truelength: 50 sublime 和 typora都可以同时编辑文章，typora加图片方便]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>格式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lucifinil的博客计划~]]></title>
    <url>%2F2019%2F09%2F07%2Flucifinil%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[搭建就做了好几天，还有一些主题优化没有成功和待完成的~~ 未成功 添加背景图片 背景及点击动态 添加字数检索和阅读时间 待完成 添加live 2d看板娘 改变字体 添加扫码关注的公众号图片 在github上备份博客 注意事项 每周将博客文章上传更新至百度云备份 每天坚持把心得学习内容总结成笔记更新博客文章 写博客用的软件 sublime text, 在d盘]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[搭建博客]]></title>
    <url>%2F2019%2F09%2F07%2F%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[404问题和网页加载出来没有框架的问题 删除blog主文件下的第一个xxx.git文件夹（可用360强力删除） 修改回上一步之前修改的内容： 比如在config里本来是有#隐藏的文件路径， 实际上next主题并没有生成这个路径。 那么把自己新建的文件删除 把#在config里加回去 blog主文件夹下右键打开 git bash here hexo clean,hexo g,hexo s 三部曲 /c/Users/A/AppData/Roaming/npm/hexo: line 12: node: command not found 环境变量是在操作系统中一个具有特定名字的对象，它包含了一个或者多个应用程序所将使用到的信息。例如Windows和DOS操作系统中的path环境变量，当要求系统运行一个程序而没有告诉它程序所在的完整路径时，系统除了在当前目录下面寻找此程序外，还应到path中指定的路径去找。用户通过设置环境变量，来更好的运行进程。环境变量一般是指在操作系统中用来指定操作系统运行环境的一些参数，比如临时文件夹位置和系统文件夹位置等。 搜索控制面板 ——&gt; 系统 ——&gt; 高级系统设置 ——&gt; 环境变量 ——&gt; 下面的框系统变量里 Path编辑： 本机系统自带的：%SystemRoot%\system32;%SystemRoot%;%SystemRoot%\System32\Wbem; 自己需要添加的：D:\blog\node_modules\hexo\binD:\MinGW\MinGW\binC:\Program Files\nodejsD:\blog\node_modules\hexo\binC:\Program Files\MySQL\MySQL Server 5.7\bin （mysql的与hexo无关） 千万不能自己写一个path将系统自带的覆盖掉，覆盖了就自己先添加系统的。 4000端口占用 打开cmd 查询占用：netstat -aon|findstr “4000” 查看对应占用进程：tasklist|findstr “xxxx” 杀掉对应进程：taskkill /f /t /im node.exe 然后关掉cmd会出现git bash hexo s虽然搭建成功 但是无法用ctrl+c退出 右上角关闭之后再hexo s虽然报错端口占用 但是本地网页已经更新 本地页面更新，但部署的网页不更新？ 可能原因1（不用）：4000 端口占用 localhost:4000 端口被占用，可执行 hexo s -p 5000 修改成5000 端口 可能原因2（基本都是这个）： 刷新问题 网页输入网址或f5刷新，hexo g, hexo s, hexo d多来几遍 解决步奏【高亮！】： hexo g, hexo s生成本地4000页面，右上角关闭，hexo d，进入网页，没有刷新，按F5刷新，就出来了 YAMLException: end of the stream or a document separator is expected at line 4, column 13: 更新失败，博客上直接没有这篇文章 原因：hexo博客规则改了，之前catpgories可以放几个，选择只能写一个了；catogories: xxx 之间要加空格，而且不能用 -xxx 修改了所有没更新出来的文章分类那里，都只分一个类了 文章点进去加载不出来 因为文章中图片太大，导致整个文章完全加载不出来。 windows文件路径与hexo部署链接不同导致网页和本地图片不能同时显示 windows路径是’&#39; hexo部署路径是’/‘ 解决：用路过图床生成的url链接替换图片路径 https://imgchr.com/lucifinil/albums路过图床网址 TypeError [ERR_INVALID_ARG_TYPE]: The “mode” argument must be integer.https://blog.csdn.net/qq_42138454/article/details/106210421 原因 node.js版本太高(14.4) 解决 电脑上搜索node，卸载，下载12.18并安装 注意 window上node不支持命令行操作，所以用软件自带的卸载。而且安装新版本之后不用再配环境。]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>bug</tag>
        <tag>解决办法</tag>
        <tag>搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F09%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
