{"meta":{"title":"Sanctuary","subtitle":null,"description":null,"author":"Lucifinil","url":"https://lucifinil-x.github.io","root":"/"},"pages":[{"title":"分类","date":"2019-09-08T10:05:38.000Z","updated":"2019-09-08T10:07:01.665Z","comments":true,"path":"categories/index.html","permalink":"https://lucifinil-x.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-09-08T09:54:57.000Z","updated":"2019-09-08T09:59:47.090Z","comments":true,"path":"tags/index.html","permalink":"https://lucifinil-x.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Git操作","slug":"Git操作","date":"2021-03-17T14:14:24.000Z","updated":"2021-03-18T18:07:57.444Z","comments":true,"path":"2021/03/17/Git操作/","link":"","permalink":"https://lucifinil-x.github.io/2021/03/17/Git操作/","excerpt":"Git介绍狂神原文 https://blog.csdn.net/qq_33369905/article/details/106647320","text":"Git介绍狂神原文 https://blog.csdn.net/qq_33369905/article/details/106647320 Git与SVN的主要区别SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而工作的时候，用的都是自己的电脑，所以首先要从中央服务器得到最新的版本，然后工作，完成工作后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，对网络带宽要求较高。 Git是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网了，因为版本都在自己电脑上。协同的方法是这样的：比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。Git可以直接看到更新了哪些代码和文件！ Git是目前世界上最先进的分布式版本控制系统。 Git Bash/Git cmdGit Bash - linux风格命令Git cmd - windows风格命令 常用的Linux命令-可以在git bash里使用平时一定要多使用这些基础的命令！ 1）、cd : 改变目录。 2）、cd . . 回退到上一个目录，直接cd进入默认目录 3）、pwd : 显示当前所在的目录路径。 4）、ls(ll): 都是列出当前目录中的所有文件，只不过ll(两个ll)列出的内容更为详细。 5）、touch : 新建一个文件 如 touch index.js 就会在当前目录下新建一个index.js文件。 6）、rm: 删除一个文件, rm index.js 就会把index.js文件删除。 7）、mkdir: 新建一个目录,就是新建一个文件夹。 8）、rm -r : 删除一个文件夹, rm -r src 删除src目录 rm -rf / 切勿在Linux中尝试！删除电脑中全部文件！9）、mv 移动文件, mv index.html src index.html 是我们要移动的文件, src 是目标文件夹,当然, 这样写,必须保证文件和目标文件夹在同一目录下。 10）、reset 重新初始化终端/清屏。 11）、clear 清屏。 12）、history 查看命令历史。 13）、help 帮助。 14）、exit 退出。 15）、#表示注释 git用户信息git config –global –list 123user.email=Lucifinil-xuser.name=Lucifinil_core.autocrlf=false Git配置所有的配置文件，其实都保存在本地！ 查看配置 git config -l 我的在C:\\Program Files\\Git中搜索gitconfig Git配置自己的信息首先，c盘里用户没有gitconfig文件 设置用户名和邮箱。 12git config --global user.name &quot;Lucifinil-x&quot;git config --global user.email 843986567@qq.com Git原理Workspace：工作区，就是你平时存放项目代码的地方 Index / Stage：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息 Repository：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本 Remote：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换 命令提交： git add . - git commit - git push 本地仓库搭建创建本地仓库的方法有两种：一种是创建全新的仓库，另一种是克隆远程仓库。 1、创建全新的仓库，需要用GIT管理的项目的根目录执行： 在当前目录新建一个Git代码库:$ git init2、执行后可以看到，仅仅在项目目录多出了一个.git目录，关于版本等的所有信息都在这个目录里面。3.注意！！！.git是隐藏文件。要点头部查看-勾选隐藏的项目。 克隆远程仓库1、另一种方式是克隆远程目录，由于是将远程服务器上的仓库完全镜像一份至本地！ 克隆一个项目和它的整个代码历史(版本信息)$ git clone [url] # https://gitee.com/kuangstudy/openclass.git2、去 gitee 或者 github 上克隆一个测试！ 文件的四种状态版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上。 Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged. Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified. 如果使用git rm移出版本库, 则成为Untracked文件 Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过, 返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改 ! Staged: 暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存, 文件状态为Modified 查看文件状态上面说文件有4种状态，通过如下命令可以查看到文件的状态： 12345678#查看指定文件状态git status [filename] #查看所有文件状态git status # git add . 添加所有文件到暂存区# git commit -m &quot;消息内容&quot; 提交暂存区中的内容到本地仓库 -m 提交信息 忽略文件有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等 在主目录下建立”.gitignore”文件，此文件有如下规则： 忽略文件中的空行或以井号（#）开始的行将会被忽略。 可以使用Linux通配符。例如：星号（ * ）代表任意多个字符，问号（？）代表一个字符，方括号（[abc]）代表可选字符范围，大括号（{string1,string2,…}）代表可选的字符串等。 如果名称的最前面有一个感叹号（!），表示例外规则，将不被忽略。 如果名称的最前面是一个路径分隔符（/），表示要忽略的文件在此目录下，而子目录中的文件不忽略。 如果名称的最后面是一个路径分隔符（/），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）。 123456*.txt #忽略所有 .txt结尾的文件,这样的话上传就不会被选中！!lib.txt #但lib.txt除外/temp #仅忽略项目根目录下的TODO文件,不包括其它目录tempbuild/ #忽略build/目录下的所有文件doc/*.txt #会忽略 doc/notes.txt 但不包括 doc/server/arch.txt使用码云 码云 免密码登录+建立git仓库设置本机绑定SSH公钥，实现免密码登录！（免密码登录，这一步挺重要的，码云是远程仓库，我们是平时工作在本地仓库！) 123# 进入 C:\\Users\\A\\.ssh 目录# 生成公钥ssh-keygen -t rsa 将公钥信息public key 添加到码云账户中即可！ 使用码云创建一个自己的仓库！ 许可证：开源是否可以随意转载，开源但是不能商业使用，不能转载，… 限制！ 把gitee仓库克隆到本地1.空文件夹根目录 git clone 码云仓库的url。就会出现包括.git文件夹在内的一些文件。 2.把这些文件拷贝到真实项目根目录。这是万能的方式，推荐。 3.idea打开文件，文件名字变酒红色，代表选中的状态。 4.和terminal同一行有一个version control.里面变更信息。 5.右上方 勾勾是commit.选中要提交的文件(等于git add .了)，右边全都不用选。 6.如果某个文件修改了，右键那个文件，git-add 7.commit message例子：第一次提交信息(在工作中，我们一般用来写我们新增/修改了哪些代码) 8.git pushidea中terminal中 git push’git’ 不是内部或外部命令，也不是可运行的程序。应该是没有配环境变量。去项目根目录用git bush执行git push.现在已经配置了环境变量，重启idea就能在terminal里用了。","categories":[],"tags":[]},{"title":"芜湖起飞社交平台项目","slug":"芜湖起飞社交平台项目","date":"2021-03-15T06:24:13.000Z","updated":"2021-03-15T11:20:32.959Z","comments":true,"path":"2021/03/15/芜湖起飞社交平台项目/","link":"","permalink":"https://lucifinil-x.github.io/2021/03/15/芜湖起飞社交平台项目/","excerpt":"名字wuhu_XJTLU_sharing_platform_javawuhu_XJTLU_sharing_platform_vue","text":"名字wuhu_XJTLU_sharing_platform_javawuhu_XJTLU_sharing_platform_vue 搭建环境-vue vue项目根目录文件夹中，shift+右键打开windows powershellc窗口 执行vue ui 手动配置项目 选择babel,router,vuex 路由不使用历史模式 不保存预设 idea打开vue,npm run serve package.json安装的版本信息 安装1.npm i buefy2.cnpm install element-ui –save 3.安装完成后main.js 导入 123456789// Buefyimport Buefy from &apos;buefy&apos;import &apos;buefy/dist/buefy.css&apos;// ElementUIimport ElementUI from &apos;element-ui&apos;;import &apos;element-ui/lib/theme-chalk/index.css&apos;;Vue.use(Buefy)Vue.use(ElementUI); login显示不了el框因为main.js中没有引入import ‘babel-polyfill’有些浏览器不能正常显示ES6 还有main.css文件前面的.wrapper决定了图片和框的显示问题 跨域问题只在java-config-添加跨域类(源码里粘贴的) vue里post(‘login’)java里”/login”/////////////////////////////////////////前端写后端端口，后端写前端端口后端.allowedOrigins(“Http://localhost:8080”,”null”)前端main.js中 12345axios.defaults.withCredentials = true; //允许跨域//Content-Type 响应头axios.defaults.headers.post[&apos;Content-Type&apos;] = &apos;application/x-www-form-urlencoded;charset=UTF-8&apos;;//基础urlaxios.defaults.baseURL = &quot;http://localhost:8000&quot;; login500问题后端是用的music的，接收的是前端post的URLSearchParams对象。前端必须把数据全部用map的形式加入URLSearchParams对象再post.目前登录成功，开始改后端和数据库。 3.15","categories":[],"tags":[]},{"title":"豆宝社区项目","slug":"豆宝社区项目","date":"2021-03-15T05:59:59.000Z","updated":"2021-03-15T06:17:21.385Z","comments":true,"path":"2021/03/15/豆宝社区项目/","link":"","permalink":"https://lucifinil-x.github.io/2021/03/15/豆宝社区项目/","excerpt":"","text":"技术栈前端BULMA(css)axiosbuefy(bulma的标签组件)elementvditor 后端springbootmysqlmybatismybatis-plusspring securityJWTlombok","categories":[],"tags":[]},{"title":"CPT204-java数据结构","slug":"CPT204-java数据结构","date":"2021-03-08T10:24:44.000Z","updated":"2021-03-09T06:35:27.879Z","comments":true,"path":"2021/03/08/CPT204-java数据结构/","link":"","permalink":"https://lucifinil-x.github.io/2021/03/08/CPT204-java数据结构/","excerpt":"分数组成1.最后一节lab写算法50%2.期末考试50%lab题目week1lab-exerciseweek1","text":"分数组成1.最后一节lab写算法50%2.期末考试50%lab题目week1lab-exerciseweek1 java+javaTest类文件夹+jar包文件夹1.用idea打开java文件夹2.project structure-library-加号-选择jar包文件夹路径-ok3.红色时钟-project structure-module-选择javasource4.project-project language level 11-SDK 11.0.55.debug运行 week21.只有用project-project language level 11-SDK 11.0.5才不会爆红2.debug","categories":[],"tags":[]},{"title":"INT202-复杂算法","slug":"INT202-复杂算法","date":"2021-03-08T10:24:10.000Z","updated":"2021-03-10T03:35:01.072Z","comments":true,"path":"2021/03/08/INT202-复杂算法/","link":"","permalink":"https://lucifinil-x.github.io/2021/03/08/INT202-复杂算法/","excerpt":"","text":"分数组成1.week8 课上考试 5%2.week14 课上考试 5%3.作业 6.6前 10%4.期末考试 80%考试都是写伪代码。","categories":[],"tags":[]},{"title":"CPT208-界面交互","slug":"CPT208-界面交互","date":"2021-03-08T10:22:24.000Z","updated":"2021-03-19T04:11:10.198Z","comments":true,"path":"2021/03/08/CPT208-界面交互/","link":"","permalink":"https://lucifinil-x.github.io/2021/03/08/CPT208-界面交互/","excerpt":"分数组成1.五次pre 10分钟+5分钟 10%2.小组project-评估界面/游戏/交互技术报告 4.16前 15%3.个人project-javaswing实现一个GUI接口+报告 5.21前 15%4.期末考试 60%","text":"分数组成1.五次pre 10分钟+5分钟 10%2.小组project-评估界面/游戏/交互技术报告 4.16前 15%3.个人project-javaswing实现一个GUI接口+报告 5.21前 15%4.期末考试 60% 低保真原型http://www.woshipm.com/pd/124256.html 未来白板UI宣传https://www.zcool.com.cn/work/ZNDM1NTUxNjA=.html 电子白板UIhttps://www.zcool.com.cn/work/ZNDU4MjI5NzI=.html 电视教育白板UIhttps://www.zcool.com.cn/work/ZMzA0Nzg4NDQ=.html","categories":[],"tags":[]},{"title":"CPT202-软件工程2","slug":"CPT202-软件工程2","date":"2021-03-08T10:20:58.000Z","updated":"2021-03-08T10:30:48.760Z","comments":true,"path":"2021/03/08/CPT202-软件工程2/","link":"","permalink":"https://lucifinil-x.github.io/2021/03/08/CPT202-软件工程2/","excerpt":"","text":"分数组成100% 有pre","categories":[],"tags":[]},{"title":"草稿箱","slug":"草稿箱","date":"2021-01-30T16:55:08.000Z","updated":"2021-01-30T16:56:31.207Z","comments":true,"path":"2021/01/31/草稿箱/","link":"","permalink":"https://lucifinil-x.github.io/2021/01/31/草稿箱/","excerpt":"配置文件123456789101112131415161718192021222324252627282930313233343536373839404142#server:# port: 8888##spring:# datasource:# url: jdbc:mysql://localhost:3306/mymusicweb?serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false# username: root# password: zhangcaiyun# driver-class-name: com.mysql.cj.jdbc.Driver# jackson:# date-format: yyyy-MM-dd HH:mm:ss# time-zone: GMT+8# servlet:# multipart:# max-file-size: 10MB# max-request-size: 10MB#mybatis:# type-aliases-package: com.example.music.domain# mapper-locations: classpath:mapper/*.xml##logging:# level:# com:# javaclimb:# music:# dao: debug##spring.datasource.type=com.alibaba.druid.pool.DruidDataSource#spring.jackson.date-format=yyyy-MM-dd HH:mm:ss#spring.jackson.time-zone=GMT+8##spring.servlet.multipart.max-file-size=10MB#spring.servlet.multipart.max-request-size=10MB##mybatis.type-aliases-package=com.javaclimb.music.domain#mybatis.mapper-locations=classpath:mapper/*.xml##logging.level.com.javaclimb.music.dao = debug","text":"配置文件123456789101112131415161718192021222324252627282930313233343536373839404142#server:# port: 8888##spring:# datasource:# url: jdbc:mysql://localhost:3306/mymusicweb?serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false# username: root# password: zhangcaiyun# driver-class-name: com.mysql.cj.jdbc.Driver# jackson:# date-format: yyyy-MM-dd HH:mm:ss# time-zone: GMT+8# servlet:# multipart:# max-file-size: 10MB# max-request-size: 10MB#mybatis:# type-aliases-package: com.example.music.domain# mapper-locations: classpath:mapper/*.xml##logging:# level:# com:# javaclimb:# music:# dao: debug##spring.datasource.type=com.alibaba.druid.pool.DruidDataSource#spring.jackson.date-format=yyyy-MM-dd HH:mm:ss#spring.jackson.time-zone=GMT+8##spring.servlet.multipart.max-file-size=10MB#spring.servlet.multipart.max-request-size=10MB##mybatis.type-aliases-package=com.javaclimb.music.domain#mybatis.mapper-locations=classpath:mapper/*.xml##logging.level.com.javaclimb.music.dao = debug pom 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.4.2&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;music&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;music&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-lang3 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.47&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;executable&gt;true&lt;/executable&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;","categories":[],"tags":[]},{"title":"音乐网站项目sp+vue","slug":"音乐网站项目sp-vue","date":"2021-01-27T11:00:09.000Z","updated":"2021-03-12T01:57:06.920Z","comments":true,"path":"2021/01/27/音乐网站项目sp-vue/","link":"","permalink":"https://lucifinil-x.github.io/2021/01/27/音乐网站项目sp-vue/","excerpt":"环境配置maven:3.6.1储存位置：D:\\maven仓库\\apache-maven-3.6.1pom.xml","text":"环境配置maven:3.6.1储存位置：D:\\maven仓库\\apache-maven-3.6.1pom.xml 前言：pom.xml中的maven依赖是指向D:\\maven仓库\\apache-maven-3.6.1里面的。如果版本过高，这里面没有，就会一直爆红。 druid:druid是什么:是jdbc组件，包括1）DruidDriver 代理Driver，能够提供基于Filter－Chain模式的插件体系。2）DruidDataSource 高效可管理的数据库连接池。3）SQLParser Druid可以做什么：1) 可以监控数据库访问性能，Druid内置提供了一个功能强大的StatFilter插件，能够详细统计SQL的执行性能，这对于线上分析数据库访问性能有帮助。2) 替换DBCP和C3P0。Druid提供了一个高效、功能强大、可扩展性好的数据库连接池。3) 数据库密码加密。直接把数据库密码写在配置文件中，这是不好的行为，容易导致安全问题。DruidDruiver和DruidDataSource都支持PasswordCallback。4) SQL执行日志，Druid提供了不同的LogFilter，能够支持Common-Logging、Log4j和JdkLog，你可以按需要选择相应的LogFilter，监控你应用的数据库访问情况。 commons-lang3提供几个工具类，类中的函数可以处理字符串，处理数字，处理数组，处理日期。需要处理的世界就调用类中的函数。所有方法-&gt;https://www.jianshu.com/p/1886903ed14c fastjson1)java后端和vue前端的数据传输是通过json字符串。(把对象转成json再传输)2)Fastjson 是一个 Java 库，可以将 Java 对象转换为 JSON 格式，当然它也可以将 JSON 字符串转换为 Java 对象。3)Fastjson 可以操作任何 Java 对象，即使是一些预先存在的没有源码的对象。 热加载模式 1.fork标签:true2.ctrl+shift+a 搜索registry…3.勾选complier.automake.allow.app.running4.java后端改完代码之后ctrl+F9 就可以热更新5.只适用于在方法内部修改的时候。如果新增了方法需要重启。 application.properties spring.datasource.url useSSL=false 不使用ssl加密(HTTPS协议使用SSL在发送方把原始数据进行加密，然后在接受方进行解密，加密和解密需要发送方和接受方通过交换共知的密钥来实现，因此，所传送的数据不容易被网络黑客截获和解密。) type-aliases-package 在Mybatis的mapper.xml文件中resultType的type或者paramterType会返回自定义entity,此时可以用全类名名来指定这些实体。 java配置中的问题按照视频里的启动会出现mybatis找不到的问题。解决：按照以前的创建项目的方法重建项目。 vue环境配置用的是D:\\vue学习练习\\音乐网站源码\\分章节源码\\music01 初始化\\music-client的vue基础项目，再cmd里到项目根目录，命令行npm install,启动npm run dev。所以这个vue项目没有从零开始配置。 数据库建表先建立表名都先只加一列主键和表名1.管理员表admin2.歌单和歌曲收藏表collect3.评论表comment4.前端用户表consumer5.歌单包含的歌曲列表list_song6.歌单排序表rank有一个没有在创建的时候体现UNIQUE KEY consumer_id (song_list_id,consumer_id) USING BTREE7.歌手表singer8.歌曲表song9.歌单介绍表song_list vue项目启动：npm run dev后台管理：music-manage-vue前台展示：music-client-vue 后端结构domain(数据库字段对应java对象)-dao(定义java对象进行操作的方法接口)-service(定义方法接口)-serviceImplement(调用dao中接口方法，实现service接口中的方法)-controller(调用service接口的方法) domain(java对象和getter setter)每个类对应数据库表属性对应表的列类实现序列化 关于序列化：1.Java序列化就是指把Java对象转换为字节序列的过程2.Java反序列化就是指把字节序列恢复为Java对象的过程。3.序列化最重要的作用：在传递和保存对象时.保证对象的完整性和可传递性。对象转换为有序字节流,以便在网络上传输或者保存在本地文件中。反序列化的最重要的作用：根据字节流中保存的对象状态及描述信息，通过反序列化重建对象。4.总结：核心作用就是对象状态的保存和重建。（整个过程核心点就是字节流中所保存的对象状态及描述信息） json/xml的数据传递： 在数据传输(也可称为网络传输)前，先通过序列化工具类将Java对象序列化为json/xml文件。在数据传输(也可称为网络传输)后，再将json/xml文件反序列化为对应语言的对象 dao(接口)service(接口)serviceImplement(类)@Service controller(类)utils(工具类)解决跨域1.java后端写一个类继承WebMvcConfigurerAdapter(一样的)2.vue中src-api-http.js中定义访问跨域、拦截器、响应头、get/post3.vue中src-api-index.js中定义业务相关的 Content-Type：axios 使用 post 发送数据时，默认是直接把 json 放到请求体中提交到后端的。也就是说，我们的 Content-Type 变成了 application/json;charset=utf-8 ,这是axios默认的请求头content-type类型。但是实际我们后端要求的 ‘Content-Type’: ‘application/x-www-form-urlencoded’ 为多见，这就与我们不符合。所以很多同学会在这里犯错误，导致请求数据获取不到。明明自己的请求地址和参数都对了却得不到数据。 我们现在来说说post请求常见的数据格式（content-type） Content-Type: application/json ： 请求体中的数据会以json字符串的形式发送到后端Content-Type: application/x-www-form-urlencoded：请求体中的数据会以普通表单形式（键值对）发送到后端Content-Type: multipart/form-data： 它会将请求体的数据处理为一条消息，以标签为单元，用分隔符分开。既可以上传键值对，也可以上传文件。 Promise框架：成功执行resolve(),失败执行rejected(). 登录跨域bug1.前端登录时前端页面Access to XMLHttpRequest at ‘http://localhost:8888/admin/login/status&#39; from origin ‘http://localhost:8080&#39; has been blocked by CORS policy: No ‘Access-Control-Allow-Origin’ header is present on the requested resource.xhr.js?ec6c:172 POST http://localhost:8888/admin/login/status net::ERR_FAILED 后端控制台When allowCredentials is true, allowedOrigins cannot contain the special value “ * “since that cannot be set on the “Access-Control-Allow-Origin” response header. 解决：后端webmvcconfig.allowedOrigins(“ * “)改成.allowedOrigins(“Http://localhost:8080”,”null”) //请求来源 2.登录post500后端控制台：username不存在 解决：后端mapperpublic int verifyPassword(String username, String password);改成public int verifyPassword(@Param(“username”) String username, @Param(“password”) String password); Home页面结构1.Home页面切换子页面，配置router于以往不同的是，没有import,而是component: resolve =&gt; require([‘../pages/Login.vue’], resolve);home的router里写children[]. 2.Home页面中的script中import子页面vue. 3.home页面布局：上面header,左边aside,右下角子页面 4.login登录中验证成功push到info页面 5.home页面-子页面(info) 6.home页面导入头/左侧页面/view-router所有在router里配置的home的children页面 左侧菜单theAside1.样式：左侧菜单框需要给上方的header留一部分空间 12345678910.sidebar&#123; /*块状显示；绝对定位随浏览器移动；定位到左边0；距离顶部70；距离底部0;背景颜色；y轴超出范围让他上下滚动；*/ display: block; position: absolute; left: 0; top: 70px; bottom: 0; background-color: #334256; overflow-y: scroll;&#125; 2.框里放一个表单在script里写属性和图标 3.框用el-menu标签，配属性注意：v-bind:key=”value(data中的值)”；缩写为:key=”value”用于绑定键值对。v-model=””是用于把data的数据与标签上输入的值进行绑定。 123&lt;!-- default-active默认点击=绑定的值;折叠=绑定的值; router是点击哪一栏就能够跳转到那一栏的index值的router；--&gt;&lt;el-menu class=&quot;sidebar-el-menu&quot; :default-active=&quot;onRoutes&quot; :collapse=&quot;collapse&quot; background-color=&quot;#334356&quot; text-color=&quot;#ffffff&quot; active-text-color=&quot;#20a0ff&quot; router&gt; 4.el-menu中遍历出数据进行每一行的信息展示template是自定义的标签名。 123456789&lt;!-- 整个循环是一个template标签，遍历出的每一项也是template标签。每一项用el-menu-item标签要绑定属性。里面展示图标和文字--&gt;&lt;template v-for=&quot;item in items&quot;&gt;&lt;template&gt; &lt;el-menu-item :index=&quot;item.index&quot; :key=&quot;item.index&quot;&gt; &lt;i :class=&quot;item.icon&quot;&gt;&lt;/i&gt; &#123;&#123;item.title&#125;&#125; &lt;/el-menu-item&gt;&lt;/template&gt;&lt;/template&gt; 头部栏theHeader头部栏theHeader-折叠侧边栏1.整体框样式2.el-icon-menu图标样式3.点击图标，折叠侧边栏vue中的bus事件机制，文件在js/bus.js已有const bus = new Vue()。在theAside中script中import.通过bus进行组件(两个页面vue)之间的通信来折叠侧边栏.点击header中的图标折叠aside.3.1 theAside中接收theHeader中发送的信息，改变其中的collaspse值。先import bus, 12345678created()&#123;//创建页面完成就执行 //通过bus进行组件(两个页面vue)之间的通信来折叠侧边栏.点击header中的图标折叠aside. //js公式$(selector).action() //接收header里发送过来的信息collapse(msg),执行=&gt;&#123;让aside的collaspse属性发生变化&#125; bus.$on(&apos;collapse&apos;, msg =&gt;&#123; this.collapse = msg; &#125;) &#125; 3.2 theHeader中发送消息图标标签中加点击事件collaspseChange,先import bus, 12345678910111213data()&#123; return&#123; collapse: false, //默认是false,在方法中点击反向true-&gt;false,false-&gt;true. // 如果默认为true,点一次图标，true-&gt;false,再把msg=false传给theAside,它里面赋值为false是不折叠。所以点两次才会折叠。 //因此这里默认是false,点一次就折叠 &#125; &#125;, methods:&#123; collaspseChange()&#123; this.collapse = !this.collapse; bus.$emit(&apos;collapse&apos;, this.collapse); &#125; &#125; 3.3 theAside中根据属性collapse改变样式实现折叠效果,以及滚动条和瑕疵处理。 123456789101112/*侧边栏如果超出范围，有滚动条*/.sidebar::-webkit-scrollbar&#123; width: 0;&#125;/*只有el-menu标签的collapse属性为false时样式才起作用 双false=true*/.sidebar-el-menu:not(.el-menu--collapse)&#123; width: 150px;&#125;/* 侧边栏的一行的宽度，下面没有字的比上面有字的宽，这里解决。ul无序列表,&gt;子选择器，第一代*/.sidebar &gt;ul&#123; height: 100%;&#125; 头部栏theHeader-全屏页面/取消全屏1.header框中设置图标位置，点击提示，点击事件,绑定变量data。2.写点击事件方法。用浏览器对象document中的函数完成全屏展示/退出。(if else)区别不同浏览器的全屏方法，达到代码兼容目的。然后改变变量data 头部栏theHeader-用户头像/名字展示/退出登录1.头像就是图片加参数样式，与叉叉展开图标同级。2.el-dropdown做点击用户名，出现下拉菜单，点击选项，退出登录。2.1 login.vue中登录成功后，前端信息存入缓存。用localStorage,这是html5的一个特性，把数据像map一样放在里面。2.2 theHeader.vue中computed中取出缓存中数据。 123456computed:&#123; // 在login页面存localstorage缓存，在这里取。构造函数。 userName()&#123; return localStorage.getItem(&apos;userName&apos;); &#125; &#125;, 2.3 el-dropdown触发事件：点击；绑定退出登录函数(清除缓存，路由页面到登录页)。el-dropdown-menu里退出登录选项参数logout作为退出登录函数的传入参数。 主体页Home主体页Home-主题页样式1.router-view是子页面的路由填充展示2.用div标签包裹router-view，用于管理css.3.首先默认的css为content-box,content-box在main.css,main.js中已经引入了main.css。4.后面v-bind:class=”{‘content-collapse’:collapse}是vue的动态绑定css,根据collapse的值进行绑定。5.data中加入collapse: false。6.created()和theAside一样。7.获取header发送的collapse的值对这里的data进行修改。vue动态绑定的css根据collapse变量值，加入css样式content-collapse。 1234567&lt;!-- content-box在main.css,main.js中已经引入了main.css。--&gt;&lt;!-- 用一个div把content-box包裹起来--&gt;&lt;!-- 首先默认的css为content-box。后面v-bind:class=&quot;&#123;&apos;content-collapse&apos;:collapse&#125;是vue的动态绑定css,根据collapse的值进行绑定。--&gt; &lt;div class=&quot;content-box&quot; v-bind:class=&quot;&#123;&apos;content-collapse&apos;:collapse&#125;&quot;&gt; &lt;!-- 让内容填充整个页面--&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; 歌手管理歌手管理-domain层(java实体对象Singer)根据数据库表中的字段写domain-Singer.1.仿照Admin,自己写。同样要实现序列化接口。2.属性。注意下面的mysql数据类型和java类型的转换 123private Byte sex; //tinyint-Byteprivate String pic;private Date birth;//datetime-Date 3.getter+setter 歌手管理-dao层(定义java对象进行增删改查操作的方法接口)1.@Repository用在持久层的接口上，这个注解是将接口的一个实现类交给spring管理。2.定义增删改查(3中查询)接口写前端的时候不够再加 1234567891011121314public interface SingerMapper &#123; //增加 歌手 :传入singer实体，返回int public int insert(Singer singer); //修改 : 传入singer实体，返回int public int update(Singer singer); //删除 歌手: 传入主键id,返回int public int delete(Integer id); //查询1 根据主键查询整个singer对象： 传入主键id,返回singer实体类对象。 public Singer selectByPrimaryKey(Integer id); //查询2 查询所有歌手：无传入参数，返回list&lt;Singer&gt; public List&lt;Singer&gt; allSinger(); //查询3 根据歌手名字模糊查询出歌手列表: 传入名字string, 返回list&lt;Singer&gt; public List&lt;Singer&gt; singerOfName(String name);&#125; 歌手管理-mapper.xml层(xml查询语句)1.写resultMap 1.mapper-namespace对应dao层接口 2.resultMap-type对应domain层java实体类 3.result-column对应数据库列名；jdbcType对应数据库数据类型(大写)；property对应属性名(都与列名一致)。2.和dao层接口对应写sql查询语句去项目中看 歌手管理-service层(定义方法成功返回接口)1.把dao层接口复制过来修改返回类型例如：int改为boolean,看是否操作成功。Singer，List返回类型不修改 歌手管理-serviceImpl层(调用mapper方法实现service层接口的返回值)1.自动引入mapper接口2.return mapper接口中的函数对应返回类型。 12345678public boolean delete(Integer id) &#123; return singerMapper.delete(id)&gt;0; &#125; @Override public Singer selectByPrimaryKey(Integer id) &#123; return singerMapper.selectByPrimaryKey(id); &#125; 歌手管理-controller层","categories":[],"tags":[]},{"title":"mongodb使用学习","slug":"mongodb使用学习","date":"2020-12-25T09:20:31.000Z","updated":"2020-12-25T11:10:36.779Z","comments":true,"path":"2020/12/25/mongodb使用学习/","link":"","permalink":"https://lucifinil-x.github.io/2020/12/25/mongodb使用学习/","excerpt":"mongodb启动启动之后创建用户：https://www.jianshu.com/p/62736bff7e2e1.启动: cmd: d: cd D:\\mongodb安装\\bin 执行mongod.exe –dbpath D:\\mongodb安装\\data\\db 启动mongod之后再启动springboot2.点击打开D:\\mongodb安装\\bin 里面的mongo.exe 执行show dbs显示所有的数据库 执行use local切换到local数据库","text":"mongodb启动启动之后创建用户：https://www.jianshu.com/p/62736bff7e2e1.启动: cmd: d: cd D:\\mongodb安装\\bin 执行mongod.exe –dbpath D:\\mongodb安装\\data\\db 启动mongod之后再启动springboot2.点击打开D:\\mongodb安装\\bin 里面的mongo.exe 执行show dbs显示所有的数据库 执行use local切换到local数据库 cmd: d: cd D:\\mongodb安装\\bin 执行 mongo这是查看27017的连接访问http://localhost:27017/ 也可以查看27017的连接 复制粘贴不能用快捷键，在白框那里右键-编辑-粘贴或者ctrl+shift+v 启动-电影网站的启动：https://blog.csdn.net/rentian1/article/details/70213463启动之后创建用户：https://www.jianshu.com/p/62736bff7e2e1.启动: cmd: d: cd D:\\mongodb安装\\bin 执行mongod.exe –dbpath :\\mongodb安装\\data\\db2.点击打开D:\\mongodb安装\\bin 里面的mongo.exe 执行shou dbs显示所有的数据库3.切换到admin数据库：use admin4.创建用户：db.createUser({user:”admin”, pwd: “518985599.”, roles: [“root”]})5.尝试使用上面创建的用户信息进行连接:db.auth(‘admin’, ‘518985599.’)6.创建数据库recommend_system：use recommend_system; db.createUser({user: “root”, pwd: “518985599.”, roles: [{ role: “dbOwner”, db: “recommend_system” }]})7.退出 mongodb操作学习创建数据库 use 数据库名 ： 在内存中创建数据库用use创建的数据库是存到内存中的，并没有持久化到磁盘中，所以用show dbs是查不出来你创建的数据库的。只有当你的这个数据库中有集合的时候(数据库中不为空)，就会自动的从内存持久化到磁盘中。show dbs也会显示。 db ： 查看当前的数据库 删除硬盘中持久化的数据库 db.dropDatabase()db是当前use的数据库 集合操作集合 = 关系型数据库中的表 集合的创建和删除1.集合的显示创建自己创建集合(表)2.集合的隐式创建在向集合中插入一个文档的时候，如果集合不存在，会自动创建集合。 db.createCollection(表名)例： db.createCollection(“my”) show collections : 显示集合(表) db.表名.drop() : 删除数据库中所有的表 文档的增删改查文档 = 表中的一条数据用的是字典格式： {“key1”: value1, “key2”: value2 } 1.创建数据库2.创建空表3.插入数据 db. db.novel_content.find() db.novel_list.find() db.novel_chapters.find() waiting for connections on port 270172020-12-25T16:51:23.014+0800 I SHARDING [ftdc] Marking collection local.oplog.rs as collection version:","categories":[],"tags":[]},{"title":"仿网易云音乐vue","slug":"仿网易云音乐vue","date":"2020-11-26T09:03:37.000Z","updated":"2020-11-26T09:08:23.506Z","comments":true,"path":"2020/11/26/仿网易云音乐vue/","link":"","permalink":"https://lucifinil-x.github.io/2020/11/26/仿网易云音乐vue/","excerpt":"运行1.D:\\vue学习练习\\李震林 vue+element仿网易云\\网易云后台接口\\NeteaseCloudMusicApi 右键打开git bush","text":"运行1.D:\\vue学习练习\\李震林 vue+element仿网易云\\网易云后台接口\\NeteaseCloudMusicApi 右键打开git bush 2.npm installnpm WARN read-shrinkwrap This version of npm is compatible with lockfileVersion@1, but package-lock.json was generated for lockfileVersion@2. I’ll try to do my best with it! 3.node app.jsinternal/modules/cjs/loader.js:969 throw err; 4.npm install express本来有问题，他自己修复了npm WARN read-shrinkwrap This version of npm is compatible with lockfileVersion@1, but package-lock.json was generated for lockfileVersion@2. I’ll try to do my best with it! core-js@2.6.11 postinstall D:\\vue学习练习\\李震林 vue+element仿网易云\\网易云后台接口\\NeteaseCloudMusicApi\\node_modules\\core-jsnode -e “try{require(‘./postinstall’)}catch(e){}” Thank you for using core-js ( https://github.com/zloirock/core-js ) for polyfilling JavaScript standard library! The project needs your help! Please consider supporting of core-js on Open Collective or Patreon: https://opencollective.com/core-jshttps://www.patreon.com/zloirock Also, the author of core-js ( https://github.com/zloirock ) is looking for a good job -) npm WARN NeteaseCloudMusicApi@3.47.3 No repository field.npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@2.1.3 (node_modules\\fsevents):npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@2.1.3: wanted {“os”:”darwin”,”arch”:”any”} (current: {“os”:”win32”,”arch”:”x64”}) express@4.17.1added 472 packages from 368 contributors and audited 473 packages in 70.977s 60 packages are looking for funding run npm fund for details found 0 vulnerabilities真正运行5.node app.jsserver running @ http://localhost:3000 6.idea中打开D:\\vue学习练习\\李震林 vue+element仿网易云\\vue-element npm run serve","categories":[],"tags":[]},{"title":"linux虚拟机","slug":"linux虚拟机","date":"2020-11-20T18:32:02.000Z","updated":"2020-11-20T18:32:02.643Z","comments":true,"path":"2020/11/21/linux虚拟机/","link":"","permalink":"https://lucifinil-x.github.io/2020/11/21/linux虚拟机/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"pycharm使用","slug":"pycharm使用","date":"2020-11-20T18:31:32.000Z","updated":"2020-11-27T12:23:28.234Z","comments":true,"path":"2020/11/21/pycharm使用/","link":"","permalink":"https://lucifinil-x.github.io/2020/11/21/pycharm使用/","excerpt":"快捷键最重要的快捷键ctrl+shift+A:万能命令行shift两次:查看资源文件新建工程第一步操作module设置把空包分层去掉,compact empty middle package设置当前的工程是utf-8,设置的Editor–&gt;File Encodings–&gt;全部改成utf-8,注释ctrl+/:单行注释光标操作ctrl+alt+enter:向上插入shift+enter:向下插入end:光标操作代码ctrl+d:复制粘贴一行ctrl+y:删除一行shift+F6:重命令ctrl+O:复写代码格式代码及其他功能ctrl+alt+L:格式代码在代码中使用alt+insert:Generate,可以get/set等操作ctrl+alt+T:添加try/catchctrl+alt+M:抽取代码ctrl+alt+F:变量抽取全局变量还需要设置前缀:Editor–&gt;code style–&gt;java–&gt;code Genertion–&gt;设置Field的前缘为m添加ctrl+alt+v:方法体内值抽取成变量保存成模板:ctrl+shift+L,这个是自定义的(save as live Template)选中内容:tab进行退格shift+tab:反向退格alt+shift+上下键:选中代码移动ctrl+shift+上下键:可以移动当前方法体,如果移动一行代码只能在代码体内移动ctrl+shift+U:代码大小写ctrl+shift+enter:补全代码(一行尾添加分号,如果是if等添加括号)进入代码ctrl+鼠标:进入代码ctrl+B:进入代码ctrl+shift+12:最大化窗口替换查找ctrl+r:替换ctrl+F:查找ctrl+shift+F:全局查找ctrl+shift+R:全局替换ctrl+shift+i:快捷查看方法实现的内容ctrl+p:查看参数ctrl+Q:查看文档描述shift+F1:查看api文档ctrl+F12:查看类的方法ctrl+H:查看类的继承关系查看变量的赋值情况:shift+ctrl+a:输入analyze data flow to Herectrl+alt+H:查看方法在那里被调用了ctrl+{}:可以定位方法体的括号F3:查看选中的内容shift+F3:反向查看内容ctrl+alt+B:查询那些类实现了光标所在的接口ctrl+U:查看父类ctrl+E:最近编辑的文件列表ctrl+alt+home:查看布局与对应的类ctrl+alt+H:查看当前方法在那里进行调用运行编译ctrl+F9:构建shift+F10:运行工程目录操作新建文件及工程:选中要创建目录使用alt+insertctrl+shift+a:输入show in explorer–&gt;打开相应目录ctrl+alt+s:打开软件设置ctrl+alt+shift+s:打开module设置alt+1:当前目录区alt+7:当前类的方法列表查看ctrl+tab:切换目录及视图alt+shift+c:查看工程最近更改的地方ctrl+J:livetemp模板查看代码快捷操作没有操作完成操作可以先写todo进行,就可以在todo的窗口进行查看F11定义书签shift+F11:查看书签ctrl+J:快捷调出模板alt+点击断点:禁用断点调试状态下按下:alt查看变量能审查表达式的值组合快捷键F2:定位错误alt+enter:修正错误alt+鼠标:进入列编辑模式ctrl+w:选中单词或其他组合操作编辑的位置","text":"快捷键最重要的快捷键ctrl+shift+A:万能命令行shift两次:查看资源文件新建工程第一步操作module设置把空包分层去掉,compact empty middle package设置当前的工程是utf-8,设置的Editor–&gt;File Encodings–&gt;全部改成utf-8,注释ctrl+/:单行注释光标操作ctrl+alt+enter:向上插入shift+enter:向下插入end:光标操作代码ctrl+d:复制粘贴一行ctrl+y:删除一行shift+F6:重命令ctrl+O:复写代码格式代码及其他功能ctrl+alt+L:格式代码在代码中使用alt+insert:Generate,可以get/set等操作ctrl+alt+T:添加try/catchctrl+alt+M:抽取代码ctrl+alt+F:变量抽取全局变量还需要设置前缀:Editor–&gt;code style–&gt;java–&gt;code Genertion–&gt;设置Field的前缘为m添加ctrl+alt+v:方法体内值抽取成变量保存成模板:ctrl+shift+L,这个是自定义的(save as live Template)选中内容:tab进行退格shift+tab:反向退格alt+shift+上下键:选中代码移动ctrl+shift+上下键:可以移动当前方法体,如果移动一行代码只能在代码体内移动ctrl+shift+U:代码大小写ctrl+shift+enter:补全代码(一行尾添加分号,如果是if等添加括号)进入代码ctrl+鼠标:进入代码ctrl+B:进入代码ctrl+shift+12:最大化窗口替换查找ctrl+r:替换ctrl+F:查找ctrl+shift+F:全局查找ctrl+shift+R:全局替换ctrl+shift+i:快捷查看方法实现的内容ctrl+p:查看参数ctrl+Q:查看文档描述shift+F1:查看api文档ctrl+F12:查看类的方法ctrl+H:查看类的继承关系查看变量的赋值情况:shift+ctrl+a:输入analyze data flow to Herectrl+alt+H:查看方法在那里被调用了ctrl+{}:可以定位方法体的括号F3:查看选中的内容shift+F3:反向查看内容ctrl+alt+B:查询那些类实现了光标所在的接口ctrl+U:查看父类ctrl+E:最近编辑的文件列表ctrl+alt+home:查看布局与对应的类ctrl+alt+H:查看当前方法在那里进行调用运行编译ctrl+F9:构建shift+F10:运行工程目录操作新建文件及工程:选中要创建目录使用alt+insertctrl+shift+a:输入show in explorer–&gt;打开相应目录ctrl+alt+s:打开软件设置ctrl+alt+shift+s:打开module设置alt+1:当前目录区alt+7:当前类的方法列表查看ctrl+tab:切换目录及视图alt+shift+c:查看工程最近更改的地方ctrl+J:livetemp模板查看代码快捷操作没有操作完成操作可以先写todo进行,就可以在todo的窗口进行查看F11定义书签shift+F11:查看书签ctrl+J:快捷调出模板alt+点击断点:禁用断点调试状态下按下:alt查看变量能审查表达式的值组合快捷键F2:定位错误alt+enter:修正错误alt+鼠标:进入列编辑模式ctrl+w:选中单词或其他组合操作编辑的位置 ctrl+alt+左右键:这个是定位到编辑的位置1.Pycharm中快捷键大全，遇到一个更新一个撤销与反撤销：Ctrl + z，Ctrl + Shift + z缩进、不缩进：Tab、Shift + tab运行：Shift + F10批量注释：Ctrl + /快速查看文档：Ctrl + q当光标在代码中间，如何回车到下一行：Shift + 回车当鼠标在代码下一行非开头位置，如何跳转到上一行末尾：Ctrl + backspace（退格键）当一行代码太长时，我们如何切换到下一行，但是格式不变：Ctrl + 回车2.Pycharm中使用技巧函数提示出错，如下图。其实函数是没有错误的，只是格式不对。只要空两格（就是如图3，4行空出来）就行；函数与函数之间也要空两格超级好用的快捷键——效率之王批量注释：Ctrl + /快速查看文档：Ctrl + q进入列编辑模式：alt+鼠标选中单词：ctrl+w搜索：ctrl+f全局搜索：ctrl+shift+f 项目创建【高亮】新建项目的时候选择已经exist的python3.7再创建 报错winerror5拒绝访问-queue.put() 原因：报错是因为新建项目的时候选择了自带有一个venv的python3.7,删掉它的项目无法运行。import 也会出错 解决办法：新建项目的时候选择已经exist的python3.7再创建 运行必须是：D:\\Python3.7.2\\python.exe D:/PyCharm2019/python学习project2/多进程/进程通信2.py","categories":[],"tags":[]},{"title":"健康平台项目","slug":"健康平台项目","date":"2020-11-10T10:11:20.000Z","updated":"2021-03-15T07:55:16.488Z","comments":true,"path":"2020/11/10/健康平台项目/","link":"","permalink":"https://lucifinil-x.github.io/2020/11/10/健康平台项目/","excerpt":"项目讲解1.跨域前端后端端口号不一样是存在跨域的，对于post,get,put,delete,options的请求虽然可以在controller进行处理，但是他是用@Configuration 做了一个全局的配置类。只放行8080端口的请求","text":"项目讲解1.跨域前端后端端口号不一样是存在跨域的，对于post,get,put,delete,options的请求虽然可以在controller进行处理，但是他是用@Configuration 做了一个全局的配置类。只放行8080端口的请求 2.登录logincontroller中传一个(vue给我们封装好的User) 3.用户信息的分页element-ui的组件完成 4.mybatis封装 一级缓存 5.前台多个api接口 开始做1.vue配置1.element-ui命令行安装，配置见vue那一篇。注意：element-ui的组件html中有绑定数据的必须把js复制完/写完才会显示出来。不显示也不是因为配置有问题 2.login页面页面详细过程 1.表单格式一级标签：el-form二级标签：el-form-item 表单组件三级标签：el-input，el-button 按钮/行放在二级标签组件中，v-model绑定值 1234567891011121314151617181920&lt;div&gt;&lt;!-- ref=给他起的类名，model数据绑定到数据loginForm对象,class类选择器写css,--&gt; &lt;el-form ref=&quot;loginFormRef&quot; v-model=&quot;loginForm&quot; label-width=&quot;80px&quot; class=&quot;login_form&quot;&gt;&lt;!-- 用户名，input标签绑定username--&gt; &lt;el-form-item &gt; &lt;el-input v-model=&quot;loginForm.username&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt;&lt;!-- 密码，input标签绑定loginForm对象中的密码--&gt; &lt;el-form-item &gt; &lt;el-input v-model=&quot;loginForm.password&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt;&lt;!-- 按钮组件，都放在el-form-item标签里面，加一个选择器好改样式--&gt; &lt;el-form-item class=&quot;btns&quot;&gt; &lt;el-button type=&quot;primary&quot; round&gt;提交&lt;/el-button&gt; &lt;el-button type=&quot;warning&quot; round&gt;重置信息&lt;/el-button&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/div&gt; 2.表单样式居中，长度，图片位置，背景大小 3.表单验证官方介绍：Form 组件提供了表单验证的功能，只需要通过 rules 属性传入约定的验证规则，并将 Form-Item 的 prop 属性设置为需校验的字段名即可。校验规则参见 async-validator el-form标签里面用:rules=”loginRules”绑定data里的校验规则对象； 用:model=”loginForm”双向绑定data里的表单数据对象【高亮！】element-ui的主标签el-form绑定v-model只能写：model=”表单对象” 使用element-ui时报错element-ui.common.js?5c96:22906 [Element Warn][Form]model is required for resetFields to work.原因：绑定的model属性可能写成了v-model，这样而且你会发现做校验做不了，因为你没有传正确的model属性过去，所以它们没有收到你输入的值 解决：使用el-form的时候绑定的model属性应该写成 ：model，而不是v-model 123456789101112131415 &lt;el-form ref=&quot;loginFormRef&quot; :rules=&quot;loginRules&quot; v-model=&quot;loginForm&quot; label-width=&quot;80px&quot; class=&quot;login_form&quot;&gt;&lt;!-- 用户名，input标签绑定username数据；item标签用prop绑定校验规则username:[]--&gt;//校验规则对象 loginRules:&#123; // 校验用户名，是data里面的数据校验； username: [ &#123; required: true, message: &apos;请输入用户名称&apos;, trigger: &apos;blur&apos; &#125;, //必填项验证 &#123; min: 3, max: 10, message: &apos;长度在 3 到 10 个字符&apos;, trigger: &apos;blur&apos; &#125;//长度验证 ], password:[ &#123; required: true, message: &apos;请输入用户密码&apos;, trigger: &apos;blur&apos; &#125;, //必填项验证 &#123; min: 3, max: 10, message: &apos;长度在 3 到 10 个字符&apos;, trigger: &apos;blur&apos; &#125;//长度验证 ] &#125; 4.重置按钮绑定自定义方法【高亮！】element-ui的主标签el-form绑定v-model只能写：model不然重置没有用 123456789&lt;el-button type=&quot;warning&quot; round v-on:click=&quot;resetLoginForm&quot;&gt;重置信息&lt;/el-button&gt; methods:&#123; //绑定上面重置按钮的重置表单方法 resetLoginForm()&#123; //链式函数 this对象的 $refs的loginFormRef这个方法提示找不到但是绑定好了还是有效果 this.$refs.loginFormRef.resetFields(); &#125; &#125; 5.登录按钮绑定方法【高亮！】对于方法this.$refs.loginFormRef.resetFields();this.$http.post(“test”);点不出来和报错TypeError: Cannot read property ‘post’ of undefined的情况：解决： 1.main.js里面删掉Vue.prototype.$axios = axios2.main.js里面加上+安装VueAxios(另外，重新装了c盘里的npm)npm install axios –save 123import axios from &apos;axios&apos;import VueAxios from &apos;vue-axios&apos;Vue.use(VueAxios,axios) //这里前后顺序不能错 这样就没有灰色波浪线了1.main.js里//设置访问根路径,这里是设置请求跨域axios.defaults.baseURL= “http://localhost:9000&quot;2.login.vue里绑定方法和写方法 123456789101112131415161718192021&lt;el-button type=&quot;warning&quot; round v-on:click=&quot;resetLoginForm&quot;&gt;重置信息&lt;/el-button&gt;login()&#123; //箭头函数 属性=&gt;&#123;响应&#125; //valid属性为true/false; 是上面的表单验证规则来判断几个值符不符合 this.$refs.loginFormRef.validate(async valid =&gt;&#123; console.log(valid); if(!valid) return; //如果前端表单校验false方法终止 // async和await都要一起写；http发给后端 /test链接 //全局定义一个data叫res接收后端&quot;/test&quot;controller里return的字符串ok； const &#123;data:res&#125; = await this.$http.post(&quot;test&quot;); //如果后端传过来的res是ok就会页面提示操作成功 if(res == &quot;ok&quot;)&#123; this.$message.success(&quot;操作成功&quot;); &#125; else&#123; this.$message.error(&quot;操作失败&quot;); &#125; &#125;) &#125;, 3.java后端 写一个接收url”/test”的controller。函数里return的字符串ok；完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136&lt;template&gt; &lt;div&gt; &lt;div class=&quot;login_container&quot;&gt; &lt;div class=&quot;login_box&quot;&gt; &lt;div class=&quot;avatar_box&quot;&gt; &lt;!--头像--&gt; &lt;img src=&quot;../assets/logo.jpg&quot; alt /&gt; &lt;/div&gt;&lt;!-- 表单--&gt; &lt;div&gt;&lt;!-- ref=给他起的类名，model数据双向绑定到数据loginForm对象,class类选择器写css,--&gt; &lt;el-form ref=&quot;loginFormRef&quot; :rules=&quot;loginRules&quot; :model=&quot;loginForm&quot; label-width=&quot;80px&quot; class=&quot;login_form&quot;&gt;&lt;!-- 用户名，input标签绑定username数据；item标签用prop绑定校验规则username:[]--&gt; &lt;el-form-item prop=&quot;username&quot;&gt; &lt;span&gt;用户名：&lt;/span&gt;&lt;el-input v-model=&quot;loginForm.username&quot; &gt;&lt;/el-input&gt; &lt;/el-form-item&gt;&lt;!-- 密码，input标签绑定loginForm对象中的密码--&gt; &lt;el-form-item prop=&quot;password&quot;&gt; 密码：&lt;el-input v-model=&quot;loginForm.password&quot; type=&quot;password&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt;&lt;!-- 按钮组件，都放在el-form-item标签里面，加一个选择器好改样式--&gt; &lt;el-form-item class=&quot;btns&quot;&gt; &lt;el-button type=&quot;primary&quot; round v-on:click=&quot;login&quot;&gt;登录&lt;/el-button&gt; &lt;el-button type=&quot;warning&quot; round v-on:click=&quot;resetLoginForm&quot;&gt;重置信息&lt;/el-button&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data()&#123; return&#123; //表单数据对象:&#123; , , &#125; //el-form 标签里面双向绑定到v-model=&quot;loginForm&quot;数据对象，才会更新 loginForm:&#123; username:&quot;admin&quot;, password:&quot;123456&quot; &#125;, //校验规则对象 loginRules:&#123; /*校验*/ /*name: [ &#123; required: true, message: &apos;请输入活动名称&apos;, trigger: &apos;blur&apos; &#125;, &#123; min: 3, max: 5, message: &apos;长度在 3 到 5 个字符&apos;, trigger: &apos;blur&apos; &#125; ],*/ // 校验用户名，是data里面的数据校验； username: [ &#123; required: true, message: &apos;请输入用户名称&apos;, trigger: &apos;blur&apos; &#125;, //必填项验证 &#123; min: 3, max: 10, message: &apos;长度在 3 到 10 个字符&apos;, trigger: &apos;blur&apos; &#125;//长度验证 ], password:[ &#123; required: true, message: &apos;请输入用户密码&apos;, trigger: &apos;blur&apos; &#125;, //必填项验证 &#123; min: 3, max: 10, message: &apos;长度在 3 到 10 个字符&apos;, trigger: &apos;blur&apos; &#125;//长度验证 ] &#125; &#125;; &#125;, methods:&#123; //绑定上面重置按钮的重置表单方法 resetLoginForm()&#123; //链式函数 this对象的 $refs的loginFormRef this.$refs.loginFormRef.resetFields(); &#125;, login()&#123; //1.验证校验规则 //箭头函数 属性=&gt;&#123;响应&#125; //valid属性为true/false; 是上面的表单验证规则来判断几个值符不符合 this.$refs.loginFormRef.validate(async valid =&gt;&#123; console.log(valid); //2.前端验证失败返回 if(!valid) return; //如果前端表单校验false方法终止 //3.前端验证成功，把前端表单数据post给后端接口test,后端返回给前端一个res(这里是字符串) // async和await都要一起写；http发给后端 /test链接 //全局定义一个data叫res接收后端&quot;/test&quot;controller里return的字符串ok； const &#123;data:res&#125; = await this.$http.post(&quot;test&quot;); //4.如果后端传过来的res是ok就会页面提示操作成功，并且前端进行路由跳转。 //不是ok就提示操作失败 if(res == &quot;ok&quot;)&#123; this.$message.success(&quot;操作成功&quot;); await this.$router.push(&#123;path: &quot;/home&quot;&#125;); &#125; else&#123; this.$message.error(&quot;操作失败&quot;); &#125; &#125;) &#125;, &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;/*根节点样式*/ .login_container&#123; background-color: #2b4b6b; height: 100%; &#125;/*背景+表单*/ .login_box&#123; /*表单居中，输入框长度*/ max-width: 600px; margin: 0 auto; margin-top: 0px; text-align: center; line-height: 160px; width: 850px; /*和图片一致*/ height: 720px; &#125; /*表单框*/ .login_form&#123; /*相对定位移动*/ position: relative; top: 300px; left: 0px; border-radius: 5px; &#125; /*图片*/ .avatar_box&#123; /*height: 1000%;*/ /*图片透明度*/ filter:alpha(opacity=20); position: absolute; left: 10%; &#125;&lt;/style&gt; 心得总结到这里完成一个前后端分离。前端自行拦截验证，前端提交表单到后端controller接口，后端接口return数据给前端，前端用接收到的数据判断并且进行前端的路由页面跳转。注意：要在前端main.js中设置请求跨域到后端的port 3.Home首页p10 19:411.配置路由 2.在login页面的login()方法中进行路由跳转 1234if(res == &quot;ok&quot;)&#123; this.$message.success(&quot;操作成功&quot;); await this.$router.push(&#123;path: &quot;/home&quot;&#125;); &#125; 4.完善后台-连接数据库进行真正的用户校验介绍在javaEE里面具有封装功能的实体叫entity实体类/bean pojo实体类 4.1创建user实体类下面看看结构-1234 12345678910111213141516171819202122232425262728//用户实体类-public class User &#123; //1.对应数据库表中的每一列 private int id; //自增主键 private String username; private String password; private String email; private String role; //角色 private boolean state; //状态 ///2.pojo实体类要有一个空构造。spring自动完成初始化。 public User()&#123; &#125; //3.(自增的)主键不需要赋值，传值的构造函数里不放它 public User(String username, String password, String email, String role, boolean state) &#123; this.username = username; this.password = password; this.email = email; this.role = role; this.state = state; &#125; //4.getter setter方法 &#125; 4.2登录验证在loginController完成1.loginController 12345678910111213//@RestController规定返回字符串@RestControllerpublic class LoginController &#123; //login方法接收前端传递给后端的数据并封装user对象中 // @RequestBody主要用来接收前端传递给后端的json字符串中的数据的(请求体中的数据的);加上这个前端post的loginform才会被封装到user @RequestMapping(&quot;/login&quot;) public String login(@RequestBody User user)&#123; System.out.println(&quot;user:&quot;+user); //user:User&#123;id=0, username=&apos;admin&apos;, password=&apos;123456&apos;, email=&apos;null&apos;, role=&apos;null&apos;, state=false&#125; return &quot;ok&quot;; &#125;&#125; 2.login.vue修改post: post到”login” 带上表单 4.3dao层接口！！！interface是interface ！不是类！ 1234567//@Repository用在持久层的接口上，这个注解是将接口的一个实现类交给spring管理。@Repositorypublic interface UserDao &#123; //用用户名和密码拿到user //@Param注解的作用是给参数命名,参数命名后就能根据名字得到参数值,正确的将参数传入sql语句中（一般通过#&#123;&#125;的方式，$&#123;&#125;会有sql注入的问题）。 public User getUserByMassage(@Param(&quot;username&quot;) String username, @Param(&quot;password&quot;) String password) ;&#125; 4.4mapper中实现接口的函数-sql【高亮！】之前一直报错找不到id=”getUserByMassage”。解决办法剪切xml内容,删除xml文件重新建立一个xml粘贴过去就好了。妈的气死了 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--namespace命名空间对应dao文件root path路径(复制reffrence),是resultType！实现dao中的方法-sql语句#&#123;&#125; 来传入dao中的 @param--&gt;&lt;mapper namespace=&quot;com.example.demo.dao.UserDao&quot;&gt; &lt;select id=&quot;getUserByMassage&quot; resultType=&quot;com.example.demo.bean.User&quot;&gt; SELECT * FROM easyuser WHERE username=#&#123;username&#125; AND password=#&#123;password&#125; AND state=1 &lt;/select&gt;&lt;/mapper&gt; 4.5loginController中用dao拿到user对象123456789101112131415161718//@RestController规定返回字符串@RestControllerpublic class LoginController &#123; @Autowired //注入dao UserDao userDao; //login方法接收前端传递给后端的数据并封装user对象中 // @RequestBody(请求体中放数据)主要用来接收前端传递给后端的json字符串中的数据的(请求体中的数据的);加上这个前端post的loginform才会被封装到user @RequestMapping(&quot;/login&quot;) public String login(@RequestBody User user)&#123; System.out.println(&quot;user:&quot;+user); //用dao的函数拿 user对象 User user1 = userDao.getUserByMassage(user.getUsername(),user.getPassword()); System.out.println(&quot;user1&quot;+user1); return &quot;ok&quot;; &#125;&#125; 4.6启动类扫描dao层的包名@MapperScan(“com.example.demo.dao”) 4.7loginController中并且把集合res转换成JSON字符串返回给前端pom里加fastjson依赖 12345678910111213141516171819202122232425@RequestMapping(&quot;/login&quot;) public String login(@RequestBody User user)&#123; String flag = &quot;error&quot;; //这个user里面只有名字密码 System.out.println(&quot;user:&quot;+user); //用dao的函数拿 user对象,这里面有user所有信息 User user1 = userDao.getUserByMassage(user.getUsername(),user.getPassword()); System.out.println(&quot;user1&quot;+user1); //后端前端接口都是JSON,json键/值都是字符串 //HashMap集合res中放两个键值对：有无user; user对象 HashMap&lt;String, Object&gt; res = new HashMap&lt;String, Object&gt;(); //数据库中有这个user，flag = &quot;ok&quot; if(user1 !=null)&#123; flag = &quot;ok&quot;; &#125; res.put(&quot;flag&quot;, flag); res.put(&quot;user&quot;, user); //把res集合对象转换成json字符串，json返回给前端 String res_json = JSON.toJSONString(res); return res_json; &#125; 4.8vue修改拿到的res12345678if(res.flag == &quot;ok&quot;)&#123; this.$message.success(&quot;操作成功&quot;); await this.$router.push(&#123;path: &quot;/home&quot;&#125;); console.log(res.user);//&#123;id: 0, password: &quot;123456&quot;, state: false, username: &quot;admin&quot;&#125; &#125; else&#123; this.$message.error(&quot;操作失败&quot;); &#125; 心得总结以上步奏完成了接收前端的表单信息，查找用户，拿到对象，返回结果1.从前端接收的表单数据封装到实体类user中，包括用户名和密码2.编写dao和mapper实现了 用用户名和密码去数据库中查找对应的user对象 的方法。(dao方法接口；mapper方法实现)3.在controller中注入dao，并且调用dao的方法，这样拿到了用户名和密码对应的user对象4.在controller中【返回值封装】把两个信息(是否有user; user对象;)装到HashMap集合res中,并且把集合res转换成JSON字符串返回给前端。5.在vue的login()中【解析返回值】现在前端是接收后端的res的json字符串，里面有两个信息，flag是ok；user是用户对象；取出res中的信息进行验证跳转路由。 5.存用户session/路由守卫存用户session：window.sessionStorage.setItem(“user”, res.user); 路由守卫：必须登录有session信息才能访问其他的页面，不然会被打回login页面【高亮！】先存session,再跳转，不然跳转不了login: 12345678910if(res.flag == &quot;ok&quot;)&#123; this.$message.success(&quot;操作成功&quot;); //console.log(res.user);//&#123;id: 0, password: &quot;123456&quot;, state: false, username: &quot;admin&quot;&#125; //存储user对象 session，然后跳转 window.sessionStorage.setItem(&quot;user&quot;, res.user); await this.$router.push(&#123;path: &quot;/home&quot;&#125;); &#125; else&#123; this.$message.error(&quot;操作失败&quot;); &#125; router index.js: 123456789101112131415//挂载路由导航守卫:必须登录有session信息才能访问其他的页面，不然会被打回login页面//三个参数： 将要访问哪,从哪来，将要干什么 next()放行router.beforeEach((to,from,next)=&gt;&#123; //访问首页，放行 if(to.path==&apos;/login&apos;) return next(); //取出user const userFlag = window.sessionStorage.getItem(&quot;user&quot;); //如果无值，返回登录页 if(!userFlag) return next(&apos;/login&apos;); //有值，放行 else next();&#125;); 清除session(home里面安全退出函数)： 12345logout()&#123; //退出的时候清除session(用户对象信息)，再回到首页 window.sessionStorage.clear(); this.$router.push(&quot;/login&quot;); &#125; 6. home页面6.1. vuehtml结构1.container布局2.加侧边栏3.侧边栏里面的菜单列表是在数据库里查询的，在created()里添加method把菜单列表信息渲染上去 123456789101112// 类似onload created() &#123; this.getMenuList(); &#125;,methods里面 // 获取所有的导航菜单 async getMenuList()&#123; const &#123;data:res&#125; = await this.$http.get(&quot;menus&quot;); console.log(res.data); if( res.status != 200) return this.$message.error(&quot;操作失败！！！&quot;); this.menuList = res.data; &#125;, 6.2. java里写对应数据库两张mune表的bean实体类和接口和查询xml1.实体类主菜单 12345private int id;private String title;private String path;//list集合里放submenu的每一行一共7行,main的id主键是sub的外键private List&lt;SubMenu&gt; sList; 子菜单 123private int id;private String title;private String path; // /use /admin 2.dao.MenuDao查询拿到所有主菜单行装到list集合中，xml里返回type是MainMenu 1234public interface MenuDao &#123; public List&lt;MainMenu&gt; getMenus();&#125; 3.mapper/MenuMapping.xmlmainmenu 一对多 submenu 要创建关系映射,用关系映射来描述main对sub一对多的关系.select语句查出来有六行 三个main 三个sub ；sub放在mian的List sList里，这是main的第四个属性. 123456789101112131415161718192021&lt;mapper namespace=&quot;com.example.demo.dao.MenuDao&quot;&gt; &lt;resultMap id=&quot;menuMap&quot; type=&quot;com.example.demo.bean.MainMenu&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/id&gt; &lt;result column=&quot;title&quot; property=&quot;title&quot;&gt;&lt;/result&gt; &lt;result column=&quot;path&quot; property=&quot;path&quot;&gt;&lt;/result&gt;&lt;!-- 这个要封装 ofType:容器里面的东西是什么。 然后把前面三个粘贴进来，改名字--&gt; &lt;collection property=&quot;sList&quot; ofType=&quot;com.example.demo.bean.SubMenu&quot;&gt; &lt;id column=&quot;sid&quot; property=&quot;id&quot;&gt;&lt;/id&gt; &lt;result column=&quot;stitle&quot; property=&quot;title&quot;&gt;&lt;/result&gt; &lt;result column=&quot;spath&quot; property=&quot;path&quot;&gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=&quot;getMenus&quot; resultMap=&quot;menuMap&quot;&gt; SELECT mm.*,sm.`id` AS sid, sm.`title` AS stitle, sm.`path` AS spath FROM mainmenu mm, submenu sm WHERE mm.id = sm.`mid` &lt;/select&gt;&lt;/mapper&gt; 6.3. MenuController业务功能：把menu查出来，如果查出来了就吧mune和状态码200放到hashmap里，如果查不出来就放状态码404到hashmap里。最后把hashmap转成json字符串给前端。 123456789101112131415161718192021222324@RestControllerpublic class MenuController &#123; @Autowired MenuDao menuDao; public String getAllMenus()&#123; //map里放查询结果 和 状态码 HashMap&lt;String,Object&gt; data = new HashMap&lt;&gt;(); int status = 404; //错误码404，成功码200 //调用dao的方法把menu查出来 放到集合menus List&lt;MainMenu&gt; menus = menuDao.getMenus(); //munes里有内容，就把munes放到hashmap data里，还有成功状态码 if(menus != null)&#123; data.put(&quot;menus&quot;, menus); data.put(&quot;flag&quot;, 200); &#125;else&#123; data.put(&quot;flag&quot;, 404); &#125; //把hashmap转成json发给前端 String stringJSON = JSON.toJSONString(data); return stringJSON; &#125;&#125; 6.4. 改home页面测试后端能不能拿得到数据async和await关键字，作为处理异步请求的一种解决方案，实际上是一个语法糖，在ES6中已经可以用生成器语法完成同样的操作，但是async/await的出现使得用这样的方式处理异步请求更加简单和明白。async 方法名(){ await 异步函数();} 12345678910111213141516created() &#123; //启动的时候就调用getMenuList() this.getMenuList(); &#125;,methods:&#123; //获取导航菜单 async getMenuList()&#123; console.log(&quot;发生了。&quot;); //用$http.get提交访问后台接口url,就可以拿到数据 //然后解析后台接口返回的json,存到res变量 const &#123;data:res&#125; = await this.$http.get(&quot;menu&quot;); //home页面打印 console.log(res); &#125;&#125; 6.5 home页面展示数据展示效果： [ { “id”: 100, “path”: “/admin”, “sList”: [ { “id”: 101, “path”: “/user”, “title”: “用户列表” }, { “id”: 102, “path”: “/rights”, “title”: “修改权限” }, { “id”: 103, “path”: “/sport”, “title”: “ 运动模块” }, { “id”: 104, “path”: “/goods”, “title”: “商品模块” } ], “title”: “权限管理” }, { “id”: 200, “path”: “/use”, “sList”: [ { “id”: 201, “path”: “/Introduction”, “title”: “运动科普” }, { “id”: 202, “path”: “/calories”, “title”: “卡路里” }, { “id”: 203, “path”: “/food”, “title”: “营养配餐” } ], “title”: “运动平台” } ] 解释： 最外面的[] 是data的，{},{}是res.menus从hashmap里取出来的mainmenu的两个对象,“sList”: [{},{},{}]是mainmenu对象的list属性,几个{}是submenu的对象。 “”: …, 对应key: value, key是xml中的property=”key名” 12345678data里： menuList:[],接上面的methodif(res.flag !=200) return this.$message.error(&quot;获取列表失败&quot;);//访问成功，数据回填到menuListthis.menuList = res.menus; 6.6. home页把数据遍历出来12345678910111213&lt;!-- mainmenu v-for遍历--&gt;&lt;el-submenu index=&quot;1&quot; v-for=&quot;item in menuList&quot; v-bind:key=&quot;item.id&quot;&gt; &lt;template slot=&quot;title&quot;&gt; &lt;i class=&quot;el-icon-location&quot;&gt;&lt;/i&gt; &lt;span&gt;导航一&#123;&#123;item.title&#125;&#125;&lt;/span&gt; &lt;/template&gt;&lt;!--submenu v-for遍历 从mainmenu的item里面取sList, 再遍历--&gt;&lt;el-menu-item index=&quot;1-1&quot; v-for=&quot;subitem in item.sList&quot; v-bind:key=&quot;subitem.id&quot;&gt; &lt;template slot=&quot;title&quot;&gt; &lt;i class=&quot;el-icon-location&quot;&gt;&lt;/i&gt; &lt;span&gt;&#123;&#123;subitem.title&#125;&#125;&lt;/span&gt; &lt;/template&gt;&lt;/el-menu-item&gt; 6.7. 没有做导航栏伸缩 p236.8. home-el-main容器里插入welcome页面1.el-main 123&lt;el-main&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/el-main&gt; 2.改路由import Welcome from ‘../views/Welcome’ 12345678910111213&#123; path: &apos;/home&apos;, name: &apos;Home&apos;, component: Home, redirect: &apos;/welcome&apos;,//先到home页面再重定向到子组件 children:[ &#123; path: &apos;/welcome&apos;, name: &apos;welcome&apos;, component: Welcome &#125; ] &#125; 6.9. 侧边栏里子导航菜单的点击跳转1.el-menu 里加v-bind:router=”true”2.el-menu-item里用v-bind:index赋值跳转的url。:index=”url” 这样el-menu点击就能跳转路由。【高亮！】v-bind:index=”subitem.path”一直跳转不到 取值的url,解决：删掉手打一遍。 1&lt;el-menu-item v-bind:index=&quot;subitem.path&quot; v-for=&quot;subitem in item.sList&quot; v-bind:key=&quot;subitem.id&quot;&gt; 6.10. 点击跳转的路径保存到session效果：在点开了子菜单之后，点刷，新导航栏就会有记忆的展开到点击过的子菜单 1.设置保存/url的data，并且和el-menu 用v-bind:双向绑定 12el-menu里v-bind:default-active=&quot;activePath&quot;data里:activePath:&apos;/welcome&apos;,//默认路径，双向绑定 2.el-menu-item里添加点击保存/url到session和data事件 12345678el-menu-item里v-on:click=&quot;saveNavState(subitem.path)&quot;methods://保存路径到activePath saveNavState(activePath)&#123; //把跳转路径放到sesson里面 window.sessionStorage.setItem(&apos;activePath&apos;, activePath); this.activePath = activePath; &#125;, 3.刷新启动的时候之前点击跳转的路径拿出来，动态修改activePath 123456created() &#123; //启动的时候就调用getMenuList() this.getMenuList(); //刷新启动的时候之前点击跳转的路径拿出来，动态修改activePath this.activePath = window.sessionStorage.getItem(&apos;activePath&apos;); &#125;, 7. /user页面7.1 大概vue页面框架【问题】搜索框很大是因为home页面里的el-main加了样式，删掉 1.面包屑导航栏 12345&lt;el-breadcrumb separator-class=&quot;el-icon-arrow-right&quot;&gt; &lt;el-breadcrumb-item :to=&quot;&#123; path: &apos;/home&apos; &#125;&quot;&gt;首页&lt;/el-breadcrumb-item&gt; &lt;el-breadcrumb-item&gt;权限管理&lt;/el-breadcrumb-item&gt; &lt;el-breadcrumb-item&gt;用户列表&lt;/el-breadcrumb-item&gt;&lt;/el-breadcrumb&gt; 样式： 1234.el-breadcrumb&#123; margin-bottom: 15px; font-size: 18px; &#125; 2.搜索框+搜索按钮el-row :gutter=”25” 让搜索框和按钮之间间隙25；el-col :span=”10” 包裹每个组件，设置组件的长度； 1234567891011121314151617&lt;!-- 卡片视图区 --&gt; &lt;el-card&gt;&lt;!-- --&gt; &lt;el-row :gutter=&quot;25&quot;&gt; &lt;!-- 搜索区域--&gt; &lt;el-col :span=&quot;10&quot;&gt; &lt;el-input placeholder=&quot;请输入搜索内容&quot; &gt; &lt;el-button slot=&quot;append&quot; icon=&quot;el-icon-search&quot;&gt;&lt;/el-button&gt; &lt;/el-input&gt; &lt;/el-col&gt; &lt;el-col :span=&quot;4&quot;&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;addDialogVisible = true&quot;&gt;添加用户&lt;/el-button&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;/el-card&gt; 卡片样式：框阴影 1234/* 卡片区域 !important 提高样式级别 */ .el-card&#123; box-shadow: 0 1px 1px rgba(0, 8, 10, 0.15) !important; &#125; 3.获取所有用户，弄到data里面大概页面框架 123456789101112131415created() &#123; this.getUserList(); &#125;, data()&#123; return&#123; &#125; &#125;, methods:&#123; //获取所有用户，弄到data里面 async getUserList() &#123; // 调用post请求 &#125; &#125; 7.2 回到java写接口UserDaogetAllUser ListgetUserCounts int 123456//有模糊查询 limit分页 开始页，每页多少条数据- //拿到所有user装到list (用户名，每页最大存放，页面大小) public List&lt;User&gt; getAllUser(@Param(&quot;username&quot;) String username, @Param(&quot;pageStart&quot;) int pageStart, @Param(&quot;pageSize&quot;) String pageSize); //根据用户名获取用户个数 public int getUserCounts(@Param(&quot;username&quot;) String username); 7.3 UserDao对应的xml分页+模糊查询模糊查询 123456789101112131415&lt;!-- if是非必须的，如果username不为null就会查询where,模糊查询 limit分页 开始页，每页多少条数据--&gt; &lt;select id=&quot;getAllUser&quot; resultType=&quot;com.example.demo.bean.User&quot;&gt; SELECT * FROM easyuser &lt;if test=&quot;username !=null&quot;&gt; WHERE username like #&#123;username&#125; &lt;/if&gt; LIMIT #&#123;pageStart&#125;, #&#123;pageSize&#125; &lt;/select&gt; &lt;select id=&quot;getUserCounts&quot; resultType=&quot;java.lang.Integer&quot;&gt; SELECT count(*) FROM easyuser &lt;if test=&quot;username !=null&quot;&gt; WHERE username like #&#123;username&#125; &lt;/if&gt; &lt;/select&gt; 7.4 UserController调用上面两个方法查出来数据并且返回getUserCounts 直接查到用户数量 -&gt;”numbers”, numbersgetAllUser 直接查到用户对象到List allUser -&gt;”data”, allUser 模糊查询的语法 “%username% “ 这一部分是在controller调用函数的时候作为参数传递过去的。 12345678910111213141516171819202122@RestControllerpublic class UserController &#123; @Autowired UserDao userDao; //把模糊查询的信息封装到实体类，从实体类调用方法拿到信息 //返回两个信息：查询的所有user,用户总数 @RequestMapping(&quot;/alluser&quot;) public String getUserList(QueryInfo queryInfo)&#123; int numbers = userDao.getUserCounts(&quot;%&quot;+queryInfo.getQuery()+&quot;%&quot;); //有模糊查询,查出用户数量 int pageStart = (queryInfo.getPageNum() -1 )* queryInfo.getPageSize(); //从哪条数据开始 //拿到所有user存到list List&lt;User&gt; allUser = userDao.getAllUser(&quot;%&quot;+queryInfo.getQuery()+&quot;%&quot;, pageStart, queryInfo.getPageSize()); HashMap&lt;String, Object&gt; res = new HashMap&lt;&gt;(); res.put(&quot;numbers&quot;, numbers); res.put(&quot;data&quot;, allUser); String jsonString = JSON.toJSONString(res); return jsonString; &#125;&#125; 7.5 userlist页面传递请求，拿到返回数据1.三个数据：queryInfo给后端发请求的参数对象；userList后端数据解析出来的所有用户列表；total后端数据解析出来的记录条数。2.用get发送请求，解析返回数据给data.调用get请求格式 (“url”, {params: 带上的数据});3.created()里调用method,之前写了就不写了。 12345678910111213141516171819202122232425262728name: &quot;&quot;,created() &#123; this.getUserList();&#125;,data()&#123; return&#123; //对应post给接口的三个参数(和后台封装的实体对象queryInfo一致)，写在对象里面 queryInfo:&#123; query:&quot;&quot;, //搜索信息 pageNum: 1, //当前页码 pageSize: 5 //每页最大条数 &#125;, //拿到返回的数据 userList: [], //用户列表 total: 0, //总记录数 &#125;&#125;,methods:&#123; //获取所有用户，弄到data里面 async getUserList() &#123; // 调用get请求格式 (&quot;url&quot;, &#123;params: 带上的数据&#125;); 同样是异步 const &#123;data:res&#125; = await this.$http.get(&quot;alluser&quot;, &#123;params: this.queryInfo&#125;); //数据取出来填到上面data this.total = res.numbers; this.userList = res.data; &#125;&#125; 7.6把data渲染到el-table展示用element-ui绘制一张表格，一个作用域插槽,还没有做几个操作的函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!-- 卡片视图区 --&gt; &lt;el-card&gt;&lt;!-- --&gt; &lt;el-row :gutter=&quot;25&quot;&gt; &lt;!-- 搜索区域--&gt; &lt;el-col :span=&quot;10&quot;&gt; &lt;el-input placeholder=&quot;请输入搜索内容&quot; &gt; &lt;el-button slot=&quot;append&quot; icon=&quot;el-icon-search&quot;&gt;&lt;/el-button&gt; &lt;/el-input&gt; &lt;/el-col&gt; &lt;el-col :span=&quot;4&quot;&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;addDialogVisible = true&quot;&gt;添加用户&lt;/el-button&gt; &lt;/el-col&gt; &lt;/el-row&gt;&lt;!-- 用户列表 绑定数据data border边框 stripe隔行变色--&gt; &lt;el-table v-bind:data=&quot;userList&quot; border stripe&gt;&lt;!-- 索引列,每一行的index自增--&gt; &lt;el-table-column type=&quot;index&quot;&gt;&lt;/el-table-column&gt;&lt;!-- 对应列名--&gt; &lt;el-table-column label=&quot;用户名&quot; prop=&quot;username&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column label=&quot;密码&quot; prop=&quot;password&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column label=&quot;邮箱&quot; prop=&quot;email&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column label=&quot;角色&quot; prop=&quot;role&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column label=&quot;状态&quot; prop=&quot;state&quot;&gt; &lt;!--状态列：作用域插槽 scope.row element-ui决定 存储了当前行的信息 --&gt; &lt;template slot-scope=&quot;scope&quot;&gt;&lt;!--数据模板，数据state添加到scope域内--&gt; &lt;el-switch v-model=&quot;scope.row.state&quot;&gt;&lt;/el-switch&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;!--自定义插槽--&gt;&lt;!-- 操作不是属性，不对应data--&gt; &lt;el-table-column label=&quot;操作&quot;&gt;&lt;!-- 每一行都有数据存储，全部操作放在template里面--&gt; &lt;template &gt; &lt;!-- 修改 --&gt; &lt;el-button type=&quot;primary&quot; icon=&quot;el-icon-edit&quot; size=&quot;mini&quot; &gt;&lt;/el-button&gt; &lt;!-- 删除 --&gt; &lt;el-button type=&quot;danger&quot; icon=&quot;el-icon-delete&quot; size=&quot;mini&quot; &gt;&lt;/el-button&gt; &lt;!-- 权限 --&gt; &lt;el-tooltip effect=&quot;dark&quot; content=&quot;分配权限&quot; placement=&quot;top-start&quot; :enterable=&quot;false&quot;&gt;&lt;!--文字提示 enterable 隐藏--&gt; &lt;el-button type=&quot;warning&quot; icon=&quot;el-icon-setting&quot; size=&quot;mini&quot;&gt;&lt;/el-button&gt; &lt;/el-tooltip&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;span&gt;&#123;&#123;userList&#125;&#125;&lt;/span&gt; &lt;/el-card&gt; 7.7 分页组件element-ui 提供了分页组件el-pagination几个属性： page-sizes：数组，提供多选框选择每页展示的记录条数 page-size：绑定data里的pageSize，每页的记录条数 total: 数据库记录总条数动态方法(@element-ui提供的方法)： @size-change=”handleSizeChange”：获取并修改当前的pageSize 12345678910111213&lt;!-- 分页组件:size-change每页最大记录条数变化(写方法)，current-change页码变化(写方法)，layout功能组件--&gt;&lt;div&gt; &lt;el-pagination @size-change=&quot;handleSizeChange&quot; @current-change=&quot;handleCurrentChange&quot; :current-page=&quot;currentPage4&quot; :page-sizes=&quot;[1, 2, 5, 100]&quot; :page-size=&quot;queryInfo.pageSize&quot; layout=&quot;total, sizes, prev, pager, next, jumper&quot; :total=&quot;total&quot;&gt; &lt;/el-pagination&gt;&lt;/div&gt; 方法：触发方法：1.获取新值，2.改变data,3.获取所有用户列表userList: []最后必须要this.getUserList();不然页面不能更新数据。因为userList所有的user对象，对象里封装了用户的所有属性。用户表格是绑定userList，列数据是绑定userList里面的属性的 12345678910111213141516171819202122methods:&#123; //获取所有用户，弄到data里面 async getUserList() &#123; // 调用get请求格式 (&quot;url&quot;, &#123;params: 带上的数据&#125;); 同样是异步 const &#123;data:res&#125; = await this.$http.get(&quot;alluser&quot;, &#123;params: this.queryInfo&#125;); //数据取出来填到上面data this.total = res.numbers; this.userList = res.data; &#125;, //size-change每页最大变化 pageSize触发功能 handleSizeChange(newSize)&#123; //改当前的pageSize this.queryInfo.pageSize = newSize; this.getUserList(); &#125;, //current-change当前最大变化 pagenum的触发功能 handleCurrentChange(newPage)&#123; //改当前的pageNum this.queryInfo.pageNum = newPage; this.getUserList(); &#125; &#125; 总结：使用element-ui提供的分页组件，自己写触发页数变化以及触发记录数变化的函数 7.8 状态switch按钮对应后台修改数据库1.UserDao定义方法根据用户id和state的boolean值(前端可以改变)去更新数据库中的数据；返回int 1public int updateState(Integer id,Boolean state); 2.usermapping实现方法 123&lt;select id=&quot;updateState&quot; resultType=&quot;java.lang.Integer&quot;&gt; UPDATE easyuser SET state = #&#123;state&#125; WHERE id = #&#123;id&#125;&lt;/select&gt; 3.usercontroller调用dao方法，返回修改成功与否 1234567 //调用dao层方法,返回是否成功@RequestMapping(&quot;/updateUserState&quot;)public String updataUserState(@RequestParam(&quot;id&quot;) Integer id, @RequestParam(&quot;state&quot;) Boolean state)&#123; //updateState返回值int,成功就有返回值1？ int successFlag = userDao.updateState(id,state); return successFlag &gt;0 ? &quot;success&quot; : &quot;error&quot;;&#125; 4.vue页面加方法@change=”userStateChanged(scope.row) 123&lt;template slot-scope=&quot;scope&quot;&gt; &lt;el-switch v-model=&quot;scope.row.state&quot; @change=&quot;userStateChanged(scope.row)&quot;&gt;&lt;/el-switch&gt; &lt;/template&gt; 1234567891011// 修改用户状态async userStateChanged(userinfo) &#123; const &#123; data: res &#125; = await this.$http.put( `userState?id=$&#123;userinfo.id&#125;&amp;state=$&#123;userinfo.state&#125;` ); if (res != &quot;success&quot;) &#123; userinfo.state = !userinfo.state; return this.$message.error(&quot;操作失败！！！&quot;); &#125; this.$message.success(&quot;操作成功！！！&quot;);&#125;, 5.存在问题：前端500报错，后端报错空指针。但是能够修改数据库中的状态！原因：UserDao.updateState attempted to return null from a method with a primitive return type (int).不管了。。。解决！！！：xml里面update语句是update标签不是select，没有返回类型 123&lt;update id=&quot;updateState&quot; &gt; UPDATE easyuser SET state = #&#123;state&#125; WHERE id = #&#123;id&#125;&lt;/update&gt; 7.9 vue查询图标绑定事件修改:绑定搜索信息，清除图标组件：点击之后展示所有列表;搜索点击模糊查询出列表 123&lt;el-input placeholder=&quot;请输入搜索内容&quot; v-model=&quot;queryInfo.query&quot; clearable @clear=&quot;getUserList&quot;&gt; &lt;el-button slot=&quot;append&quot; icon=&quot;el-icon-search&quot; @click=&quot;getUserList&quot;&gt;&lt;/el-button&gt;&lt;/el-input&gt; 7.10 添加用户后台实现1.userDaopublic int addUser(User user);2.xmlVALUE (#{username}, #{password},#{email},#{role},#{state})这些带#号的变量要和user实体对象一一对应 12345&lt;!--insert标签！！！，没有返回类型--&gt; &lt;insert id=&quot;addUser&quot; &gt; INSERT INTO easyuser (username,PASSWORD,email,role,state) VALUE (#&#123;username&#125;, #&#123;password&#125;,#&#123;email&#125;,#&#123;role&#125;,#&#123;state&#125;) &lt;/insert&gt; 3.controller 12345678 //前端的数据封装在user对象里面.前端传username,PASSWORD,email，controller里面设置Role，State@RequestMapping(&quot;/addUser&quot;)public String addUser(@RequestBody User user)&#123; user.setRole(&quot;普通用户&quot;); user.setState(false); int i = userDao.addUser(user); //insert语句会返回更新的条数 return i&gt;0 ? &quot;success&quot;:&quot;error&quot;;&#125; 7.11 添加用户vue页面实现点击 添加用户 出现表单， 提交【高亮】一个标签里面不能写两个@click=””,不然会报错而且整个页面都不会显示出来 1.绘制用户添加的表单:visible.sync=”addDialogVisible”是v-bind指令，只有v-bind指令才能缩写为： 123456789101112131415161718192021222324&lt;!-- 添加用户表单--&gt;&lt;!-- :model=&quot;表单对象&quot;;:visible.sync=&quot;addDialogVisible&quot;绑定出现消失对应属性；@click=&quot;addDialogVisible = false&quot;点击事件改变属性--&gt; &lt;el-dialog title=&quot;添加用户&quot; :visible.sync=&quot;addDialogVisible&quot; width=&quot;50%&quot; @close=&quot;addDialogClosed&quot;&gt; &lt;el-form :model=&quot;addForm&quot; :rules=&quot;addFormRules&quot; ref=&quot;addFormRef&quot; label-width=&quot;70px&quot;&gt; &lt;el-form-item prop=&quot;username&quot;&gt; &lt;span&gt;用户名：&lt;/span&gt;&lt;el-input v-model=&quot;addForm.username&quot; &gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;!-- 密码，input标签绑定loginForm对象中的密码--&gt; &lt;el-form-item prop=&quot;password&quot;&gt; 密码：&lt;el-input v-model=&quot;addForm.password&quot; type=&quot;password&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item prop=&quot;email&quot;&gt; 邮箱：&lt;el-input v-model=&quot;addForm.email&quot; type=&quot;email&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-form&gt;&lt;!-- 按钮，写在el-form外面,el-dialog里面--&gt; &lt;span slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;addUser&quot;&gt;确 定&lt;/el-button&gt;&lt;!-- 取消，让这个表单不显示--&gt; &lt;el-button @click=&quot;addDialogVisible = false&quot;&gt;取 消&lt;/el-button&gt; &lt;/span&gt; &lt;/el-dialog&gt; 2.添加用户按钮@click=”addDialogVisible = true”点击事件改变属性,让表单显示 12345&lt;el-col :span=&quot;4&quot;&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;addDialogVisible = true&quot;&gt;添加用户&lt;/el-button&gt;&lt;/el-col&gt;``` 3.data里添加这些绑定的属性 addDialogVisible: false, //对话框出现与否//表单对象addForm:{ username:””, password:””, email:””},//校验规则addFormRules:{ username: [ { required: true, message: ‘请输入用户名称’, trigger: ‘blur’ }, //必填项验证 { min: 3, max: 10, message: ‘长度在 3 到 10 个字符’, trigger: ‘blur’ }//长度验证 ], password:[ { required: true, message: ‘请输入用户密码’, trigger: ‘blur’ }, //必填项验证 { min: 3, max: 10, message: ‘长度在 3 到 10 个字符’, trigger: ‘blur’ }//长度验证 ], email:[ { required: true, message: ‘请输入邮箱’, trigger: ‘blur’ }, //必填项验证 { min: 5, max: 20, message: ‘请输入正确邮箱’, trigger: ‘blur’ }//长度验证 ]}, 12#### 7.12 写click绑定的方法成功与否都要拿到res //监听添加用户，看表单是否关闭。// 表单清零addDialogClosed(){ this.$refs.addFormRef.resetFields();},//添加用户表单校验和post表单和拿到返回值和把表单窗口隐藏掉和重新拉取用户数据async addUser(){ this.$refs.addFormRef.validate(async valid=&gt;{ console.log(valid); if(!valid) return; //成功与否都要res const{data:res} = await this.$http.post(“addUser”, this.addForm); if(res !=&quot;success&quot;){ this.$message.error(&quot;添加用户失败！&quot;); return; } else{ this.$message.success(&quot;添加用户成功！&quot;); //把表单窗口隐藏掉 this.addDialogVisible = false; this.getUserList(); //重新拉取用户数据 } })}, 12345#### 7.13 删除用户后台1.dao//删除用户(通过主键删除用户)public int deleteUser(int id);2.xml delete from easyuser where id = #{id} 13.controller @RequestMapping(“/deleteUser”)public String deleteUser(@RequestParam(“id”) Integer id){ int i = userDao.deleteUser(id); return i&gt;0 ? “success”:”error”;} 12#### 7.14 删除用户vue1.删除标签那里绑定method(传参id) &lt;el-table-column label=&quot;操作&quot;&gt; 12.方法 //根据主键删除用户async deleteUser(id){ //给用户一个提示信息 const confirmResult = await this.$confirm(“此操作将永久删除用户，是否删除？”,”提示”,{ //{}中写提示信息 确定按钮 取消按钮 confirmButtonText: “确定”, cancelButtonText: “取消”, type: ‘warning’ //按钮类型 }).catch(error =&gt; error); //取消删除 返回并提示信息 if(confirmResult !=’confirm’){ return this.$message.info(“已取消删除”); } //没有取消返回就delete const {data:res} = await this.$http.delete(“deleteUser?id=”+id); if(res !=”success”) return this.$message.error(“删除失败”); else{ return this.$message.success(“删除成功”); this.getUserList(); //拉取用户信息，刷新table }}, 12345678910#### 7.15 修改用户信息后台注意：两个方法，写两个controller的方法都要返回给前端1.dao//修改用户信息//先用主键id获取到要修改的user对象public User getUpdateUser(int id);//再用user对象去数据库里修改信息public int editUser(User user);2.xml &lt;select id=&quot;getUpdateUser&quot; resultType=&quot;com.example.demo.bean.User&quot;&gt; select * from easyuser where id = #{id} &lt;/select&gt; &lt;update id=&quot;editUser&quot;&gt; update easyuser set username = #{username}, password=#{password}, email=#{email}, role=#{role}, state=#{state} where id = #{id} &lt;/update&gt;123.controller //springboot会把提交给前端页面的任何对象转换成json字符串，但是这里都是手动转了//修改用户信息@RequestMapping(“/getUpdateUser”)public String getUpdateUser(@RequestParam(“id”) Integer id){ User updateUser = userDao.getUpdateUser(id); //把查出来的user对象转成json字符串，返回给前端 String jsonString = JSON.toJSONString(updateUser); return jsonString;}@RequestMapping(“/editUser”)public String editUser(@RequestBody User editUser){ int i = userDao.editUser(editUser); return i&gt;0 ? “success”:”error”;} 12#### 7.16 修改用户信息vue1.修改按钮 &lt;el-button type=”primary” icon=”el-icon-edit” size=”mini” @click=”showEditDialog(scope.row.id)”&gt; 122.修改对话框表单 &lt;el-dialog title=&quot;编辑用户信息&quot; :visible.sync=&quot;editDialogVisible&quot; width=&quot;50%&quot; @close=&quot;editDialogClosed&quot;&gt; &lt;el-form :model=&quot;editForm&quot; :rules=&quot;editFormRules&quot; ref=&quot;editFormRef&quot; label-width=&quot;70px&quot;&gt; &lt;el-form-item prop=&quot;username&quot; &gt; &lt;span&gt;用户名：&lt;/span&gt;&lt;el-input v-model=&quot;editForm.username&quot; disabled&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;!-- 密码，input标签绑定loginForm对象中的密码--&gt; &lt;el-form-item prop=&quot;password&quot;&gt; 密码：&lt;el-input v-model=&quot;editForm.password&quot; type=&quot;password&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item prop=&quot;email&quot;&gt; 邮箱：&lt;el-input v-model=&quot;editForm.email&quot; type=&quot;email&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;!-- 按钮，写在el-form外面,el-dialog里面--&gt; &lt;span slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;editUserInfo&quot;&gt;确 定&lt;/el-button&gt; &lt;!-- 取消，让这个表单不显示--&gt; &lt;el-button @click=&quot;editDialogVisible = false&quot;&gt;取 消&lt;/el-button&gt; &lt;/span&gt; &lt;/el-dialog&gt;123.添加data editDialogVisible: false, //修改用户表单出现与否//添加用户表单对象addForm:{ username:””, password:””, email:””},//修改用户信息表单对象,后台传过来的对象editForm:{}, 12344.添加method【高亮！！！】 res = await点击报错username undifined，后台没错能进入接口返回string,是因为这里没写await！！拿不到返回值！！ //点击修改按钮的时候就用id去后台拿这行id对应的user对象，并且让编辑对话框显示async showEditDialog(id){ //获取id对应的user对象,get和put都是 (“url?后端接收的参数”+前端参数) //点击报错username undifined，后台没错能进入接口返回string,是因为这里没写await！！拿不到返回值！！ const {data: res} = await this.$http.get(“getUpdateUser?id=”+id); this.editForm = res; //后台给的user信息反填到editForm里 this.editDialogVisible = true; //让编辑对话框显示 //console.log(editForm);},//关闭对话框窗口editDialogClosed(){ this.$refs.editFormRef.resetFields();//重置对话框信息},//确认按钮async editUserInfo(){ this.$refs.editFormRef.validate(async valid =&gt; { //前端验证不成功 if(!valid) return; //前端验证成功发起请求; const {data:res} = await this.$http.post(“editUser”, this.editForm); if(res !=”success”){ return this.$message.error(“编辑用户失败”); } else{ this.$message.success(“编辑用户成功”); //隐藏对话框 this.editDialogVisible = false; //重新拉取加载用户table this.getUserList(); } })}, --- ### 视频完结-闲聊 项目从大到小，从面到点，遇见什么去学什么。 做得少了，不知道哪里薄弱哪里补。 不能放弃数据结构和算法。 自律晚做不如早做。","categories":[],"tags":[]},{"title":"电影网站","slug":"电影网站","date":"2020-11-09T06:22:12.000Z","updated":"2020-11-10T10:10:45.706Z","comments":true,"path":"2020/11/09/电影网站/","link":"","permalink":"https://lucifinil-x.github.io/2020/11/09/电影网站/","excerpt":"安装安装docker安装Minio安装教程：https://blog.csdn.net/kylinregister/article/details/88910350?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param运行：https://blog.csdn.net/qq_39218530/article/details/107839487","text":"安装安装docker安装Minio安装教程：https://blog.csdn.net/kylinregister/article/details/88910350?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param运行：https://blog.csdn.net/qq_39218530/article/details/107839487 1.下载2.cmd进入安装目录cd D:\\安装Minio3.创建一个放图片的文件夹D:\\安装Minio\\img存储目录4.执行.\\minio.exe server D:\\安装Minio\\img存储目录5.进入http://127.0.0.1:9000浏览器访问http://127.0.0.1:9000，如果可以访问，则表示minio已经安装成功。输入上面自定义的access key 和 secret key就可以登录了。 命令行给的密码：AccessKey: minioadminSecretKey: minioadmin 命令行给的地址都能用：这里用这个http://127.0.0.1:9000 不安装nacos安装和配置：https://blog.csdn.net/wk52525/article/details/880962951.下载安装包-解压2.cmd进入bin目录：cd D:\\nacos安装\\nacos-develop\\distribution\\bin3.startup.cmd 安装Elasticsearch教程：https://blog.csdn.net/qq_27512271/article/details/848588811.下载并安装Elasticsearch服务 2.1、安装Java JDK：在安装Elasticsearch引擎之前，必须安装ES需要的软件环境，安装Java JDK和配置JAVA_HOME环境变量，Elasticsearch5.0以上版本需要安装jdk1.8，其他版本安装jdk1.7即可。安装jdk后最好禁用Java JDK的自动更新。 2.2、从官方下载中心：ElasticSearch Download下载ElasticSearch安装包并解压。 2.3、开启ElasticSearch 服务：进入D:\\Elasticsearch安装\\elasticsearch-7.9.3\\bin目录，双击执行 elasticsearch.bat，该脚本文件执行 ElasticSearch 安装程序，稍等片刻，打开浏览器，输入 http://localhost:9200 ，显式以下画面，说明ES安装成功。 2.安装Elasticsearch head插件 为了便于管理ES，本文使用head插件，这是最初级的管理工具，在浏览器中显示ES集群，索引等信息，十分好用。 3.1、安装Elasticsearch head： 下载地址：elasticsearch-head，点击clone or download按钮，点击download zip进行下载。下载完毕后解压到任意路径上，别放在elasticsearch安装路径上。 3.2、安装node.js：(安装过) 3.3、安装grunt： 运行head需要借助grunt命令，因此需要安装grunt，打开cmd，输入命令 cd C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Node.js（你安装nodejs的路径） 进入nodejs的根目录下，然后执行指令 npm install -g grunt -cli 进行安装grunt。 3.4、安装pathomjs： 输入命令 cd D:\\Elasticsearch安装\\elasticsearch-head-master（你安装head的路径） 进入head的根目录下，然后执行命令：npm install 进行安装pathomjs。 3.5、运行head： cd D:\\Elasticsearch安装\\elasticsearch-head-master（你安装head的路径） 接着运行命令 grunt server，启动head服务（默认端口号是9100）。 3.6、用head访问elasticsearch浏览器访问 http://localhost:9100 （head的服务端口） mongodb启动：https://blog.csdn.net/rentian1/article/details/70213463启动之后创建用户：https://www.jianshu.com/p/62736bff7e2e 1.启动: cmd: d: cd D:\\mongodb安装\\bin 执行mongod.exe –dbpath :\\mongodb安装\\data\\db 2.点击打开D:\\mongodb安装\\bin 里面的mongo.exe 执行shou dbs显示所有的数据库 3.切换到admin数据库：use admin 4.创建用户：db.createUser({user:”admin”, pwd: “518985599.”, roles: [“root”]}) 5.尝试使用上面创建的用户信息进行连接:db.auth(‘admin’, ‘518985599.’) 6.创建数据库recommend_system：use recommend_system; db.createUser({user: “root”, pwd: “518985599.”, roles: [{ role: “dbOwner”, db: “recommend_system” }]}) 7.退出 mysqlsql文件位置：D:\\vue学习练习\\MovieWeb\\安装教程 cmd用sql文件导入数据：1.搜索mysql5.7打开命令行2.输入密码 ok3.Mysql&gt;source 【sql脚本文件的路径全名】 这里是：source D:\\vue学习练习\\MovieWeb\\安装教程\\recommendSystemTables.sql进入数据库用sql文件导入数据：【推荐】1.点击打开sqlyog2.创建数据库(db: “recommend_system”)3.右键数据库-导入-执行sql脚本-选择sql文件位置4.刷新数据库 修改springboot-java1.mysql【高亮】几个属性要对齐 123456spring: datasource: url: jdbc:mysql://localhost:3306/recommend_system?useUnicode=true&amp;useSSL=false&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai username: root password: zhangcaiyun driver-class-name: com.mysql.jdbc.Driver 2.mongodb没有改对于数据库创建的时候指定了用户名和密码 user: “root”, pwd: “518985599.”, @后面要改 1234data: mongodb: uri: mongodb://admin:518985599.@mongo:27017/?authSource=admin database: recommend_system 3.rabbitmq 123456rabbitmq: host: 127.0.0.1 # rabbitmq的连接地址 port: 5672 # rabbitmq的连接端口号 # virtual-host: /mall # rabbitmq的虚拟host username: guest # rabbitmq的用户名 password: guest # rabbitmq的密码 4.redis 12345redis: host: 127.0.0.1 # Redis服务器地址 database: 0 # Redis数据库索引（默认为0） port: 6379 # Redis服务器连接端口 password: # Redis服务器连接密码（默认为空） 5.minio 123456minio: endpoint: http://127.0.0.1:9000 #nginx反向代理到minio所在的地址 http://192.168.198.128:9090 nginxPath: http://localhost/img bucketName: bilibili #存储桶名称 accessKey: minioadmin #访问的key secretKey: minioadmin #访问的秘钥 6.config-shiro-esconfig本机ip:IPv4 地址 . . . . . . . . . . . . : 192.168.56.1(首选)host用es的默认 920 运行bug1.改了pom.xml的tomcathttps://blog.csdn.net/qq_40051434/article/details/830398782.说service,esmovierepository里面爆红https://blog.csdn.net/u013030276/article/details/50959349pom.xml-build里加入,就没有这个报错了，而且运行控制台有颜色了 12345678910111213141516171819202122&lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;include&gt;**/*.tld&lt;/include&gt; &lt;include&gt;**/*.jsp&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;include&gt;**/*.tld&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt;&lt;/resources&gt; 3.启动类springboot后面加(exclude = DataSourceAutoConfiguration.class)https://blog.csdn.net/lizhe0327/article/details/104934522报错：If you want an embedded database (H2, HSQL or Derby), please put it on the classpath. If you have database settings to be loaded from a particular profile you may need to activate it (no profiles are currently active).4.ybatis-generator-maven的外部文件链接爆红https://blog.csdn.net/qq_35598865/article/details/88936975 运行vuenpm run serve 作者代码clone到本地运行（调用的是公网接口） 体验账号 青城山下 密码12345678首页http://localhost/后台界面 http://localhost/#/admin 开始做太难了感觉有cloud","categories":[],"tags":[]},{"title":"小说网站","slug":"小说网站","date":"2020-11-06T09:03:36.000Z","updated":"2020-12-23T19:13:32.711Z","comments":true,"path":"2020/11/06/小说网站/","link":"","permalink":"https://lucifinil-x.github.io/2020/11/06/小说网站/","excerpt":"安装1.安装RabbitMQhttps://www.cnblogs.com/saryli/p/9729591.html出错了就卸载重新装了，访问http://localhost:15672默认用户名和密码都是guest，登陆即可。","text":"安装1.安装RabbitMQhttps://www.cnblogs.com/saryli/p/9729591.html出错了就卸载重新装了，访问http://localhost:15672默认用户名和密码都是guest，登陆即可。 运行它： 1.打开 D:\\RabbitMQ安装\\rabbitmq_server-3.8.9\\sbin目录，双击rabbitmq-server.bat 2.访问http://localhost:15672 3.输入用户名和密码都是guest 2.mongodbhttps://blog.csdn.net/weixin_41466575/article/details/105326230 https://blog.csdn.net/qq_15980721/article/details/1025865183.python的库pikahttps://www.imooc.com/article/17327pycharm中打开项目，命令行pip install pika -i https://pypi.douban.com/simple/提示让使用：pip install pika -i https://pypi.douban.com/simple/python -m pip install –upgrade pip然后Successfully installed pip-20.2.4安装了pip 是python的软件管理包然后再pip install pika -i https://pypi.douban.com/simple/显示已经可以了Requirement already satisfied: pika in d:\\python3.7.2\\lib\\site-packages (1.1.0) py文件中不报红就可以了4.python的库PyMySQL 命令行pip install PyMySQL5.python的库scrapy pip install scrapy6.python的库redis pip3 install redis7.python的库pymongopip install pymongo 导入springboot项目-javafile-open-项目文件夹 是他本来的文件夹！然后maven自己导入依赖能够运行的文件位置：D:\\vue学习练习\\vueNovelWeb\\NovelWebGit\\javaPro 导入vue项目1.进入vue项目文件夹(根目录)2.直接shift+右键3.npm install 4.npm run dev注意：npm install 时候报错不用管直接运行就可以了。found 1226 vulnerabilities (1185 low, 16 moderate, 25 high) run npm audit fix to fix them, or npm audit for details 运行https://gitee.com/liupengss/novel1.运行RabbitMQ 1.打开 D:\\RabbitMQ安装\\rabbitmq_server-3.8.9\\sbin目录，双击rabbitmq-server.bat 2.访问http://localhost:15672 3.输入用户名和密码都是guest 2.mongodb启动：https://blog.csdn.net/rentian1/article/details/70213463启动之后创建用户：https://www.jianshu.com/p/62736bff7e2e 1.启动: cmd: d: cd D:\\mongodb安装\\bin 执行mongod.exe –dbpath D:\\mongodb安装\\data\\db 启动mongod之后再启动springboot 2.点击打开D:\\mongodb安装\\bin 里面的mongo.exe 执行show dbs显示所有的数据库 执行use local切换到local数据库 3.运行redis 1.cmd1命令行 cd C:\\redis 然后运行 redis-server.exe redis.windows.conf (两行全部复制不要复制漏了) 2. cmd2命令行 cd C:\\redis 然后运行 redis-cli.exe -h 127.0.0.1 -p 6379 4.springboot idea启动 5.运行两个vue 1.进入vue项目文件夹(根目录) 2.直接shift+右键 3.npm run dev 或者 1.idea中打开vue项目文件夹 2.alt+f12 3.npm run dev 6.运行python 1.cmd: d: cd D:\\vue学习练习\\vueNovelWeb\\NovelWebGit\\pythonPro\\novel-spider\\novel\\spiders 2.执行python test.py — 1.打开pycharm D:\\vue学习练习\\vueNovelWeb\\NovelWebGit\\pythonPro\\novel-spider\\novel 是novel 2.open 6.进入网页 http://localhost:1113/ 进入前端页面 http://localhost:9528/ 进入后端管理页面 测试账号 admin1/123456 修改的地方1.java项目-resources-application.yml 和dev-yml:host都为127.0.0.1(因为报错rabbitmq，原因时两个rabbitmq的host不一致) 1234567891011121314rabbitmq: host: 127.0.0.1 # rabbitmq的连接地址 port: 5672 # rabbitmq的连接端口号 virtual-host: /novel # rabbitmq的虚拟host username: guest # rabbitmq的用户名 password: guest # rabbitmq的密码 publisher-confirms: true #如果对异步消息需要回调必须设置为truesrabbitmq: host: 127.0.0.1 # rabbitmq的连接地址 port: 5672 # rabbitmq的连接端口号 virtual-host: /novel # rabbitmq的虚拟host username: guest # rabbitmq的用户名 password: guest # rabbitmq的密码 publisher-confirms: true #如果对异步消息需要回调必须设置为trues 2.java项目-resources-application.yml 和dev-yml:host: 127.0.0.1 (因为报错连接不到redis) 1234567891011121314redis: #host: redis # Redis服务器地址 host: 127.0.0.1 database: 0 # Redis数据库索引（默认为0） port: 6379 # Redis服务器连接端口 password: # Redis服务器连接密码（默认为空） timeout: 3000ms # 连接超时时间（毫秒）redis: #host: dev # Redis服务器地址 host: 127.0.0.1 database: 0 # Redis数据库索引（默认为0） port: 6379 # Redis服务器连接端口 password: # Redis服务器连接密码（默认为空） timeout: 3000ms # 连接超时时间（毫秒） 3.mysql(因为报错ERROR 6720 — [eate-1953120246] com.alibaba.druid.pool.DruidDataSource : create connection SQLException, url: jdbc:mysql://mysql:3306/novel?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai, errorCode 0, state 08S01)改成： 1234datasource: url: jdbc:mysql://localhost:3306/novel?useUnicode=true&amp;useSSL=false&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai username: root password: zhangcaiyun 原代码： 12345678910-dev的： datasource: url: jdbc:mysql://dev:3306/novel?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai username: root password: rootdatasource: url: jdbc:mysql://mysql:3306/novel?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai username: root password: root 4.python spiders里的import 把novel全删了改 12pool = redis.ConnectionPool(host=&apos;cloud-redis&apos;, port=6379, decode_responses=True)db = pymysql.connect(&apos;127.0.0.1&apos;, &apos;root&apos;, &apos;zhangcaiyun&apos;, &apos;novel&apos;)","categories":[],"tags":[]},{"title":"element-ui","slug":"element-ui","date":"2020-11-02T11:20:03.000Z","updated":"2020-11-14T10:54:01.637Z","comments":true,"path":"2020/11/02/element-ui/","link":"","permalink":"https://lucifinil-x.github.io/2020/11/02/element-ui/","excerpt":"安装位置 element-ui: vue项目的根目录 element-ui安装安装插件element-ui","text":"安装位置 element-ui: vue项目的根目录 element-ui安装安装插件element-ui 1.控制台vue项目文件夹路径下cnpm install element-ui –save2.项目中main.js 导入依赖之后就可以在项目中(xxx.vue)全局复制使用elementui的组件代码。 main.js 导入依赖：import Element from ‘element-ui’main.js 导入element-ui的css样式：import “element-ui/lib/theme-chalk/index.css”main.js 声明使用: Vue.use(Element); 官网https://element.eleme.cn/#/zh-CN/component/container 特性！(遇坑)1.element-ui的主标签el-form绑定v-model只能写：model 使用element-ui时报错element-ui.common.js?5c96:22906 [Element Warn][Form]model is required for resetFields to work.原因：绑定的model属性可能写成了v-model，这样而且你会发现做校验做不了，因为你没有传正确的model属性过去，所以它们没有收到你输入的值 解决：使用el-form的时候绑定的model属性应该写成 ：model，而不是v-model2.element-ui使用了container就是div下的一级标签了 写页面嵌套路由1234567891011121314151617&#123; path: &quot;/main&quot;, name: &apos;main&apos;, component: main, //children[&#123;&#125;,&#123;&#125;,&#123;&#125;]嵌套路由 外面大路由里面小路由 在main页面里面跳转 8080/user/profile 展示局部页面 children: [ &#123;path: &quot;/user/profile&quot;, name: &apos;profile&apos;, component: UserProfile &#125;, &#123; path: &quot;/user/list&quot;, name: &apos;list&apos;, component: UserList //写成功了ctrl+左键能点进vue组件 &#125; ] &#125; 页面局部展示 局部页面跳转用router-link to 12345678&lt;el-submenu index=&quot;1&quot;&gt; &lt;template slot=&quot;title&quot;&gt;&lt;i class=&quot;el-icon-message&quot;&gt;&lt;/i&gt; &lt;router-link to=&quot;/user/profile&quot;&gt;用户信息&lt;/router-link&gt;&lt;/template&gt; &lt;/el-submenu&gt; &lt;el-submenu index=&quot;2&quot;&gt; &lt;template slot=&quot;title&quot;&gt;&lt;i class=&quot;el-icon-menu&quot;&gt;&lt;/i&gt;&lt;router-link to=&quot;/user/list&quot;&gt;用户列表&lt;/router-link&gt;&lt;/template&gt; &lt;/el-submenu&gt; 局部页面展示写在el-main里面 123&lt;el-main&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/el-main&gt; url传递参数解释： 接收多个参数的url链接用数组，还要改路由. {name: ‘地址’, params:{参数: 参数值}. vm双向绑定，to需要绑定,v-bind:设置元素的属性. name是组件名(路由里设置的name),params传递参数需要对象，通过v-bind: 绑定对象，对象由路由里的path接收. 第一种流程： 1.main页面router-link链接params传递参数 id:1. 2.路由path接收参数/:id. 3.跳转到的页面组件取出参数展示 1.主页面： 123&lt;template slot=&quot;title&quot;&gt;&lt;i class=&quot;el-icon-message&quot;&gt;&lt;/i&gt; &lt;router-link :to=&quot;&#123;name: &apos;profile&apos;, params:&#123;id:1&#125;&#125;&quot;&gt;用户信息&lt;/router-link&gt;&lt;/template&gt; 2.路由： 123456789101112&#123; path: &quot;/main&quot;, name: &apos;main&apos;, component: main, //children[&#123;&#125;,&#123;&#125;,&#123;&#125;]嵌套路由 外面大路由里面小路由 在main页面里面跳转 8080/user/profile 展示局部页面 children: [ &#123;path: &quot;/user/profile/:id&quot;, name: &apos;profile&apos;, component: UserProfile &#125; ] &#125; 3.跳转页面 1234567&lt;template&gt; &lt;div&gt; &lt;h1&gt;用户信息&lt;/h1&gt;&lt;!-- 数据双向绑定，取值展示到页面，取值用route--&gt; &#123;&#123;$route.params.id&#125;&#125; &lt;/div&gt;&lt;/template&gt; 第二种流程： 1.修改路由配置 props 2.页面组件添加 props,取值展示 1.路由 12345&#123;path: &quot;/user/profile/:id&quot;, name: &apos;profile&apos;, component: UserProfile, props: true //第二种绑定传参数 &#125;, 2.页面 123456789&lt;!-- 第二种方式props: [&apos;id&apos;]和path/:id绑定起来，html里面就可以取出来用了--&gt; &#123;&#123;id&#125;&#125;export default &#123; //路由那边props: true允许了id参数，组件这边props接收参数id // props: [&apos;id&apos;]和path/:id绑定起来，html里面就可以取出来用了 props: [&apos;id&apos;], name: &quot;&quot; &#125; 第三种流程(多参数不清楚)： 1.改main中params 2.改路由path: “/user/profile”,props: true 3.子页面props和取值 props: [‘id’, ‘name’], 登录跳转到main页面带上用户的表单信息1.login组件 12345if (valid) &#123; alert(&apos;submit!&apos;); //进内容页main,登录push进当前用户的年龄 this.$router.push(&quot;/main/&quot; +this.ruleForm.age); &#125; 2.main的路由 1234path: &quot;/main/:age&quot;, name: &apos;main&apos;, component: main, props: true, 3.main组件 12&lt;span&gt;&#123;&#123;age&#125;&#125;&lt;/span&gt;props: [&apos;age&apos;],","categories":[],"tags":[]},{"title":"vs使用","slug":"vs使用","date":"2020-10-12T11:24:08.000Z","updated":"2020-10-31T13:45:45.592Z","comments":true,"path":"2020/10/12/vs使用/","link":"","permalink":"https://lucifinil-x.github.io/2020/10/12/vs使用/","excerpt":"","text":"vs快捷键ctrl + A 全选代码shift + ctrl + / 全部注释ctrl+鼠标滚轮 缩放代码比例ctrl + shift + H 查找和替换","categories":[],"tags":[]},{"title":"对程序本质的思考-狂神","slug":"对程序本质的思考-狂神","date":"2020-10-03T10:38:22.000Z","updated":"2020-10-05T02:38:25.179Z","comments":true,"path":"2020/10/03/对程序本质的思考-狂神/","link":"","permalink":"https://lucifinil-x.github.io/2020/10/03/对程序本质的思考-狂神/","excerpt":"第一节程序编程是指挥程序帮助我们解决生活中的问题应用层客户端/前端 是 页面与用户交互，提交请求的。服务端都是做请求的处理。–存数据，查询数据，返回结果给客户端。","text":"第一节程序编程是指挥程序帮助我们解决生活中的问题应用层客户端/前端 是 页面与用户交互，提交请求的。服务端都是做请求的处理。–存数据，查询数据，返回结果给客户端。 数据库：关系型，非关系型(键值对，用key查value)客户端提交url+参数给服务器。写接口–请求处理的方法：接收数据，查询数据，返回数据/页面","categories":[],"tags":[]},{"title":"狂神的springboot学习","slug":"狂神的springboot学习","date":"2020-09-25T05:15:47.000Z","updated":"2020-10-14T08:48:54.083Z","comments":true,"path":"2020/09/25/狂神的springboot学习/","link":"","permalink":"https://lucifinil-x.github.io/2020/09/25/狂神的springboot学习/","excerpt":"https://blog.csdn.net/qq_33369905/article/details/105828924","text":"https://blog.csdn.net/qq_33369905/article/details/105828924 学习代码笔记注解/逻辑controller逻辑1.填表提交跳转页面@controller.(默认跳转ok页面)所以加上@ResponseBody会展示ok字符串 //目前的逻辑：index.html里面form里有一个(sign in)提交按钮，提交之后th:action=”@{/uer/login}”通过action提交表单给/uer/login，跳转到/uer/login的url。// 然后这里的controller接收前端传来的/uer/login的url，然后return “OK”字符串再/uer/login的页面上 12345678@Controllerpublic class LoginController &#123; @RequestMapping(&quot;/uer/login&quot;) //接收前端 @ResponseBody //这里return的ok不是页面，又用的@controller.(默认跳转ok页面) 所有加上@ResponseBody会展示ok字符串 public String login()&#123; return &quot;OK&quot;; &#125;&#125; 2.提交，验证参数，跳转页面，页面中回显消息(html) 12345678910111213141516171819202122232425@Controllerpublic class LoginController &#123; //目前的逻辑：index.html里面form里有一个(sign in)提交按钮，提交之后th:action=&quot;@&#123;/uer/login&#125;&quot;通过action提交表单给/uer/login，跳转到/uer/login的url。 // 然后这里的controller接收前端传来的/uer/login的url，然后return &quot;OK&quot;字符串再/uer/login的页面上 @RequestMapping(&quot;/uer/login&quot;) //接收前端url //@ResponseBody //这里return的ok不是f页面，又用的@controller.(默认跳转ok页面) 所有加上@ResponseBody会展示ok字符串 public String login(@RequestParam(&quot;username&quot;) String username, @RequestParam(&quot;password&quot;) String password , Model model)&#123; //接收前端提交过来的表格中的数据： @请求参数(form里的name) String 自己取的参数名字. 回显数据：Model model //具体的业务 if(!StringUtils.isEmpty(username) &amp;&amp; &quot;12345&quot;.equals(password) )&#123; //验证用户名和密码 return &quot;dashboard&quot;;// return &quot;redirect:/main.html&quot;; &#125; else&#123; //告诉用户登录失败,用model值，显示在页面 model.addAttribute(&quot;msg&quot;, &quot;用户名或者密码错误&quot;); //stirng,object(这里是字符串) return &quot;index&quot;; //失败到index //到index之后应该在请登录大标题那里 放一个提示。网页审查元素发现是h1标签。于是去index.html h1下面放一个消息回显 &#125;// return &quot;OK&quot;; &#125;&#125; 小point1.java代码改了要重启，html css js 这些静态资源改了只需要刷新网页 SpringBoot01：Hello,World！回顾什么是SpringSpring是一个开源框架，2003 年兴起的一个轻量级的Java 开发框架，作者：Rod Johnson 。 Spring是为了解决企业级应用开发的复杂性而创建的，简化开发。 **** Spring是如何简化Java开发的为了降低Java开发的复杂性，Spring采用了以下4种关键策略： 1、基于POJO的轻量级和最小侵入性编程，所有东西都是bean； 2、通过IOC，依赖注入（DI）和面向接口实现松耦合； 3、基于切面（AOP）和惯例进行声明式编程； 4、通过切面和模版减少样式代码，RedisTemplate，xxxTemplate； 什么是SpringBoot学过javaweb的同学就知道，开发一个web应用，从最初开始接触Servlet结合Tomcat, 跑出一个Hello Wolrld程序，是要经历特别多的步骤；后来就用了框架Struts，再后来是SpringMVC，到了现在的SpringBoot，过一两年又会有其他web框架出现；你们有经历过框架不断的演进，然后自己开发项目所有的技术也在不断的变化、改造吗？建议都可以去经历一遍； 言归正传，什么是SpringBoot呢，就是一个javaweb的开发框架，和SpringMVC类似，对比其他javaweb框架的好处，官方说是简化开发，约定大于配置， you can “just run”，能迅速的开发web应用，几行代码开发一个http接口。 所有的技术框架的发展似乎都遵循了一条主线规律：从一个复杂应用场景 衍生 一种规范框架，人们只需要进行各种配置而不需要自己去实现它，这时候强大的配置功能成了优点；发展到一定程度之后，人们根据实际生产应用情况，选取其中实用功能和设计精华，重构出一些轻量级的框架；之后为了提高开发效率，嫌弃原先的各类配置过于麻烦，于是开始提倡“约定大于配置”，进而衍生出一些一站式的解决方案。 是的这就是Java企业级应用-&gt;J2EE-&gt;spring-&gt;springboot的过程。 随着 Spring 不断的发展，涉及的领域越来越多，项目整合开发需要配合各种各样的文件，慢慢变得不那么易用简单，违背了最初的理念，甚至人称配置地狱。Spring Boot 正是在这样的一个背景下被抽象出来的开发框架，目的为了让大家更容易的使用 Spring 、更容易的集成各种常用的中间件、开源软件； Spring Boot 基于 Spring 开发，Spirng Boot 本身并不提供 Spring 框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于 Spring 框架的应用程序。也就是说，它并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。Spring Boot 以约定大于配置的核心思想，默认帮我们进行了很多设置，多数 Spring Boot 应用只需要很少的 Spring 配置。同时它集成了大量常用的第三方库配置（例如 Redis、MongoDB、Jpa、RabbitMQ、Quartz 等等），Spring Boot 应用中这些第三方库几乎可以零配置的开箱即用。 简单来说就是SpringBoot其实不是什么新的框架，它默认配置了很多框架的使用方式，就像maven整合了所有的jar包，spring boot整合了所有的框架 。 Spring Boot 出生名门，从一开始就站在一个比较高的起点，又经过这几年的发展，生态足够完善，Spring Boot 已经当之无愧成为 Java 领域最热门的技术。 Spring Boot的主要优点： 为所有Spring开发者更快的入门 开箱即用，提供各种默认配置来简化项目配置 内嵌式容器简化Web项目 没有冗余代码生成和XML配置的要求 真的很爽，我们快速去体验开发个接口的感觉吧！ 微服务架构(把业务拆分成模块)分布式里：吧业务放在不同的电能里，吧原来的一个小服务(eg,userservice)变成一个模块 这个模块里，配springmvc,写controller,就负责提供接口。其他的电能就能使用了。很多接口分布在不同的电脑上，他就是一个网状的概念。 准备工作我们将学习如何快速的创建一个Spring Boot应用，并且实现一个简单的Http请求处理。通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。 我的环境准备： java version “1.8.0_181” Maven-3.6.1 SpringBoot 2.x 最新版 开发工具： IDEA 创建基础项目说明Spring官方提供了非常方便的工具让我们快速构建应用 Spring Initializr：https://start.spring.io/ 项目创建方式一：使用Spring Initializr 的 Web页面创建项目 1、打开 https://start.spring.io/ 2、填写项目信息 3、点击”Generate Project“按钮生成项目；下载此项目 4、解压项目包，并用IDEA以Maven项目导入，一路下一步即可，直到项目导入完毕。 5、如果是第一次使用，可能速度会比较慢，包比较多、需要耐心等待一切就绪。 项目创建方式二：使用 IDEA 直接创建项目 1、创建一个新项目 2、选择spring initalizr ， 可以看到默认就是去官网的快速构建工具那里实现 3、填写项目信息 4、选择初始化的组件（初学勾选 Web 即可） 5、填写项目路径 6、等待项目构建成功 项目结构分析： 通过上面步骤完成了基础项目的创建。就会自动生成以下文件。 1、程序的主启动类 2、一个 application.properties 配置文件 3、一个 测试类 4、一个 pom.xml pom.xml 分析打开pom.xml，看看Spring Boot项目的依赖： 123&lt;!-- 父依赖 --&gt;&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;!-- web场景启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- springboot单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;!-- 剔除依赖 --&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;!-- 打包插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 编写一个http接口1、在主程序的同级目录下，新建一个controller包，一定要在同级目录下，否则识别不到 2、在包中新建一个HelloController类 12@RestControllerpublic class HelloController &#123; @RequestMapping(&quot;/hello&quot;) public String hello() &#123; return &quot;Hello World&quot;; &#125; &#125; 3、编写完毕后，从主程序启动项目，浏览器发起请求，看页面返回；控制台输出了 Tomcat 访问的端口号！ 简单几步，就完成了一个web接口的开发，SpringBoot就是这么简单。所以我们常用它来建立我们的微服务项目！ 将项目打成jar包，点击 maven的 package 如果遇到以上错误，可以配置打包时 跳过项目运行测试用例 1&lt;!-- 在工作中,很多情况下我们打包是不想执行测试用例的 可能是测试用例不完事,或是测试用例会影响数据库数据 跳过测试用例执 --&gt;&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;!--跳过项目运行测试用例--&gt; &lt;skipTests&gt;true&lt;/skipTests&gt; &lt;/configuration&gt;&lt;/plugin&gt; 如果打包成功，则会在target目录下生成一个 jar 包 打成了jar包后，就可以在任何地方运行了！OK 彩蛋 如何更改启动时显示的字符拼成的字母，SpringBoot呢？也就是 banner 图案； 只需一步：到项目下的 resources 目录下新建一个banner.txt 即可。 图案可以到：https://www.bootschool.net/ascii 这个网站生成，然后拷贝到文件中即可！ SpringBoot这么简单的东西背后一定有故事，我们之后去进行一波源码分析！ SpringBoot02: 运行原理探究我们之前写的HelloSpringBoot，到底是怎么运行的呢，Maven项目，我们一般从pom.xml文件探究起； pom.xml 父依赖其中它主要是依赖一个父项目，主要是管理项目的资源过滤及插件！ 1234567&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt; 点进去，发现还有一个父依赖 1&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;&lt;/parent&gt; 这里才是真正管理SpringBoot应用里面所有依赖版本的地方，SpringBoot的版本控制中心； 以后我们导入依赖默认是不需要写版本；但是如果导入的包没有在依赖中管理着就需要手动配置版本了； 启动器 spring-boot-starter 1&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; springboot-boot-starter-xxx：就是spring-boot的场景启动器 spring-boot-starter-web：帮我们导入了web模块正常运行所依赖的组件； SpringBoot将所有的功能场景都抽取出来，做成一个个的starter （启动器），只需要在项目中引入这些starter即可，所有相关的依赖都会导入进来 ， 我们要用什么功能就导入什么样的场景启动器即可 ；我们未来也可以自己自定义 starter； 主启动类 分析完了 pom.xml 来看看这个启动类 默认的主启动类 123//@SpringBootApplication 来标注一个主程序类//说明这是一个Spring Boot应用@SpringBootApplicationpublic class SpringbootApplication &#123; public static void main(String[] args) &#123; //以为是启动了一个方法，没想到启动了一个服务 SpringApplication.run(SpringbootApplication.class, args); &#125;&#125; 但是一个简单的启动类并不简单！我们来分析一下这些注解都干了什么 @SpringBootApplication作用：标注在某个类上说明这个类是SpringBoot的主配置类 ， SpringBoot就应该运行这个类的main方法来启动SpringBoot应用； 进入这个注解：可以看到上面还有很多其他注解！ 1@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan( excludeFilters = &#123;@Filter( type = FilterType.CUSTOM, classes = &#123;TypeExcludeFilter.class&#125;), @Filter( type = FilterType.CUSTOM, classes = &#123;AutoConfigurationExcludeFilter.class&#125;)&#125;)public @interface SpringBootApplication &#123; // ......&#125; @ComponentScan这个注解在Spring中很重要 ,它对应XML配置中的元素。 作用：自动扫描并加载符合条件的组件或者bean ， 将这个bean定义加载到IOC容器中 @SpringBootConfiguration作用：SpringBoot的配置类 ，标注在某个类上 ， 表示这是一个SpringBoot的配置类； 我们继续进去这个注解查看 12// 点进去得到下面的 @Component@Configurationpublic @interface SpringBootConfiguration &#123;&#125;@Componentpublic @interface Configuration &#123;&#125; 这里的 @Configuration，说明这是一个配置类 ，配置类就是对应Spring的xml 配置文件； 里面的 @Component 这就说明，启动类本身也是Spring中的一个组件而已，负责启动应用！ 我们回到 SpringBootApplication 注解中继续看。 @EnableAutoConfiguration@EnableAutoConfiguration ：开启自动配置功能 以前我们需要自己配置的东西，而现在SpringBoot可以自动帮我们配置 ；@EnableAutoConfiguration告诉SpringBoot开启自动配置功能，这样自动配置才能生效； 点进注解接续查看： @AutoConfigurationPackage ：自动配置包 1@Import(&#123;Registrar.class&#125;)public @interface AutoConfigurationPackage &#123;&#125; @import ：Spring底层注解@import ， 给容器中导入一个组件 Registrar.class 作用：将主启动类的所在包及包下面所有子包里面的所有组件扫描到Spring容器 ； 这个分析完了，退到上一步，继续看 @Import({AutoConfigurationImportSelector.class}) ：给容器导入组件 ； AutoConfigurationImportSelector ：自动配置导入选择器，那么它会导入哪些组件的选择器呢？我们点击去这个类看源码： 1、这个类中有一个这样的方法 1// 获得候选的配置protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123; //这里的getSpringFactoriesLoaderFactoryClass（）方法 //返回的就是我们最开始看的启动自动导入配置文件的注解类；EnableAutoConfiguration List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader()); Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;); return configurations;&#125; 2、这个方法又调用了 SpringFactoriesLoader 类的静态方法！我们进入SpringFactoriesLoader类loadFactoryNames() 方法 1public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader) &#123; String factoryClassName = factoryClass.getName(); //这里它又调用了 loadSpringFactories 方法 return (List)loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());&#125; 3、我们继续点击查看 loadSpringFactories 方法 12345private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) &#123; //获得classLoader ， 我们返回可以看到这里得到的就是EnableAutoConfiguration标注的类本身 MultiValueMap&lt;String, String&gt; result = (MultiValueMap)cache.get(classLoader); if (result != null) &#123; return result; &#125; else &#123; try &#123; //去获取一个资源 &quot;META-INF/spring.factories&quot; Enumeration&lt;URL&gt; urls = classLoader != null ? classLoader.getResources(&quot;META-INF/spring.factories&quot;) : ClassLoader.getSystemResources(&quot;META-INF/spring.factories&quot;); LinkedMultiValueMap result = new LinkedMultiValueMap(); //将读取到的资源遍历，封装成为一个Properties while(urls.hasMoreElements()) &#123; URL url = (URL)urls.nextElement(); UrlResource resource = new UrlResource(url); Properties properties = PropertiesLoaderUtils.loadProperties(resource); Iterator var6 = properties.entrySet().iterator(); while(var6.hasNext()) &#123; Entry&lt;?, ?&gt; entry = (Entry)var6.next(); String factoryClassName = ((String)entry.getKey()).trim(); String[] var9 = StringUtils.commaDelimitedListToStringArray((String)entry.getValue()); int var10 = var9.length; for(int var11 = 0; var11 &lt; var10; ++var11) &#123; String factoryName = var9[var11]; result.add(factoryClassName, factoryName.trim()); &#125; &#125; &#125; cache.put(classLoader, result); return result; &#125; catch (IOException var13) &#123; throw new IllegalArgumentException(&quot;Unable to load factories from location [META-INF/spring.factories]&quot;, var13); &#125; &#125;&#125; 4、发现一个多次出现的文件：spring.factories，全局搜索它 spring.factories我们根据源头打开spring.factories ， 看到了很多自动配置的文件；这就是自动配置根源所在！ WebMvcAutoConfiguration 我们在上面的自动配置类随便找一个打开看看，比如 ：WebMvcAutoConfiguration 可以看到这些一个个的都是JavaConfig配置类，而且都注入了一些Bean，可以找一些自己认识的类，看着熟悉一下！ 所以，自动配置真正实现是从classpath中搜寻所有的META-INF/spring.factories配置文件 ，并将其中对应的 org.springframework.boot.autoconfigure. 包下的配置项，通过反射实例化为对应标注了 @Configuration的JavaConfig形式的IOC容器配置类 ， 然后将这些都汇总成为一个实例并加载到IOC容器中。 结论： SpringBoot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值 将这些值作为自动配置类导入容器 ， 自动配置类就生效 ， 帮我们进行自动配置工作； 整个J2EE的整体解决方案和自动配置都在springboot-autoconfigure的jar包中； 它会给容器中导入非常多的自动配置类 （xxxAutoConfiguration）, 就是给容器中导入这个场景需要的所有组件 ， 并配置好这些组件 ； 有了自动配置类 ， 免去了我们手动编写配置注入功能组件等的工作； 现在大家应该大概的了解了下，SpringBoot的运行原理，后面我们还会深化一次！ SpringApplication 不简单的方法我最初以为就是运行了一个main方法，没想到却开启了一个服务； 1@SpringBootApplicationpublic class SpringbootApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootApplication.class, args); &#125;&#125; SpringApplication.run分析 分析该方法主要分两部分，一部分是SpringApplication的实例化，二是run方法的执行； SpringApplication这个类主要做了以下四件事情： 1、推断应用的类型是普通的项目还是Web项目 2、查找并加载所有可用初始化器 ， 设置到initializers属性中 3、找出所有的应用程序监听器，设置到listeners属性中 4、推断并设置main方法的定义类，找到运行的主类 查看构造器： 1public SpringApplication(ResourceLoader resourceLoader, Class... primarySources) &#123; // ...... this.webApplicationType = WebApplicationType.deduceFromClasspath(); this.setInitializers(this.getSpringFactoriesInstances(); this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class)); this.mainApplicationClass = this.deduceMainApplicationClass();&#125; run方法流程分析 跟着源码和这幅图就可以一探究竟了！ 配置文件SpringBoot使用一个全局的配置文件 ， 配置文件名称是固定的 application.properties 语法结构 ：key=value application.yml 语法结构 ：key：空格 value 配置文件的作用 ：修改SpringBoot自动配置的默认值，因为SpringBoot在底层都给我们自动配置好了； 比如我们可以在配置文件中修改Tomcat 默认启动的端口号！测试一下！ 1server.port=8081 SpringBoot03：yml配置yaml概述YAML是 “YAML Ain’t a Markup Language” （YAML不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：”Yet Another Markup Language”（仍是一种标记语言） 这种语言以数据**作**为中心，而不是以标记语言为重点！ 以前的配置文件，大多数都是使用xml来配置；比如一个简单的端口配置，我们来对比下yaml和xml 传统xml配置： 1&lt;server&gt; &lt;port&gt;8081&lt;port&gt;&lt;/server&gt; yaml配置： 1server： prot: 8080 yaml基础语法说明：语法要求严格！ 1、空格不能省略 2、以缩进来控制层级关系，只要是左边对齐的一列数据都是同一个层级的。 3、属性和值的大小写都是十分敏感的。 字面量：普通的值 [ 数字，布尔值，字符串 ] 字面量直接写在后面就可以 ， 字符串默认不用加上双引号或者单引号； 1k: v 注意： “ ” 双引号，不会转义字符串里面的特殊字符 ， 特殊字符会作为本身想表示的意思； 比如 ：name: “kuang \\n shen” 输出 ：kuang 换行 shen ‘’ 单引号，会转义特殊字符 ， 特殊字符最终会变成和普通字符一样输出 比如 ：name: ‘kuang \\n shen’ 输出 ：kuang \\n shen 对象、Map（键值对） 1#对象、Map格式k: v1: v2: 在下一行来写对象的属性和值得关系，注意缩进；比如： 1student: name: qinjiang age: 3 行内写法 1student: &#123;name: qinjiang,age: 3&#125; 数组（ List、set ） 用 - 值表示数组中的一个元素,比如： 1pets: - cat - dog - pig 行内写法 1pets: [cat,dog,pig] 修改SpringBoot的默认端口号 配置文件中添加，端口号的参数，就可以切换端口； 1server: port: 8082 注入配置文件 yaml文件更强大的地方在于，他可以给我们的实体类直接注入匹配值！ yaml注入配置文件1、在springboot项目中的resources目录下新建一个文件 application.yml 2、编写一个实体类 Dog； 12package com.kuang.springboot.pojo;@Component //注册bean到容器中public class Dog &#123; private String name; private Integer age; //有参无参构造、get、set方法、toString()方法 &#125; 3、思考，我们原来是如何给bean注入属性值的！@Value，给狗狗类测试一下： 1@Component //注册beanpublic class Dog &#123; @Value(&quot;阿黄&quot;) private String name; @Value(&quot;18&quot;) private Integer age;&#125; 4、在SpringBoot的测试类下注入狗狗输出一下； 1234@SpringBootTestclass DemoApplicationTests &#123; @Autowired //将狗狗自动注入进来 Dog dog; @Test public void contextLoads() &#123; System.out.println(dog); //打印看下狗狗对象 &#125;&#125; 结果成功输出，@Value注入成功，这是我们原来的办法对吧。 5、我们在编写一个复杂一点的实体类：Person 类 1@Component //注册bean到容器中public class Person &#123; private String name; private Integer age; private Boolean happy; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; //有参无参构造、get、set方法、toString()方法 &#125; 6、我们来使用yaml配置的方式进行注入，大家写的时候注意区别和优势，我们编写一个yaml配置！ 1person: name: qinjiang age: 3 happy: false birth: 2000/01/01 maps: &#123;k1: v1,k2: v2&#125; lists: - code - girl - music dog: name: 旺财 age: 1 7、我们刚才已经把person这个对象的所有值都写好了，我们现在来注入到我们的类中！ 1/*@ConfigurationProperties作用：将配置文件中配置的每一个属性的值，映射到这个组件中；告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定参数 prefix = “person” : 将配置文件中的person下面的所有属性一一对应*/@Component //注册bean@ConfigurationProperties(prefix = &quot;person&quot;)public class Person &#123; private String name; private Integer age; private Boolean happy; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog;&#125; 8、IDEA 提示，springboot配置注解处理器没有找到，让我们看文档，我们可以查看文档，找到一个依赖！ 1&lt;!-- 导入配置文件处理器，配置文件进行绑定就会有提示，需要重启 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 9、确认以上配置都OK之后，我们去测试类中测试一下： 1234@SpringBootTestclass DemoApplicationTests &#123; @Autowired Person person; //将person自动注入进来 @Test public void contextLoads() &#123; System.out.println(person); //打印person信息 &#125;&#125; 结果：所有值全部注入成功！ yaml配置注入到实体类完全OK！ 课堂测试： 1、将配置文件的key 值 和 属性的值设置为不一样，则结果输出为null，注入失败 2、在配置一个person2，然后将 @ConfigurationProperties(prefix = “person2”) 指向我们的person2； 加载指定的配置文件@PropertySource ：加载指定的配置文件； @configurationProperties：默认从全局配置文件中获取值； 1、我们去在resources目录下新建一个person.properties文件 1name=kuangshen 2、然后在我们的代码中指定加载person.properties文件 123@PropertySource(value = &quot;classpath:person.properties&quot;)@Component //注册beanpublic class Person &#123; @Value(&quot;$&#123;name&#125;&quot;) private String name; ...... &#125; 3、再次输出测试一下：指定配置文件绑定成功！ 配置文件占位符配置文件还可以编写占位符生成随机数 1person: name: qinjiang$&#123;random.uuid&#125; # 随机uuid age: $&#123;random.int&#125; # 随机int happy: false birth: 2000/01/01 maps: &#123;k1: v1,k2: v2&#125; lists: - code - girl - music dog: name: $&#123;person.hello:other&#125;_旺财 age: 1 回顾properties配置我们上面采用的yaml方法都是最简单的方式，开发中最常用的；也是springboot所推荐的！那我们来唠唠其他的实现方式，道理都是相同的；写还是那样写；配置文件除了yml还有我们之前常用的properties ， 我们没有讲，我们来唠唠！ 【注意】properties配置文件在写中文的时候，会有乱码 ， 我们需要去IDEA中设置编码格式为UTF-8； settings–&gt;FileEncodings 中配置； 测试步骤： 1、新建一个实体类User 1@Component //注册beanpublic class User &#123; private String name; private int age; private String sex;&#125; 2、编辑配置文件 user.properties 1user1.name=kuangshenuser1.age=18user1.sex=男 3、我们在User类上使用@Value来进行注入！ 1@Component //注册bean@PropertySource(value = &quot;classpath:user.properties&quot;)public class User &#123; //直接使用@value @Value(&quot;$&#123;user.name&#125;&quot;) //从配置文件中取值 private String name; @Value(&quot;#&#123;9*2&#125;&quot;) // #&#123;SPEL&#125; Spring表达式 private int age; @Value(&quot;男&quot;) // 字面量 private String sex;&#125; 4、Springboot测试 1234@SpringBootTestclass DemoApplicationTests &#123; @Autowired User user; @Test public void contextLoads() &#123; System.out.println(user); &#125;&#125; 结果正常输出： 对比小结@Value这个使用起来并不友好！我们需要为每个属性单独注解赋值，比较麻烦；我们来看个功能对比图 1、@ConfigurationProperties只需要写一次即可 ， @Value则需要每个字段都添加 2、松散绑定：这个什么意思呢? 比如我的yml中写的last-name，这个和lastName是一样的， - 后面跟着的字母默认是大写的。这就是松散绑定。可以测试一下 3、JSR303数据校验 ， 这个就是我们可以在字段是增加一层过滤器验证 ， 可以保证数据的合法性 4、复杂类型封装，yml中可以封装对象 ， 使用value就不支持 结论： 配置yml和配置properties都可以获取到值 ， 强烈推荐 yml； 如果我们在某个业务中，只需要获取配置文件中的某个值，可以使用一下 @value； 如果说，我们专门编写了一个JavaBean来和配置文件进行一一映射，就直接@configurationProperties，不要犹豫 SpringBoot04：JSR303实体数据校验先看看如何使用Springboot中可以用@validated来校验数据，如果数据异常则会统一抛出异常，方便异常中心统一处理。我们这里来写个注解让我们的name只能支持Email格式； 12@Component //注册bean@ConfigurationProperties(prefix = &quot;person&quot;)@Validated //数据校验public class Person &#123; @Email(message=&quot;邮箱格式错误&quot;) //name必须是邮箱格式 private String name;&#125; 运行结果 ：default message [不是一个合法的电子邮件地址]; 使用数据校验，可以保证数据的正确性； 常见参数 1234@NotNull(message=&quot;名字不能为空&quot;)private String userName;@Max(value=120,message=&quot;年龄最大不能查过120&quot;)private int age;@Email(message=&quot;邮箱格式错误&quot;)private String email;空检查@Null 验证对象是否为null@NotNull 验证对象是否不为null, 无法查检长度为0的字符串@NotBlank 检查约束字符串是不是Null还有被Trim的长度是否大于0,只对字符串,且会去掉前后空格.@NotEmpty 检查约束元素是否为NULL或者是EMPTY. Booelan检查@AssertTrue 验证 Boolean 对象是否为 true @AssertFalse 验证 Boolean 对象是否为 false 长度检查@Size(min=, max=) 验证对象（Array,Collection,Map,String）长度是否在给定的范围之内 @Length(min=, max=) string is between min and max included.日期检查@Past 验证 Date 和 Calendar 对象是否在当前时间之前 @Future 验证 Date 和 Calendar 对象是否在当前时间之后 @Pattern 验证 String 对象是否符合正则表达式的规则.......等等除此以外，我们还可以自定义一些数据校验规则 多环境切换 profile是Spring对不同环境提供不同配置功能的支持，可以通过激活不同的环境版本，实现快速切换环境； 多配置文件我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml , 用来指定多个环境版本； 例如： application-test.properties 代表测试环境配置 application-dev.properties 代表开发环境配置 但是Springboot并不会直接启动这些配置文件，它默认使用application.properties主配置文件； 我们需要通过一个配置来选择需要激活的环境： 1#比如在配置文件中指定使用dev环境，我们可以通过设置不同的端口号进行测试；#我们启动SpringBoot，就可以看到已经切换到dev下的配置了；spring.profiles.active=dev yaml的多文档块和properties配置文件中一样，但是使用yml去实现不需要创建多个配置文件，更加方便了 ! 12345server: port: 8081#选择要激活那个环境块spring: profiles: active: prod---server: port: 8083spring: profiles: dev #配置环境的名称---server: port: 8084spring: profiles: prod #配置环境的名称 注意：如果yml和properties同时都配置了端口，并且没有激活其他环境 ， 默认会使用properties配置文件的！ 配置文件加载位置外部加载配置文件的方式十分多，我们选择最常用的即可，在开发的资源文件中进行配置！ 官方外部配置文件说明参考文档 springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件： 1优先级1：项目路径下的config文件夹配置文件优先级2：项目路径下配置文件优先级3：资源路径下的config文件夹配置文件优先级4：资源路径下配置文件 优先级由高到底，高优先级的配置会覆盖低优先级的配置； SpringBoot会从这四个位置全部加载主配置文件；互补配置； 我们在最低级的配置文件中设置一个项目访问路径的配置来测试互补问题； 1#配置项目的访问路径server.servlet.context-path=/kuang 拓展，运维小技巧指定位置加载配置文件 我们还可以通过spring.config.location来改变默认的配置文件位置 项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；这种情况，一般是后期运维做的多，相同配置，外部指定的配置文件优先级最高 1java -jar spring-boot-config.jar --spring.config.location=F:/application.properties SpringBoot05：自动配置原理配置文件到底能写什么？怎么写？ SpringBoot官方文档中有大量的配置，我们无法全部记住 分析自动配置原理我们以HttpEncodingAutoConfiguration（Http编码自动配置）为例解释自动配置原理； 123456//表示这是一个配置类，和以前编写的配置文件一样，也可以给容器中添加组件；@Configuration //启动指定类的ConfigurationProperties功能； //进入这个HttpProperties查看，将配置文件中对应的值和HttpProperties绑定起来； //并把HttpProperties加入到ioc容器中@EnableConfigurationProperties(&#123;HttpProperties.class&#125;) //Spring底层@Conditional注解 //根据不同的条件判断，如果满足指定的条件，整个配置类里面的配置就会生效； //这里的意思就是判断当前应用是否是web应用，如果是，当前配置类生效@ConditionalOnWebApplication( type = Type.SERVLET)//判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；@ConditionalOnClass(&#123;CharacterEncodingFilter.class&#125;)//判断配置文件中是否存在某个配置：spring.http.encoding.enabled； //如果不存在，判断也是成立的 //即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；@ConditionalOnProperty( prefix = &quot;spring.http.encoding&quot;, value = &#123;&quot;enabled&quot;&#125;, matchIfMissing = true)public class HttpEncodingAutoConfiguration &#123; //他已经和SpringBoot的配置文件映射了 private final Encoding properties; //只有一个有参构造器的情况下，参数的值就会从容器中拿 public HttpEncodingAutoConfiguration(HttpProperties properties) &#123; this.properties = properties.getEncoding(); &#125; //给容器中添加一个组件，这个组件的某些值需要从properties中获取 @Bean @ConditionalOnMissingBean //判断容器没有这个组件？ public CharacterEncodingFilter characterEncodingFilter() &#123; CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.RESPONSE)); return filter; &#125; //。。。。。。。&#125; 一句话总结 ：根据当前不同的条件判断，决定这个配置类是否生效！ 一但这个配置类生效；这个配置类就会给容器中添加各种组件； 这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的； 所有在配置文件中能配置的属性都是在xxxxProperties类中封装着； 配置文件能配置什么就可以参照某个功能对应的这个属性类 1//从配置文件中获取指定的值和bean的属性进行绑定@ConfigurationProperties(prefix = &quot;spring.http&quot;) public class HttpProperties &#123; // .....&#125; 我们去配置文件里面试试前缀，看提示！ 这就是自动装配的原理！ 精髓1、SpringBoot启动会加载大量的自动配置类 2、我们看我们需要的功能有没有在SpringBoot默认写好的自动配置类当中； 3、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件存在在其中，我们就不需要再手动配置了） 4、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们只需要在配置文件中指定这些属性的值即可； xxxxAutoConfigurartion：自动配置类；给容器中添加组件 xxxxProperties:封装配置文件中相关属性； 了解：@Conditional了解完自动装配的原理后，我们来关注一个细节问题，自动配置类必须在一定的条件下才能生效； @Conditional派生注解（Spring注解版原生的@Conditional作用） 作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效； 那么多的自动配置类，必须在一定的条件下才能生效；也就是说，我们加载了这么多的配置类，但不是所有的都生效了。 我们怎么知道哪些自动配置类生效？ 我们可以通过启用 debug=true属性；来让控制台打印自动配置报告，这样我们就可以很方便的知道哪些自动配置类生效； 1#开启springboot的调试类debug=true Positive matches:（自动配置类启用的：正匹配） Negative matches:（没有启动，没有匹配成功的自动配置类：负匹配） Unconditional classes: （没有条件的类） 【演示：查看输出的日志】 掌握吸收理解原理，即可以不变应万变！","categories":[],"tags":[]},{"title":"springMVC","slug":"springMVC","date":"2020-09-24T08:59:12.000Z","updated":"2020-09-25T04:34:04.152Z","comments":true,"path":"2020/09/24/springMVC/","link":"","permalink":"https://lucifinil-x.github.io/2020/09/24/springMVC/","excerpt":"补充项目各层dao 链接数据库service层调用dao层执行具体的业务，只管业务servlet层 (中转)接收前端(jsp/html)的数据,吧数据交给service层处理，处理完的结果返回给用户展示，调用控制页面跳转","text":"补充项目各层dao 链接数据库service层调用dao层执行具体的业务，只管业务servlet层 (中转)接收前端(jsp/html)的数据,吧数据交给service层处理，处理完的结果返回给用户展示，调用控制页面跳转 前端 数据传输 实体类 1.1、什么是MVC MVC是模型(Model)、视图(View)、控制器(Controller)的简写，是一种软件设计规范。 是将业务逻辑、数据、显示分离的方法来组织代码。 MVC主要作用是降低了视图与业务逻辑间的双向偶合。 MVC不是一种设计模式，MVC是一种架构模式。当然不同的MVC存在差异 Model（模型）：数据模型，提供要展示的数据，因此包含数据和行为，可以认为是领域模型或JavaBean组件（包含数据和行为），不过现在一般都分离开来：Value Object（数据Dao） 和 服务层（行为Service）。也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务。 View（视图）：负责进行模型的展示，一般就是我们见到的用户界面，客户想看到的东西。 Controller（控制器）：接收用户请求，委托给模型进行处理（状态改变），处理完毕后把返回的模型数据返回给视图，由视图负责展示。也就是说控制器做了个调度员的工作。 最典型的MVC就是JSP + servlet + javabean的模式。 1.2、Model1时代 在web早期的开发中，通常采用的都是Model1。 Model1中，主要分为两层，视图层和模型层。 Model1优点：架构简单，比较适合小型项目开发； Model1缺点：JSP职责不单一，职责过重，不便于维护； 1.3、Model2时代Model2把一个项目分成三部分，包括视图、控制、模型。 用户发请求 Servlet接收请求数据，并调用对应的业务逻辑方法 业务处理完毕，返回更新后的数据给servlet servlet转向到JSP，由JSP来渲染页面 响应给前端更新后的页面 职责分析： Controller：控制器 取得表单数据 调用业务逻辑 转向指定的页面 Model：模型 业务逻辑 保存数据的状态 View：视图 显示页面 Model2这样不仅提高的代码的复用率与项目的扩展性，且大大降低了项目的维护成本。Model 1模式的实现比较简单，适用于快速开发小规模项目，Model1中JSP页面身兼View和Controller两种角色，将控制逻辑和表现逻辑混杂在一起，从而导致代码的重用性非常低，增加了应用的扩展性和维护的难度。Model2消除了Model1的缺点。 1.4、回顾Servlet 新建一个Maven工程当做父工程！pom依赖！ 123456789101112131415161718192021222324252627&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 建立一个Moudle：springmvc-01-servlet ， 添加Web app的支持！(邮件项目文件夹第二项 add framework support) 导入servlet 和 jsp 的 jar 依赖 12345678910&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt;&lt;/dependency&gt; 编写一个Servlet类，用来处理用户的请求 123456789101112131415161718192021222324package com.kuang.servlet;//实现Servlet接口public class HelloServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //取得参数 String method = req.getParameter(&quot;method&quot;); if (method.equals(&quot;add&quot;))&#123; req.getSession().setAttribute(&quot;msg&quot;,&quot;执行了add方法&quot;); &#125; if (method.equals(&quot;delete&quot;))&#123; req.getSession().setAttribute(&quot;msg&quot;,&quot;执行了delete方法&quot;); &#125; //业务逻辑 //视图跳转 req.getRequestDispatcher(&quot;/WEB-INF/jsp/hello.jsp&quot;).forward(req,resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req,resp); &#125;&#125; 编写Hello.jsp，在WEB-INF目录下新建一个jsp的文件夹，新建hello.jsp 123456789&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Kuangshen&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;msg&#125;&lt;/body&gt;&lt;/html&gt; 在web.xml中注册Servlet 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;servlet&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.kuang.servlet.HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/user&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 配置Tomcat，并启动测试 localhost:8080/user?method=add localhost:8080/user?method=delete MVC框架要做哪些事情 将url映射到java类或java类的方法 . 封装用户提交的数据 . 处理请求–调用相关的业务处理–封装响应数据 . 将响应的数据进行渲染 . jsp / html 等表示层数据 . 说明： ​ 常见的服务器端MVC框架有：Struts、Spring MVC、ASP.NET MVC、Zend Framework、JSF；常见前端MVC框架：vue、angularjs、react、backbone；由MVC演化出了另外一些模式如：MVP、MVVM 等等…. 2、什么是SpringMVC2.1、概述 Spring MVC是Spring Framework的一部分，是基于Java实现MVC的轻量级Web框架。 查看官方文档：https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/web.html#spring-web 我们为什么要学习SpringMVC呢? Spring MVC的特点： 轻量级，简单易学 高效 , 基于请求响应的MVC框架 与Spring兼容性好，无缝结合 约定优于配置 功能强大：RESTful、数据验证、格式化、本地化、主题等 简洁灵活 Spring的web框架围绕DispatcherServlet [ 调度Servlet ] 设计。 DispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解形式进行开发，十分简洁； 正因为SpringMVC好 , 简单 , 便捷 , 易学 , 天生和Spring无缝集成(使用SpringIoC和Aop) , 使用约定优于配置 . 能够进行简单的junit测试 . 支持Restful风格 .异常处理 , 本地化 , 国际化 , 数据验证 , 类型转换 , 拦截器 等等……所以我们要学习 . 最重要的一点还是用的人多 , 使用的公司多 . 2.2、中心控制器​ Spring的web框架围绕DispatcherServlet设计。DispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解的controller声明方式。 ​ Spring MVC框架像许多其他MVC框架一样, 以请求为驱动 , 围绕一个中心Servlet分派请求及提供其他功能，DispatcherServlet是一个实际的Servlet (它继承自HttpServlet 基类)。 SpringMVC的原理如下图所示： ​ 当发起请求时被前置的控制器拦截到请求，根据请求参数生成代理请求，找到请求对应的实际控制器，控制器处理请求，创建数据模型，访问数据库，将模型响应给中心控制器，控制器使用模型与视图渲染视图结果，将结果返回给中心控制器，再将结果返回给请求者。 2.3、SpringMVC执行原理 图为SpringMVC的一个较完整的流程图，实线表示SpringMVC框架提供的技术，不需要开发者实现，虚线表示需要开发者实现。 简要分析执行流程 DispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求。 我们假设请求的url为 : http://localhost:8080/SpringMVC/hello 如上url拆分成三部分： http://localhost:8080服务器域名 SpringMVC部署在服务器上的web站点 hello表示控制器 通过分析，如上url表示为：请求位于服务器localhost:8080上的SpringMVC站点的hello控制器。 HandlerMapping为处理器映射。DispatcherServlet调用HandlerMapping,HandlerMapping根据请求url查找Handler。 HandlerExecution表示具体的Handler,其主要作用是根据url查找控制器，如上url被查找控制器为：hello。 HandlerExecution将解析后的信息传递给DispatcherServlet,如解析控制器映射等。 HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler。 Handler让具体的Controller执行。 Controller将具体的执行信息返回给HandlerAdapter,如ModelAndView。 HandlerAdapter将视图逻辑名或模型传递给DispatcherServlet。 DispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。 视图解析器将解析的逻辑视图名传给DispatcherServlet。 DispatcherServlet根据视图解析器解析的视图结果，调用具体的视图。 最终视图呈现给用户。 在这里先听一遍原理，不理解没有关系，我们马上来写一个对应的代码实现大家就明白了，如果不明白，那就写10遍，没有笨人，只有懒人！ 在上一节中，我们讲解了 什么是SpringMVC以及它的执行原理！ 狂神说SpringMVC01：什么是SpringMVC 现在我们来看看如何快速使用SpringMVC编写我们的程序吧！ 配置版1、新建一个Moudle ， springmvc-02-hello ， 添加web的支持！ 2、确定导入了SpringMVC 的依赖！ 3、配置web.xml ， web.xml中注册DispatcherServlet 1234&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!--1.注册DispatcherServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--关联一个springmvc的配置文件:【servlet-name】-servlet.xml--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--启动级别-1--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--/ 匹配所有的请求；（不包括.jsp）--&gt; &lt;!--/* 匹配所有的请求；（包括.jsp）--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 4、编写SpringMVC 的 配置文件！名称：springmvc-servlet.xml : [servletname]-servlet.xml 说明，这里的名称要求是按照官方来的 12&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;/beans&gt; 5、添加 处理映射器 1&lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;/&gt; 6、添加 处理器适配器 1&lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;/&gt; 7、添加 视图解析器 1&lt;!--视图解析器:DispatcherServlet给他的ModelAndView--&gt;&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;InternalResourceViewResolver&quot;&gt; &lt;!--前缀--&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;!--后缀--&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;&lt;/bean&gt; 8、编写我们要操作业务Controller ，要么实现Controller接口，要么增加注解；需要返回一个ModelAndView，装数据，封视图； 123456package com.kuang.controller;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.mvc.Controller;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;//注意：这里我们先导入Controller接口public class HelloController implements Controller &#123; public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; //ModelAndView 模型和视图 ModelAndView mv = new ModelAndView(); //封装对象，放在ModelAndView中。Model mv.addObject(&quot;msg&quot;,&quot;HelloSpringMVC!&quot;); //封装要跳转的视图，放在ModelAndView中 mv.setViewName(&quot;hello&quot;); //: /WEB-INF/jsp/hello.jsp return mv; &#125; &#125; 9、将自己的类交给SpringIOC容器，springmvc-servlet.xml中注册bean 1&lt;!--Handler--&gt;&lt;bean id=&quot;/hello&quot; class=&quot;com.kuang.controller.HelloController&quot;/&gt; 10、写要跳转的jsp页面，显示ModelandView存放的数据，以及我们的正常页面； 1&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Kuangshen&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;msg&#125;&lt;/body&gt;&lt;/html&gt; 11、配置Tomcat 启动测试！ 可能遇到的问题：访问出现404，排查步骤： 查看控制台输出，看一下是不是缺少了什么jar包。 如果jar包存在，显示无法输出，就在IDEA的项目发布中，添加lib依赖！ 重启Tomcat 即可解决！ 小结：看这个估计大部分同学都能理解其中的原理了，但是我们实际开发才不会这么写，不然就疯了，还学这个玩意干嘛！我们来看个注解版实现，这才是SpringMVC的精髓，到底有多么简单，看这个图就知道了。 注解版1、新建一个Moudle，springmvc-03-hello-annotation 。添加web支持！ 2、由于Maven可能存在资源过滤的问题，我们将配置完善 1&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 3、在pom.xml文件引入相关的依赖：主要有Spring框架核心库、Spring MVC、servlet , JSTL等。我们在父依赖中已经引入了！ 4、配置web.xml 注意点： 1234&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!--1.注册servlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动顺序，数字越小，启动越早 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--所有请求都会被springmvc拦截 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; / 和 /* 的区别：&lt; url-pattern &gt; / &lt;/ url-pattern &gt; 不会匹配到.jsp， 只针对我们编写的请求；即：.jsp 不会进入spring的 DispatcherServlet类 。&lt; url-pattern &gt; /* &lt;/ url-pattern &gt; 会匹配 *.jsp，会出现返回 jsp视图 时再次进入spring的DispatcherServlet 类，导致找不到对应的controller所以报404错。 注意web.xml版本问题，要最新版！ 注册DispatcherServlet 关联SpringMVC的配置文件 启动级别为1 映射路径为 / 【不要用/*，会404】 5、添加Spring MVC配置文件 在resource目录下添加springmvc-servlet.xml配置文件，配置的形式与Spring容器配置基本类似，为了支持基于注解的IOC，设置了自动扫描包的功能，具体配置信息如下： 1234&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --&gt; &lt;context:component-scan base-package=&quot;com.kuang.controller&quot;/&gt; &lt;!-- 让Spring MVC不处理静态资源 --&gt; &lt;mvc:default-servlet-handler /&gt; &lt;!-- 支持mvc注解驱动 在spring中一般采用@RequestMapping注解来完成映射关系 要想使@RequestMapping注解生效 必须向上下文中注册DefaultAnnotationHandlerMapping 和一个AnnotationMethodHandlerAdapter实例 这两个实例分别在类级别和方法级别处理。 而annotation-driven配置帮助我们自动完成上述两个实例的注入。 --&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 视图解析器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt; &lt;!-- 前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt; &lt;!-- 后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; 在视图解析器中我们把所有的视图都存放在/WEB-INF/目录下，这样可以保证视图安全，因为这个目录下的文件，客户端不能直接访问。 让IOC的注解生效 静态资源过滤 ：HTML . JS . CSS . 图片 ， 视频 ….. MVC的注解驱动 配置视图解析器 6、创建Controller 编写一个Java控制类：com.kuang.controller.HelloController , 注意编码规范 1234package com.kuang.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;@Controller@RequestMapping(&quot;/HelloController&quot;)public class HelloController &#123; //真实访问地址 : 项目名/HelloController/hello @RequestMapping(&quot;/hello&quot;) public String sayHello(Model model)&#123; //向模型中添加属性msg与值，可以在JSP页面中取出并渲染 model.addAttribute(&quot;msg&quot;,&quot;hello,SpringMVC&quot;); //web-inf/jsp/hello.jsp return &quot;hello&quot;; &#125;&#125; @Controller是为了让Spring IOC容器初始化时自动扫描到； @RequestMapping是为了映射请求路径，这里因为类与方法上都有映射所以访问时应该是/HelloController/hello； 方法中声明Model类型的参数是为了把Action中的数据带到视图中； 方法返回的结果是视图的名称hello，加上配置文件中的前后缀变成WEB-INF/jsp/hello.jsp。 7、创建视图层 在WEB-INF/ jsp目录中创建hello.jsp ， 视图可以直接取出并展示从Controller带回的信息； 可以通过EL表示取出Model中存放的值，或者对象； 1&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;SpringMVC&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;msg&#125;&lt;/body&gt;&lt;/html&gt; 8、配置Tomcat运行 配置Tomcat ， 开启服务器 ， 访问 对应的请求路径！ OK，运行成功！ 小结实现步骤其实非常的简单： 新建一个web项目 导入相关jar包 编写web.xml , 注册DispatcherServlet 编写springmvc配置文件 接下来就是去创建对应的控制类 , controller 最后完善前端视图和controller之间的对应 测试运行调试. 使用springMVC必须配置的三大件： 处理器映射器、处理器适配器、视图解析器 通常，我们只需要手动配置视图解析器，而处理器映射器和处理器适配器只需要开启注解驱动即可，而省去了大段的xml配置 再来回顾下原理吧~ 下面我们准备研究下Controller及RestFul风格！ 控制器Controller 控制器复杂提供访问应用程序的行为，通常通过接口定义或注解定义两种方法实现。 控制器负责解析用户的请求并将其转换为一个模型。 在Spring MVC中一个控制器类可以包含多个方法 在Spring MVC中，对于Controller的配置方式有很多种 实现Controller接口Controller是一个接口，在org.springframework.web.servlet.mvc包下，接口中只有一个方法； 12345//实现该接口的类获得控制器功能public interface Controller &#123; //处理请求且返回一个模型与视图对象 ModelAndView handleRequest(HttpServletRequest var1, HttpServletResponse var2) throws Exception;&#125; 测试 新建一个Moudle，springmvc-04-controller 。将刚才的03 拷贝一份, 我们进行操作！ 删掉HelloController mvc的配置文件只留下 视图解析器！ 编写一个Controller类，ControllerTest1 123456789101112//定义控制器//注意点：不要导错包，实现Controller接口，重写方法；public class ControllerTest1 implements Controller &#123; public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123; //返回一个模型视图对象 ModelAndView mv = new ModelAndView(); mv.addObject(&quot;msg&quot;,&quot;Test1Controller&quot;); mv.setViewName(&quot;test&quot;); return mv; &#125;&#125; 编写完毕后，去Spring配置文件中注册请求的bean；name对应请求路径，class对应处理请求的类 1&lt;bean name=&quot;/t1&quot; class=&quot;com.kuang.controller.ControllerTest1&quot;/&gt; 编写前端test.jsp，注意在WEB-INF/jsp目录下编写，对应我们的视图解析器 123456789&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Kuangshen&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;msg&#125;&lt;/body&gt;&lt;/html&gt; 配置Tomcat运行测试，我这里没有项目发布名配置的就是一个 / ，所以请求不用加项目名，OK！ 说明： 实现接口Controller定义控制器是较老的办法 缺点是：一个控制器中只有一个方法，如果要多个方法则需要定义多个Controller；定义的方式比较麻烦； 使用注解@Controller @Controller注解类型用于声明Spring类的实例是一个控制器（在讲IOC时还提到了另外3个注解）； Spring可以使用扫描机制来找到应用程序中所有基于注解的控制器类，为了保证Spring能找到你的控制器，需要在配置文件中声明组件扫描。 12&lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt;&lt;context:component-scan base-package=&quot;com.kuang.controller&quot;/&gt; 增加一个ControllerTest2类，使用注解实现； 1234567891011121314//@Controller注解的类会自动添加到Spring上下文中@Controllerpublic class ControllerTest2&#123; //映射访问路径 @RequestMapping(&quot;/t2&quot;) public String index(Model model)&#123; //Spring MVC会自动实例化一个Model对象用于向视图中传值 model.addAttribute(&quot;msg&quot;, &quot;ControllerTest2&quot;); //返回视图位置 return &quot;test&quot;; &#125;&#125; 运行tomcat测试 可以发现，我们的两个请求都可以指向一个视图，但是页面结果的结果是不一样的，从这里可以看出视图是被复用的，而控制器与视图之间是弱偶合关系。 注解方式是平时使用的最多的方式！ RequestMapping@RequestMapping @RequestMapping注解用于映射url到控制器类或一个特定的处理程序方法。可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。 为了测试结论更加准确，我们可以加上一个项目名测试 myweb 只注解在方法上面 1234567@Controllerpublic class TestController &#123; @RequestMapping(&quot;/h1&quot;) public String test()&#123; return &quot;test&quot;; &#125;&#125; 访问路径：http://localhost:8080 / 项目名 / h1 同时注解类与方法 12345678@Controller@RequestMapping(&quot;/admin&quot;)public class TestController &#123; @RequestMapping(&quot;/h1&quot;) public String test()&#123; return &quot;test&quot;; &#125;&#125; 访问路径：http://localhost:8080 / 项目名/ admin /h1 , 需要先指定类的路径再指定方法的路径； RestFul 风格概念 Restful就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。 功能 资源：互联网所有的事物都可以被抽象为资源 资源操作：使用POST、DELETE、PUT、GET，使用不同方法对资源进行操作。 分别对应 添加、 删除、修改、查询。 传统方式操作资源 ：通过不同的参数来实现不同的效果！方法单一，post 和 get ​ http://127.0.0.1/item/queryItem.action?id=1 查询,GET ​ http://127.0.0.1/item/saveItem.action 新增,POST ​ http://127.0.0.1/item/updateItem.action 更新,POST ​ http://127.0.0.1/item/deleteItem.action?id=1 删除,GET或POST 使用RESTful操作资源 ：可以通过不同的请求方式来实现不同的效果！如下：请求地址一样，但是功能可以不同！ ​ http://127.0.0.1/item/1 查询,GET ​ http://127.0.0.1/item 新增,POST ​ http://127.0.0.1/item 更新,PUT ​ http://127.0.0.1/item/1 删除,DELETE 学习测试 在新建一个类 RestFulController 123@Controllerpublic class RestFulController &#123;&#125; 在Spring MVC中可以使用 @PathVariable 注解，让方法参数的值对应绑定到一个URI模板变量上。 12345678910111213141516@Controllerpublic class RestFulController &#123; //映射访问路径 @RequestMapping(&quot;/commit/&#123;p1&#125;/&#123;p2&#125;&quot;) public String index(@PathVariable int p1, @PathVariable int p2, Model model)&#123; int result = p1+p2; //Spring MVC会自动实例化一个Model对象用于向视图中传值 model.addAttribute(&quot;msg&quot;, &quot;结果：&quot;+result); //返回视图位置 return &quot;test&quot;; &#125; &#125; 我们来测试请求查看下 思考：使用路径变量的好处？ 使路径变得更加简洁； 获得参数更加方便，框架会自动进行类型转换。 通过路径变量的类型可以约束访问参数，如果类型不一样，则访问不到对应的请求方法，如这里访问是的路径是/commit/1/a，则路径与方法不匹配，而不会是参数转换失败。 ![img](https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JOmNdhqNbrRK9XaseXIDsumkKQDDBx9D7E67IK9dmVtHnjn0WjPSOZxKnwz9AXrTPRLy6Xu42yrg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1) 我们来修改下对应的参数类型，再次测试 1234567891011//映射访问路径@RequestMapping(&quot;/commit/&#123;p1&#125;/&#123;p2&#125;&quot;)public String index(@PathVariable int p1, @PathVariable String p2, Model model)&#123; String result = p1+p2; //Spring MVC会自动实例化一个Model对象用于向视图中传值 model.addAttribute(&quot;msg&quot;, &quot;结果：&quot;+result); //返回视图位置 return &quot;test&quot;;&#125; 使用method属性指定请求类型 用于约束请求的类型，可以收窄请求范围。指定请求谓词的类型如GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE等 我们来测试一下： 增加一个方法 123456//映射访问路径,必须是POST请求@RequestMapping(value = &quot;/hello&quot;,method = &#123;RequestMethod.POST&#125;)public String index2(Model model)&#123; model.addAttribute(&quot;msg&quot;, &quot;hello!&quot;); return &quot;test&quot;;&#125; 我们使用浏览器地址栏进行访问默认是Get请求，会报错405： 如果将POST修改为GET则正常了； 123456//映射访问路径,必须是Get请求@RequestMapping(value = &quot;/hello&quot;,method = &#123;RequestMethod.GET&#125;)public String index2(Model model)&#123; model.addAttribute(&quot;msg&quot;, &quot;hello!&quot;); return &quot;test&quot;;&#125; 小结： Spring MVC 的 @RequestMapping 注解能够处理 HTTP 请求的方法, 比如 GET, PUT, POST, DELETE 以及 PATCH。 所有的地址栏请求默认都会是 HTTP GET 类型的。 方法级别的注解变体有如下几个：组合注解 12345@GetMapping@PostMapping@PutMapping@DeleteMapping@PatchMapping @GetMapping 是一个组合注解，平时使用的会比较多！ 它所扮演的是 @RequestMapping(method =RequestMethod.GET) 的一个快捷方式。 扩展：小黄鸭调试法场景一：我们都有过向别人（甚至可能向完全不会编程的人）提问及解释编程问题的经历，但是很多时候就在我们解释的过程中自己却想到了问题的解决方案，然后对方却一脸茫然。 场景二：你的同行跑来问你一个问题，但是当他自己把问题说完，或说到一半的时候就想出答案走了，留下一脸茫然的你。 其实上面两种场景现象就是所谓的小黄鸭调试法（Rubber Duck Debuging），又称橡皮鸭调试法，它是我们软件工程中最常使用调试方法之一。 此概念据说来自《程序员修炼之道》书中的一个故事，传说程序大师随身携带一只小黄鸭，在调试代码的时候会在桌上放上这只小黄鸭，然后详细地向鸭子解释每行代码，然后很快就将问题定位修复了。 下面我们准备研究下参数接受和结果跳转！ 结果跳转方式ModelAndView设置ModelAndView对象 , 根据view的名称 , 和视图解析器跳到指定的页面 . 页面 : {视图解析器前缀} + viewName +{视图解析器后缀} 12345678&lt;!-- 视图解析器 --&gt;&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt; &lt;!-- 前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt; &lt;!-- 后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;&lt;/bean&gt; 对应的controller类 12345678910public class ControllerTest1 implements Controller &#123; public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123; //返回一个模型视图对象 ModelAndView mv = new ModelAndView(); mv.addObject(&quot;msg&quot;,&quot;ControllerTest1&quot;); mv.setViewName(&quot;test&quot;); return mv; &#125;&#125; ServletAPI通过设置ServletAPI , 不需要视图解析器 . 1、通过HttpServletResponse进行输出 2、通过HttpServletResponse实现重定向 3、通过HttpServletResponse实现转发 123456789101112131415161718192021@Controllerpublic class ResultGo &#123; @RequestMapping(&quot;/result/t1&quot;) public void test1(HttpServletRequest req, HttpServletResponse rsp) throws IOException &#123; rsp.getWriter().println(&quot;Hello,Spring BY servlet API&quot;); &#125; @RequestMapping(&quot;/result/t2&quot;) public void test2(HttpServletRequest req, HttpServletResponse rsp) throws IOException &#123; rsp.sendRedirect(&quot;/index.jsp&quot;); &#125; @RequestMapping(&quot;/result/t3&quot;) public void test3(HttpServletRequest req, HttpServletResponse rsp) throws Exception &#123; //转发 req.setAttribute(&quot;msg&quot;,&quot;/result/t3&quot;); req.getRequestDispatcher(&quot;/WEB-INF/jsp/test.jsp&quot;).forward(req,rsp); &#125;&#125; SpringMVC通过SpringMVC来实现转发和重定向 - 无需视图解析器； 测试前，需要将视图解析器注释掉 1234567891011121314151617181920@Controllerpublic class ResultSpringMVC &#123; @RequestMapping(&quot;/rsm/t1&quot;) public String test1()&#123; //转发 return &quot;/index.jsp&quot;; &#125; @RequestMapping(&quot;/rsm/t2&quot;) public String test2()&#123; //转发二 return &quot;forward:/index.jsp&quot;; &#125; @RequestMapping(&quot;/rsm/t3&quot;) public String test3()&#123; //重定向 return &quot;redirect:/index.jsp&quot;; &#125;&#125; 通过SpringMVC来实现转发和重定向 - 有视图解析器； 重定向 , 不需要视图解析器 , 本质就是重新请求一个新地方嘛 , 所以注意路径问题. 可以重定向到另外一个请求实现 . 12345678910111213141516@Controllerpublic class ResultSpringMVC2 &#123; @RequestMapping(&quot;/rsm2/t1&quot;) public String test1()&#123; //转发 return &quot;test&quot;; &#125; @RequestMapping(&quot;/rsm2/t2&quot;) public String test2()&#123; //重定向 return &quot;redirect:/index.jsp&quot;; //return &quot;redirect:hello.do&quot;; //hello.do为另一个请求/ &#125;&#125; 数据处理处理提交数据1、提交的域名称和处理方法的参数名一致 提交数据 : http://localhost:8080/hello?name=kuangshen 处理方法 : 12345@RequestMapping(&quot;/hello&quot;)public String hello(String name)&#123; System.out.println(name); return &quot;hello&quot;;&#125; 后台输出 : kuangshen 2、提交的域名称和处理方法的参数名不一致 提交数据 : http://localhost:8080/hello?username=kuangshen 处理方法 : 123456//@RequestParam(&quot;username&quot;) : username提交的域的名称 .@RequestMapping(&quot;/hello&quot;)public String hello(@RequestParam(&quot;username&quot;) String name)&#123; System.out.println(name); return &quot;hello&quot;;&#125; 后台输出 : kuangshen 3、提交的是一个对象 要求提交的表单域和对象的属性名一致 , 参数使用对象即可 1、实体类 12345678public class User &#123; private int id; private String name; private int age; //构造 //get/set //tostring()&#125; 2、提交数据 : http://localhost:8080/mvc04/user?name=kuangshen&amp;id=1&amp;age=15 3、处理方法 : 12345@RequestMapping(&quot;/user&quot;)public String user(User user)&#123; System.out.println(user); return &quot;hello&quot;;&#125; 后台输出 : User { id=1, name=’kuangshen’, age=15 } 说明：如果使用对象的话，前端传递的参数名和对象名必须一致，否则就是null。 数据显示到前端第一种 : 通过ModelAndView 我们前面一直都是如此 . 就不过多解释 12345678910public class ControllerTest1 implements Controller &#123; public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123; //返回一个模型视图对象 ModelAndView mv = new ModelAndView(); mv.addObject(&quot;msg&quot;,&quot;ControllerTest1&quot;); mv.setViewName(&quot;test&quot;); return mv; &#125;&#125; 第二种 : 通过ModelMap ModelMap 12345678@RequestMapping(&quot;/hello&quot;)public String hello(@RequestParam(&quot;username&quot;) String name, ModelMap model)&#123; //封装要显示到视图中的数据 //相当于req.setAttribute(&quot;name&quot;,name); model.addAttribute(&quot;name&quot;,name); System.out.println(name); return &quot;hello&quot;;&#125; 第三种 : 通过Model Model 12345678@RequestMapping(&quot;/ct2/hello&quot;)public String hello(@RequestParam(&quot;username&quot;) String name, Model model)&#123; //封装要显示到视图中的数据 //相当于req.setAttribute(&quot;name&quot;,name); model.addAttribute(&quot;msg&quot;,name); System.out.println(name); return &quot;test&quot;;&#125; 对比就对于新手而言简单来说使用区别就是： 12345Model 只有寥寥几个方法只适合用于储存数据，简化了新手对于Model对象的操作和理解；ModelMap 继承了 LinkedMap ，除了实现了自身的一些方法，同样的继承 LinkedMap 的方法和特性；ModelAndView 可以在储存数据的同时，可以进行设置返回的逻辑视图，进行控制展示层的跳转。 当然更多的以后开发考虑的更多的是性能和优化，就不能单单仅限于此的了解。 请使用80%的时间打好扎实的基础，剩下18%的时间研究框架，2%的时间去学点英文，框架的官方文档永远是最好的教程。 乱码问题测试步骤： 1、我们可以在首页编写一个提交的表单 1234&lt;form action=&quot;/e/t&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt; 2、后台编写对应的处理类 12345678@Controllerpublic class Encoding &#123; @RequestMapping(&quot;/e/t&quot;) public String test(Model model,String name)&#123; model.addAttribute(&quot;msg&quot;,name); //获取表单提交的值 return &quot;test&quot;; //跳转到test页面显示输入的值 &#125;&#125; 3、输入中文测试，发现乱码 不得不说，乱码问题是在我们开发中十分常见的问题，也是让我们程序猿比较头大的问题！ 以前乱码问题通过过滤器解决 , 而SpringMVC给我们提供了一个过滤器 , 可以在web.xml中配置 . 修改了xml文件需要重启服务器！ 123456789101112&lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 但是我们发现 , 有些极端情况下.这个过滤器对get的支持不好 . 处理方法 : 1、修改tomcat配置文件 ：设置编码！ 123&lt;Connector URIEncoding=&quot;utf-8&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 2、自定义过滤器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108package com.kuang.filter;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletRequestWrapper;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.UnsupportedEncodingException;import java.util.Map;/*** 解决get和post请求 全部乱码的过滤器*/public class GenericEncodingFilter implements Filter &#123; @Override public void destroy() &#123; &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; //处理response的字符编码 HttpServletResponse myResponse=(HttpServletResponse) response; myResponse.setContentType(&quot;text/html;charset=UTF-8&quot;); // 转型为与协议相关对象 HttpServletRequest httpServletRequest = (HttpServletRequest) request; // 对request包装增强 HttpServletRequest myrequest = new MyRequest(httpServletRequest); chain.doFilter(myrequest, response); &#125; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125;&#125;//自定义request对象，HttpServletRequest的包装类class MyRequest extends HttpServletRequestWrapper &#123; private HttpServletRequest request; //是否编码的标记 private boolean hasEncode; //定义一个可以传入HttpServletRequest对象的构造函数，以便对其进行装饰 public MyRequest(HttpServletRequest request) &#123; super(request);// super必须写 this.request = request; &#125; // 对需要增强方法 进行覆盖 @Override public Map getParameterMap() &#123; // 先获得请求方式 String method = request.getMethod(); if (method.equalsIgnoreCase(&quot;post&quot;)) &#123; // post请求 try &#123; // 处理post乱码 request.setCharacterEncoding(&quot;utf-8&quot;); return request.getParameterMap(); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; &#125; else if (method.equalsIgnoreCase(&quot;get&quot;)) &#123; // get请求 Map&lt;String, String[]&gt; parameterMap = request.getParameterMap(); if (!hasEncode) &#123; // 确保get手动编码逻辑只运行一次 for (String parameterName : parameterMap.keySet()) &#123; String[] values = parameterMap.get(parameterName); if (values != null) &#123; for (int i = 0; i &lt; values.length; i++) &#123; try &#123; // 处理get乱码 values[i] = new String(values[i] .getBytes(&quot;ISO-8859-1&quot;), &quot;utf-8&quot;); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; hasEncode = true; &#125; return parameterMap; &#125; return super.getParameterMap(); &#125; //取一个值 @Override public String getParameter(String name) &#123; Map&lt;String, String[]&gt; parameterMap = getParameterMap(); String[] values = parameterMap.get(name); if (values == null) &#123; return null; &#125; return values[0]; // 取回参数的第一个值 &#125; //取所有值 @Override public String[] getParameterValues(String name) &#123; Map&lt;String, String[]&gt; parameterMap = getParameterMap(); String[] values = parameterMap.get(name); return values; &#125;&#125; 这个也是我在网上找的一些大神写的，一般情况下，SpringMVC默认的乱码处理就已经能够很好的解决了！ 然后在web.xml中配置这个过滤器即可！ 乱码问题，需要平时多注意，在尽可能能设置编码的地方，都设置为统一编码 UTF-8！ 有了这些知识，我们马上就可以进行SSM整合了！ 整合SSM 环境要求 环境： IDEA MySQL 5.7.19 Tomcat 9 Maven 3.6 要求： 需要熟练掌握MySQL数据库，Spring，JavaWeb及MyBatis知识，简单的前端知识； 数据库环境 创建一个存放书籍数据的数据库表 123456789101112131415161718CREATE DATABASE `ssmbuild`;USE `ssmbuild`;DROP TABLE IF EXISTS `books`;CREATE TABLE `books` (`bookID` INT(10) NOT NULL AUTO_INCREMENT COMMENT &apos;书id&apos;,`bookName` VARCHAR(100) NOT NULL COMMENT &apos;书名&apos;,`bookCounts` INT(11) NOT NULL COMMENT &apos;数量&apos;,`detail` VARCHAR(200) NOT NULL COMMENT &apos;描述&apos;,KEY `bookID` (`bookID`)) ENGINE=INNODB DEFAULT CHARSET=utf8INSERT INTO `books`(`bookID`,`bookName`,`bookCounts`,`detail`)VALUES(1,&apos;Java&apos;,1,&apos;从入门到放弃&apos;),(2,&apos;MySQL&apos;,10,&apos;从删库到跑路&apos;),(3,&apos;Linux&apos;,5,&apos;从进门到进牢&apos;); 基本环境搭建 1、新建一Maven项目！ssmbuild ， 添加web的支持 2、导入相关的pom依赖！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;dependencies&gt; &lt;!--Junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;!--数据库驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--Servlet - JSP --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--Mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--Spring--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3、Maven资源过滤设置 1234567891011121314151617181920&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 4、建立基本结构和配置框架！ com.kuang.pojo com.kuang.dao com.kuang.service com.kuang.controller mybatis-config.xml 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;&lt;/configuration&gt; applicationContext.xml 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;/beans&gt; Mybatis层编写 1、数据库配置文件 database.properties 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/ssmbuild?useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf8jdbc.username=rootjdbc.password=123456 2、IDEA关联数据库 3、编写MyBatis的核心配置文件 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;typeAliases&gt; &lt;package name=&quot;com.kuang.pojo&quot;/&gt; &lt;/typeAliases&gt; &lt;mappers&gt; &lt;mapper resource=&quot;com/kuang/dao/BookMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 4、编写数据库对应的实体类 com.kuang.pojo.Books 使用lombok插件！ 1234567891011121314151617package com.kuang.pojo;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructorpublic class Books &#123; private int bookID; private String bookName; private int bookCounts; private String detail; &#125; 5、编写Dao层的 Mapper接口！ 1234567891011121314151617181920212223package com.kuang.dao;import com.kuang.pojo.Books;import java.util.List;public interface BookMapper &#123; //增加一个Book int addBook(Books book); //根据id删除一个Book int deleteBookById(int id); //更新Book int updateBook(Books books); //根据id查询,返回一个Book Books queryBookById(int id); //查询全部Book,返回list集合 List&lt;Books&gt; queryAllBook();&#125; 6、编写接口对应的 Mapper.xml 文件。需要导入MyBatis的包； 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.kuang.dao.BookMapper&quot;&gt; &lt;!--增加一个Book--&gt; &lt;insert id=&quot;addBook&quot; parameterType=&quot;Books&quot;&gt; insert into ssmbuild.books(bookName,bookCounts,detail) values (#&#123;bookName&#125;, #&#123;bookCounts&#125;, #&#123;detail&#125;) &lt;/insert&gt; &lt;!--根据id删除一个Book--&gt; &lt;delete id=&quot;deleteBookById&quot; parameterType=&quot;int&quot;&gt; delete from ssmbuild.books where bookID=#&#123;bookID&#125; &lt;/delete&gt; &lt;!--更新Book--&gt; &lt;update id=&quot;updateBook&quot; parameterType=&quot;Books&quot;&gt; update ssmbuild.books set bookName = #&#123;bookName&#125;,bookCounts = #&#123;bookCounts&#125;,detail = #&#123;detail&#125; where bookID = #&#123;bookID&#125; &lt;/update&gt; &lt;!--根据id查询,返回一个Book--&gt; &lt;select id=&quot;queryBookById&quot; resultType=&quot;Books&quot;&gt; select * from ssmbuild.books where bookID = #&#123;bookID&#125; &lt;/select&gt; &lt;!--查询全部Book--&gt; &lt;select id=&quot;queryAllBook&quot; resultType=&quot;Books&quot;&gt; SELECT * from ssmbuild.books &lt;/select&gt;&lt;/mapper&gt; 7、编写Service层的接口和实现类 接口： 12345678910111213141516171819package com.kuang.service;import com.kuang.pojo.Books;import java.util.List;//BookService:底下需要去实现,调用dao层public interface BookService &#123; //增加一个Book int addBook(Books book); //根据id删除一个Book int deleteBookById(int id); //更新Book int updateBook(Books books); //根据id查询,返回一个Book Books queryBookById(int id); //查询全部Book,返回list集合 List&lt;Books&gt; queryAllBook();&#125; 实现类： 1234567891011121314151617181920212223242526272829303132333435package com.kuang.service;import com.kuang.dao.BookMapper;import com.kuang.pojo.Books;import java.util.List;public class BookServiceImpl implements BookService &#123; //调用dao层的操作，设置一个set接口，方便Spring管理 private BookMapper bookMapper; public void setBookMapper(BookMapper bookMapper) &#123; this.bookMapper = bookMapper; &#125; public int addBook(Books book) &#123; return bookMapper.addBook(book); &#125; public int deleteBookById(int id) &#123; return bookMapper.deleteBookById(id); &#125; public int updateBook(Books books) &#123; return bookMapper.updateBook(books); &#125; public Books queryBookById(int id) &#123; return bookMapper.queryBookById(id); &#125; public List&lt;Books&gt; queryAllBook() &#123; return bookMapper.queryAllBook(); &#125;&#125; OK，到此，底层需求操作编写完毕！ Spring层 1、配置Spring整合MyBatis，我们这里数据源使用c3p0连接池； 2、我们去编写Spring整合Mybatis的相关的配置文件；spring-dao.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 配置整合mybatis --&gt; &lt;!-- 1.关联数据库文件 --&gt; &lt;context:property-placeholder location=&quot;classpath:database.properties&quot;/&gt; &lt;!-- 2.数据库连接池 --&gt; &lt;!--数据库连接池 dbcp 半自动化操作 不能自动连接 c3p0 自动化操作（自动的加载配置文件 并且设置到对象里面） --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;!-- 配置连接池属性 --&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;!-- c3p0连接池的私有属性 --&gt; &lt;property name=&quot;maxPoolSize&quot; value=&quot;30&quot;/&gt; &lt;property name=&quot;minPoolSize&quot; value=&quot;10&quot;/&gt; &lt;!-- 关闭连接后不自动commit --&gt; &lt;property name=&quot;autoCommitOnClose&quot; value=&quot;false&quot;/&gt; &lt;!-- 获取连接超时时间 --&gt; &lt;property name=&quot;checkoutTimeout&quot; value=&quot;10000&quot;/&gt; &lt;!-- 当获取连接失败重试次数 --&gt; &lt;property name=&quot;acquireRetryAttempts&quot; value=&quot;2&quot;/&gt; &lt;/bean&gt; &lt;!-- 3.配置SqlSessionFactory对象 --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;!-- 配置MyBaties全局配置文件:mybatis-config.xml --&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt; &lt;/bean&gt; &lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口注入到spring容器中 --&gt; &lt;!--解释 ：https://www.cnblogs.com/jpfss/p/7799806.html--&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;!-- 注入sqlSessionFactory --&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt; &lt;!-- 给出需要扫描Dao接口包 --&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.kuang.dao&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 3、Spring整合service层 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 扫描service相关的bean --&gt; &lt;context:component-scan base-package=&quot;com.kuang.service&quot; /&gt; &lt;!--BookServiceImpl注入到IOC容器中--&gt; &lt;bean id=&quot;BookServiceImpl&quot; class=&quot;com.kuang.service.BookServiceImpl&quot;&gt; &lt;property name=&quot;bookMapper&quot; ref=&quot;bookMapper&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置事务管理器 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; Spring层搞定！再次理解一下，Spring就是一个大杂烩，一个容器！对吧！ SpringMVC层 1、web.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!--DispatcherServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!--一定要注意:我们这里加载的是总的配置文件，之前被这里坑了！--&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!--encodingFilter--&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt; org.springframework.web.filter.CharacterEncodingFilter &lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!--Session过期时间--&gt; &lt;session-config&gt; &lt;session-timeout&gt;15&lt;/session-timeout&gt; &lt;/session-config&gt; &lt;/web-app&gt; 2、spring-mvc.xml 1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!-- 配置SpringMVC --&gt; &lt;!-- 1.开启SpringMVC注解驱动 --&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 2.静态资源默认servlet配置--&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!-- 3.配置jsp 显示ViewResolver视图解析器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot; /&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt; &lt;!-- 4.扫描web相关的bean --&gt; &lt;context:component-scan base-package=&quot;com.kuang.controller&quot; /&gt;&lt;/beans&gt; 3、Spring配置整合文件，applicationContext.xml 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;import resource=&quot;spring-dao.xml&quot;/&gt; &lt;import resource=&quot;spring-service.xml&quot;/&gt; &lt;import resource=&quot;spring-mvc.xml&quot;/&gt; &lt;/beans&gt; 配置文件，暂时结束！Controller 和 视图层编写 1、BookController 类编写 ， 方法一：查询全部书籍 123456789101112131415@Controller@RequestMapping(&quot;/book&quot;)public class BookController &#123; @Autowired @Qualifier(&quot;BookServiceImpl&quot;) private BookService bookService; @RequestMapping(&quot;/allBook&quot;) public String list(Model model) &#123; List&lt;Books&gt; list = bookService.queryAllBook(); model.addAttribute(&quot;list&quot;, list); return &quot;allBook&quot;; &#125;&#125; 2、编写首页 index.jsp 1234567891011121314151617181920212223242526272829&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; %&gt;&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;首页&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; a &#123; text-decoration: none; color: black; font-size: 18px; &#125; h3 &#123; width: 180px; height: 38px; margin: 100px auto; text-align: center; line-height: 38px; background: deepskyblue; border-radius: 4px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt; &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/book/allBook&quot;&gt;点击进入列表页&lt;/a&gt;&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; 3、书籍列表页面 allbook.jsp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;书籍列表&lt;/title&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;!-- 引入 Bootstrap --&gt; &lt;link href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row clearfix&quot;&gt; &lt;div class=&quot;col-md-12 column&quot;&gt; &lt;div class=&quot;page-header&quot;&gt; &lt;h1&gt; &lt;small&gt;书籍列表 —— 显示所有书籍&lt;/small&gt; &lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-4 column&quot;&gt; &lt;a class=&quot;btn btn-primary&quot; href=&quot;$&#123;pageContext.request.contextPath&#125;/book/toAddBook&quot;&gt;新增&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row clearfix&quot;&gt; &lt;div class=&quot;col-md-12 column&quot;&gt; &lt;table class=&quot;table table-hover table-striped&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;书籍编号&lt;/th&gt; &lt;th&gt;书籍名字&lt;/th&gt; &lt;th&gt;书籍数量&lt;/th&gt; &lt;th&gt;书籍详情&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;c:forEach var=&quot;book&quot; items=&quot;$&#123;requestScope.get(&apos;list&apos;)&#125;&quot;&gt; &lt;tr&gt; &lt;td&gt;$&#123;book.getBookID()&#125;&lt;/td&gt; &lt;td&gt;$&#123;book.getBookName()&#125;&lt;/td&gt; &lt;td&gt;$&#123;book.getBookCounts()&#125;&lt;/td&gt; &lt;td&gt;$&#123;book.getDetail()&#125;&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/book/toUpdateBook?id=$&#123;book.getBookID()&#125;&quot;&gt;更改&lt;/a&gt; | &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/book/del/$&#123;book.getBookID()&#125;&quot;&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 4、BookController 类编写 ， 方法二：添加书籍 1234567891011@RequestMapping(&quot;/toAddBook&quot;)public String toAddPaper() &#123; return &quot;addBook&quot;;&#125;@RequestMapping(&quot;/addBook&quot;)public String addPaper(Books books) &#123; System.out.println(books); bookService.addBook(books); return &quot;redirect:/book/allBook&quot;;&#125; 5、添加书籍页面：addBook.jsp 123456789101112131415161718192021222324252627282930&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;新增书籍&lt;/title&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;!-- 引入 Bootstrap --&gt; &lt;link href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row clearfix&quot;&gt; &lt;div class=&quot;col-md-12 column&quot;&gt; &lt;div class=&quot;page-header&quot;&gt; &lt;h1&gt; &lt;small&gt;新增书籍&lt;/small&gt; &lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/book/addBook&quot; method=&quot;post&quot;&gt; 书籍名称：&lt;input type=&quot;text&quot; name=&quot;bookName&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; 书籍数量：&lt;input type=&quot;text&quot; name=&quot;bookCounts&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; 书籍详情：&lt;input type=&quot;text&quot; name=&quot;detail&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;添加&quot;&gt; &lt;/form&gt;&lt;/div&gt; 6、BookController 类编写 ， 方法三：修改书籍 12345678910111213141516@RequestMapping(&quot;/toUpdateBook&quot;)public String toUpdateBook(Model model, int id) &#123; Books books = bookService.queryBookById(id); System.out.println(books); model.addAttribute(&quot;book&quot;,books ); return &quot;updateBook&quot;;&#125;@RequestMapping(&quot;/updateBook&quot;)public String updateBook(Model model, Books book) &#123; System.out.println(book); bookService.updateBook(book); Books books = bookService.queryBookById(book.getBookID()); model.addAttribute(&quot;books&quot;, books); return &quot;redirect:/book/allBook&quot;;&#125; 7、修改书籍页面 updateBook.jsp 12345678910111213141516171819202122232425262728293031&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;修改信息&lt;/title&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;!-- 引入 Bootstrap --&gt; &lt;link href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row clearfix&quot;&gt; &lt;div class=&quot;col-md-12 column&quot;&gt; &lt;div class=&quot;page-header&quot;&gt; &lt;h1&gt; &lt;small&gt;修改信息&lt;/small&gt; &lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/book/updateBook&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;bookID&quot; value=&quot;$&#123;book.getBookID()&#125;&quot;/&gt; 书籍名称：&lt;input type=&quot;text&quot; name=&quot;bookName&quot; value=&quot;$&#123;book.getBookName()&#125;&quot;/&gt; 书籍数量：&lt;input type=&quot;text&quot; name=&quot;bookCounts&quot; value=&quot;$&#123;book.getBookCounts()&#125;&quot;/&gt; 书籍详情：&lt;input type=&quot;text&quot; name=&quot;detail&quot; value=&quot;$&#123;book.getDetail() &#125;&quot;/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt; &lt;/form&gt;&lt;/div&gt; 8、BookController 类编写 ， 方法四：删除书籍 12345@RequestMapping(&quot;/del/&#123;bookId&#125;&quot;)public String deleteBook(@PathVariable(&quot;bookId&quot;) int id) &#123; bookService.deleteBookById(id); return &quot;redirect:/book/allBook&quot;;&#125; 配置Tomcat，进行运行！ 到目前为止，这个SSM项目整合已经完全的OK了，可以直接运行进行测试！这个练习十分的重要，大家需要保证，不看任何东西，自己也可以完整的实现出来！ 项目结构图 小结及展望 这个是同学们的第一个SSM整合案例，一定要烂熟于心！ SSM框架的重要程度是不言而喻的，学到这里，大家已经可以进行基本网站的单独开发。但是这只是增删改查的基本操作。可以说学到这里，大家才算是真正的步入了后台开发的门。也就是能找一个后台相关工作的底线。 或许很多人，工作就做这些事情，但是对于个人的提高来说，还远远不够！ 我们后面还要学习一些 SpringMVC 的知识！ Ajax 和 Json 文件上传和下载 拦截器 什么是JSON？ JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式，目前使用特别广泛。 采用完全独立于编程语言的文本格式来存储和表示数据。 简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。 在 JavaScript 语言中，一切都是对象。因此，任何JavaScript 支持的类型都可以通过 JSON 来表示，例如字符串、数字、对象、数组等。看看他的要求和语法格式： 对象表示为键值对，数据由逗号分隔 花括号保存对象 方括号保存数组 JSON 键值对是用来保存 JavaScript 对象的一种方式，和 JavaScript 对象的写法也大同小异，键/值对组合中的键名写在前面并用双引号 “” 包裹，使用冒号 : 分隔，然后紧接着值： 123&#123;&quot;name&quot;: &quot;QinJiang&quot;&#125;&#123;&quot;age&quot;: &quot;3&quot;&#125;&#123;&quot;sex&quot;: &quot;男&quot;&#125; 很多人搞不清楚 JSON 和 JavaScript 对象的关系，甚至连谁是谁都不清楚。其实，可以这么理解： JSON 是 JavaScript 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。 12var obj = &#123;a: &apos;Hello&apos;, b: &apos;World&apos;&#125;; //这是一个对象，注意键名也是可以使用引号包裹的var json = &apos;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&apos;; //这是一个 JSON 字符串，本质是一个字符串 JSON 和 JavaScript 对象互转 要实现从JSON字符串转换为JavaScript 对象，使用 JSON.parse() 方法： 12var obj = JSON.parse(&apos;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&apos;);//结果是 &#123;a: &apos;Hello&apos;, b: &apos;World&apos;&#125; 要实现从JavaScript 对象转换为JSON字符串，使用 JSON.stringify() 方法： 12var json = JSON.stringify(&#123;a: &apos;Hello&apos;, b: &apos;World&apos;&#125;);//结果是 &apos;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&apos; 代码测试 1、新建一个module ，springmvc-05-json ， 添加web的支持 2、在web目录下新建一个 json-1.html ， 编写测试内容 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;JSON_秦疆&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot;&gt; //编写一个js的对象 var user = &#123; name:&quot;秦疆&quot;, age:3, sex:&quot;男&quot; &#125;; //将js对象转换成json字符串 var str = JSON.stringify(user); console.log(str); //将json字符串转换为js对象 var user2 = JSON.parse(str); console.log(user2.age,user2.name,user2.sex);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3、在IDEA中使用浏览器打开，查看控制台输出！ Controller返回JSON数据 Jackson应该是目前比较好的json解析工具了 当然工具不止这一个，比如还有阿里巴巴的 fastjson 等等。 我们这里使用Jackson，使用它需要导入它的jar包； 123456&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.8&lt;/version&gt;&lt;/dependency&gt; 配置SpringMVC需要的配置 web.xml 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!--1.注册servlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动顺序，数字越小，启动越早 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--所有请求都会被springmvc拦截 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; springmvc-servlet.xml 12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt; &lt;context:component-scan base-package=&quot;com.kuang.controller&quot;/&gt; &lt;!-- 视图解析器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt; &lt;!-- 前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt; &lt;!-- 后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; 我们随便编写一个User的实体类，然后我们去编写我们的测试Controller； 1234567891011121314151617package com.kuang.pojo;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;//需要导入lombok@Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123; private String name; private int age; private String sex; &#125; 这里我们需要两个新东西，一个是@ResponseBody，一个是ObjectMapper对象，我们看下具体的用法 编写一个Controller； 1234567891011121314151617@Controllerpublic class UserController &#123; @RequestMapping(&quot;/json1&quot;) @ResponseBody public String json1() throws JsonProcessingException &#123; //创建一个jackson的对象映射器，用来解析数据 ObjectMapper mapper = new ObjectMapper(); //创建一个对象 User user = new User(&quot;秦疆1号&quot;, 3, &quot;男&quot;); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(user); //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便 return str; &#125;&#125; 配置Tomcat ， 启动测试一下！ http://localhost:8080/json1 发现出现了乱码问题，我们需要设置一下他的编码格式为utf-8，以及它返回的类型； 通过@RequestMaping的produces属性来实现，修改下代码 12//produces:指定响应体返回类型和编码@RequestMapping(value = &quot;/json1&quot;,produces = &quot;application/json;charset=utf-8&quot;) 再次测试， http://localhost:8080/json1 ， 乱码问题OK！ 【注意：使用json记得处理乱码问题】 代码优化 乱码统一解决 上一种方法比较麻烦，如果项目中有许多请求则每一个都要添加，可以通过Spring配置统一指定，这样就不用每次都去处理了！ 我们可以在springmvc的配置文件上添加一段消息StringHttpMessageConverter转换配置！ 1234567891011121314&lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt; &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt; &lt;constructor-arg value=&quot;UTF-8&quot;/&gt; &lt;/bean&gt; &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt; &lt;property name=&quot;objectMapper&quot;&gt; &lt;bean class=&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt; &lt;property name=&quot;failOnEmptyBeans&quot; value=&quot;false&quot;/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt; 返回json字符串统一解决 在类上直接使用 @RestController ，这样子，里面所有的方法都只会返回 json 字符串了，不用再每一个都添加@ResponseBody ！我们在前后端分离开发中，一般都使用 @RestController ，十分便捷！ 1234567891011121314151617@RestControllerpublic class UserController &#123; //produces:指定响应体返回类型和编码 @RequestMapping(value = &quot;/json1&quot;) public String json1() throws JsonProcessingException &#123; //创建一个jackson的对象映射器，用来解析数据 ObjectMapper mapper = new ObjectMapper(); //创建一个对象 User user = new User(&quot;秦疆1号&quot;, 3, &quot;男&quot;); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(user); //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便 return str; &#125;&#125; 启动tomcat测试，结果都正常输出！ 测试集合输出 增加一个新的方法 1234567891011121314151617181920@RequestMapping(&quot;/json2&quot;)public String json2() throws JsonProcessingException &#123; //创建一个jackson的对象映射器，用来解析数据 ObjectMapper mapper = new ObjectMapper(); //创建一个对象 User user1 = new User(&quot;秦疆1号&quot;, 3, &quot;男&quot;); User user2 = new User(&quot;秦疆2号&quot;, 3, &quot;男&quot;); User user3 = new User(&quot;秦疆3号&quot;, 3, &quot;男&quot;); User user4 = new User(&quot;秦疆4号&quot;, 3, &quot;男&quot;); List&lt;User&gt; list = new ArrayList&lt;User&gt;(); list.add(user1); list.add(user2); list.add(user3); list.add(user4); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(list); return str;&#125; 运行结果 : 十分完美，没有任何问题！ 输出时间对象 增加一个新的方法 1234567891011@RequestMapping(&quot;/json3&quot;)public String json3() throws JsonProcessingException &#123; ObjectMapper mapper = new ObjectMapper(); //创建时间一个对象，java.util.Date Date date = new Date(); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(date); return str;&#125; 运行结果 : 默认日期格式会变成一个数字，是1970年1月1日到当前日期的毫秒数！ Jackson 默认是会把时间转成timestamps形式 解决方案：取消timestamps形式 ， 自定义时间格式 1234567891011121314151617@RequestMapping(&quot;/json4&quot;)public String json4() throws JsonProcessingException &#123; ObjectMapper mapper = new ObjectMapper(); //不使用时间戳的方式 mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); //自定义日期格式对象 SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); //指定日期格式 mapper.setDateFormat(sdf); Date date = new Date(); String str = mapper.writeValueAsString(date); return str;&#125; 运行结果 : 成功的输出了时间！ 抽取为工具类 如果要经常使用的话，这样是比较麻烦的，我们可以将这些代码封装到一个工具类中；我们去编写下 123456789101112131415161718192021222324252627282930package com.kuang.utils;import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.SerializationFeature;import java.text.SimpleDateFormat;public class JsonUtils &#123; public static String getJson(Object object) &#123; return getJson(object,&quot;yyyy-MM-dd HH:mm:ss&quot;); &#125; public static String getJson(Object object,String dateFormat) &#123; ObjectMapper mapper = new ObjectMapper(); //不使用时间差的方式 mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); //自定义日期格式对象 SimpleDateFormat sdf = new SimpleDateFormat(dateFormat); //指定日期格式 mapper.setDateFormat(sdf); try &#123; return mapper.writeValueAsString(object); &#125; catch (JsonProcessingException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 我们使用工具类，代码就更加简洁了！ 123456@RequestMapping(&quot;/json5&quot;)public String json5() throws JsonProcessingException &#123; Date date = new Date(); String json = JsonUtils.getJson(date); return json;&#125; 大功告成！完美！ FastJson fastjson.jar是阿里开发的一款专门用于Java开发的包，可以方便的实现json对象与JavaBean对象的转换，实现JavaBean对象与json字符串的转换，实现json对象与json字符串的转换。实现json的转换方法很多，最后的实现结果都是一样的。 fastjson 的 pom依赖！ 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.60&lt;/version&gt;&lt;/dependency&gt; fastjson 三个主要的类： JSONObject 代表 json 对象 JSONObject实现了Map接口, 猜想 JSONObject底层操作是由Map实现的。 JSONObject对应json对象，通过各种形式的get()方法可以获取json对象中的数据，也可利用诸如size()，isEmpty()等方法获取”键：值”对的个数和判断是否为空。其本质是通过实现Map接口并调用接口中的方法完成的。 JSONArray 代表 json 对象数组 内部是有List接口中的方法来完成操作的。 JSON代表 JSONObject和JSONArray的转化 JSON类源码分析与使用 仔细观察这些方法，主要是实现json对象，json对象数组，javabean对象，json字符串之间的相互转化。 代码测试，我们新建一个FastJsonDemo 类 1234567891011121314151617181920212223242526272829303132333435363738394041package com.kuang.controller;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;import com.kuang.pojo.User;import java.util.ArrayList;import java.util.List;public class FastJsonDemo &#123; public static void main(String[] args) &#123; //创建一个对象 User user1 = new User(&quot;秦疆1号&quot;, 3, &quot;男&quot;); User user2 = new User(&quot;秦疆2号&quot;, 3, &quot;男&quot;); User user3 = new User(&quot;秦疆3号&quot;, 3, &quot;男&quot;); User user4 = new User(&quot;秦疆4号&quot;, 3, &quot;男&quot;); List&lt;User&gt; list = new ArrayList&lt;User&gt;(); list.add(user1); list.add(user2); list.add(user3); list.add(user4); System.out.println(&quot;*******Java对象 转 JSON字符串*******&quot;); String str1 = JSON.toJSONString(list); System.out.println(&quot;JSON.toJSONString(list)==&gt;&quot;+str1); String str2 = JSON.toJSONString(user1); System.out.println(&quot;JSON.toJSONString(user1)==&gt;&quot;+str2); System.out.println(&quot;\\n****** JSON字符串 转 Java对象*******&quot;); User jp_user1=JSON.parseObject(str2,User.class); System.out.println(&quot;JSON.parseObject(str2,User.class)==&gt;&quot;+jp_user1); System.out.println(&quot;\\n****** Java对象 转 JSON对象 ******&quot;); JSONObject jsonObject1 = (JSONObject) JSON.toJSON(user2); System.out.println(&quot;(JSONObject) JSON.toJSON(user2)==&gt;&quot;+jsonObject1.getString(&quot;name&quot;)); System.out.println(&quot;\\n****** JSON对象 转 Java对象 ******&quot;); User to_java_user = JSON.toJavaObject(jsonObject1, User.class); System.out.println(&quot;JSON.toJavaObject(jsonObject1, User.class)==&gt;&quot;+to_java_user); &#125;&#125; 这种工具类，我们只需要掌握使用就好了，在使用的时候在根据具体的业务去找对应的实现。和以前的commons-io那种工具包一样，拿来用就好了！ 简介 AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。 AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 Ajax 不是一种新的编程语言，而是一种用于创建更好更快以及交互性更强的Web应用程序的技术。 在 2005 年，Google 通过其 Google Suggest 使 AJAX 变得流行起来。Google Suggest能够自动帮你完成搜索单词。 Google Suggest 使用 AJAX 创造出动态性极强的 web 界面：当您在谷歌的搜索框输入关键字时，JavaScript 会把这些字符发送到服务器，然后服务器会返回一个搜索建议的列表。 就和国内百度的搜索框一样! 传统的网页(即不用ajax技术的网页)，想要更新内容或者提交一个表单，都需要重新加载整个网页。 使用ajax技术的网页，通过在后台服务器进行少量的数据交换，就可以实现异步局部更新。 使用Ajax，用户可以创建接近本地桌面应用的直接、高可用、更丰富、更动态的Web用户界面。 伪造Ajax 我们可以使用前端的一个标签来伪造一个ajax的样子。iframe标签 1、新建一个module ：sspringmvc-06-ajax ， 导入web支持！ 2、编写一个 ajax-frame.html 使用 iframe 测试，感受下效果 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;kuangshen&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot;&gt; window.onload = function()&#123; var myDate = new Date(); document.getElementById(&apos;currentTime&apos;).innerText = myDate.getTime(); &#125;; function LoadPage()&#123; var targetUrl = document.getElementById(&apos;url&apos;).value; console.log(targetUrl); document.getElementById(&quot;iframePosition&quot;).src = targetUrl; &#125;&lt;/script&gt;&lt;div&gt; &lt;p&gt;请输入要加载的地址：&lt;span id=&quot;currentTime&quot;&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt; &lt;input id=&quot;url&quot; type=&quot;text&quot; value=&quot;https://www.baidu.com/&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;提交&quot; onclick=&quot;LoadPage()&quot;&gt; &lt;/p&gt;&lt;/div&gt;&lt;div&gt; &lt;h3&gt;加载页面位置：&lt;/h3&gt; &lt;iframe id=&quot;iframePosition&quot; style=&quot;width: 100%;height: 500px;&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3、使用IDEA开浏览器测试一下！ 利用AJAX可以做： 注册时，输入用户名自动检测用户是否已经存在。 登陆时，提示用户名密码错误 删除数据行时，将行ID发送到后台，后台在数据库中删除，数据库删除成功后，在页面DOM中将数据行也删除。 ….等等 jQuery.ajax 纯JS原生实现Ajax我们不去讲解这里，直接使用jquery提供的，方便学习和使用，避免重复造轮子，有兴趣的同学可以去了解下JS原生XMLHttpRequest ！ Ajax的核心是XMLHttpRequest对象(XHR)。XHR为向服务器发送请求和解析服务器响应提供了接口。能够以异步方式从服务器获取新数据。 jQuery 提供多个与 AJAX 有关的方法。 通过 jQuery AJAX 方法，您能够使用 HTTP Get 和 HTTP Post 从远程服务器上请求文本、HTML、XML 或 JSON – 同时您能够把这些外部数据直接载入网页的被选元素中。 jQuery 不是生产者，而是大自然搬运工。 jQuery Ajax本质就是 XMLHttpRequest，对他进行了封装，方便调用！ 123456789101112131415161718192021jQuery.ajax(...) 部分参数： url：请求地址 type：请求方式，GET、POST（1.9.0之后用method） headers：请求头 data：要发送的数据 contentType：即将发送信息至服务器的内容编码类型(默认: &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;) async：是否异步 timeout：设置请求超时时间（毫秒） beforeSend：发送请求前执行的函数(全局) complete：完成之后执行的回调函数(全局) success：成功之后执行的回调函数(全局) error：失败之后执行的回调函数(全局) accepts：通过请求头发送给服务器，告诉服务器当前客户端可接受的数据类型 dataType：将服务器端返回的数据转换成指定类型 &quot;xml&quot;: 将服务器端返回的内容转换成xml格式 &quot;text&quot;: 将服务器端返回的内容转换成普通文本格式 &quot;html&quot;: 将服务器端返回的内容转换成普通文本格式，在插入DOM中时，如果包含JavaScript标签，则会尝试去执行。 &quot;script&quot;: 尝试将返回值当作JavaScript去执行，然后再将服务器端返回的内容转换成普通文本格式 &quot;json&quot;: 将服务器端返回的内容转换成相应的JavaScript对象 &quot;jsonp&quot;: JSONP 格式使用 JSONP 形式调用函数时，如 &quot;myurl?callback=?&quot; jQuery 将自动替换 ? 为正确的函数名，以执行回调函数 我们来个简单的测试，使用最原始的HttpServletResponse处理 , .最简单 , 最通用 1、配置web.xml 和 springmvc的配置文件，复制上面案例的即可 【记得静态资源过滤和注解驱动配置上】 123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt; &lt;context:component-scan base-package=&quot;com.kuang.controller&quot;/&gt; &lt;mvc:default-servlet-handler /&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 视图解析器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt; &lt;!-- 前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt; &lt;!-- 后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; 2、编写一个AjaxController 12345678910111213@Controllerpublic class AjaxController &#123; @RequestMapping(&quot;/a1&quot;) public void ajax1(String name , HttpServletResponse response) throws IOException &#123; if (&quot;admin&quot;.equals(name))&#123; response.getWriter().print(&quot;true&quot;); &#125;else&#123; response.getWriter().print(&quot;false&quot;); &#125; &#125;&#125; 3、导入jquery ， 可以使用在线的CDN ， 也可以下载导入 12&lt;script src=&quot;https://code.jquery.com/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/statics/js/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt; 4、编写index.jsp测试 1234567891011121314151617181920212223242526&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;%--&lt;script src=&quot;https://code.jquery.com/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt;--%&gt; &lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/statics/js/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; function a1()&#123; $.post(&#123; url:&quot;$&#123;pageContext.request.contextPath&#125;/a1&quot;, data:&#123;&apos;name&apos;:$(&quot;#txtName&quot;).val()&#125;, success:function (data,status) &#123; alert(data); alert(status); &#125; &#125;); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt;&lt;%--onblur：失去焦点触发事件--%&gt;用户名:&lt;input type=&quot;text&quot; id=&quot;txtName&quot; onblur=&quot;a1()&quot;/&gt; &lt;/body&gt;&lt;/html&gt; 5、启动tomcat测试！打开浏览器的控制台，当我们鼠标离开输入框的时候，可以看到发出了一个ajax的请求！是后台返回给我们的结果！测试成功！ Springmvc实现 实体类user 12345678910@Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123; private String name; private int age; private String sex;&#125; 我们来获取一个集合对象，展示到前端页面 12345678@RequestMapping(&quot;/a2&quot;)public List&lt;User&gt; ajax2()&#123; List&lt;User&gt; list = new ArrayList&lt;User&gt;(); list.add(new User(&quot;秦疆1号&quot;,3,&quot;男&quot;)); list.add(new User(&quot;秦疆2号&quot;,3,&quot;男&quot;)); list.add(new User(&quot;秦疆3号&quot;,3,&quot;男&quot;)); return list; //由于@RestController注解，将list转成json格式返回&#125; 前端页面 123456789101112131415161718192021222324252627282930313233343536373839&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;获取数据&quot;/&gt;&lt;table width=&quot;80%&quot; align=&quot;center&quot;&gt; &lt;tr&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;年龄&lt;/td&gt; &lt;td&gt;性别&lt;/td&gt; &lt;/tr&gt; &lt;tbody id=&quot;content&quot;&gt; &lt;/tbody&gt;&lt;/table&gt;&lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/statics/js/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(function () &#123; $(&quot;#btn&quot;).click(function () &#123; $.post(&quot;$&#123;pageContext.request.contextPath&#125;/a2&quot;,function (data) &#123; console.log(data) var html=&quot;&quot;; for (var i = 0; i &lt;data.length ; i++) &#123; html+= &quot;&lt;tr&gt;&quot; + &quot;&lt;td&gt;&quot; + data[i].name + &quot;&lt;/td&gt;&quot; + &quot;&lt;td&gt;&quot; + data[i].age + &quot;&lt;/td&gt;&quot; + &quot;&lt;td&gt;&quot; + data[i].sex + &quot;&lt;/td&gt;&quot; + &quot;&lt;/tr&gt;&quot; &#125; $(&quot;#content&quot;).html(html); &#125;); &#125;) &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 成功实现了数据回显！可以体会一下Ajax的好处！ 注册提示效果 我们再测试一个小Demo，思考一下我们平时注册时候，输入框后面的实时提示怎么做到的；如何优化 我们写一个Controller 1234567891011121314151617181920@RequestMapping(&quot;/a3&quot;)public String ajax3(String name,String pwd)&#123; String msg = &quot;&quot;; //模拟数据库中存在数据 if (name!=null)&#123; if (&quot;admin&quot;.equals(name))&#123; msg = &quot;OK&quot;; &#125;else &#123; msg = &quot;用户名输入错误&quot;; &#125; &#125; if (pwd!=null)&#123; if (&quot;123456&quot;.equals(pwd))&#123; msg = &quot;OK&quot;; &#125;else &#123; msg = &quot;密码输入有误&quot;; &#125; &#125; return msg; //由于@RestController注解，将msg转成json格式返回&#125; 前端页面 login.jsp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;ajax&lt;/title&gt; &lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/statics/js/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; function a1()&#123; $.post(&#123; url:&quot;$&#123;pageContext.request.contextPath&#125;/a3&quot;, data:&#123;&apos;name&apos;:$(&quot;#name&quot;).val()&#125;, success:function (data) &#123; if (data.toString()==&apos;OK&apos;)&#123; $(&quot;#userInfo&quot;).css(&quot;color&quot;,&quot;green&quot;); &#125;else &#123; $(&quot;#userInfo&quot;).css(&quot;color&quot;,&quot;red&quot;); &#125; $(&quot;#userInfo&quot;).html(data); &#125; &#125;); &#125; function a2()&#123; $.post(&#123; url:&quot;$&#123;pageContext.request.contextPath&#125;/a3&quot;, data:&#123;&apos;pwd&apos;:$(&quot;#pwd&quot;).val()&#125;, success:function (data) &#123; if (data.toString()==&apos;OK&apos;)&#123; $(&quot;#pwdInfo&quot;).css(&quot;color&quot;,&quot;green&quot;); &#125;else &#123; $(&quot;#pwdInfo&quot;).css(&quot;color&quot;,&quot;red&quot;); &#125; $(&quot;#pwdInfo&quot;).html(data); &#125; &#125;); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt; 用户名:&lt;input type=&quot;text&quot; id=&quot;name&quot; onblur=&quot;a1()&quot;/&gt; &lt;span id=&quot;userInfo&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt; 密码:&lt;input type=&quot;text&quot; id=&quot;pwd&quot; onblur=&quot;a2()&quot;/&gt; &lt;span id=&quot;pwdInfo&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 【记得处理json乱码问题】 测试一下效果，动态请求响应，局部刷新，就是如此！ 获取baidu接口Demo 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;JSONP百度搜索&lt;/title&gt; &lt;style&gt; #q&#123; width: 500px; height: 30px; border:1px solid #ddd; line-height: 30px; display: block; margin: 0 auto; padding: 0 10px; font-size: 14px; &#125; #ul&#123; width: 520px; list-style: none; margin: 0 auto; padding: 0; border:1px solid #ddd; margin-top: -1px; display: none; &#125; #ul li&#123; line-height: 30px; padding: 0 10px; &#125; #ul li:hover&#123; background-color: #f60; color: #fff; &#125; &lt;/style&gt; &lt;script&gt; // 2.步骤二 // 定义demo函数 (分析接口、数据) function demo(data)&#123; var Ul = document.getElementById(&apos;ul&apos;); var html = &apos;&apos;; // 如果搜索数据存在 把内容添加进去 if (data.s.length) &#123; // 隐藏掉的ul显示出来 Ul.style.display = &apos;block&apos;; // 搜索到的数据循环追加到li里 for(var i = 0;i&lt;data.s.length;i++)&#123; html += &apos;&lt;li&gt;&apos;+data.s[i]+&apos;&lt;/li&gt;&apos;; &#125; // 循环的li写入ul Ul.innerHTML = html; &#125; &#125; // 1.步骤一 window.onload = function()&#123; // 获取输入框和ul var Q = document.getElementById(&apos;q&apos;); var Ul = document.getElementById(&apos;ul&apos;); // 事件鼠标抬起时候 Q.onkeyup = function()&#123; // 如果输入框不等于空 if (this.value != &apos;&apos;) &#123; // ☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆JSONPz重点☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆ // 创建标签 var script = document.createElement(&apos;script&apos;); //给定要跨域的地址 赋值给src //这里是要请求的跨域的地址 我写的是百度搜索的跨域地址 script.src = &apos;https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=&apos;+this.value+&apos;&amp;cb=demo&apos;; // 将组合好的带src的script标签追加到body里 document.body.appendChild(script); &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;text&quot; id=&quot;q&quot; /&gt;&lt;ul id=&quot;ul&quot;&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; Ajax在我们开发中十分重要，一定要学会使用！ 概述 SpringMVC的处理器拦截器类似于Servlet开发中的过滤器Filter,用于对处理器进行预处理和后处理。开发者可以自己定义一些拦截器来实现特定的功能。 过滤器与拦截器的区别：拦截器是AOP思想的具体应用。 过滤器 servlet规范中的一部分，任何java web工程都可以使用 在url-pattern中配置了/*之后，可以对所有要访问的资源进行拦截 拦截器 拦截器是SpringMVC框架自己的，只有使用了SpringMVC框架的工程才能使用 拦截器只会拦截访问的控制器方法， 如果访问的是jsp/html/css/image/js是不会进行拦截的 自定义拦截器 那如何实现拦截器呢？ 想要自定义拦截器，必须实现 HandlerInterceptor 接口。 1、新建一个Moudule ， springmvc-07-Interceptor ， 添加web支持 2、配置web.xml 和 springmvc-servlet.xml 文件 3、编写一个拦截器 12345678910111213141516171819202122232425262728package com.kuang.interceptor;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class MyInterceptor implements HandlerInterceptor &#123; //在请求处理的方法之前执行 //如果返回true执行下一个拦截器 //如果返回false就不执行下一个拦截器 public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception &#123; System.out.println(&quot;------------处理前------------&quot;); return true; &#125; //在请求处理方法执行之后执行 public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;------------处理后------------&quot;); &#125; //在dispatcherServlet处理后执行,做清理工作. public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception &#123; System.out.println(&quot;------------清理------------&quot;); &#125;&#125; 4、在springmvc的配置文件中配置拦截器 1234567891011&lt;!--关于拦截器的配置--&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!--/** 包括路径及其子路径--&gt; &lt;!--/admin/* 拦截的是/admin/add等等这种 , /admin/add/user不会被拦截--&gt; &lt;!--/admin/** 拦截的是/admin/下的所有--&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;!--bean配置的就是拦截器--&gt; &lt;bean class=&quot;com.kuang.interceptor.MyInterceptor&quot;/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 5、编写一个Controller，接收请求 1234567891011121314151617package com.kuang.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;//测试拦截器的控制器@Controllerpublic class InterceptorController &#123; @RequestMapping(&quot;/interceptor&quot;) @ResponseBody public String testFunction() &#123; System.out.println(&quot;控制器中的方法执行了&quot;); return &quot;hello&quot;; &#125;&#125; 6、前端 index.jsp 1&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/interceptor&quot;&gt;拦截器测试&lt;/a&gt; 7、启动tomcat 测试一下！ 验证用户是否登录 (认证用户) 实现思路 1、有一个登陆页面，需要写一个controller访问页面。 2、登陆页面有一提交表单的动作。需要在controller中处理。判断用户名密码是否正确。如果正确，向session中写入用户信息。返回登陆成功。 3、拦截用户请求，判断用户是否登陆。如果用户已经登陆。放行， 如果用户未登陆，跳转到登陆页面 测试： 1、编写一个登陆页面 login.jsp 1234567891011121314151617&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;h1&gt;登录页面&lt;/h1&gt;&lt;hr&gt;&lt;body&gt;&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/user/login&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;br&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;pwd&quot;&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 2、编写一个Controller处理请求 12345678910111213141516171819202122232425262728293031323334353637383940package com.kuang.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import javax.servlet.http.HttpSession;@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123; //跳转到登陆页面 @RequestMapping(&quot;/jumplogin&quot;) public String jumpLogin() throws Exception &#123; return &quot;login&quot;; &#125; //跳转到成功页面 @RequestMapping(&quot;/jumpSuccess&quot;) public String jumpSuccess() throws Exception &#123; return &quot;success&quot;; &#125; //登陆提交 @RequestMapping(&quot;/login&quot;) public String login(HttpSession session, String username, String pwd) throws Exception &#123; // 向session记录用户身份信息 System.out.println(&quot;接收前端===&quot;+username); session.setAttribute(&quot;user&quot;, username); return &quot;success&quot;; &#125; //退出登陆 @RequestMapping(&quot;logout&quot;) public String logout(HttpSession session) throws Exception &#123; // session 过期 session.invalidate(); return &quot;login&quot;; &#125;&#125; 3、编写一个登陆成功的页面 success.jsp 1234567891011121314&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;登录成功页面&lt;/h1&gt;&lt;hr&gt;$&#123;user&#125;&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/user/logout&quot;&gt;注销&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 4、在 index 页面上测试跳转！启动Tomcat 测试，未登录也可以进入主页！ 12345678910111213&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;首页&lt;/h1&gt; &lt;hr&gt;&lt;%--登录--%&gt; &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/user/jumplogin&quot;&gt;登录&lt;/a&gt; &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/user/jumpSuccess&quot;&gt;成功页面&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; 5、编写用户登录拦截器 12345678910111213141516171819202122232425262728293031323334353637383940package com.kuang.interceptor;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.io.IOException;public class LoginInterceptor implements HandlerInterceptor &#123; public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws ServletException, IOException &#123; // 如果是登陆页面则放行 System.out.println(&quot;uri: &quot; + request.getRequestURI()); if (request.getRequestURI().contains(&quot;login&quot;)) &#123; return true; &#125; HttpSession session = request.getSession(); // 如果用户已登陆也放行 if(session.getAttribute(&quot;user&quot;) != null) &#123; return true; &#125; // 用户没有登陆跳转到登陆页面 request.getRequestDispatcher(&quot;/WEB-INF/jsp/login.jsp&quot;).forward(request, response); return false; &#125; public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception &#123; &#125; public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception &#123; &#125;&#125; 6、在Springmvc的配置文件中注册拦截器 1234567&lt;!--关于拦截器的配置--&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;bean id=&quot;loginInterceptor&quot; class=&quot;com.kuang.interceptor.LoginInterceptor&quot;/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 7、再次重启Tomcat测试！ OK，测试登录拦截功能无误. 文件上传和下载 准备工作 文件上传是项目开发中最常见的功能之一 ,springMVC 可以很好的支持文件上传，但是SpringMVC上下文中默认没有装配MultipartResolver，因此默认情况下其不能处理文件上传工作。如果想使用Spring的文件上传功能，则需要在上下文中配置MultipartResolver。 前端表单要求：为了能上传文件，必须将表单的method设置为POST，并将enctype设置为multipart/form-data。只有在这样的情况下，浏览器才会把用户选择的文件以二进制数据发送给服务器； 对表单中的 enctype 属性做个详细的说明： application/x-www=form-urlencoded：默认方式，只处理表单域中的 value 属性值，采用这种编码方式的表单会将表单域中的值处理成 URL 编码方式。 multipart/form-data：这种编码方式会以二进制流的方式来处理表单数据，这种编码方式会把文件域指定文件的内容也封装到请求参数中，不会对字符编码。 text/plain：除了把空格转换为 “+” 号外，其他字符都不做编码处理，这种方式适用直接通过表单发送邮件。 1234&lt;form action=&quot;&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt; 一旦设置了enctype为multipart/form-data，浏览器即会采用二进制流的方式来处理表单数据，而对于文件上传的处理则涉及在服务器端解析原始的HTTP响应。在2003年，Apache Software Foundation发布了开源的Commons FileUpload组件，其很快成为Servlet/JSP程序员上传文件的最佳选择。 Servlet3.0规范已经提供方法来处理文件上传，但这种上传需要在Servlet中完成。 而Spring MVC则提供了更简单的封装。 Spring MVC为文件上传提供了直接的支持，这种支持是用即插即用的MultipartResolver实现的。 Spring MVC使用Apache Commons FileUpload技术实现了一个MultipartResolver实现类： CommonsMultipartResolver。因此，SpringMVC的文件上传还需要依赖Apache Commons FileUpload的组件。 文件上传 1、导入文件上传的jar包，commons-fileupload ， Maven会自动帮我们导入他的依赖包 commons-io包； 123456789101112&lt;!--文件上传--&gt;&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.3&lt;/version&gt;&lt;/dependency&gt;&lt;!--servlet-api导入高版本的--&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt;&lt;/dependency&gt; 2、配置bean：multipartResolver 【注意！！！这个bena的id必须为：multipartResolver ， 否则上传文件会报400的错误！在这里栽过坑,教训！】 12345678&lt;!--文件上传配置--&gt;&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;!-- 请求的编码格式，必须和jSP的pageEncoding属性一致，以便正确读取表单的内容，默认为ISO-8859-1 --&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot;/&gt; &lt;!-- 上传文件大小上限，单位为字节（10485760=10M） --&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;10485760&quot;/&gt; &lt;property name=&quot;maxInMemorySize&quot; value=&quot;40960&quot;/&gt;&lt;/bean&gt; CommonsMultipartFile 的 常用方法： String getOriginalFilename()：获取上传文件的原名 InputStream getInputStream()：获取文件流 void transferTo(File dest)：将上传文件保存到一个目录文件中 我们去实际测试一下 3、编写前端页面 1234&lt;form action=&quot;/upload&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt; &lt;input type=&quot;submit&quot; value=&quot;upload&quot;&gt;&lt;/form&gt; 4、Controller 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.kuang.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.multipart.commons.CommonsMultipartFile;import javax.servlet.http.HttpServletRequest;import java.io.*;@Controllerpublic class FileController &#123; //@RequestParam(&quot;file&quot;) 将name=file控件得到的文件封装成CommonsMultipartFile 对象 //批量上传CommonsMultipartFile则为数组即可 @RequestMapping(&quot;/upload&quot;) public String fileUpload(@RequestParam(&quot;file&quot;) CommonsMultipartFile file , HttpServletRequest request) throws IOException &#123; //获取文件名 : file.getOriginalFilename(); String uploadFileName = file.getOriginalFilename(); //如果文件名为空，直接回到首页！ if (&quot;&quot;.equals(uploadFileName))&#123; return &quot;redirect:/index.jsp&quot;; &#125; System.out.println(&quot;上传文件名 : &quot;+uploadFileName); //上传路径保存设置 String path = request.getServletContext().getRealPath(&quot;/upload&quot;); //如果路径不存在，创建一个 File realPath = new File(path); if (!realPath.exists())&#123; realPath.mkdir(); &#125; System.out.println(&quot;上传文件保存地址：&quot;+realPath); InputStream is = file.getInputStream(); //文件输入流 OutputStream os = new FileOutputStream(new File(realPath,uploadFileName)); //文件输出流 //读取写出 int len=0; byte[] buffer = new byte[1024]; while ((len=is.read(buffer))!=-1)&#123; os.write(buffer,0,len); os.flush(); &#125; os.close(); is.close(); return &quot;redirect:/index.jsp&quot;; &#125;&#125; 5、测试上传文件，OK！ 采用file.Transto 来保存上传的文件 1、编写Controller 1234567891011121314151617181920/** 采用file.Transto 来保存上传的文件*/@RequestMapping(&quot;/upload2&quot;)public String fileUpload2(@RequestParam(&quot;file&quot;) CommonsMultipartFile file, HttpServletRequest request) throws IOException &#123; //上传路径保存设置 String path = request.getServletContext().getRealPath(&quot;/upload&quot;); File realPath = new File(path); if (!realPath.exists())&#123; realPath.mkdir(); &#125; //上传文件地址 System.out.println(&quot;上传文件保存地址：&quot;+realPath); //通过CommonsMultipartFile的方法直接写文件（注意这个时候） file.transferTo(new File(realPath +&quot;/&quot;+ file.getOriginalFilename())); return &quot;redirect:/index.jsp&quot;;&#125; 2、前端表单提交地址修改 3、访问提交测试，OK！ 文件下载 文件下载步骤： 1、设置 response 响应头 2、读取文件 – InputStream 3、写出文件 – OutputStream 4、执行操作 5、关闭流 （先开后关） 代码实现： 12345678910111213141516171819202122232425262728293031@RequestMapping(value=&quot;/download&quot;)public String downloads(HttpServletResponse response ,HttpServletRequest request) throws Exception&#123; //要下载的图片地址 String path = request.getServletContext().getRealPath(&quot;/upload&quot;); String fileName = &quot;基础语法.jpg&quot;; //1、设置response 响应头 response.reset(); //设置页面不缓存,清空buffer response.setCharacterEncoding(&quot;UTF-8&quot;); //字符编码 response.setContentType(&quot;multipart/form-data&quot;); //二进制传输数据 //设置响应头 response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;fileName=&quot;+URLEncoder.encode(fileName, &quot;UTF-8&quot;)); File file = new File(path,fileName); //2、 读取文件--输入流 InputStream input=new FileInputStream(file); //3、 写出文件--输出流 OutputStream out = response.getOutputStream(); byte[] buff =new byte[1024]; int index=0; //4、执行 写出操作 while((index= input.read(buff))!= -1)&#123; out.write(buff, 0, index); out.flush(); &#125; out.close(); input.close(); return null;&#125; 前端 1&lt;a href=&quot;/download&quot;&gt;点击下载&lt;/a&gt; 测试，文件下载OK，大家可以和我们之前学习的JavaWeb原生的方式对比一下，就可以知道这个便捷多了! 拦截器及文件操作在我们开发中十分重要，一定要学会使用！","categories":[],"tags":[]},{"title":"ssm阶段","slug":"ssm阶段","date":"2020-09-24T08:35:20.000Z","updated":"2020-09-24T08:58:23.582Z","comments":true,"path":"2020/09/24/ssm阶段/","link":"","permalink":"https://lucifinil-x.github.io/2020/09/24/ssm阶段/","excerpt":"ssm阶段回顾1.mybatis2.spring3.springmvc1.mybatis持久化：数据冻起来，才能拿出来再用CRUDspring配置ResultMap结果集映射 一对多 多对一log4j分页注解开发动态SQL 判断if 和 循环for缓存 一级/二级缓存","text":"ssm阶段回顾1.mybatis2.spring3.springmvc1.mybatis持久化：数据冻起来，才能拿出来再用CRUDspring配置ResultMap结果集映射 一对多 多对一log4j分页注解开发动态SQL 判断if 和 循环for缓存 一级/二级缓存 2.springIOCAOP代理模式 静态动态注解开发spring","categories":[],"tags":[]},{"title":"JavaScript学习","slug":"JavaScript学习","date":"2020-09-14T09:26:21.000Z","updated":"2020-11-13T12:10:39.988Z","comments":true,"path":"2020/09/14/JavaScript学习/","link":"","permalink":"https://lucifinil-x.github.io/2020/09/14/JavaScript学习/","excerpt":"了解框架框架 jQuery: 不是框架，是一个库，方法不用手写了，用别人的方法。现在用的越来越少，因为有更多成熟的框架。实现前端通信 React: 虚拟DOM，减少dom操作，提高渲染效率，需要学习jsx语言,使用复杂 vue: 结合模块化开发和虚拟dom, Axios: 实现前后端AJAX通信，封装简单","text":"了解框架框架 jQuery: 不是框架，是一个库，方法不用手写了，用别人的方法。现在用的越来越少，因为有更多成熟的框架。实现前端通信 React: 虚拟DOM，减少dom操作，提高渲染效率，需要学习jsx语言,使用复杂 vue: 结合模块化开发和虚拟dom, Axios: 实现前后端AJAX通信，封装简单 UI框架 Ant-Design: 基于React ElementUI,ice: 基于vue JavaScript构建工具 Babel WebPack 什么是JavaScriptJavaScript是世界上最流行的脚本语言==一个合格的后端人员，必须精通JavaScript，写的可能会是最多的== ECMAScript它可以理解为是JavaScript的一个标准 js大部分都是在做网络通信、交互、操作dom 快速入门引入JavaScript用script标签在HTML5文件中引入1.内部引入 123456789&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script&gt; alert(&apos;hello,world&apos;); &lt;/script&gt;&lt;/head&gt; 2.外部引入 123456789101112&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;!-- 外部引入JavaScript--&gt;&lt;!-- 注意：script标签必须成对出现--&gt; &lt;script src=&quot;JS代码/1..js&quot;&gt;&lt;/script&gt;&lt;!-- type不写也默认是JavaScript--&gt; &lt;script type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;/head&gt; 基本语法1.定义变量 没有变量类型，只有 var 变量名 = 变量值；2.条件控制if与java一样 ； 严格区分大小写 12345678if(num&gt;1)&#123; alert(&quot;true&quot;); if(num&gt;4 &amp;&amp; num&lt;8)&#123; alert(num+&quot;=&quot;+&quot;2-8&quot;); &#125; else&#123; &#125;&#125; 3.网页审查元素-console-可以写js代码并在console/上面执行常用函数：console.log(num); console输出4.网页审查元素-source-可以看到源代码；可以在源代码上面打断点，f5/一步一步进行调试 数据类型数值，文本，图形，音频，视频 变量不能以数字开头var A_a_q_1 = 3;var 王者荣耀 = “倔强青铜”; numberjs不区分小数和整数 123456123123.11.2e2-99Nan //not a numberInfinity //无限大 字符串 12&apos;abc&apos;&quot;abc&quot; 布尔值true false 逻辑运算&amp;&amp; || ! 比较运算符(重要)坚持不用==比较，用=== 123= //赋值== //类型不一样，值一样,也会为true=== //类型一样，值一样,才会是ture. 一般都用这个 须知： - NaN与所有数值都不相等，包括自己 NaN===NaN; //false - 判断数值(NaN)是否为NaN: isNaN(NaN) //true 浮点数问题console.log((1/3)===(1-2/3)) //false尽量避免使用浮点数进行计算，会存在精度问题Math.abs(1/3-(1-2/3))&lt;0.000000000001 //true null和undefinednull 空undefined 未定义 数组 []数组中可以存不同的java数据类型，因为js只有一个类型var 定义数组： 123//定义数组：保证数组的可读性，尽量使用[] var arr = [1,2,3,&apos;hello&apos;,null,true]; new Array(1,2,3,&apos;hello&apos;,null,true,2,3,2,1); 打印，取值： 12console.log(arr); //(6) [1, 2, 3, &quot;hello&quot;, null, true] console.log(arr[8]) //undefined 取数组下标：如果越界就会undefined 不会报错 对象 {}初始化对象：12345678//对象大括号，数组是中括号//java: Person p = new Person(1,2,3,4,5);//js 大括号里跟Py的字典一样用： 每对属性像py键值对一样用,隔开最后一个不用var p = &#123; name: &quot;qin&quot;, age: 3, tags: [&apos;ja&apos;,&apos;ss&apos;,&apos;aa&apos;,3,4]&#125; 取对象的值： 12console.log(p.name);console.log(p.age); 严格检查模式‘use strict’严格检查模式，预防js的随意性导致的一些问题 ，必须写在script的第一行。 局部变量建议使用let,可以用var但是会有灰色提示. 1234567&lt;!-- &apos;use strict&apos;严格检查模式，预防js的随意性导致的一些问题 ，必须写在script的第一行。 局部变量建议使用let,可以用var但是会有灰色提示--&gt; &lt;script&gt; &apos;use strict&apos;; //全局变量 let i =1; &lt;/script&gt; 数据类型讲解字符串1.正常字符串： ‘ ‘ “ “ 2.转义字符,都需要写在” “里面 12345\\&apos;\\n\\t\\u4e2d unicode字符\\x41 ASCII字符 3.分行字符串 (tab上面，esc下面 123456789var msg = `hello j s a ` //hello j s a 4.模板字符串 ${变量} (tab上面，esc下面 1234567let name = &apos;qin&apos;;let age = 3;let message = `你好,$&#123;name&#125;`console.log(message) //你好,qinmessage = `你好,`+name; //你好,qin java那样的也可以 5.字符串长度和java一样 str.length 6.字符串不可变，不可赋值(字符串里的)和java一样 7.大小写转换调用函数 str.toUpperCase(); str.toLowerCase();这里的str是字符串变量！ 8.通过字符取下标索引str.indexOf(‘字符串中的字符’); //得到第一次出现的下标值 12let stu = &quot;student&quot;;console.log(stu.indexOf(&apos;d&apos;)) //3 9.子字符串和java一样 console.log(stu.substring(1,3)); //tu用的多 数组数组可以包含任意的数据类型数组：就是存储数据的，需要知道如何存，如何取，其他方法都可以自己实现！ 1.定义var arr = [1,2,3,4,5,6]; 2.长度console.log(arr.length);数组的长度可以通过赋值改变，与其他语言不同。如果给arr.length赋值，数组的大小就会发生变化。如果赋值太小，数组中元素就会丢失。 123arr.length = 3;console.log(arr); //(3) [1, 2, 3] 3.通过数组中的元素获取下标索引arr.indexOf(3); //2 4.slice() 截取数组，返回新数组，类似于字符串中的substring()。记住。 123var arr2 = [1,2,3,4,5,6,7,8,9];var arr3 = arr2.slice(3,7);console.log(arr3); 5.push() pop()push() 向尾部增加元素pop() 弹出尾部的一个元素,数组缩短 1234arr3.push(&apos;a&apos;,&apos;v&apos;,&apos;c&apos;);console.log(arr3); //[4, 5, 6, 7, &quot;a&quot;, &quot;v&quot;, &quot;c&quot;]arr3.pop(); //carr3.pop(); //v 6.unshift(),shift()unshift() 向头部增加元素shift() 弹出头部的一个元素,数组缩短 123arr3.unshift(&apos;sa&apos;,&apos;q&apos;,1); //[&quot;sa&quot;, &quot;q&quot;, 1, 4, 5, 6, 7, &quot;a&quot;]console.log(arr3);arr3.shift(); //sa 7.reverse() 元素翻转，原数组改变 123var arr4 = [1,2,3,4,5,6,7,8];var arr5 = arr4.reverse();console.log(arr5); 8.sort() 排序，原数组改变 123var arr6 = [1,4,3,2,5,6,7,8];var arr7 = arr6.sort();console.log(arr7); 9.concat([数组]) 拼接数组，原数组不改变同样，字符串也有这个函数，原字符串不改变。 1234var arr8 = [1,4,3,2,5,6,7,8];var arr9 = arr8.concat([&apos;a&apos;,&apos;aa&apos;,&apos;asx&apos;]);console.log(arr8); // [1, 4, 3, 2, 5, 6, 7, 8]console.log(arr9); //[1, 4, 3, 2, 5, 6, 7, 8, &quot;a&quot;, &quot;aa&quot;, &quot;asx&quot;] 10.join(‘字符串’) 用特定字符串拼接数组中元素，变成字符串，原数组不改变。 12var arr10 = arr8.join(&apos;--&apos;);console.log(arr10); //1--4--3--2--5--6--7--8 11.多维数组 12var arr11 = [[1,2],[&apos;2&apos;,&apos;axd&apos;]];console.log(arr11[1][1]); //axd 对象1.对象定义对象的定义和py的字典一样都是键值对，不过py没有类型，js属性名(键)不用加””，因为js的键都是字符串，要取用的时候需要加’’. py字典: 123tinydict = &#123;&apos;name&apos;: &apos;runoob&apos;, &apos;code&apos;:1, &apos;site&apos;: &apos;www.runoob.com&apos;&#125; js对象： 1234567891011var 对象名 = &#123; 属性名1 : 属性值1， 属性名2 : 属性值2&#125; var person = &#123; name : &quot;qin&quot;, age: 3, email: &quot;xxx@qq.com&quot;, score: 0 &#125;; 2.对象赋值person.name = ‘lulu’; 3.使用不存在的对象属性，不会报错，会undefined. 4.通过delete删除对象属性delete person.name; 5.通过对象赋值，添加对象的属性person.hhh = “hhh”; 6.判断属性值是否在这个对象中 in‘age’ in persontrue‘toString’ in person //这个是继承来的true 7.判断一个属性是否是这个对象自身拥有的 hasOwnProperty(‘键’)person.hasOwnProperty(‘toString’);falseperson.hasOwnProperty(‘age’);true 流程控制1.if和java没有区别 12345678var age =3;if(age&gt;3)&#123; alert(&apos;111&apos;);&#125;else if(age&lt;5)&#123; alert(&apos;222&apos;);&#125;else&#123; alert(&apos;333&apos;);&#125; 2.while,避免死循环，关不掉的和java没有区别 3.for和java没有区别fori 等一下就可以自动填充for条件那三个 1234for (let i = 0; i &lt;3 ; i++) &#123; alert(&apos;forfor&apos;); i++;&#125; 4.forEach循环 12345var ages = [1,2,3,4,5];ages.forEach(function (a) &#123; console.log(a); //a自己写的，都可以&#125;) 5.for in循环，没有for好用，不知道长度可以用for infor(var index in 对象){} 123456for(var num in ages)&#123; if(ages.hasOwnProperty(num))&#123; console.log(&quot;存在&quot;); console.log(ages[num]); //拿到的都是下标，值要用下标来取 &#125;&#125; 6.for of循环(es6)遍历数组/Map/Set： 123456789101112var ages = [1,2,3,4,5];for(var x of ages)&#123; console.log(x);&#125;var map = new Map([[&apos;3&apos;,33],[&apos;1&apos;,11],[&apos;2&apos;,22]]);for(var x of map)&#123; console.log(x);&#125;var set = new Set([1,2,2,2,3,4,5]);for(var x of set)&#123; console.log(x)&#125; Map和SetMap和Set的遍历用for of循环，代码在上面 MapMap是ES6中的，非常像py里的字典。 1.定义，初始化js: var map = new Map([[‘tom’,100], [‘jack’,90], [‘haha’,80]]); py: dict([(k1,v1), (k2,v2), (k3,v3)]) 2.get取值，通过key获得value 12var score = map.get(&apos;tom&apos;);console.log(name); 3.set赋值/新增 12map.set(&apos;tom&apos;,99);map.set(&apos;xx&apos;,88); 4.delete删除map.delete(‘tom’); Set 无序不重复的集合Set可以去重1.定义，初始化var set =new Set([1,2,2,2,3,4,5]); 2.增删 12set.add(24);set.delete(3); 3.是否包含元素set.has(3); iteratores6新特性 iterator迭代 for of循环(es6)遍历数组/Map/Set： 123456789101112var ages = [1,2,3,4,5];for(var x of ages)&#123; console.log(x);&#125;var map = new Map([[&apos;3&apos;,33],[&apos;1&apos;,11],[&apos;2&apos;,22]]);for(var x of map)&#123; console.log(x);&#125;var set = new Set([1,2,2,2,3,4,5]);for(var x of set)&#123; console.log(x)&#125; 函数函数不是方法，方法是在对象里面的，方法是通过对象来调用的。二者放的地方不同。 定义函数定义一：建议使用 1234function 函数名(参数)&#123; ... return ;&#125; 定义二:function(x){…}这是一个匿名函数，但是可以吧结果赋值给 函数名，通过 函数名 就可以调用函数！ 1234var 函数名 = function(参数)&#123; ... return ;&#125; 调用函数1函数名(参数); 参数问题：js可以传任意个参数/不传参数如果函数的参数只有一个，调用函数传入多参，则匹配第一个参数。如果函数有参数，调用函数传入空参，则会返回NaN 1.空参处理：可以设置手动异常抛出，规避空参/不存在类型。 123456function f(a) &#123; if(typeof x!==&apos;number&apos;)&#123; throw &apos;不是数字&apos; &#125; return a+2;&#125; 2.多参处理：arguments关键字，rest关键字arguments关键字，包含传递进来的所有参数，它是一个数组。 12345678function f(a) &#123; for (let i = 0; i &lt;arguments.length ; i++) &#123; console.log(arguments[i]); &#125; return a+2;&#125;调用：f(2,3,4,5); rest参数，包含传递进来的除了函数定义的，剩下的所有参数，它是一个数组。rest参数只能写在最后面，必须用…标识 123456789function aaa(a,b,...rest)&#123; console.log(&apos;a&apos;+a); console.log(&apos;b&apos;+b); console.log(rest); // [3, 4, 6, 7, 7] for (let i = 0; i &lt;arguments.length ; i++) &#123; console.log(arguments[i]); //全部输出 &#125;&#125;aaa(1,2,3,4,6,7,7); 变量的作用域js中，var定义变量是有作用域的。如果是在函数体中声明的变量，则在函数体之外是不可以使用的。 1.不同函数可以声明/用同一个变量名，互不相干 1234567function q()&#123; var x=1; x=x+1;&#125;function f() &#123; var x =2;&#125; 2.外部函数不能用内部的变量,内部函数可以使用外部函数的变量。和java一样。 1234567function out()&#123; var c =1; function inner()&#123; var b = c+1; &#125; var c=b+1; //b undefined 外部函数不能用内部的变量&#125; 3.养成规范：所有变量在函数第一行定义，不要乱放，便于代码维护。 4.全局对象window默认全局变量都自动绑定在window对象下. 123var x = &apos;xxx&apos;;//默认全局变量都自动绑定在window对象下alert(x); //alert()函数本身也是一个window变量(函数定义的第二种方式就是把函数看做一个变量赋值)alert(window.x); alert()函数本身也是一个window变量(函数定义的第二种方式就是把函数看做一个变量赋值). 把alert属性赋值给newalert,newalert()就是一个alert()函数了 12var newalert = window.alert;newalert(x); 123456//函数的重写window.alert =function () &#123; console.log(&quot;hahahha&quot;)&#125;alert(); js实际上只有一个全局作用域，任何变量(包括函数)，如果没有在函数作用域中找到，就会向外查找。如果直到在全局作用域中都没有找到就会报错RefrenceError. 5.规范：吧自己的代码(变量，函数)全部放入自己定义的唯一空间名字中，降低全局命名冲突的问题。 由于我们所有的全局变量都会绑定到window对象上，如果不同的js文件，使用了相同的全局变量，那么就会冲突。 jQuery里面就是大量的封装了这种 12345678//唯一全局变量var kuangshen = &#123;&#125;;//定义全局变量kuangshen.name = &apos;kuang&apos;;//定义函数kuangshen.add = function()&#123; return a+b;&#125; 6.局部作用域letvar 定义的局部变量在循环外部都还能访问使用，用let 定义局部变量就改善了这个问题。 所以之前说尽量都用let定义变量。 下面的代码会在fori循环之后，i还生效： 1234567function f() &#123; for (var i = 0; i &lt;10 ; i++) &#123; console.log(i); &#125; console.log(i+1); //11&#125; var-&gt;let 1234567function f() &#123; for (let i = 0; i &lt;10 ; i++) &#123; console.log(i); &#125; console.log(i+1); //i is not defined&#125; 7.常量const(官方名：只读变量)const pi = ‘3.14’; 方法(函数放在对象中)对象只有两个东西：属性+方法 定义：123456789101112131415161718192021//第一种写法var shen =&#123; name: &apos;秦&apos;, birth: 2020, //方法 age: function () &#123; var now = new Date().getFullYear(); return now - this.birth; //对象里的属性不能直接用。 &#125;&#125;//第二种写法:拆开写，只能通过对象调用！this指向调用他的对象。function getAge() &#123; var now = new Date().getFullYear(); return now - this.birth; //对象里的属性不能直接用。&#125;var shen =&#123; name: &apos;秦&apos;, birth: 2020, //方法 age: getAge&#125; 调用shen.age(); //不用new对象 apply指定函数中的this指向的对象对于拆开写的方法,getAge()可以用在多个对象中，通过apply指定this去调用： 1234567891011121314151617181920//第二种写法:拆开写，只能通过对象调用！this指向调用他的对象。function getAge() &#123; var now = new Date().getFullYear(); return now - this.birth; //对象里的属性不能直接用。&#125;var shen =&#123; name: &apos;秦&apos;, birth: 2020, //方法 age: getAge&#125;var xiao =&#123; name: &apos;小明&apos;, birth: 2020, //方法 age: getAge&#125;//applygetAge.apply(xiao,[]); 内部对象标准对象typeof 输出数据对象类型number,string,boolean,number,object,function,undefined DateDate()对象就是时间。基本使用： 123456789var now = new Date(); //Thu Sep 17 2020 11:38:34 GMT+0800 (中国标准时间)now.getFullYear();now.getMonth();now.getDate();now.getHours();now.getMinutes();now.getSeconds();now.getTime();//时间戳，全世界统一 1970 1.1到现在的毫秒数 1600313914560console.log(new Date(1600313914560)); //new Date(时间戳)时间戳转为时间 Thu Sep 17 2020 11:38:34 GMT+0800 (中国标准时间) 时间戳转换为Date对象： 123var newdate = new Date(1600313914560);newdate.toLocaleString(); //2020/9/17 上午11:38:34&quot;newdate.toUTCString(); //&quot;Thu, 17 Sep 2020 03:38:34 GMT&quot; JSON JSON是什么： 早期，所有数据传输习惯使用XML文件 JSON= JavaScript Object notation,是一种轻量级的数据交换格式。 简洁和清晰的层次结构使得JSON成为理想的数据交换语言。 易于人阅读和编写，同时易于机器解析和生成，并且有效的提升网络传输效率。 后端前端接口都是JSON 在JS，一切皆为对象，任何js支持的类型都可以用json来表示(无缝转换)!!!格式： 对象用 () 数组用 [] 所有键值对用 {key:value} js对象(js一切都是对象) -&gt; json字符串JSON.stringify(对象) 1234567var user = &#123; name: &apos;qin&apos;, age: 3, sex: &apos;男&apos;&#125;//对象转化为json字符串var jsonUser = JSON.stringify(user); jsonUser“{“name”:”qin”,”age”:3,”sex”:”男”}”user{name: “qin”, age: 3, sex: “男”} json字符串 -&gt; js对象JSON.parse(‘字符串中的内容’) 1var 转换回来 = JSON.parse(&apos;&#123;&quot;name&quot;:&quot;qin&quot;,&quot;age&quot;:3,&quot;sex&quot;:&quot;男&quot;&#125;&apos;); //&#123;name: &quot;qin&quot;, age: 3, sex: &quot;男&quot;&#125; json字符串和js对象的区别-json键/值都是字符串json：“{“name”:”qin”,”age”:3,”sex”:”男”}”js:{name: “qin”, age: 3, sex: “男”} Ajax面向对象编程什么是面向对象面向对象特性的语言： javascript,java,c# 类：类是模板，对象的抽象对象：对象是类的具体表现 在JS，一切皆为对象 原型继承在js中：原型(模板)，就像继承，原型对象理解为父类。对象a.proto = 对象b; 对象a就包含对象b中的属性和方法了。 123456789101112131415161718192021222324var Student =&#123; name: &apos;qin&apos;, age:3, run: function () &#123; console.log(this.name+&quot;runrunrun&quot;); &#125;&#125;;var xiaoming = &#123; name: &apos;xiaoming&apos;&#125;;//js的模板，小明的模板原型指向studentxiaoming.__proto__ = Student;console.log(xiaoming.run()); //xiaomingrunrunrunvar bird =&#123; fly: function () &#123; console.log(&quot;我会飞&quot;) &#125;&#125;;xiaoming.__proto__ = bird;xiaoming.fly(); class继承本质：查看对象原型，写法友好了。 1234567891011121314151617181920212223//es6之后，直接定义student类class student&#123; constructor(name) &#123; this.name = name; &#125; hello()&#123; alert(&apos;hello&apos;); &#125;&#125;var xiaoming = new student(&apos;小明&apos;);var xiaohong = new student(&apos;小红&apos;);class xuesheng extends student&#123; constructor(name,grade) &#123; //构造函数哦！ super(name); this.grade = grade; &#125; mygrade()&#123; //对象内部方法 alert(&apos;我是小学生&apos;); &#125;&#125;xiaohong = new xuesheng(&apos;xiaohong&apos;);xiaohong.mygrade(); js叫原型链，java叫继承。 操作BOM对象(重点) 浏览器介绍：js的诞生就是为了能够让他在浏览器中运行 BOM = 浏览器对象模型浏览器对象： window 浏览器窗口window代表浏览器窗口，window.属性/window.函数().window对象可以获取浏览器自身的一些属性 Navigator(不建议使用) 浏览器的信息Navigator,封装了浏览器的信息navigator.属性 -&gt;查手册大多数时候我们不用navigator对象，因为会被人为修改。不建议使用这些属性来判断和编写代码。 12345678navigator.appName&quot;Netscape&quot;navigator.appVersion&quot;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.83 Safari/537.36&quot;navigator.userAgent&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.83 Safari/537.36&quot;navigator.platform&quot;Win32&quot; screen 屏幕尺寸代表屏幕尺寸 1234screen.width1280screen.height720 location(重要) url信息location代表当前页面的url信息一般用来设置新的定位，访问这个网站的人都会跳转到重定位的网站。 12345678location.host;&quot;local-ntp&quot;location.href;&quot;chrome-search://local-ntp/local-ntp.html&quot;location.protocol&quot;chrome-search:&quot;location.reload(); //刷新网页location.assign(&apos;https://www.baidu.com/&apos;); //重定向 document 页面document代表当前的页面 1234document.title&quot;百度一下，你就知道&quot;document.title = &apos;skmdm&apos; //改变页面的title&quot;skmdm&quot; 获取具体的文档树结点 1234567891011&lt;body&gt;&lt;dl id=&quot;app&quot;&gt; &lt;dt&gt;java&lt;/dt&gt; &lt;dd&gt;javase&lt;/dd&gt; &lt;dd&gt;javaee&lt;/dd&gt;&lt;/dl&gt;&lt;script&gt; var dl = document.getElementById(&apos;app&apos;); //获取具体的文档树结点，能获取结点，能动态的删除、添加结点，就能动态的修改网页了。&lt;/script&gt; 获取cookie 1document.cookie 劫持cookie原理：恶意人员的js代码能获取你的cookie,上传到他的服务器。例子：淘宝登录，天猫已经是登录状态https://www.taobao.com/ https://www.tmall.com/虽然cookie可以跨域名，但是淘宝和天猫域名都不一样。 1&lt;script src=&quot;xxx.js&quot;&gt;&lt;/script&gt; 服务器端可以设置cookie: httpOnlycookie就只读不可取，这样就安全了 historyhistory对象实现浏览器的前进后退12history.back()history.forward() 操作DOM对象(重点)【就是操作dom节点，就是操作标签节点】很重要，js的行为就体现在DOMDOM: 文档对象模型 html标签就像一棵倒着的树DOM结点是标签 核心：要操作dom节点，就必须要先获得这个dom节点。浏览器网页就是一个DOM属性结构！ 更新：更新DOM节点 遍历dom结点： 得到dom节点 删除： 删除一个dom节点 添加： 添加一个dom节点 核心：获取dom文档树节点【高亮！】直接在html里写js,会var h1document.getElementById（）返回null.解决办法：外部引入js，defer=”true”，解决加载顺序问题拿不到节点问题。 1&lt;script src=&quot;获取dom.js&quot; defer=&quot;true&quot;&gt;&lt;/script&gt; 通过id/class/标签选择器拿到文档树结点,class/标签返回数组，id返回？？ 12345678910111213 &lt;script&gt; //通过id/class/标签选择器拿到dom结点 var h1 = document.getElementById(&apos;p1&apos;); //通过id选择器拿到文档树结点&lt;p id=&quot;p1&quot;&gt;p1&lt;/p&gt; var h2 = document.getElementsByTagName(&apos;h1&apos;); //通过标签名拿到文档树结点 HTMLCollection [h1] var h3 = document.getElementsByClassName(&apos;p2&apos;);//通过class选择器拿到文档树结点 HTMLCollection [p.p2] &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;标题一&lt;/h1&gt;&lt;p id=&quot;p1&quot;&gt;p1&lt;/p&gt;&lt;p class=&quot;p2&quot;&gt;p2&lt;/p&gt;&lt;/body&gt; 我们只要能够定位到文档树上的某一个节点，我们就可以根据这个节点去找它周围的一些节点(找父类，子类，左右相邻的下一类) 123456789101112var father1 = document.getElementById(&apos;fa&apos;);//father是父节点,父节点这里只能用id选择器(唯一)var childrens = father1.children;//获取父节点下的所有子节点 HTMLCollection(3) [h1, p#p1, p.p2, p1: p#p1]var node1 = father1.firstChild; //获取父节点下的第一个子节点var node2 = father1.lastChild;var node3 = father1.nextElementSibling; //获取下一个相邻结点&lt;div id=&quot;fa&quot;&gt; &lt;h1&gt;标题一&lt;/h1&gt; &lt;p id=&quot;p1&quot;&gt;p1&lt;/p&gt; &lt;p class=&quot;p2&quot;&gt;p2&lt;/p&gt;&lt;/div&gt; 这是原生代码，之后我们尽量都是使用jQuery(); 更新dom节点1.node1.innerText=’123’; //修改文本的值 12var node1 = document.getElementById(&apos;id1&apos;);浏览器中写：node1.innerText=&apos;123&apos;; //修改文本的值 2.node1.innerHTML=’html代码’; //解析html文本标签 1node1.innerHTML=&apos; &lt;strong&gt;12sss3&lt;/strong&gt;&apos; 3.操作css样式：修改文本的值和颜色 节点的style属性 123var node1 = document.getElementById(&apos;id1&apos;);node1.innerText = &quot;dnsdwdwdwd&quot;;node1.style.color = &apos;red&apos;; 以前能够改css去改浏览器页面，现在就能写js代码修改页面的css了 123456var ss = document.getElementById(&apos;su&apos;);undefinedss&lt;input type=​&quot;submit&quot; id=​&quot;su&quot; value=​&quot;百度一下&quot; class=​&quot;bg s_btn&quot;&gt;​ss.style.padding=&apos;10px&apos;&quot;10px&quot; 删除dom节点删除节点的步奏：指定子节点，先获取父节点，再通过父节点干掉子节点。 1234//1.指定子节点2.获取父节点3.父节点删除子节点var self = document.getElementById(&apos;id3&apos;);var father = self.parentElement;father.removeChild(self); 动态删除子节点，children数组是在时刻变化的，删除结点的时候一定要注意.比如说一共4个子节点进行了前两行删除，只剩下两个子节点，就没有[2]了就会报错 123father.removeChild(father.children[0]);father.removeChild(father.children[1]);father.removeChild(father.children[2]); 插入dom节点append 追加（移动），会删除原节点 1234var boss = document.getElementById(&apos;boss&apos;);var list = document.getElementById(&apos;list&apos;);//list.append(boss); append 追加（移动），会删除原节点 创建新dom节点&amp;插入节点通过createElement创建新节点，设置节点的选择器和内容，再追加到list结点里面 1234var newP =document.createElement(&apos;p&apos;);//这里放tagname标签名newP.id = &apos;id5&apos;;newP.innerText = &apos;hello,新节点&apos;;list.append(newP); 设置新节点属性通用：节点.setAttribute(‘属性名’,’属性’); 例子：创建script标签节点,在加入到body标签里面 1234var newscript = document.createElement(&apos;script&apos;);newscript.setAttribute(&apos;type&apos;,&apos;text/javascript&apos;); //script type=&quot;text/javascript&quot;var body1 = document.getElementById(&apos;body&apos;);body1.append(newscript); 插入到前面：insertBefore(新节点，目标结点); 1234567//在父节点里面：吧新节点插入到目标结点的前面//insertBefore(新节点，目标结点)；//注意：新节点不能是list的子节点，如果是子节点，已经在list里面了var move1 = document.getElementById(&apos;move1&apos;);var id1 = document.getElementById(&apos;id1&apos;);var list = document.getElementById(&apos;list&apos;);list.insertBefore(move1,id1); 操作表单(验证)java-前端验证-避免在服务器端做处理-服务器端处理容易出大问题 表单是什么表单-form dom树里一个节点 文本框 text 下拉框 select 单选框 radio 多选框 checkbox 隐藏域 hidden 密码框 password… 表单的目的：提交信息 获得表单(获得要提交的信息) 得到/修改输入框(dom结点)的值 123456789&lt;form action=&quot;&quot;&gt;&lt;!-- id是选择器--&gt; &lt;span&gt;用户名：&lt;/span&gt; &lt;input type=&quot;text&quot; id=&quot;username&quot;&gt;&lt;/form&gt;var input_text = document.getElementById(&apos;username&apos;);input_text.value; //得到输入框(dom结点)的值input_text.value = &apos;1234&apos;; //修改输入框(dom结点)的值 得到/修改单选框被选中信息 1234567891011121314151617&lt;!-- 单选框和多选框的值都是定义好的value--&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;men&quot; id=&quot;boy&quot;&gt; 男 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;women&quot; id=&quot;girl&quot;&gt; 女//拿到多选框两个节点，用input第三拿var inputs = document.getElementsByTagName(&apos;input&apos;); //拿到数组var boy = inputs[1]; //用数组下标拿var girl = inputs[2];// boy.value //value只能拿到固定的定义好的值// &quot;men&quot;// boy.checked //checked获取当期是否被选中(返回结果)// false// girl.checked// true//boy.checked = true //赋值checked,换成男被选中 表单提交验证拿到用户名密码，点击提交修改密码 1234567891011121314151617181920212223&lt;form action=&quot;#&quot; method=&quot;post&quot;&gt; &lt;p&gt;&lt;span&gt;用户名：&lt;/span&gt; &lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot;&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;密码：&lt;/span&gt; &lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;password&quot;&gt;&lt;/p&gt; &lt;!--&lt;p&gt;&lt;input type=&quot;submit&quot;&gt;&lt;/p&gt;--&gt; &lt;!--button普通按钮，自己绑定事件。onclick被点击事件绑定函数clicksubmit()(写在js)--&gt; &lt;!--点击事件能运行函数，那么用函数就能够获取到表单的值了--&gt; &lt;p&gt;&lt;button type=&quot;submit&quot; onclick=&quot;clicksubmit()&quot;&gt;提交&lt;/button&gt;&lt;/p&gt;&lt;!-- 提交的表单在network-里面看密码是被拦截函数加密的--&gt;&lt;!-- 必须改成submit之后，才能提交表单，在network-header-点文件-看formdata.-里面有提交的用户名密码。密码已经被函数修改--&gt;&lt;/form&gt;//拿到用户名密码，修改密码function clicksubmit() &#123; alert(1); var uname = document.getElementById(&apos;username&apos;); var pwd = document.getElementById(&apos;password&apos;); console.log(uname.value,pwd.value); //value点不出来，但是不报错 pwd.value = &apos;123d12&apos;; // uname.value = &apos;adasd&apos;; return true; console.log(pwd.value);&#125; MD5加密前端提交的密码 和 表单提交检测引入md5,js提交函数中用md5对密码进行加密。username: t4tpassword: e0b73a1699aeee785d156388f584cf74 123456789101112&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/blueimp-md5/1.0.1/js/md5.min.js&quot;&gt;&lt;/script&gt;//md5函数加密function clicksubmit() &#123; alert(1); var uname = document.getElementById(&apos;username&apos;); var pwd = document.getElementById(&apos;password&apos;); console.log(uname.value,pwd.value); //value点不出来，但是不报错 pwd.value = md5(pwd); return true; console.log(pwd.value);&#125; 表单绑定提交事件：form标签里设置onsubmit属性.绑定一个提交检测的函数，来判断表单是否通过。可以在前端进行表单提交的拦截/过滤。 1234567&lt;!--表单绑定提交事件：form标签里设置onsubmit属性--&gt;&lt;!--onsubmit=&quot;&quot;对于submit动作进行过滤，return true就放行。t/f是函数给的返回值--&gt;&lt;form action=&quot;#&quot; method=&quot;post&quot; onsubmit=&quot;return clicksubmit()&quot;&gt; &lt;p&gt;&lt;button type=&quot;submit&quot; onclick=&quot;clicksubmit()&quot;&gt;提交&lt;/button&gt;&lt;/p&gt;&lt;form&gt; md5加密提交密码，密码框中的点会变长，影响用户体验。 12345678910111213&lt;p&gt;&lt;span&gt;密码：&lt;/span&gt;&lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;password&quot;&gt;&lt;/p&gt;&lt;!-- md5加密提交密码，密码框中的点会变长,....--&gt;&lt;input type=&quot;hidden&quot; id=&quot;md5-pwd&quot; name=&quot;pass&quot;&gt;function clicksubmit() &#123; alert(1); var uname = document.getElementById(&apos;username&apos;); var pwd = document.getElementById(&apos;password&apos;); var md5pwd = document.getElementById(&apos;md5-pwd&apos;); //pwd.value = md5(pwd.value); //如果写了这一行，密码框中的点会变长，如果不写这一行，network的包里password就没加密 md5pwd.value = md5(pwd.value); return true;&#125; jQueryjavaScript 和 jQuery的关系：jQuery库里面存在大量的js的函数。 获取/引入jQuery1.在线cdn引入jq 1&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/jquery/3.5.0/jquery.min.js&quot;&gt;&lt;/script&gt; 但是用不了：Unresolved function or method $() 2.jq官网下载jdk,放在项目文件夹里(新建一个lib文件夹) 下载到D:\\代码库\\jQuery3.5.1\\jquery-3.5.1 没用！报错！ 3.这个可以用！群里老哥给的 jq放在html下面！ 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;!--太难了 终于有个能用的--&gt; &lt;script src=&quot;https://libs.baidu.com/jquery/1.11.3/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;span&gt;&lt;a id=&quot;123&quot;&gt; 提示&lt;/a&gt;&lt;/span&gt;&lt;!--jQuery的script代码一定要放在body的html代码下面，不然不生效--&gt;&lt;script&gt; $(&quot;#123&quot;).click(function()&#123;console.log(123)&#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; jq公式jq就记住一个公式： $(selector).action() 三个选择器：$(‘p’).click();$(‘#id1’).click();$(‘.class1’).click(); 事件鼠标事件，键盘事件 鼠标移动，显示坐标 123456789101112131415161718192021222324252627282930313233343536373839&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;https://libs.baidu.com/jquery/1.11.3/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;style&gt; #divmove&#123; width: 500px; height: 500px; background: darkcyan; border: solid 1px red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;!--获取鼠标当前坐标--&gt;&lt;p&gt; mouse: &lt;span id=&quot;mouseMove&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;div id=&quot;divmove&quot;&gt; 在这里移动鼠标试试&lt;/div&gt;&lt;script&gt; // &lt;!--当网页元素加载完毕之后，响应/加载jq事件--&gt; // $(document).ready(function () &#123;&#125;) //由于经常使用，所以简化为以下： //$(function () &#123;&#125;) $(function () &#123; $(&apos;#divmove&apos;).mousemove(function (e) &#123; //e那里随便加入什么参数，一般用e占位 $(&apos;#mouseMove&apos;).text(&apos;x:&apos;+ e.pageX+&apos;y:&apos;+e.pageY); &#125;); &#125;);&lt;/script&gt;&lt;/body&gt; jq操作dom元素1234567891011121314151617181920&lt;body&gt;&lt;ul id=&quot;test-ul&quot;&gt; &lt;li class=&quot;js&quot;&gt;javascript&lt;/li&gt; &lt;li name=&quot;python&quot;&gt;python&lt;/li&gt; &lt;li name=&quot;hidden&quot;&gt;我被隐藏啦&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; //选择器1 标签[绑定属性] $(&apos;#test-ul li[name=python]&apos;).text(); //获得值 $(&apos;#test-ul li[name=python]&apos;).text(&apos;python222&apos;); //设置值 $(&apos;#test-ul li[class=js]&apos;).html(&apos;&lt;a href=&quot;&quot;&gt;lalal&lt;/a&gt;&apos;);//设置值 $(&apos;#test-ul li[name=python]&apos;).css(&quot;color&quot;,&quot;red&quot;); //设置的属性查文档，多个属性用键值对 //显示和隐藏在网页中使用非常多，本质是css的display:none $(&apos;#test-ul li[name=hidden]&apos;).hide(); //隐藏 $(&apos;#test-ul li[name=hidden]&apos;).show(); //显示&lt;/script&gt; 未来重点ajax()-springmvc小技巧js写动画和游戏源码之家：青蛙吃苍蝇，翻牌子，别猜白块，鼠标箭头(js代码的200-300行)，打砖块。看源码。 扒页面(静态网页)点代码行，从header开始删掉多余的，点delete就能删掉，如果删了页面元素没有了在ctrlz，影响网页的都是核心文件。删掉多余的之后，html第一行右键copy outerhtml ,粘贴就能. 学习js html css1.js:看jq文档，看游戏源码2.html,css:扒网站，copy下来，修改看效果3.前端：提升眼界(别人做的页面组件)，怎么实现的代码","categories":[],"tags":[]},{"title":"javaSE阶段","slug":"javaSE阶段","date":"2020-09-14T09:16:31.000Z","updated":"2020-09-14T09:24:18.488Z","comments":true,"path":"2020/09/14/javaSE阶段/","link":"","permalink":"https://lucifinil-x.github.io/2020/09/14/javaSE阶段/","excerpt":"狂神视频：2小时java所有基础有集合io流线程网络编程GUI注解和反射网络编程IP端口Socket编程","text":"狂神视频：2小时java所有基础有集合io流线程网络编程GUI注解和反射网络编程IP端口Socket编程 TCP面向连接三次握手，四次挥手 UDP无连接以包发送 URL聊天通信文件上传下载","categories":[],"tags":[]},{"title":"python基础学习","slug":"python基础学习","date":"2020-09-08T03:41:33.000Z","updated":"2021-01-02T18:40:10.308Z","comments":true,"path":"2020/09/08/python基础学习/","link":"","permalink":"https://lucifinil-x.github.io/2020/09/08/python基础学习/","excerpt":"https://www.runoob.com/python3/python3-tutorial.html","text":"https://www.runoob.com/python3/python3-tutorial.html python优缺点 优点：免费开源，面向对象，可扩展性(py中使用c语言程序)，库多编译型语言(c) c语言程序-编译器整体编译成可执行二进制文件-计算机执行 解释型语言(py,js) py程序-py解释器 逐行翻译逐行解释，解析好的二进制-计算机执行 缺点：执行效率低 基础函数1.input() 接收键盘输入 1password = input(&quot;输入密码：&quot;) 2.占位符格式化输出 12name = input(&quot;输入名字：&quot;)print(&quot;姓名：%s&quot; %name) 3.eval(str1)提取字符串中的数字4.len(str1)字符串长度 循环和ifif语句12345if 90 &lt;= score &lt;= 100:elif (score &gt;=0 and score &lt; 60) or (score &gt;=0 and score &gt; 80):else: 三目运算true 就是前面的代码，false就是后面的代码 1max_num = smallnum if smallnum &gt; bignum else bignum 基本数据类型Python3 的六个标准数据类型中： 不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）；可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合）。 Number数字Python3 支持 int、float、bool、complex（复数）。 字符串索引https://www.runoob.com/python3/python3-string.htmlstr[a:b] str[a]到str[b-1] Python中的字符串有两种索引方式，从左往右以0开始，从右往左以-1开始：str[2:-1] str[2]到 str[-1]前一位 请记住： t=[‘a’,’b’,’c’,’d’,’e’]正索引： 0 1 2 3 4倒索引： -5 -4 -3 -2 -1Python 没有单独的字符类型，一个字符就是长度为1的字符串 Python中的字符串不能改变。 1234567891011121314str = &apos;Runoob&apos;print (str) # 输出字符串print (str[0:-1]) # 输出第一个到倒数第二个的所有字符print (str[0]) # 输出字符串第一个字符print (str[2:5]) # 输出从第三个开始到第五个的字符print (str[:2]) # 不指定开始下标，默认从0开始print (str[2:]) # 输出从第三个开始的后的所有字符， 结束下标不指定，默认取到最后一个print (str[-1:-3:-1])# 从右往左取值，步长应该为负数print (str[::-1]) # 翻转字符串，从右往左取值 print (str[:]) # 从左开始取完整字符串print (str * 2) # 输出字符串两次，也可以写成 print (2 * str)print (str + &quot;TEST&quot;) # 连接字符串 字符串格式化-处理字符串中的动态数据123print (&quot;我叫 %s 今年 %d 岁!&quot; % (&apos;小明&apos;, 10))我叫 小明 今年 10 岁! f-string-处理字符串中的动态数据f” “ 字符串中用{}绑定动态数据 1intro = f&apos;我叫&#123;name&#125;&apos; 字符串常见操作函数1.find 获取字符串中该数据对应的下标，找不到返回-12.index 获取字符串中该数据对应的下标，找不到程序崩溃3.count 统计数据在字符串中出现的次数4.replace 对字符串中的数据进行替换，返回新的字符串5.split 根据指定数据对字符串进行分割，返回list6.join 返回拼接字符串,必须全是字符串才能用join进行拼接7.startwith(‘’) 判断字符串是否以某字符串开头8.endwith(‘’) 判断字符串是否以某字符串结尾9.partition(‘’) 从左开始以某字符串进行分割成几个部分。包含分割符自身。10.strip() (‘’) 取出两边空白字符(空格 \\n \\t)11.eval(‘’) 提取字符串中的数字12.len(‘’) 求字符串长度 1.index = mystr.find(‘h’,0,3) 要找的，开始下标，结束下标(不包含)2.index = mystr.index(‘h’,0,3)3.count = mystr.count(‘l’) 也可以加范围4.newstr = mystr.replace(‘l’,’w’,3) 目标，替换为，替换次数(不写次数默认全部替换)5.mystr = “香蕉、苹果、葡萄”result = mystr.split(“、”,1) 分隔符，分割次数(默认全部分割)6. 12345mystr2 = &quot;abcd&quot;result = &quot;_ &quot;.join(mystr2) //a_b_c_dmylist = [&apos;adda&apos;,&apos;adsd&apos;,&apos;s&apos;]re = &apos;$&apos;.join(mylist) # adda$adsd$s listlist特性1、List写在方括号之间，元素用逗号隔开,存储任意类型的数据。[x,y,z]2、和字符串一样，list可以被索引和切片。3、List可以使用+操作符进行拼接。4、List中的元素是可以改变的。5、使用切片list[2:] 12345678910list = [ &apos;abcd&apos;, 786 , 2.23, &apos;runoob&apos;, 70.2 ]tinylist = [123, &apos;runoob&apos;]print (list) # 输出完整列表print (list[0]) # 输出列表第一个元素print (list[1:3]) # 从第二个开始输出到第三个元素print (list[2:]) # 输出从第三个元素开始的所有元素print (tinylist * 2) # 输出两次列表print (list + tinylist) # 连接列表 123456a = [1, 2, 3, 4, 5, 6]a[0] = 9a[2:5] = [13, 14, 15]print(a) # [9, 2, 13, 14, 15, 6]a[2:5] = []print(a) # [9, 2, 6] 翻转字符串输出结果为：runoob like I 1234567891011121314151617181920212223def reverseWords(input): # 通过空格将字符串分隔符，把各个单词分隔为列表 inputWords = input.split(&quot; &quot;) # 翻转字符串 # 假设列表 list = [1,2,3,4], # list[0]=1, list[1]=2 ，而 -1 表示最后一个元素 list[-1]=4 ( 与 list[3]=4 一样) # inputWords[-1::-1] 有三个参数 # 第一个参数 -1 表示最后一个元素 # 第二个参数为空，表示移动到列表末尾 # 第三个参数为步长，-1 表示逆向 inputWords=inputWords[-1::-1] # 重新组合字符串 output = &apos; &apos;.join(inputWords) return output if __name__ == &quot;__main__&quot;: input = &apos;I like runoob&apos; rw = reverseWords(input) print(rw) 循环取值1.for循环 12for i in namelist: print(i) 2.while循环 1234len = len(namelist)while i&lt;len: print(namelist[i]) i+=1 同时遍历两个list 1.ziplist1 = [‘name’, ‘age’, ‘job’]list2 = [‘jim’, 35, ‘test_coder’]for i, j in zip(list1, list2): print(i, j) name jimage 35 job test_coder 2.用i12345for i in range(len(all_files)): file_name = file_names[i] one_file = all_files[i] # 进程池.apply_async(进程任务,args=(文件名,文件绝对路径,旧文件夹名，新文件夹名)) pool.apply_async(copy_file, args=(file_name,one_file,old_folder_name,new_folder_name)) 对列表修改的操作 添加数据 1.a.append(b) a末尾添加b2.a.extend(b) a末尾逐一添加b中的所有元素 3.a.insert( , ) (插入下标，插入元素) 修改数据 1.a[i] = b 单个数据修改 2.a[:2] = [‘xx’,’yy’] 切片修改 删除数据 1.del a[0] 直接删除下标的数据2.value = a.pop(0) 删除并返回删除的下标的数据 a.pop() 默认删除最后一个数据 3.a.remove(‘值’) 删列表中的数据，不存在就报错 查找数据 1.in result = ‘xx’ in a 判断数据是否在列表中，返回true/false2.not in3.result = a.index(‘xx’,0,2) (数据，开始下标，结束下标)查找’xx’对应的下标 4.result = a.count(‘xx’) 统计数据出现的次数 排序 1.a.sort() 从小到大排序，会改变a，无返回值2.a.reverse() 翻转顺序，会改变a3.a.sort(reverse=True) 排序之后再翻转=1+2=从大到小排序 列表嵌套list = [ [‘aa’,’bb’], [‘cc’, ‘dd’] ] 1.取值list1 = list[0]list2 = list[1]bb = list[0][1] 像二维数组一样 2.添加值list[1].append(‘ee’) 取出一维列表后用函数添加值 tuple元组元组的特性元组（tuple）与列表类似，不同之处在于元组的元素不能修改。元组写在小括号 () 里，元素之间用逗号隔开。 元组中的元素类型也可以不相同： 12345678910tup1 = () # 空元组tuple = ( &apos;abcd&apos;, 786 , 2.23, &apos;runoob&apos;, 70.2 , [1,2,3,4] )tinytuple = (123, &apos;runoob&apos;)print (tuple) # 输出完整元组print (tuple[0]) # 输出元组的第一个元素print (tuple[1:3]) # 输出从第二个元素开始到第三个元素print (tuple[2:]) # 输出从第三个元素开始的所有元素print (tinytuple * 2) # 输出两次元组print (tuple + tinytuple) # 连接元组 元组与字符串类似，可以被索引且下标索引从0开始，-1 为从末尾开始的位置。也可以进行截取 其实，可以把字符串看作一种特殊的元组。 注意：如果元组里只有一个数据需要加, mytuple = (“李四”,) 如果不加, 那么mytuple的类型就是str字符串 mytuple = (“李四”) 应用场景1.字符串的格式化输出使用元组print(‘姓名：%s 年龄：%d’ % (name,age))2.函数的返回值，使用元组返回多个数据 元组的遍历1.for循环for name in nametuple:2.while循环 12345index = 0len = nametuple.__len__()while index&lt;len: print(nametuple[index]) index += 1 count和index1.re = tuple1.count(1)2.re2 = tuple1.index(‘1’) 截取python对字符串，list,元组可以进行截取xx[1:5] 对xx截取 索引1到5，含左不含右。 1234567str = &apos;abcdef&apos;list = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;,&apos;f&apos;]tu = (&apos;a&apos;,1,list,&apos;str&apos;,&apos;d&apos;,&apos;e&apos;) # 虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表。print(str[1:5]) # bcdeprint(list[1:5]) # [&apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]print(tu[1:5]) # (1, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;], &apos;str&apos;, &apos;d&apos;) 集合集合（set）是由一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员。 基本功能是进行成员关系测试和删除重复元素(print时会自动删除重复元素)。 可以使用大括号 { } 或者 set() 函数创建集合，注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。 123456789101112131415161718192021222324sites = &#123;&apos;Google&apos;, &apos;Taobao&apos;, &apos;Runoob&apos;, &apos;Facebook&apos;, &apos;Zhihu&apos;, &apos;Baidu&apos;, &apos;Baidu&apos;&#125;print(sites) # 输出集合，重复的元素被自动去掉# 成员测试if &apos;Runoob&apos; in sites : print(&apos;Runoob 在集合中&apos;)else : print(&apos;Runoob 不在集合中&apos;)# set可以进行集合运算a = set(&apos;abracadabra&apos;)b = set(&apos;alacazam&apos;)print(a)print(a - b) # a 和 b 的差集print(a | b) # a 和 b 的并集print(a &amp; b) # a 和 b 的交集print(a ^ b) # a 和 b 中不同时存在的元素 dictionary字典特点，初始化，赋值字典（dictionary）是Python中另一个非常有用的内置数据类型。 列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。 字典是一种映射类型，字典用 { } 标识，它是一个无序的 键(key) : 值(value) 的集合。 键(key)必须使用不可变类型。 在同一个字典中，键(key)必须是唯一的 1、字典是一种映射类型，它的元素是键值对。2、字典的关键字必须为不可变类型，且不能重复。3、创建空字典使用 { }。4、字典可以修改 1234567891011121314dict = &#123;&#125; # 空字典&#123;&#125;dict[&apos;one&apos;] = &quot;1 - 菜鸟教程&quot; #&apos;one&apos;作为键dict[2] = &quot;2 - 菜鸟工具&quot; # int 2 作为键tinydict = &#123;&apos;name&apos;: &apos;runoob&apos;, &apos;code&apos;:1, &apos;site&apos;: &apos;www.runoob.com&apos;&#125;print (dict[&apos;one&apos;]) # 输出键为 &apos;one&apos; 的值print (dict[2]) # 输出键为 2 的值print (tinydict) # 输出完整的字典print (tinydict.keys()) # 输出所有键print (tinydict.values()) # 输出所有值 dict()字典构造函数:1.dict([(),(),()])2.dict(k1=v1,k2=v2,k3=v3) 123456789# dict()字典构造函数testDic = dict([(&apos;Runoob&apos;, 1), (&apos;Google&apos;, 2), (&apos;Taobao&apos;, 3)])# &#123;&apos;Runoob&apos;: 1, &apos;Google&apos;: 2, &apos;Taobao&apos;: 3&#125;testDic2 = &#123;x: x**2 for x in (2, 4, 6)&#125;testDic2 = &#123;x: x**2 for x in[2,4,6]&#125;# &#123;2: 4, 4: 16, 6: 36&#125; x**2是x的2次幂testDic3 = dict(Runoob=1, Google=2, Taobao=3)# &#123;&apos;Runoob&apos;: 1, &apos;Google&apos;: 2, &apos;Taobao&apos;: 3&#125;print(testDic,testDic2,testDic3) 所以现在初始化字典的方式1.创建空字典+赋值: dic1 = {} dic1[k1] = v1 dic[k2] = v22.创建键值对字典: dic2 = {k1:v1, k2:v2}3.dict()字典构造函数: 3.1. dict([(k1,v1), (k2,v2), (k3,v3)]) 3.2. dict(k1=v1,k2=v2,k3=v3) 字典取值1.用[key]取值 12dic1 = &#123;&apos;name&apos;: &apos;李四&apos;, &apos;age&apos;:30&#125;name = dic1[&apos;name&apos;] 2.用get方法取值 1age=dic1.get(&apos;age&apos;) get取值如果不存在key还可以设置默认值,但字典中数据不会变化 1tel = dic1.get(&apos;tel&apos;,&apos;2333&apos;) 字典添加/修改数据1.根据key修改,key存在是修改，key不存在是添加 12dic1[&apos;age&apos;] = 40dic1[&apos;ssd&apos;] = &apos;dwidj&apos; 2.update 吧dic2中的数据逐一添加到dic1中dic1.update(dic2) 字典删除数据1.del 根据key删除 1del dic1[&apos;age&apos;] 2.pop 根据key删除，并返回删除的数据;如果dic2中有dic1中的key则更新 1value = dic1.pop(&apos;age&apos;) 3.clear() 全部清空 1dic1.clear() 常见获取操作1.获取键值对的个数 123dic3 = &#123;&apos;name&apos;:&apos;貂蝉&apos;, &apos;age&apos;:20, &apos;sex&apos;:&apos;女&apos;&#125;len = len(dic3)len = dic3.__len__() 2.获取字典中的所有key 1keys = dic3.keys() # dict_keys([&apos;name&apos;, &apos;age&apos;, &apos;sex&apos;]) &lt;class &apos;dict_keys&apos;&gt; 3.获取字典中的所有value 1values = dic3.values() # dict_values([&apos;貂蝉&apos;, 20, &apos;女&apos;]) 4.获取字典中的所有item(每项数据)字典每项数据是一个元组，元组第一个值是key，第二个值是value 1items = dic3.items() # dict_items([(&apos;name&apos;, &apos;貂蝉&apos;), (&apos;age&apos;, 20), (&apos;sex&apos;, &apos;女&apos;)]) 字典遍历1.遍历key 123dic3 = &#123;&apos;name&apos;:&apos;貂蝉&apos;, &apos;age&apos;:20, &apos;sex&apos;:&apos;女&apos;&#125;for key in dic3.keys(): print(key,&quot;key对应的值&quot;,dic3[key]) 2.遍历value 12for value in dic3.values(): print(value) 3.遍历item字典每项数据是一个元组 12for item in dic3.items(): print(item) 4.遍历key和valuek,v对应着字典中的键，值 这是py中的拆包.kv直接拿到字符串/值 12for k,v in dic3.items(): print(k,v) enumerate函数使用 list/字符串/字典-结合for循环使用又能拿下标又能拿数字 在for循环遍历容器类型的数据时候，既要下标又要数据。拿到的就是下标+数值的元组了 123namelist = [&apos;曹操&apos;,&apos;刘备&apos;,&apos;孙淑&apos;]for value in enumerate(namelist): print(value) # (0, &apos;曹操&apos;)拿到的是元组 下标和名字拆包 123456for index , value in enumerate(namelist): num = index +1 print(index,value,f&quot;当前是&#123;num&#125;项数据&quot;)# 0 曹操 当前是1项数据1 刘备 当前是2项数据2 孙淑 当前是3项数据 python数据类型之间的转化函数int(x [,base]) 将x转换为一个整数 eval(str1)提取字符串中的数字 float(x) 将x转换到一个浮点数 complex(real [,imag]) 创建一个复数 str(x) 将对象 x 转换为字符串 repr(x) 将对象 x 转换为表达式字符串 eval(str) 用来计算在字符串中的有效Python表达式,并返回一个对象 tuple(s) 将序列 s 转换为一个元组 list(s) 将序列 s 转换为一个列表 set(s) 转换为可变集合 dict(d) 创建一个字典。d 必须是一个 (key, value)元组序列。 frozenset(s) 转换为不可变集合 chr(x) 将一个整数转换为一个字符 ord(x) 将一个字符转换为它的整数值 hex(x) 将一个整数转换为一个十六进制字符串 oct(x) 将一个整数转换为一个八进制字符串 取值用下标取值： 字符串，列表，元组用key取值： 字典 切片切片是用下标范围对操作的对象截取其中一部分的操作切片支持：字符串，列表，元组语法：[开始下标：结束下标：步长] 包含开始下标，不包含结束下标，步长不指定默认为1 例子：字符串中 先看步长，步长决定从哪边开始取值。步长为正从左到右，步长为负数，从右到左。 运算python位运算a = 0011 1100 b = 0000 1101 a&amp;b = 0000 1100 a|b = 0011 1101 a^b = 0011 0001 ab相同是0,B不同是1 ~ a = 1100 0011 成员运算符 in/ not in 是否属于in如果在指定的序列中找到值返回 True，否则返回 False。 x 在 y 序列中 , 如果 x 在 y 序列中返回 True。 not in如果在指定的序列中没有找到值返回 True，否则返回 False。 x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。 1234567a = 2list = [1, 2, 3, 4, 5 ];if ( a in list ): print (&quot;3 - 变量 a 在给定的列表中 list 中&quot;)elif (a not in list): print (&quot;3 - 变量 a 不在给定的列表中 list 中&quot;) 身份运算符 is/ is not 是否引用同一对象isis 是判断两个标识符是不是引用自一个对象 x is y, 类似 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 False is not is not 是判断两个标识符是不是引用自不同对象 x is not y ， 类似 id(a) != id(b)。如果引用的不是同一个对象则返回结果 True，否则返回 False。is 与 == 区别： is 用于判断两个变量引用对象是否为同一个，== 用于判断引用变量的值是否相等。 函数print函数print(“面积是%d” % value) //面积是12print(“面积是”,value) //面积是 12 py里不能像java用+链接变量，会报错，比如：print(“面积是”+value) 自定义函数1.空参函数 12def hello(): print(&quot;hello&quot;) 2.普通带参数函数调用+函数返回值 1234def area(width,height): return width*heightvalue = area(3,4) 3.普通带参数函数调用 12345678def changelist(mylist): list = [1,2,3,&quot;hello&quot;] # mylist.append(list) mylist.extend(list) print(mylist)list = [10,20,30]changelist(list) 4.函数参数不需要对应位置，只需要 参数=值 12345def printinfo(name,age): print(&quot;年龄 &quot;,age) print(&quot;名字&quot;,name)printinfo(age=[1,2,3,4], name=&apos;shi&apos;) 5.* vartuple可以接收不定长的参数，他是一个元组，参数以元组形式传入，arg1是对应的第一个参数 1234567891011121314151617def print1(arg1, *vartuple): print(&quot;输出&quot;) print(arg1) print(&quot;输出&quot;) for var in vartuple: print(var) returnprint1(1,2,3,4,3)//输出1输出2343 6.* * vartuple可以接收不定长的参数，参数以字典形式传入， 12345678910111213def print1(arg1, **vartuple): print(&quot;输出&quot;) print(arg1) print(&quot;输出&quot;) print(vartuple) returnprint1(1,a=2,b=3,c=4,d=3)输出1输出&#123;&apos;a&apos;: 2, &apos;b&apos;: 3, &apos;c&apos;: 4, &apos;d&apos;: 3&#125; 单独出现，* 之后的参数c必须用关键字传入 c=值,d=值1234def print2(a,b,*,c,d): print(a+b+c+d)print2(1,2,c=3,d=4) //10 文件操作文件操作模式字符串相关：r 以只读方式打开文件。以字符串方式读取文件中的数据w 以字符串方式写入数据到文件。打开一个文件只用于写入。(w不会保存之前的数据，打开就会覆盖，只保存新数据)如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 a 打开一个文件用于追加。字节/二进制相关：rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。wb 以二进制格式打开一个文件只用于写入。ab 以二进制格式打开一个文件用于追加。 全部：t 文本模式 (默认)。x 写模式，新建一个文件，如果该文件已存在则会报错。b 二进制模式。 打开一个文件进行更新(可读可写)。U 通用换行模式（不推荐）。r 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。r+ 打开一个文件用于读写。文件指针将会放在文件的开头。rb+ 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。w 打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。wb 以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。w+ 打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。wb+ 以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。ab 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。ab+ 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。 文件的读写模式字符串文件操作步奏 读 r注意：r模式打开文件，一定保证文件存在 12345678#1.打开文件指定文件操作模式,默认是r.file = open(&quot;a.txt&quot;,&quot;r&quot;,encoding=&apos;utf-8&apos;)print(file.encoding)#2.读取文件中的所有数据content = file.read()print(content)#3.关闭文件file.close() 写 w注意：文件存在会清空文件中数据再写入 123456#打开file = open(&quot;b.txt&quot;,&apos;w&apos;,encoding=&quot;utf-8&quot;)#写入file.write(&quot;hahah&quot;)#关闭file.close() 追加 a 123file = open(&quot;b.txt&quot;,&apos;a&apos;,encoding=&apos;utf-8&apos;)file.write(&quot;dnndk&quot;)file.close() 二进制文件读写操作(网络传输数据只能传输二进制数据) 读二进制 rb带b的open()不指定编码格式，只在解码时候指定。但是对我们来说解码操作不是必须的，因为我们读到了字节数据，将字节数据交给socket,socket通过网络就能把数据给对方了，我们不需要解码！ 123456789file = open(&quot;a.txt&quot;,&apos;rb&apos;)data = file.read()print(data)print(type(data))#decode对二进制数据解码转换成字符串data.decode(&quot;utf-8&quot;)print(data)print(type(data))file.close() 接收网络传输过来的数据，把接收的二进制数据写入文件 wb 12345678file = open(&quot;c.txt&quot;,&apos;wb&apos;)#要把字符串进行编码，转换成二进制数据，才能写入文件content = &quot;hello&quot;data = content.encode(&quot;utf-8&quot;)print(data,type(data))file.write(data)file.close() 追加二进制数据 ab 123456file = open(&quot;c.txt&quot;,&apos;ab&apos;)content = &quot;python&quot;# 字符串转换成二进制数据data = content.encode(&quot;utf-8&quot;)file.write(data)file.close() 1.open()完整的语法格式为：open(file, mode=’r’, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None) 参数说明: file: 必需，文件路径（相对或者绝对路径）。mode: 可选，文件打开模式buffering: 设置缓冲encoding: 指定文件编码格式，默认是读取的cp936(gbk),一般指定使用utf-88errors: 报错级别newline: 区分换行符closefd: 传入的file参数类型opener: 文件方法及描述1file.close() 关闭文件。关闭后文件不能再进行读写操作。 2file.flush() 刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入。 3file.fileno() 返回一个整型的文件描述符(file descriptor FD 整型), 可以用在如os模块的read方法等一些底层操作上。 4file.isatty() 如果文件连接到一个终端设备返回 True，否则返回 False。 5file.next() 返回文件下一行。 6file.read([size]) 从文件读取指定的字节数，如果未给定或为负则读取所有。 12345678910# read(5) r-5个字符串 rb-5个字节file = open(&quot;b.txt&quot;,&apos;r&apos;,encoding=&quot;utf-8&quot;)while True: con = file.read(5) if(con.__len__()&gt;0): print(con) else: print(&quot;读完了&quot;) breakprint(con) 7file.readline([size]) 读取整行，包括 “\\n” 字符。 123456file = open(&quot;b.txt&quot;,&apos;r&apos;,encoding=&quot;utf-8&quot;)line = file.readline()while line.__len__()&gt;0: print(line) line = file.readline()file.close() 8file.readlines([sizeint]) 读取所有行并返回列表，若给定sizeint&gt;0，则是设置一次读多少字节，这是为了减轻读取压力。 123456# 既然是列表，就可以用切片 lines[-1:]file = open(&quot;b.txt&quot;,&apos;r&apos;,encoding=&quot;utf-8&quot;)lines = file.readlines()for line in lines: print(line,lines)file.close() 9file.seek(offset[, whence]) 设置文件当前位置 10file.tell() 返回文件当前位置。 11file.truncate([size]) 截取文件，截取的字节通过size指定，默认为当前文件位置。 12file.write(str) 将字符串写入文件，返回的是写入的字符长度。 13file.writelines(sequence) 向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符。 TCP协议通讯 三次握手，四次挥手(传输层TCP/网络层IP协议) TCP/IP协议是传输层的一个面向连接的安全可靠的一个传输协议，三次握手的机制是为了保证能建立一个安全可靠的连接。那么第一次握手是由客户端发起，客户端会向服务端发送一个报文，在报文里面：SYN标志位置为1，表示发起新的连接。当服务端收到这个报文之后就知道客户端要和我建立一个新的连接，于是服务端就向客户端发送一个确认消息包，在这个消息包里面：ack标志位置为1，表示确认客户端发起的第一次连接请求。以上两次握手之后，对于客户端而言：已经明确了我既能给服务端成功发消息，也能成功收到服务端的响应。但是对于服务端而言：两次握手是不够的，因为到目前为止，服务端只知道一件事，客户端发给我的消息我能收到，但是我响应给客户端的消息，客户端能不能收到我是不知道的。所以，还需要进行第三次握手，第三次握手就是当客户端收到服务端发送的确认响应报文之后，还要继续去给服务端进行回应，也是一个ack标志位置1的确认消息。通过以上三次连接，不管是客户端还是服务端，都知道我既能给对方发送消息，也能收到对方的响应。那么，这个连接就被安全的建了。 服务端 123456789101112131415161718192021222324from socket import *#服务端# IP PORT 是服务端的ip,端口号 与客户端接口保持一致IP = &apos;127.0.0.1&apos;PORT = 50000# 定义一次从socket缓冲区读入512个字节数据BUFLEN = 512# 实例化(初始化) 服务器的socket 对象# AF_INET 网络层使用IP协议；SOCK_STREAM传输层使用TCP协议listenSocket = socket(AF_INET,SOCK_STREAM)# socket服务器地址和端口listenSocket.bind((IP,PORT))# 开启监听状态，等待客户端发起连接请求 参数5表示最多接收多少个等待连接的客户端listenSocket.listen(5)print(f&quot;服务器启动成功，在&#123;PORT&#125;端口等待客户端连接。。&quot;)# 第二次握手：服务器接收到客户端发起连接请求(报文)。# 于是服务端就向客户端发送一个确认消息包，在这个消息包里面：ack标志位置为1，表示确认客户端发起的第一次连接请求。# accept()返回元组，包含两个元素:一个用来传输数据的socket用来接收和发送信息, 一个包含客户端的地址和端口号 dataSocket, addr = listenSocket.accept()print(&quot;接受一个客户端的连接，地址是：&quot;, addr) 客户端 12345678910111213141516171819#客户端from socket import *# IP PORT 是服务端的ip,端口号 与客户端接口保持一致IP = &apos;127.0.0.1&apos;SERVER_PORT = 50000# 定义一次从socket缓冲区读入512个字节数据BUFLEN = 512# 实例化(初始化) 客户端的socket 对象# AF_INET 网络层使用IP协议；SOCK_STREAM传输层使用TCP协议dataSocket = socket(AF_INET,SOCK_STREAM)# 连接服务器的socket的地址和端口# 连接开始TCP三次握手# connect 第一次握手：向服务端发送三次握手的第一个报文。(操作系统底层的协议栈发送过来的)在报文里面：SYN标志位置为1，表示发起新的连接。dataSocket.connect((IP,SERVER_PORT ))# 第三次握手：客户端收到服务端发送的确认响应报文之后，还要继续去给服务端进行回应，也是一个ack标志位置1的确认消息。 b站socket 文件传输一定是先开服务端再开客户端，不然 s.connect((host,port))ConnectionRefusedError: [WinError 10061] 由于目标计算机积极拒绝，无法连接。服务端和客户端的ip,port都要一致，不然 s.connect((host,port))ConnectionRefusedError: [WinError 10061] 由于目标计算机积极拒绝，无法连接。 客户端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import socketimport tqdmimport os# 通用模块：os, sys, socket, struct, hashlib, math, tqdm, numpy# 传输数据分隔符# 它是面向连接的，每次服务端都会请求，每次客户端都会响应的过程。# 一次可以传输多个数据，用分隔符分开，这样减少连接次数(节约时间)# 在服务端根据分隔符解析出每个数据，这样一次连接传一次就能传多个数据SEPARATOR = &quot;&lt;SEPARATOR&gt;&quot;# 服务器信息host = &apos;192.168.56.1&apos; # host就是ipport= 50000 # 可使用20000到30000之间的任何端口；# 文件传输的缓冲区# 我们不是一个字节一个字节传输的，我们是吧字节放在缓冲区里面再传，这样提高速度BUFFER_SIZE = 4096# 传输文件名字 (这里是直接定死的 不用再后台输入，cw里不是)filename = &quot;D:/大三上学期/CAN201 网络/Projects作业1/文件传输测试/客户端/testfile.pptx&quot;# 文件大小，进度条显示传输file_size = os.path.getsize(filename)# 创建socket s 连接 04.31s = socket.socket()# 连接服务器print(f&quot;服务器连接中&#123;host&#125;:&#123;port&#125;&quot;)# connect里面一定是把用括号当一个参数的s.connect((host,port))print(&quot;与服务器连接成功！&quot;)# 先发送文件名字和文件大小，必须进行编码处理 encode() 到utf-8 告诉服务器我要穿一个文件名字 大小s.send(f&quot;&#123;filename&#125;&#123;SEPARATOR&#125;&#123;file_size&#125;&quot;.encode())# 然后再文件传输# 进度条progress(文件大小，提示发送的文件名字， 进度单位Byte , 单位换算 1024bit =byte )progress = tqdm.tqdm(range(file_size), f&quot;发送&#123;filename&#125;&quot;, unit=&quot;B&quot;,unit_divisor=1024)# rb方式(以二进制格式打开一个文件用于只读)打开文件，# _表示要用循环不用变量,读取文件;withopen会自动关闭不用显示关闭with open(filename, &quot;rb&quot;) as f: for _ in progress: # 每次读取缓冲那么多的 读到bytes_read bytes_read = f.readline(BUFFER_SIZE) # 如果bytes_read是空的，就没有读取(读完了)，就结束了 if not bytes_read: break # socket的sendall方法可以确保及时网络忙碌的时候，数据仍然可以传输 s.sendall(bytes_read) # 按照每次读取的bytes_read 更新进度条 progress.update(len(bytes_read))# 关闭资源;withopen会自动关闭不用显示关闭s.close() 服务端12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import socketimport tqdmimport os# 设置服务器的ip和端口SERVER_HOST = &apos;192.168.56.1&apos; # host就是ipSERVER_PORT= 50000 # 可使用20000到30000之间的任何端口；# 设置文件读写的缓冲区BUFFER_SIZE = 4096SEPARATOR = &quot;&lt;SEPARATOR&gt;&quot;# 创建server的sockets = socket.socket()# socket绑定ip和端口s.bind((SERVER_HOST, SERVER_PORT))# 设置连接 监听 数量s.listen(5)print(f&quot;服务器端监听&#123;SERVER_HOST&#125;:&#123;SERVER_PORT&#125;&quot;)# 服务器socket接受客户端连接,返回的是客户端的socket和地址client_socket, address = s.accept()# 打印客户端的Ipprint(f&quot;客户端ip&#123;address&#125;连接&quot;)# 接受客户端信息,用拿到的客户端的socket去接受缓冲区大小的，要解码received = client_socket.recv(BUFFER_SIZE).decode()# 客户端传过来是加了分隔符的，这里接收就用分隔符分开还原 文件名字 文件大小filename, file_size = received.split(SEPARATOR)# 客户端传递的filename可能是有加上路径的，服务端要拿到的只是纯文件名，所以只获取文件名字不要路径filename = os.path.basename(filename)# 文件大小一定是int类型file_size = int(file_size)# 文件接收处理# 进度条progress(文件大小，提示发送的文件名字， 进度单位Byte , 单位换算 1024bit =byte, 属性 )progress = tqdm.tqdm(range(file_size), f&quot;接收&#123;filename&#125;&quot;, unit=&quot;B&quot;, unit_divisor=1024,unit_scale=True)# wb写以二进制格式打开一个文件只用于写入。with open(filename, &quot;wb&quot;) as f: for _ in progress: # 从客户端读取 缓冲区大小数据byte_read byte_read = client_socket.recv(BUFFER_SIZE) # 如果没有数据传输内容，就退出 if not byte_read: break # 有数据就写入 f.write(byte_read) # 更新进度条 progress.update(len(byte_read))# 关闭资源:先关客户端，再关服务端client_socket.close()s.close() socket网络编程程序的通讯通过TCP/IP协议消息发送过程：appA - socket编程接口 - 操作系统(传输层TCP/网络层IP协议) - 通讯硬件 - 通讯硬件 - 操作系统(传输层TCP/网络层IP协议) - socket编程接口 - appB http接口底层就是用到的socket编程接口 tcp协议通讯socket编程发送网络消息，可以使用py内置的socket库。使用最多的就是tcp协议。 服务端代码1.实例化(初始化) 服务器的socket 对象2.建立连接3.不断的收和发信息4.关闭socket对象 12345678910111213141516171819202122232425262728293031323334353637383940414243444546from socket import *#服务端# IP PORT 是服务端的ip,端口号 与客户端接口保持一致IP = &apos;192.168.56.1&apos;PORT = 50000# 定义一次从socket缓冲区读入512个字节数据BUFLEN = 512# 实例化(初始化) 服务器的socket 对象# AF_INET 网络层使用IP协议；SOCK_STREAM传输层使用TCP协议listenSocket = socket(AF_INET,SOCK_STREAM)# socket服务器地址和端口listenSocket.bind((IP,PORT))# 开启监听状态，等待客户端发起连接请求 参数5表示最多接收多少个等待连接的客户端listenSocket.listen(5)print(f&quot;服务器启动成功，在&#123;PORT&#125;端口等待客户端连接。。&quot;)# 第二次握手：服务器接收到客户端发起连接请求(报文)。# 于是服务端就向客户端发送一个确认消息包，在这个消息包里面：ack标志位置为1，表示确认客户端发起的第一次连接请求。# accept()返回元组，包含两个元素:一个用来传输数据的socket用来接收和发送信息, 一个包含客户端的地址和端口号dataSocket, addr = listenSocket.accept()print(&quot;接受一个客户端的连接，地址是：&quot;, addr)# 不断的收和发while True: # 从拿到的数据socket中读取对方的信息 # 指定一次从缓冲里读取多少字节bytes received = dataSocket.recv(BUFLEN) # 判断如果返回空bytes 表示对方关闭了连接。退出循环，结束消息收发 if not received: break # 如果返回的是有数据的字节串，那么就解码为字符串(根据数据类型进行解码处理,音频，视频) info = received.decode(&quot;utf-8&quot;) print(f&apos;收到对方的信息：&#123;info&#125;&apos;) # 发送给客户端的数据必须是字节bytes,就编码,encode不带参数就是用utf-8编码 # 整个字符串编码成字节 dataSocket.send(f&apos;服务器接收到了信息&#123;info&#125;&apos;.encode())# 结束收发循环，服务端也调用close()关闭socketdataSocket.close()listenSocket.close() 客户端代码1234567891011121314151617181920212223242526272829303132333435363738394041#客户端from socket import *# IP PORT 是服务端的ip,端口号 与客户端接口保持一致IP = &apos;127.0.0.1&apos;SERVER_PORT = 50000# 定义一次从socket缓冲区读入512个字节数据BUFLEN = 512# 实例化(初始化) 客户端的socket 对象# AF_INET 网络层使用IP协议；SOCK_STREAM传输层使用TCP协议dataSocket = socket(AF_INET,SOCK_STREAM)# 连接服务器的socket的地址和端口# 连接开始TCP三次握手# connect 第一次握手：向服务端发送三次握手的第一个报文。(操作系统底层的协议栈发送过来的)在报文里面：SYN标志位置为1，表示发起新的连接。dataSocket.connect((IP,SERVER_PORT ))# 第三次握手：客户端收到服务端发送的确认响应报文之后，还要继续去给服务端进行回应，也是一个ack标志位置1的确认消息。# 收发while True: # 从终端读取用户输入信息的字符串 toSend = input(&apos;&gt;&gt;&gt; &apos;) # 以exit结束输入 if toSend == &apos;exit&apos;: break # 发送消息，编码为字节数据 # 发送也是阻塞态的 dataSocket.send(toSend.encode()) # 从socket中接收读取服务器发过来的消息 # 如果没有消息，阻塞等待是在recv()这行代码等待的 received = dataSocket.recv(BUFLEN) cont = received.decode(&quot;utf-8&quot;) # 如果返回是空bytes,表示对方关闭了连接 if not received: break print(f&apos;服务端发过来了:&#123;cont&#125;&apos;) 执行运行服务端-cmd查看 netstat -an|find /i “50000” - 运行客户端 - cmd查看 netstat -an|find /i “50000” 运行客户端之后会出现三行socket 应用消息格式-一定要有消息边界！上面的例子，我们发送的消息就是要传递的内容，字符串。实际上，企业中 开发的程序通讯，消息都有 格式定义。消息的格式定义可以归入OSI网络模型的 表示层。比如：定义的消息包括 消息头 和 消息体。消息头： 消息的长度，类型，状态消息体： 具体的传送数据 对于TCP协议传输信息的程序，格式定义一定要明确规定 消息的边界。因为TCP传输的是字节流，如果不规定长度/边界，接收方就不知道从哪开始从哪结束。 指定消息的边界有两种方式(简单模式)： 用特殊字节结尾用不可能出现的字节串，比如FFFFFF 在消息开头某个位置，直接指定消息的长度UDP协议通常不需要指定消息边界，因为UDP是数据报协议，应用程序从socket接收到的必定是发送方发送的完整消息。 发送方加边界，接收方处理消息 消息格式示例消息头消息体：json数据 from import导包导入同一文件夹下的py文件：from . import py文件名 python多线程什么是多线程同一时间，把数据分成12345段，放在不同线程里面，线程同时开启，就可以节省数据运算的时间 1.添加线程 线程创建(target=线程要做的事情,name=线程名字)+开启线程： 12345678# 线程要做的事情 写成一个函数，赋值给线程创建函数的参数targetdef thread_job(): print(&quot;this is an added thread, number of current thread is %s&quot; % threading.current_thread())def main(): # 线程创建(target=线程要做的事情)+开启线程 added_thread = threading.Thread(target=thread_job) added_thread.start() 线程函数 1.threading.active_count()计算现在被激活的线程的数量 2.threading.enumerate()返回一个包含正在运行的线程的list。 3.threading.currentThread(): 返回当前的线程变量。 2.join功能Thread类提供的方法(用Thread()创建的线程可以使用的方法)：run(): 用以表示线程活动的方法。start():启动线程活动。join([time]): 等待至此线程中止才会执行下面的语句。这阻塞调用线程直至线程的join() 方法被调用中止-正常退出或者抛出未处理的异常-或者是可选的超时发生。isAlive(): 返回线程是否活动的。getName(): 返回线程名。setName(): 设置线程名。 3.Queue功能args传参数args=(path,) 必须是() 必须加, 1234567891011121314151617181920212223t_file_scan = threading.Thread(target=get_file_job,args=(path,))# 线程任务:把share里的文件path都加到global all_filesdef get_file_job(root_path): global all_files # 上锁，如果之前没有被上锁，那么上锁成功；如果之前已经被上锁，那么此时会堵塞在这里，直到这个锁被解开，再上锁成功 mutex.acquire() get_file(root_path, all_files) # 线程任务执行完，解锁 mutex.release()# 全局变量放文件路径名字all_files = []# 递归函数，遍历该文档目录和子目录下的所有文件，获取其pathdef get_file(root_path,all_files): time.sleep(1) files = os.listdir(root_path) for file in files: if not os.path.isdir(root_path + &apos;/&apos; + file): # not a dir all_files.append(root_path + &apos;/&apos; + file) else: # is a dir get_file((root_path + &apos;/&apos; + file), all_files) 互斥锁123456789全局创建锁mutex = threading.Lock()锁住对全局变量进行修改的代码# 上锁，如果之前没有被上锁，那么上锁成功；如果之前已经被上锁，那么此时会堵塞在这里，直到这个锁被解开，再上锁成功mutex.acquire()get_file(root_path, all_files)# 线程任务执行完，解锁mutex.release() 多个互斥锁会出现问题 应用：多任务版的udp聊天器一个线程 recv一个线程 sendto一个socket 可以又收又发 python多进程程序：没有运行的exe文件进程：运行的程序程序和进程的关系：程序可以只有一个，但是可以有多个进程(开多个qq) 进程拥有系统资源，它是操作系统分配系统资源的基本单元。 进程也是实现多任务的方式。 python里面创建运行多process之后，相当于在运行这个文件的子进程。可以kill掉子进程。 进程任务=线程任务 进程.star之后就创建了子进程，执行他的进程任务。进程线程对比线程和进程都能够实现同时做多任务，区别在多进程耗费资源相当大，浪费，进程任务运行效率就越低。345678个进程效率一定比单进程效率高。浪费内存，但提高效率 和几核cpu有关系。 每个进程都要一份代码(每个进程的代码都一样，就不都复制一份了共用一份)，一份内存,一份操作系统的资源先有进程再有线程，进程是所有线程的资源总和。线程不能独立执行，必须存在在进程中。 一个进程=一个流水线一个线程=一条流水线上的工人 工人共享流水线上的资源去组装=线程共享进程的资源 多进程多线程=多条流水线上多个工人一起做 结论：多线程更多用线程共享数据-进程间通信多线程：共享全局变量 多线程：互相独立，进程间通信(socket快/文件慢 在硬盘中)队列Queue就是一块内存，来存数据。用队列可以实现进程之间的通信：A进程向队列内存中存数据，B进程向队列中取出数据。 可以放任意类型的数据import multiprocessingq = multiprocessing.Queue() 创建队列对象q.put() 存值q.get() 放值q.full() 判断是否满q.empty() 判断是否空 123456789101112import multiprocessingq = multiprocessing.Queue()q.put(&quot;111&quot;)q.put(111)q.put([11,1,22,&quot;qsqsqs&quot;])q.put(&#123;&quot;xx&quot;,11&#125;)print(q.get())print(q.get())print(q.get())print(q.get()) 在进程创建之前创建队列，把队列的引用作为实参传给通信的进程队列只能在同一台电脑中的不同进程之间通信，redis对于分布式(很多电脑运行同一程序)， 一台电脑向redis里写入数据，另外一台电脑得到redis中的数据【高亮】winerror5拒绝访问-queue.put() 原因：报错是因为新建项目的时候选择了自带有一个venv的python3.7,删掉它的项目无法运行。import 也会出错 解决办法：新建项目的时候选择已经exist的python3.7再创建 运行必须是：D:\\Python3.7.2\\python.exe D:/PyCharm2019/python学习project2/多进程/进程通信2.py进程池进程池，重复利用里面的进程。想要实现多任务，进程不见得越多越好。池子里指定最大进程数量。程序的创建和销毁会花大量资源。(要减少这个次数，为了提高效率)进程池就是这个目的，不需要创建新的进程用原来的进程完成多任务。进程数量不确定用进程池。要用进程再创建。 进程池创建1234567891011121314151617181920212223242526272829from multiprocessing import Process, Queue, Poolimport os,time,randomdef woker(msg): print(&quot;jinru&quot;) t_start = time.time() print(&quot;%s开始执行,进程号为&quot; % (msg)) # 随机生成0-1之间浮点数 time.sleep(random.random()*2) t_stop = time.time() print(msg, &quot;执行完毕，耗时%0.2f&quot; % (t_stop-t_start))def main(): po = Pool(3) # 定义一个进程池，最大进程数3 # 进程池内3个进程调用目标， for i in range(0, 10): # 进程池.apply_async(进程任务,(传递给目标的参数元组,)) # 每次循环会用空闲出来的子进程去调用目标 po.apply_async(woker, (i,)) print(&quot;--start--&quot;) # 关池子之后不再接受新的请求 po.close() # 等待池子中所有子进程执行完，必须在close之后 po.join() print(&quot;--end--&quot;)if __name__ == &apos;__main__&apos;: main() 进程任务如果进程池任务出问题不会报错 json文件json类型 k:v类型 1.一个k对一个vdistance.json 123&#123;&quot;u&quot;: 2,&quot;w&quot;: 3 &#125; 2.一个k对多个v,用[]把对应的所有value包括起来ip.json 123&#123;&quot;x&quot;: [&quot;127.0.0.1&quot;, 10003], &quot;u&quot;: [&quot;127.0.0.1&quot;, 10000], &quot;w&quot;: [&quot;127.0.0.1&quot;, 10002]&#125; ###json模块函数dumps ： 把数据类型转换成字符串dump ： 把数据类型转换成字符串并存储在文件中loads ： 把字符串转换成数据类型load ： 把文件打开从字符串转换成数据类型 加载josn文件1.load:把文件打开，并把文件中的字符串变换为数据类型 12345678910111213import jsondef read_file(file_path): with open(file_path, &apos;r&apos;) as load_f: load_dict = json.load(load_f) print(load_dict) print(type(load_dict))def main(): read_file(&quot;w_distance.json&quot;)if __name__ == &apos;__main__&apos;: main() 写入json文件1.dumps：将python中的 字典 转换为 字符串 123456789import jsontest_dict = &#123;&apos;bigberg&apos;: [7600, &#123;1: [[&apos;iPhone&apos;, 6300], [&apos;Bike&apos;, 800], [&apos;shirt&apos;, 300]]&#125;]&#125;print(test_dict)print(type(test_dict))# dumps 将数据转换成字符串json_str = json.dumps(test_dict)print(json_str)print(type(json_str)) 2.dump: 将数据类型写入json文件中(字典不用先转成json字符串，直接就可以写入文件) 123with open(&quot;../config/record.json&quot;,&quot;w&quot;) as f: json.dump(new_dict,f) print(&quot;加载入文件完成...&quot;) 3.我用的 1234567891011121314151617181920import jsondef write_file(file_path): test_dict = &#123;&apos;bigberg&apos;: [7600, &#123;1: [[&apos;iPhone&apos;, 6300], [&apos;Bike&apos;, 800], [&apos;shirt&apos;, 300]]&#125;] &#125; print(test_dict) print(type(test_dict)) # dumps 将数据转换成字符串 json_str = json.dumps(test_dict) print(json_str) print(type(json_str)) # dump ： 把数据类型转换成字符串并存储在文件中 with open(file_path, &quot;w&quot;) as f: json.dump(test_dict, f) print(&quot;+ 写入json文件完成...&quot;)def main(): write_file(&quot;test_output.json&quot;)if __name__ == &apos;__main__&apos;: main()","categories":[],"tags":[]},{"title":"CPT205 计算机图形学","slug":"CPT205-计算机图形学","date":"2020-09-07T03:11:08.000Z","updated":"2020-12-06T19:21:18.527Z","comments":true,"path":"2020/09/07/CPT205-计算机图形学/","link":"","permalink":"https://lucifinil-x.github.io/2020/09/07/CPT205-计算机图形学/","excerpt":"CPT205 计算机图形学 CW x2 + CW = 15分x2 + 70分4-8/9-13/13,14","text":"CPT205 计算机图形学 CW x2 + CW = 15分x2 + 70分4-8/9-13/13,14 handbook本课程介绍计算机图形学和应用的广泛主题。它旨在通过实验室实践和评估，为学生提供基础理论和实践经验。它遵循一个标准的教科书，附加了用于当代发展和应用的材料。A、 对本课程所涉及的计算机图形学主题和应用有很好的理解；B、 演示几何创建和变换、投影、剪切和隐藏几何体移除、照明和材质以及纹理映射的深入知识；C、 将本模块所涵盖的相关技术/算法应用于特定场景；D、 结合流行的图形平台（例如OpenGL）编写编程代码。 评估1:2D图形项目（涵盖学习成果B、C和D，占整个模块评估的15%）在实验室会议期间，将使用模块中介绍的方法和技术创建二维工艺品，并提供指导和支持。除了手工艺品共6页第4页书面报告将被要求与源代码一起提交。作业简报将在第4周左右给出，截止日期约为第8周。评估2：持续工作（涵盖学习成果B、C和D，占整个模块评估的15%）这将包括从第9周到第13周的几个每周组成部分。对于每个组成部分，学生将制作一个关于本周主题的课程/报告，并在课堂/实验室中给出示例代码和解释。评估将根据这些部分给出综合分数。作业3：期末专题和讨论（涵盖所有学习成果A-D，占整个模块评估的70%）这将是一个综合性的项目，使用本模块所涵盖的各种方法和技术，如几何创建、变换、分层建模、查看和投影、照明和材料、纹理、动画和交互作用，制作3D工艺品。一个简短的书面报告将被要求与源代码一起提交。此外，还有讨论问题。详细说明将在第13/14周给出，截止日期为2020年1月。Resit评估（涵盖所有学习成果A-D，占整个模块评估的100%）如果学生的评估1-3的总成绩达不到40%或更高，她/他将被要求在2021年8月初进行resit评估，该模块的权重为100%。 vs2019快捷键opengl配置1.下载学校给的glut2.按照学校lab1教程配置项目属性(2个vcc,1个link,1个否) 3.点debug旁边的绿色箭头运行，就自动弹出来opengl的窗口了创建空项目1.左键项目点属性2.最上面选x643.点vc++目录: 包含目录：D:\\OPENGL\\freeglut\\include; $(IncludePath) 库目录： D:\\OPENGL\\freeglut\\lib; $(LibraryPath)4.点链接器-输入：前面加freeglut_static.lib;5.点清单工具-输入和输出：嵌入清单 否6.关闭属性，debug选x647.源文件文件夹，右键添加新建项，c++文件8.写代码9.点击上面的绿色箭头运行，自动弹出opengl窗口10.点击红色正方形停止调试，vs页面恢复正常11.vs有自动保存12.vs一个项目只能有一个main函数，在头上解决方案”opengl-glut学习”邮件新建项目13.点击新项目，视图，其他窗口，属性管理器，debug64邮件，添加现有的配置，找到文件夹里的gl配置.properties导入。14.会报错，只能新建项目重新配置15.必须在前面有#define FREEGLUT_STATIC // Define a static library for calling functions 不然报错找不到！！ freeglut学习博客学习https://hewei.blog.csdn.net/article/details/74463427?utm_medium=distribute.pc_relevant_download.none-task-blog-baidujs-2.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_download.none-task-blog-baidujs-2.nonecaseGLUT在调用glutMainLoop后，会把控制权交给GLUT,它会开始内部的主循环，直到我们点击窗口上的关闭按钮，而且默认会直接退出程序（可能并不是我们所想要的，glutMainLoop后的代码不会被执行），导致一些资源未释放。 直接进入代码库123456789#define FREEGLUT_STATIC // Define a static library for calling functions#include &lt;GL/freeglut.h&gt; // Include the header file#include &lt;GL/glut.h&gt;#include&lt;math.h&gt;#include&lt;iostream&gt; main打开窗口必要函数 1234567891011void main(int argc, char** argv) &#123; glutInit(&amp;argc, argv); //必要，可以不用实现 glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB); glutInitWindowPosition(50, 50); glutInitWindowSize(winWidth, winHeight); glutCreateWindow(&quot;Perspective View of a Square&quot;); init(); glutDisplayFunc(displayFcn); //必要，可以不用实现 glutReshapeFunc(reshapeFcn); glutMainLoop();&#125; 视频教程第二课 main 视口 画点GL_POINTS 画线GL_LINE_STRIP，GL_LINE_LOOP12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#define FREEGLUT_STATIC // Define a static library for calling functions#include &lt;GL/freeglut.h&gt; // Include the header file#include &lt;GL/glut.h&gt;#include&lt;math.h&gt;void draw() &#123; glClearColor(0.0, 0, 0, 0); //设置背景颜色 glClear(GL_COLOR_BUFFER_BIT); //颜色缓冲 //glRectf(-0.5,-0.5,0.5,0.5); //用当前的绘图颜色绘制一个填充矩形。 //没有创建视口，矩形大小会跟着窗口变化。窗口就像是画布，会跟着变形 //改变点的大小，为10px glPointSize(10); //定义线宽 glLineWidth(20); glLineStipple(0,12); //线条的线型 //画点 glBegin(GL_POINTS); glVertex3f(0,0,0); //三个参数xyz 二个参数xy//0,0,0点就在视口中间 glEnd(); //画线 从点到点 中间是x,y轴 //glBegin(GL_LINE_STRIP); //GL_LINE_STRIP点和点之间连接到一起 glBegin(GL_LINE_LOOP); //GL_LINE_LOOP点和点之间连接成闭合，和GL_LINE_STRIP类似 glVertex3f(0,0,0); glVertex3f(0.7,0.5,0); glVertex3f(0.5, 0.5, 0); glVertex3f(0.2, 0.9, 0); glVertex3f(-0.7, 0.5, 0); glVertex3f(0.4, -0.3, 0); glEnd(); glBegin(GL_LINES); glVertex3f(0, 0, 0); glVertex3f(0.7, 0.5, 0); glEnd(); glFlush(); //告诉电脑我开始画了&#125;//创建视口,两个参数 宽 高void view(int x, int y) &#123; //选择较小边 int dis = x &gt; y ? y : x; //创建一个视口 左下角的位置0,0 在视口中的宽度和高度dis,dis //把画的位置准确定好 glViewport(0,0,dis,dis);&#125;int main(int argc, char** argv)&#123; glutInit(&amp;argc, argv); //指定RGB颜色模式的窗口，指定单缓存窗口 glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB); glutInitWindowPosition(0,0);//设置窗口位置 默认在左上角0,0 glutInitWindowSize(500, 500);//设置窗口大小 glutCreateWindow(&quot;Graphics Primitives&quot;); glutDisplayFunc(draw); glutReshapeFunc(view); //创建视图 glutMainLoop();&#125; 第三课 画三角形GL_TRIANGLES，GL_TRIANGLE_FAN12345678910111213141516171819void draw2() &#123; glClearColor(0.0, 0, 0, 0); //设置背景颜色 glClear(GL_COLOR_BUFFER_BIT); //颜色缓冲 //glBegin(GL_TRIANGLES); //以三个顶点连成三角形，填充。三个点结束，下面三个点继续连成三角形 //glBegin(GL_TRIANGLE_STRIP); //以三个顶点连成三角形，填充。第2,3点找第4点。。。。 glBegin(GL_TRIANGLE_FAN); //1,2,3--1,3,4--1,4,5 以第一个点为中心 glVertex3f(0, 0, 0); glVertex3f(0.7, 0.5, 0); glVertex3f(0.5, 0.5, 0); glVertex3f(0.2, 0.9, 0); glVertex3f(-0.7, 0.5, 0); glVertex3f(0.4, -0.3, 0); glEnd(); glFlush(); //告诉电脑我开始画了&#125; 三角形渐变填充颜色 1234567891011121314151617181920212223242526272829void draw3() &#123; glClearColor(0.0, 0, 0, 0); //设置背景颜色 glClear(GL_COLOR_BUFFER_BIT); //颜色缓冲 glShadeModel(GL_SMOOTH); //glbegin之前，三角形的填充的颜色平滑渐变过渡 glShadeModel(GL_FLAT); //glbegin之前，三角形的填充的颜色不会渐变填充，填充的是第一次定义的颜色 glBegin(GL_TRIANGLES); //以三个顶点连成三角形，填充。三个点结束，下面三个点继续连成三角形 //glBegin(GL_TRIANGLE_STRIP); //以三个顶点连成三角形，填充。第2,3点找第4点。。。。 //glBegin(GL_TRIANGLE_FAN); //1,2,3--1,3,4--1,4,5 以第一个点为中心 glColor3f(0.8,0.3,0.6); //定义画三角形的颜色，下面画的三角形自动填充 //0:33 glVertex3f(0, 0, 0); glColor3f(0.3, 0.3, 0.6); //每个点前面都设置颜色再加上glbegin前面的glShadeModel(GL_SMOOTH)就会平滑渐变 glVertex3f(0.7, 0.5, 0); glColor3f(0.9, 0.3, 0.6); //每个点前面都设置颜色再加上glbegin前面的glShadeModel(GL_SMOOTH)就会平滑渐变 glVertex3f(0.5, 0.5, 0); glColor3f(0.5, 0.5, 0.6); //定义画三角形的颜色，下面画的三角形自动填充，覆盖之前设置的色 glVertex3f(0.2, 0.9, 0); glVertex3f(-0.7, 0.5, 0); glVertex3f(0.4, -0.3, 0); glEnd(); glFlush(); //告诉电脑我开始画了&#125; 第三课 画多边形 GL_POLYGON glPolygonMode(GL_FRONT, GL_LINE); //可以吧这项渲染模式应用到多边形的两面GL_FRONT_AND_BACK或只应用到正面GL_FRONT或者背面GL_BACK(第1个参数)。//把多边形渲染为(默认值)填充的实心GL_FILL，轮廓线GL_LINE或者是点GL_POINT(第2个参数)。 glShadeModel(GL_SMOOTH); //glbegin之前，图形/线段的填充的颜色平滑渐变过渡 glBegin(GL_POLYGON); //画多边形，很多顶点连起来 glEdgeFlag(GL_FALSE); //边缘标记false让下面的点连成的线段全部不显示 多边形绘制规则所有多边形的顶点必须在一个平面上，不能在空间中扭曲多边形的边决不能相交，必须是凸多边形。 12345678910111213141516171819202122232425262728293031//画多边形void draw4() &#123; glClearColor(0.0, 0, 0, 0); //设置背景颜色 glClear(GL_COLOR_BUFFER_BIT); //颜色缓冲 glPolygonMode(GL_FRONT, GL_LINE); //可以吧这项渲染模式应用到多边形的两面GL_FRONT_AND_BACK或只应用到正面GL_FRONT或者背面GL_BACK(第1个参数)。 //把多边形渲染为(默认值)填充的实心GL_FILL，轮廓线GL_LINE或者是点GL_POINT(第2个参数)。 glShadeModel(GL_SMOOTH); //glbegin之前，图形/线段的填充的颜色平滑渐变过渡 glBegin(GL_POLYGON); //画多边形，很多顶点连起来 glColor3f(0.8, 0.3, 0.6); //定义画三角形的颜色，下面画的三角形自动填充 //0:33 glVertex3f(0, 0, 0); glColor3f(0.3, 0.3, 0.6); //每个点前面都设置颜色再加上glbegin前面的glShadeModel(GL_SMOOTH)就会平滑渐变 glVertex3f(0.7, 0.5, 0); glColor3f(0.9, 0.3, 0.6); //每个点前面都设置颜色再加上glbegin前面的glShadeModel(GL_SMOOTH)就会平滑渐变 glEdgeFlag(GL_FALSE); //边缘标记false让下面的点连成的线段全部不显示 glColor3f(0.7, 0.5, 0.6); //定义画三角形的颜色，下面画的三角形自动填充，覆盖之前设置的色 glVertex3f(0.5, 0.5, 0); glEdgeFlag(GL_TRUE); //边缘标记true 下面的线段继续显示 glVertex3f(-0.2, 0.9, 0); glVertex3f(-0.5, -0.7, 0); glEnd(); glFlush(); //告诉电脑我开始画了 没这个函数电脑不画&#125; 第二课 反走样123456glLineWidth(20); //线宽 glEnable(GL_BLEND); //反走样混合模式 glEnable(GL_LINE_SMOOTH); glHint(GL_LINE_SMOOTH_HINT,GL_NICEST); //最高等级 glBegin(GL_LINES); 第三课 画四边形(不同于多边形)普通模式GL_QUADS, 特殊模式GL_QUAD_STRIP1234点顺序形成顺序不同普通模式GL_QUADS按照1234顺序连接线，然后下面的三个连不成四边形不画；特殊模式GL_QUAD_STRIP按照1243链接线，见图平板上 123456789101112131415161718192021222324252627282930//画四边形 07:49void draw6() &#123; glClearColor(0.0, 0, 0, 0); //设置背景颜色 glClear(GL_COLOR_BUFFER_BIT); //颜色缓冲 //普通模式GL_QUADS, 特殊模式GL_QUAD_STRIP //1234点顺序形成顺序不同 //普通模式GL_QUADS按照1234顺序连接线，然后下面的三个连不成四边形不画； //特殊模式GL_QUAD_STRIP按照1243链接线，见图 glBegin(GL_QUAD_STRIP); //1 glColor3f(0.1,0.3,0.6); glVertex3f(0,0,0); //2 glColor3f(0.2, 0.6, 0.6); glVertex3f(0.7, 0.3, 0); //3 glColor3f(0.9, 0.3, 0.7); glVertex3f(0.2, 0.5, 0); //4 glVertex3f(0.5, 0.6, 0); glColor3f(0.2, 0.3, 0.6); glVertex3f(0, 0, 0); glVertex3f(-0.5, 0.9, 0); glEnd(); glFlush();&#125; 第四课 二维观察 二维剪裁窗口观察流水线：剪裁窗口viewing window：把窗口当场画布，画布分区域视口viewport：控制画的东西在窗口中的位置二维观察变换：窗口到视口的变换/视口到窗口的变换 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//创建视口,两个参数 宽 高void view2(int x, int y) &#123; //选择较小边，这样的视口长宽是窗口的高 int dis = x &gt; y ? y : x; //创建一个视口 左下角的坐标0,0 在视口中的宽度和高度dis,dis //把画的位置准确定好 glViewport(0, 0, dis, dis); &#125;//画四边形 07:49void draw7() &#123; glClearColor(0.0, 0, 0, 0); //设置背景颜色 glClear(GL_COLOR_BUFFER_BIT); //颜色缓冲 //普通模式GL_QUADS, 特殊模式GL_QUAD_STRIP //1234点顺序形成顺序不同 //普通模式GL_QUADS按照1234顺序连接线，然后下面的三个连不成四边形不画； //特殊模式GL_QUAD_STRIP按照1243链接线，见图 glBegin(GL_QUAD_STRIP); //1 glColor3f(10, 30, 60); glVertex3f(0, 0, 0); //2 glColor3f(0.2, 0.6, 0.6); glVertex3f(70, 30, 0); //3 glColor3f(0.9, 0.3, 0.7); glVertex3f(20, 50, 0); //4 glVertex3f(50, 60, 0); glColor3f(0.2, 0.3, 0.6); glVertex3f(0, 0, 0); glVertex3f(-50, 90, 0); glEnd(); glFlush();&#125;int main(int argc, char** argv)&#123; glutInit(&amp;argc, argv); glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB); glutInitWindowPosition(0,0);//设置窗口位置 默认在左上角0,0 glutInitWindowSize(500, 500);//设置窗口大小 glutCreateWindow(&quot;Graphics Primitives&quot;); glMatrixMode(GL_PROJECTION); //指定当前操作的是投影矩阵堆栈 glLoadIdentity(); //初始化，指定当前操作的矩阵堆栈的栈顶元素为单位矩阵 gluOrtho2D(-500,500,-500,500); //定义二维剪裁窗口，参数：左，右，下，上 四条边 //没有写gluOrtho2D的时候，点的坐标是-1到1.写了这个函数之后，屏幕上画的东西就要改点坐标 //gluOrtho2D(-500,500,-500,500);就是一个标准的xy轴了，点的坐标就根据最大长500，0.0在视口正中间 glutDisplayFunc(draw7); glutReshapeFunc(view2); //创建视图 glViewport(0, 0, dis, dis); glutMainLoop();&#125; 第四课 平移旋转缩放glTranslatef(100,200,0);//平移：右100上200 glScalef(0.5, 2, 0); //缩放：x轴0.5倍，y轴2倍 glRotatef(160,0,0,0);//(逆时针)旋转：旋转角度，以点(0,0,0)旋转 后面接画的图 123456789101112131415161718192021222324252627282930313233343536void draw8() &#123; glClearColor(0.4, 0.5, 0.9, 0); //设置背景颜色蓝色 glClear(GL_COLOR_BUFFER_BIT); //颜色缓冲 glTranslatef(100,200,0);//平移：右100上200 //glScalef(0.5, 2, 0); //缩放：x轴0.5倍，y轴2倍 glScalef(3, 3, 0); glRotatef(160,0,0,0);//(逆时针)旋转：旋转角度，以点(0,0,0)旋转 //普通模式GL_QUADS, 特殊模式GL_QUAD_STRIP //1234点顺序形成顺序不同 //普通模式GL_QUADS按照1234顺序连接线，然后下面的三个连不成四边形不画； //特殊模式GL_QUAD_STRIP按照1243链接线，见图 glBegin(GL_QUAD_STRIP); //1 glColor3f(10, 30, 60); glVertex3f(0, 0, 0); //2 glColor3f(0.2, 0.6, 0.6); glVertex3f(70, 30, 0); //3 glColor3f(0.9, 0.3, 0.7); glVertex3f(20, 50, 0); //4 glVertex3f(50, 60, 0); glColor3f(0.2, 0.3, 0.6); glVertex3f(0, 0, 0); glVertex3f(-50, 90, 0); glEnd(); glFlush();&#125; 后面那三个数字分别代表绕xyz三轴旋转的系数，旋转系数乘以角度。glRotatef(45,1,0,0) 物體如何旋转？想象：从 坐标（0，0，0）即原点，引出一条线到（1,0,0）,用右手握住这条线，这时，你会问，如何握？右手大拇指指向 （0，0，0）至（1，0，0）的方向 才握。另外四个手指的弯曲指向 即是物体旋转方向。这个旋转能让圆锥从平摊的立起来glRotatef(180,0,1,1); gluCylinder(quadricObj, 0.4, 0.0, 0.6, 260, 130);本来是平面的球体旋转：绕着第一象限x轴和y轴之间的斜线 自传90度 变成斜线点(1,1)glRotatef(90, 1, 1, 0); 旋转：绕着第四象限x轴和y轴之间的斜线 自传90度 变成斜线点(-1,1)glRotatef(90, -1, 1, 0); 旋转：绕着x轴 自传90度 变成横线glRotatef(90, 1, 0, 0); 旋转：绕着y轴 自传90度 变成竖线glRotatef(90, 0, 1, 0); 旋转：转不见了glRotatef(90, 0, 0, 1); 第四课 选择矩阵堆栈glMatrixMode(参数mode); (display里的第一个函数)参数mode用于确定将哪个矩阵堆栈用于矩阵操作。GL_MODELVIEW 模型视图矩阵GL_PROJECTION 投影矩阵GL_TEXTURE 纹理矩阵 模型视图矩阵：在对图1进行平移/旋转/缩放后，再对图2进行平移/旋转/缩放。图2的变换会累积图1和图2的变换 不想让平移/旋转/缩放叠加，首位加push,pop 1234567//在进行变换之前要用glPushMatrix();glPushMatrix();//变换--沿x轴移动glTranslatef(0.2, 0.0, 0.0);glPopMatrix(); 投影矩阵：1.平行投影矩阵： 无论物体距离相机多远，投影后的物体大小尺寸不变。平行投影函数：glOrtho,gluOrtho2D2.透视投影： 近大远小。 第五课 画曲线Bezier曲线步奏：1.指定控制点坐标CP 2.设定求值函数glMap1f(GL_MAP1_VERTEX_3,0,1,3,4,&amp;CP[0][0]); //我们这里是glMap1f(GL_MAP1_VERTEX_3,最小值，最大值，三维数组写3，矩阵阶数4个点，矩阵的第一个指针) 3.激活求值函数glEnable(GL_MAP1_VERTEX_3) 4.计算沿样条路径的位置并显示曲线void glEvalCoord1f{fd}(TYPE t); 生日贺卡-lab中用到过的函数lab2 lab2目的 帮助您进一步熟悉MS Visual Studio 2019和OpenGL图形库 向您展示如何在屏幕上指定设备区域的尺寸和虚拟世界中窗口的尺寸 向您展示如何在屏幕上绘制基本图形原语 初始化画图窗口12345678910111213141516171819202122232425262728#define FREEGLUT_STATIC#include &lt;GL/freeglut.h&gt;void define_to_OpenGL(); //写在main下面的函数先声明int main(int argc, char** argv)&#123; glutInit(&amp;argc, argv); //必要 //创建窗口+窗口名字 glutCreateWindow(&quot;Graphics Primitives&quot;); //窗口属性(define_to_OpenGL配置函数) glutDisplayFunc(define_to_OpenGL); glutMainLoop(); //让窗口一直出现&#125;void define_to_OpenGL()&#123; //glClearColor函数设置好清除颜色，glClear利用glClearColor函数设置好的当前清除颜色设置窗口颜色 glClearColor(1.0, 1.0, 0.6, 1.0); glClear(GL_COLOR_BUFFER_BIT); // The stuff to appear on screen goes here //glFlush：将GL命令队列中的命令发送给显卡并清空命令队列，发送完立即返回； glFlush();&#125; glClear(GL_COLOR_BUFFER_BIT);参数：GL_COLOR_BUFFER_BIT,颜色缓冲 GL_DEPTH_BUFFER_BIT,深度缓冲 GL_STENCIL_BUFFER_BIT，模板缓冲 glViewPort（）和gluOrtho2D（）和glutInitWindowSize（）区分 glutInitWindowSize（width，height）定义窗口的大小，也限制我们显示的最大范围。窗口左下角为原点，而我们电脑窗口的原点为左上角。 gluOrtho2D（x1,x2,y1,y2）左右下上相当于画板，我们所绘的东西在这上面 glViewPort（x1,y1,x2,y2）它的原点（0，0）在所生产的窗口的坐下角。定义了gluOrtho2D定义的窗口在glutInitWindowSize定义的窗口的投影大小，默认为窗口大小控制着gluOrtho2D所定义的画板在glutInitWindowSize所定义的窗口的缩放，因为最终的显示还是在glutInitWindowSize所定义的窗口。 调好的窗口位置和大小放在main 1234567891011int main(int argc, char** argv)&#123; glutInit(&amp;argc, argv); // Task 2 glutInitWindowPosition(400, 120);//设置窗口位置 glutInitWindowSize(400, 400);//设置窗口大小 glutCreateWindow(&quot;Graphics Primitives&quot;); glutDisplayFunc(mydisplay);//设置显示回调函数 glutMainLoop();&#125; glColor3f颜色glColor3f(0.0, 0.0, 0.0); –&gt; 黑色glColor3f(1.0, 0.0, 0.0); –&gt; 红色glColor3f(0.0, 1.0, 0.0); –&gt; 绿色glColor3f(0.0, 0.0, 1.0); –&gt; 蓝色glColor3f(1.0, 1.0, 0.0); –&gt; 黄色glColor3f(1.0, 0.0, 1.0); –&gt; 品红色glColor3f(0.0, 1.0, 1.0); –&gt; 青色glColor3f(1.0, 1.0, 1.0); –&gt; 白色 项目名字test3第五课之前的opengl-glut学习 lab6之后的 第六课之后 第六课 光照材料颜色模式：glcolor3f 颜色表模式 02着色模型：void glShadeModel(GLenum mode) mode取 平滑GL_SMOOTH（默认）；纯色GL_FLAT光照：光照类型：光源 Light source环境光 Ambient Light 整体的光 暗面(反射光)散射光 Diffuse Light 高光旁边一圈镜面光 Specular Light 高光 镭射光 Emitted Light任何一种光都由这三种组成：环境光 Ambient Light 暗面(反射光)散射光 Diffuse Light 高光旁边的散射(像太阳照射地球) 镜面光 Specular Light 高光添加光源步奏：1.创建光源 glLight()2.选择光照模型3.启用光照 glEnable(GL_LIGHTING) glEnable(GL_LIGHT0) glEnable就是启用xxx 4.设置材质光源类型分三类：(第四个参数重要)平行光 LightPosition(1,0,0,1)点光源 LightPosition(1,0,0,0) 聚光灯 全局光照 glLightModel(pname,param)材质材质颜色（分环境、漫反射、镜面反射）材质属性 glMaterial(face,pname,param)颜色材质模式：glEnable(GL_COLOR_MATERIAL);void glColorMaterial(face,mode); 17:5545:00 多个物体有光照的混合叠加若光源颜色为( LR , LG , LB )，材质颜色为( MR , MG , MB )，最终颜色为( LRMR , LGMG , LBMB )。(B1+B2)MB )。因此，材料的颜色成分决定了入射光被反射的百分比。void glLight{if}v设置光源特性。 light是名字例如：GL_LIGHT0,GL_LIGHT1…GL_LIGHT7。 pname 缺省值 说明GL_AMBIENT 0,0,0,1 RGBA模式的环境光GL_DIFFUSE 1,1,1,1 RGBA模式的漫反射光GL_SPECULAR 1,1,1,1 RGBA模式的镜面光GL_POSTION 1,0,1,0 光源位置齐次坐标GL_SPOT_DIRECTION 0,0,-1 点光源聚光方向矢量(x,y,z,w)GL_SPOT_EXPONENT 0 点光源聚光指数GL_SPOT_CUTOFF 180 点光源聚光发散半角GL_CONSTANT_ATTENUATION 1 常数衰减因子GL_LINER_ATTENUATION 0 线性衰减因子GL_QUADRATIC_ATTENUATION 0 平方衰减因子说明：GL_DIFFUSE GL_SPECULAR的缺省值只用于GL_LIGHT0,其他光源GL_DIFFUSE GL_SPECULAR缺省值为：(0.0,0.0,0.0,1.0) lab11 材料纹理这个实验室有三个示例程序：使用创建纹理的过程进行纹理映射 按像素从图像文件进行模式、mipmapping和纹理映射。请先运行这些程序 试着去理解做了什么和使用了什么函数。你可以进一步练习函数 看看效果。然后你就可以开始做评估2的任务2了。 1） 过程创建纹理图案的纹理映射示例代码 在示例程序中，由交替的黑白方块组成的纹理，如棋盘 由程序生成。程序将此纹理应用于两个正方形，然后在中渲染 透视图，其中一个正对着观众，另一个向后倾斜45度。 棋盘格纹理是在例程makeCheckImage（）中生成的，以及所有纹理映射 初始化发生在例程myinit（）中。单个、全分辨率纹理贴图由指定 glTexImage2D（），其参数指示图像的大小、类型、位置和其他属性。 接下来对glTexParameter* （）的四个调用指定如何包装纹理（请参见“重复和” “钳制纹理”）以及如果在 屏幕上的纹理和像素（参见“控制过滤”）。 接下来，glTexEnv* （）将绘图模式设置为GL峎udap，以便使用绘制纹理的多边形 纹理贴图中的颜色（而不是考虑多边形的颜色） 没有纹理的绘制）。最后，glEnable（）打开纹理。 例程display（）绘制两个多边形。请注意，纹理坐标与 顶点坐标。 glTexCoord* （）命令的行为类似于glNormal（）命令：它设置当前纹理 坐标；任何后续的顶点命令都有与其关联的纹理坐标，直到 再次调用glTexCoord* （）。 当您在 机器-例如，它看起来像两个三角形，上面有棋盘图像的不同投影 他们。如果是这样，请尝试将参数GL_PERSPECTIVE_CORRECTION_HINT设置为GL_NICEST and running 再举个例子。为此，请使用glHint（）。教函数https://blog.csdn.net/wang15061955806/article/details/51000450 例如:如果纹理位置是 [0.5,0.1]，纹理宽度是320，纹理高度是200，那个对应纹理单元位置就是 (160,20) (0.5 * 320 = 160 和 0.1 * 200 = 20)。可以运行的例子-旋转 https://blog.csdn.net/dcrmg/article/details/53180369贴图旋转正方体 https://www.cnblogs.com/missouter/p/12878363.html很炫酷的盒子 https://zhuanlan.zhihu.com/p/109325397纹理贴纸可以开光灯//光照换第三参数GL_MODULATE glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE); 图片文件要粘贴到项目文件夹里，才能用相对路径bmp图片转化用：jpg图片右键打开方式 画图 另存为 bmp图片 就可以用lab12 Cohen-SutherLand直线裁剪算法函数： glRasterPos2f(x,y)其实就相当于是glVertex2f(x,y)的坐标,只是glRasterPos2f(x,y)用于显示[字体]时设置字符的起始位置,而glVertex2f(x,y)是绘制一个2D点.且glRasterPos2f(x,y)仍受当前模视矩阵的影响,即glTranslatef()可改变字符显示的位置, glRasterPos2f(x,y)显示字体时,其位置可随模视矩阵的改变而改变.裁剪算法解释：https://blog.csdn.net/weixin_44348327/article/details/89975412?utm_medium=distribute.pc_relevant.none-task-blog-title-7&amp;spm=1001.2101.3001.4242中间盒子0000一侧为内部，左边界第一条竖线内是0000一侧，右边界第二条竖线内是0000一侧1.处理左边界：裁掉左边界外的线段2.处理右边界：裁掉右边界外的线段3.处理下边界：裁掉下边界外的线段-第二条横线下面是下边界外 4.处理上边界：裁掉上边界外的线段-第以条横线上面是上边界外总结就是：在盒子左边界右边界的直线，裁掉直线之外的线段；在盒子上边界下边界的直线，裁掉直线之外的线段https://blog.csdn.net/lyp_1020k/article/details/79437083?utm_medium=distribute.pc_relevant_download.none-task-blog-baidujs-2.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_download.none-task-blog-baidujs-2.nonecase","categories":[],"tags":[]},{"title":"CPT203 软件工程1","slug":"CPT203-软件工程1","date":"2020-09-07T03:10:47.000Z","updated":"2020-10-22T07:47:45.306Z","comments":true,"path":"2020/09/07/CPT203-软件工程1/","link":"","permalink":"https://lucifinil-x.github.io/2020/09/07/CPT203-软件工程1/","excerpt":"CPT203 软件工程1 AssCW x3 + 网上考试(2h) = 15分x3 + 55分4/8/11周","text":"CPT203 软件工程1 AssCW x3 + 网上考试(2h) = 15分x3 + 55分4/8/11周 handbook本模块旨在了解与重要计算系统（即太大而不能由一个人设计和开发的系统）开发相关的问题，和被设计为供许多用户使用）和欣赏必要的技术和工具来有效地开发这种系统，以一种成本效益高的方式。特别是，本模块介绍了每个基本软件工程活动的问题，更重要的是，用于解决这些问题的方法和工具。在本单元的最后，学生们将了解设计和建造重要计算机系统的问题。他们应了解设计完全满足预期用户要求的系统的必要性，并认识到需要确保设计的实施得到充分测试，以确保完成的系统符合规范。学生应充分了解软件系统及其组件的设计和开发的面向对象方法的原理和实践，并能在实践中应用这些原则。[A] 认识到设计和建造重要计算机系统的问题；[B] 了解设计完全满足预期用户要求的系统的需要；[C] 认识到需要确保对设计的实施进行充分的测试，以确保完成的系统符合规范；[D] 充分了解软件系统及其组件的设计和开发的面向对象方法的原理和实践；[E] 能够在实践中运用这些原则； 画图mobi里的说明use case用例图第一个图用例图通常很简单。它没有显示用例的详细信息： •它只总结了用例、参与者和系统之间的一些关系椭圆里的文字是动词，例子有：添加用户、创建订单、发送通知等。 &lt;&lt; extend &gt;&gt;: 第三个图•扩展用例依赖于扩展（基本）用例。在下图中，没有“下单”用例，“跟踪订单”用例没有多大意义。•扩展用例通常是可选的，可以有条件地触发。•扩展（基本）用例本身必须有意义。这意味着它应该是独立的，不能依赖于扩展用例的行为。 &lt;&lt; include &gt;&gt;：第四个图重用通用操作，包含的用例是强制性的，不是可选的 UML图第二个图白色箭头指向的是父类","categories":[],"tags":[]},{"title":"CAN201 网络","slug":"CAN201-网络","date":"2020-09-07T03:10:14.000Z","updated":"2021-01-14T07:28:55.505Z","comments":true,"path":"2020/09/07/CAN201-网络/","link":"","permalink":"https://lucifinil-x.github.io/2020/09/07/CAN201-网络/","excerpt":"作业CAN201 网络 icequiz x2 + 两部分CW = 15分x2 + 70分w6和w14 quiz ; 程序项目，用python3","text":"作业CAN201 网络 icequiz x2 + 两部分CW = 15分x2 + 70分w6和w14 quiz ; 程序项目，用python3 黑马补课socket是全双工：在发的时候可以收，在收的时候可以发，只不过在目前程序里体现不出来，同一时间可以干很多事情的。tcp:服务器创建的socket是用来绑定自己本机的ip,port,并且设置监听。服务器创建的socket接收客户端发过来的socket,接收到新的new socket里，接收客户端发过来的数据是用new socket接收，发送给客户端数据是用new socket发送 csdn一个服务器多个客户端+时间戳 https://www.jb51.net/article/138172.htm明天看Python socket模拟客户端一直接收服务端数据，同时不影响客户端发送数据 https://blog.csdn.net/JIA227/article/details/72962786?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control还有老师的视频！ 今晚做完205！ 代码问题A复制给B要改端口号，不然A收不到数据 B改 下面的def；path = ‘VMB_share’ C改except OSError:myRecvPort = ports[2] 和 下面的def; path = ‘VMC_share’一定要复制A和B的py命令！看好了再回车因为端口号问题：测试服务器一对多客户端：A只收到B,B收到A和C，C都没收到 然后一会要把处理客户端的线程，存值用f{}来改key值ip问题：实际上ABC本机作为服务器的时候用同一个port,所以本机作为客户端连接服务器的时候都连这同一个port，但是一个电脑测试，我用A 20001 ，B 20002， C 20003 而且ABC程序写死对方的端口，复制过去B改，C改。 大家给别人的ip都是0,1 ports = [20001,20002,20003]测试时候改B,C对于B:给AC搜索[1]改四处改两处A 129 改成[0] [2] 12345678910if destAddr[0] == B_client_info[&apos;client_ip&apos;]: which_client_info = B_client_info # 字典 which_client_info[&apos;server_port&apos;] = ports2[1] # 这里是B下载服务端口号 recv_news_list = B_news_list which_download_ticket_list = B_download_ticket_list # 一个文件信息一个ticketdic, 所有ticket加入ticketlistelif destAddr[0] == C_client_info[&apos;client_ip&apos;]: which_client_info = C_client_info which_client_info[&apos;server_port&apos;] = ports2[2] # 这里是B下载服务端口号 recv_news_list = C_news_list which_download_ticket_list = C_download_ticket_list 184 1234567def sendData_thread_job(ipList): sleep(5) # ports = [20001,20002,20003] client_send_to_B_thread = threading.Thread(target=client_send_to_server_job, args=(ipList[0],ports1[0])) client_send_to_C_thread = threading.Thread(target=client_send_to_server_job, args=(ipList[1],ports1[2])) client_send_to_B_thread.start() client_send_to_C_thread.start() 241 1234567def sendFile_thread_job(ipList): sleep(5) # ports2 = [20011,20012,20013] client_sendFile_to_B_thread = threading.Thread(target=client_sendFile_to_server_job, args=(ipList[0], ports2[0])) client_sendFile_to_C_thread = threading.Thread(target=client_sendFile_to_server_job, args=(ipList[1], ports2[2])) client_sendFile_to_B_thread.start() client_sendFile_to_C_thread.start() 255 1with open(join(&quot;D:\\大三上学期\\CAN201 网络\\cw1ABC文件仓库\\B仓库&quot;,send_file_pathname), &quot;wb&quot;) as f: 对于C:给AB搜索[1]改四处开启线程改两处A改两处except 129 改成 [0] [1] 12345678910if destAddr[0] == B_client_info[&apos;client_ip&apos;]: which_client_info = B_client_info # 字典 which_client_info[&apos;server_port&apos;] = ports2[1] # 这里是B下载服务端口号 recv_news_list = B_news_list which_download_ticket_list = B_download_ticket_list # 一个文件信息一个ticketdic, 所有ticket加入ticketlistelif destAddr[0] == C_client_info[&apos;client_ip&apos;]: which_client_info = C_client_info which_client_info[&apos;server_port&apos;] = ports2[2] # 这里是B下载服务端口号 recv_news_list = C_news_list which_download_ticket_list = C_download_ticket_list 140 1except OSError:myRecvPort = ports[2] 288 12except OSError: myRecvPort = ports2[2] 184 1234567def sendData_thread_job(ipList): sleep(5) # ports = [20001,20002,20003] client_send_to_B_thread = threading.Thread(target=client_send_to_server_job, args=(ipList[0],ports1[0])) client_send_to_C_thread = threading.Thread(target=client_send_to_server_job, args=(ipList[1],ports1[1])) client_send_to_B_thread.start() client_send_to_C_thread.start() 241 1234567def sendFile_thread_job(ipList): sleep(5) # ports2 = [20011,20012,20013] client_sendFile_to_B_thread = threading.Thread(target=client_sendFile_to_server_job, args=(ipList[0], ports2[0])) client_sendFile_to_C_thread = threading.Thread(target=client_sendFile_to_server_job, args=(ipList[1], ports2[1])) client_sendFile_to_B_thread.start() client_sendFile_to_C_thread.start() 255 1with open(join(&quot;D:\\大三上学期\\CAN201 网络\\cw1ABC文件仓库\\C仓库&quot;,send_file_pathname), &quot;wb&quot;) as f: 运行测试同时开启时候可以收到B/C的client_info_list 一个机器断开连接就不知道怎么办了而且本机只能扫描到自己的一个文件-这是因为没有循环发文件而且如果传有目录结构的文件，而并没有子文件夹就会写入不了FileNotFoundError: [Errno 2] No such file or directory: ‘D:\\大三上学期\\CAN201 网络\\cw1ABC文件仓库\\A仓库\\VMA_share\\file1\\file1.1\\aaaa3’写入的时候需要判断文件夹结构，创建目录 12345678Traceback (most recent call last): File &quot;D:\\Python3.7.2\\lib\\threading.py&quot;, line 917, in _bootstrap_inner self.run() File &quot;D:\\Python3.7.2\\lib\\threading.py&quot;, line 865, in run self._target(*self._args, **self._kwargs) File &quot;AllCS_A.py&quot;, line 217, in client_sendFile_to_server_job tcpSendSocket.send(f&quot;&#123;send_file_pathname&#125;&#123;SEPARATOR&#125;&#123;send_file_size&#125;&#123;SEPARATOR&#125;&#123;send_file_block&#125;&quot;.encode())ConnectionResetError: [WinError 10054] 远程主机强迫关闭了一个现有的连接。 12345678910111213141516171819Exception in thread Thread-16:Traceback (most recent call last): File &quot;D:\\Python3.7.2\\lib\\threading.py&quot;, line 917, in _bootstrap_inner self.run() File &quot;D:\\Python3.7.2\\lib\\threading.py&quot;, line 865, in run self._target(*self._args, **self._kwargs) File &quot;AllCS_A.py&quot;, line 254, in client_file_handle_job send_file_pathname, send_file_size,send_file_block = received.split(SEPARATOR)ValueError: not enough values to unpack (expected 3, got 1)---Exception in thread Thread-12:Traceback (most recent call last): File &quot;D:\\Python3.7.2\\lib\\threading.py&quot;, line 917, in _bootstrap_inner self.run() File &quot;D:\\Python3.7.2\\lib\\threading.py&quot;, line 865, in run self._target(*self._args, **self._kwargs) File &quot;AllCS_A.py&quot;, line 218, in client_sendFile_to_server_job tcpSendSocket.send(sendTitle)ConnectionResetError: [WinError 10054] 远程主机强迫关闭了一个现有的连接。 1234567print(&quot;压缩文件接收完成，开始解压&quot;) print(&quot;解压前&quot;,join(&quot;recv_compress_dir&quot;, send_file_name)) print(&quot;解压后&quot;,join(localTestDirPath,send_file_pathname)) # 解压前 recv_compress_dir\\我是CCC.txt # 解压后 D:\\大三上学期\\CAN201 网络\\cw1ABC文件仓库\\A仓库\\VMC_share\\我是CCC.txt FileNotFoundError: [WinError 3] 系统找不到指定的路径。: &apos;D:\\\\大三上学期\\\\CAN201 网络\\\\cw1ABC文件仓库\\\\A仓库\\\\VMC_share\\\\我是CCC.txt\\\\VMC_share&apos; 解决办法error1.send(f””.encode()) 直接send不要变量2.接收.decode(“utf8”,”ignore”)3.接收的时候也不要用变量，直接decode()4.通过socket用字符串发过去解码全是字符串，list不能遍历拿到字典。必须发json字符串，再转成list,相当于都要发header 5.使用append()方法将dict内容追加到list时，发现值被覆盖 6.客户端请求+接收文件用while true 开一个socket请求一个文件写入，关socket;下一个文件请求再开socket 7.服务端接收请求不能加while true,因为服务端的socket一直在accept,接收到一次就分配一个线程。对方客户端关了，服务器这边也关了，会自动接收到下一个客户端的socket,然后开下一个线程。 8.tarfile解压会自动创建文件夹目录 12for one in file_detail_list: # 本地测试规定死VMA server_port就是port2[0],VMB server_port就是port2[1],VMC server_port就是port2[2] 将dict声明，放在方法体内 123456789 if not os.path.isdir(join(root_path, file)): # not a dir self_file_detail_dict = &#123;&#125; # 要改变的字典变量不能设置为全局变量,放在每次改值前面 file_path_new = join(root_path, file) self_file_detail_dict[&apos;self_file_path&apos;]=file_path_new self_file_detail_dict[&apos;self_file_name&apos;]=file self_file_detail_dict[&apos;self_file_size&apos;]=getsize(file_path_new) self_file_detail_dict[&apos;self_file_lastmodifytime&apos;]=getmtime(file_path_new) self_file_detail_list.append(self_file_detail_dict)​ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171188.为yes了没有连接也没有发：因为while+条件=if+条件 只会执行一次while True: if self_update_message == &quot;YES&quot;:9.更新之后新建了两条一样的ticket,因为扫描文件的时候添加了一次self_more_files_paths_list,还把之前的文件信息修改了。### 虚拟机上测试要改的地方1.mkdir 12行里 \\\\ 换成 / 2. 服务端绑定的端口号3.扫描线程0,1秒重启一次## 代码结构### 拿到变量1.本机服务端连接到两个客户端，接收两个客户端发的他们的文件list.存到自己的B,C机的字典里面。这时候已经有了三个机器ABC的文件列表了。所以，接下来做A和B,A和C文件列表的对比：对比只会出现两种情况：1.本机多了文件list对比结果：本机文件listA和拿到的listB，和listC都要多一部分self_more_files_path全局变量：保存本机多的文件pathc/s:这时本机作为客户端，对B,C服务端发送多的文件---2.本机没有多文件本机检查自己文件夹内有无新/修改文件。【在扫描线程任务中还没写完】---【其实应该只检查本机文件的变化，有变化传，无变化等待。】【所以暂时不做ABC的比较，做文件传输】list对比结果：1.本机文件listA比拿到的listB少，和listC一样 c/s:这时本机作为服务端，接收B客户端发送多的文件2.本机文件listA比拿到的listC少，和listB一样c/s:这时本机作为服务端，接收C客户端发送多的文件用？对比如果A的文件比B/C的文件都要多，A通过客户端发送线程通知B/C开启服务端接收线程；A要把 A比B/C多的文件 通过客户端发送线程发给B/C；B/C要在服务端接收线程，接收A发过来的文件。---2.本机客户端给两个服务端发自己的文件list,收到服务端的回复的机子的文件list.(这里只作为消息发送成功的回复，不做文件变量修改。)---在文件path递归的时候还要拿到 文件的size 和文件的 lastmodifytime.用于本机检查自己文件夹内有无新文件。文件的size 和文件的 lastmodifytime就可以判断这个文件有没有变。文件变了【本机客户端线程】就要发个news给其他机器.中途挂掉的机器就看接收到了第几块文件，接收到了500块就从501块继续接收。Last Modify Time• os.path.getmtime(filename) -&gt; Unix timestamp (a float number)• Get file size:• os.path.getsize(filename) -&gt; number of bytes• Get file/folder list of a folder:• os.listdir(dir)• How to traverse the entire folder?---【本机服务端线程】接收其他机器有新文件的news,并且开始接收客户端的文件。---接收的压缩的文件存到临时文件夹，在临时文件夹解压缩之后再move到share文件夹---把数据包加密，两边都用对称加密的秘钥，用对称加密的库。发的时候加密，收的时候解密。### 函数功能main()1.ipList =命令行输入的ip的list2.t_file_scan扫描线程= 线程任务：get_file_job，参数：path = &apos;VMA_share&apos;4.tcp_server_recvData_thread本机服务端接收线程 = 线程任务：recvData_thread_job, args=(ipList,)5.tcp_client_sendData_thread本机客户端发送线程= target=sendData_thread_job, args=(ipList,)6.开启线程7.---全局变量all_files_path是share文件夹下的文件路径all_files_name是hare文件夹下的文件名，不带路径### 线程任务1.扫描线程任务def get_file_job(root_path):1.调用方法get_file(root_path, all_files_path,all_files_name)递归函数，遍历该文档目录和子目录下的所有文件，获取其path,和文件名---2.本机服务端接收线程任务，一对多def recvData_thread_job(ipList):1.全局变量global B_files_pathglobal B_files_name2.服务器tcpRecvSocket3.myRecvPort服务器端口号4.服务器tcpRecvSocket绑定本机ip和端口号测试ABC时，C需要换成myRecvPort = ports[2]但是实际在虚拟机上ABC的服务器绑定本机ip和相同端口号5.服务器tcpRecvSocket监听6.while true 接收客户端的socket 和(ip,port)给每个客户端创建一个独立的线程进行管理---2.1给每个客户端创建一个独立的线程进行管理def message_handle_for_client_job(clientSocket, destAddr):对接收的客户端进行处理:接收文件信息，回复本机文件信息每接收到一个客户端A_connected_client_nums+1；用A_connected_client_nums去对应client_who = [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;]中的机器编号；用A_connected_client_nums去拿到client_info_list列表中对应的客户端信息字典对象-变量名which_client_info; 客户端信息字典对象，B,C字典中的key: ‘client_ip’,’client_port’,’{client_who[A_connected_client_nums]}_files_path’,{client_who[A_connected_client_nums]}_files_name’ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566## 虚拟机测试### 创建目录+执行workplace-cw1-shareD:\\virtualbox资源\\putty.exe putty命令：cd cwdputty命令：cd workplace/cw1/192.168.56.102192.168.56.103192.168.56.104python3 main.py --ip 192.168.56.103,192.168.56.104 --encryption yespython3 main.py --ip 192.168.56.102,192.168.56.104 --encryption yespython3 main.py --ip 192.168.56.102,192.168.56.103 --encryption yes---python main.py --node u v w x---python3 main.py --node u v w xpython3 main.py --node u v w x ypython3 main.py --node u v w x y a b c添加文件软链接先ln -s /home/tc/workplace/cw1/ruan/toupdate.txt /home/tc/workplace/cw1/share/toupdate.txt后把修改的文件再拖过去 ruan----ln -s /home/tc/workplace/cw1/ruan/Software.pdf /home/tc/workplace/cw1/share/Software.pdf----1218.pdfln -s /home/tc/workplace/cw1/ruan/Core.vmdk /home/tc/workplace/cw1/share/Core.vmdkln -s /home/tc/workplace/cw1/ruan/Ambiguity.pdf /home/tc/workplace/cw1/share/Ambiguity.pdfln -s /home/tc/workplace/cw1/ruan/CSE205-W5.pdf /home/tc/workplace/cw1/share/CSE205-W5.pdfln -s /home/tc/workplace/cw1/ruan/CAN 2-11考试搜索.pdf /home/tc/workplace/cw1/share/CAN 2-11考试搜索.pdf## 虚拟机### 启动双击coreovacore-运行启动右键terminal命令 ifconfig查看虚拟机ip:192.168.56.101在putty.exe 中执行命令---### putty.exe中执行命令D:\\virtualbox资源\\putty.exe 双击putty.exe 输入ip192.168.56.101login as: tcpassword:123 回车ssh tc@192.168.56.101 回车yespassword:123 回车这样就已经成功的远程启动虚拟机继续：python3 显示python3.6.9which python3 显示/usr/local/bin/python3---lab10 pwd 查看当前所在位置17:52 建立文件夹cw1和share 下面两行要一起执行mkdir workplacesudo mount /mnt/sda1 ./workplace/ ls 显示workplace/cd workplace/sudo mkdir cw1 目的：创建文件夹cw1ls 显示：cw1/ lost+found/ tce/cd cw1/ 目的：进入cw1文件夹再创建share文件夹sudo mkdir sharecd .. 目的：返回到workplacecd cw1/share/ 目的：进入share文件夹。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107---### 远程代码测试lab1 用专业版连接远程运行代码打开专业版2019.1.2pycharm,create project 文件名下面点箭头，选择existing interpreter的最右边的···打开，选择SSH Interpreter,new server下面填 host:192.168.56.101 , username:tc，密码：123(必须先开虚拟机并且右键打开命令行之后，再开D:\\virtualbox资源\\putty.exe ，最后开py)选择interpreter右边的···，找/usr/local/bin/python3，完成，创建测试运行之后：ssh://tc@192.168.56.101:22/usr/local/bin/python3 -u /tmp/pycharm_project_559/remote_run_test.py之后代码测试就用这个文件夹project:TC_Python---社区版可以安装paramiko，专业版不行---同一文件夹的文件 直接import xx.py解决：只有换一个路径新建工程才好，之前那个project就是要报错，没有办法21:20软链接### linux命令https://blog.csdn.net/luansj/article/details/97272672文件和目录 cd /home 进入 &apos;/ home&apos; 目录&apos; cd .. 返回上一级目录 cd ../.. 返回上两级目录 cd 进入个人的主目录 cd ~user1 进入个人的主目录 cd - 返回上次所在的目录 pwd 显示工作路径 ls 查看目录中的文件 ls -F 查看目录中的文件 ls -l 显示文件和目录的详细资料 ls -a 显示隐藏文件 ls * [0-9] * 显示包含数字的文件名和目录名 tree 显示文件和目录由根目录开始的树形结构lstree 显示文件和目录由根目录开始的树形结构mkdir dir1 创建一个叫做 &apos;dir1&apos; 的目录&apos; mkdir dir1 dir2 同时创建两个目录 mkdir -p /tmp/dir1/dir2 创建一个目录树 rm -f file1 删除一个叫做 &apos;file1&apos; 的文件&apos; rmdir dir1 删除一个叫做 &apos;dir1&apos; 的目录&apos; rm -rf dir1 删除一个叫做 &apos;dir1&apos; 的目录并同时删除其内容 rm -rf dir1 dir2 同时删除两个目录及它们的内容 mv dir1 new_dir 重命名/移动 一个目录 cp file1 file2 复制一个文件 cp dir/ * . 复制一个目录下的所有文件到当前工作目录 cp -a /tmp/dir1 . 复制一个目录到当前工作目录 cp -a dir1 dir2 复制一个目录 ### 存放D:\\virtualbox资源putty.exe ## project要求老师的结构main：file scannertcp listenserfile downloader主函数开三个进程，最后和另外两个机器打招呼---file scanner： 无尽循环1.遍历share文件夹2.用文件size和lastmodifytime对比已存在的文件信息字典3.如果有任何变化，发送news【就是更新的文件信息字典装在list里面】【news转换为json字符串】给同伴，发送之前必须保证对方的服务器没有问题。---tcp listenser： 1.listen a port(不是无尽循环可以终止)2.(无尽循环)有新的连接加入，就创建一个新线程，然后把连接传给新的子线程任务 子线程任务： 3个消息需要检查：news,hello,get_file request. 1.news【就是更新的文件信息list,他说的是传list】 如果接收到新的news就准备下载,不是立刻下载！！，只是给一个下载器ticket 2.hello 本机文件全部列表【接收别人的全部的文件list,返回自己的文件list】如果接收到新的news就留ticket给下载器准备下载 3.get_file: 请求需要的文件块。如果要文件传的快，要用长连接。---file downloader： 无尽循环 0.1秒扫描一次1.检查news文件list给的ticket2.下载最早的ticket 2.1.用list里的字典检查文件的size/lmt,如果本机的list存在这个文件名，而且size和lmt一致，就跳过不下载。 2.2.对于第一个文件块，创建空文件xxx.yyy.lefting(要创建文件夹)，用相同的size(填0)？？？ 2.3.一个接一个的接收文件块，遇到任何的error都停止接收，删除，然后下载下一个文件，如果文件块已经接收成功，把记录写在ticket上(接收了几个文件块) 2.4.当文件全部接收，删除ticket,关闭文件，改文件名xxx.yyy.lefting.3.更新文件字典，本机的和临时的。---进程和线程之间共享的变量：from multiprocessing import Processimport threadingimport multiprocessing as mp两个全局变量给文件扫描线程 args=(g_peers,g_file_dict)，他说不用globalg_peers = mp.Manager().list([])g_file_dict = mp.Manager().dict(&#123;&#125;)创建文件扫描进程/线程---协议：4bytes: json header size4bytes: binary data sizejson header(binary) ------- &quot;news&quot;: ,&quot;hello&quot;: ,&quot;get_file&quot;: ,binary data---tcp socket发送的东西需要符合协议---文件名share/123/456.txt,接收时做文件夹--- 两个全局变量给文件扫描线程 args=(g_peers,g_file_dict)，他说不用globalg_peers = mp.Manager().list([])g_file_dict = mp.Manager().dict({}) STATE_READY =1STATE_NOT_READY = 0DEFAULT_PORT = 20000BUFFER_SIZE_LAOSHI = 210241024BLOCK_SIZE_LAOSHI = BUFFER_SIZE_LAOSHI/2NO_FILE = 401FILE_CHANGED = 402OVER_BLOCK_INDEX = 403 def get_md5(b): def make_package(d,b=None): def get_tcp_package(connection) 下面是file scannerdef file_scanner(folder, file_dict, file_dict_local,peers,state): def print_file_dict(file_dict) def traverse(dir_path): def send_file_list(addr,file_list): def save_file_dict(file_dict,fn): 下面是file 下载器def file_downloader(file_dict, file_dict_local): 下面 tcp listenerdef tcp_listener(server_port, file_dict, state): server_socket = socket(AF_INET,SOCK_STREAM) # 1.closesocket（一般不会立即关闭而经历TIME_WAIT的过程）后想继续重用该socket： server_socket.setsockopt(SOL_SOCKET ,SO_REUSEADDR,1) server_socket.bind((‘’,server_port)) server_socket.listen(28) print(“start tcp server”) state[‘tcp_listener’] = STATE_READY while True: connection_socket, addr = server_socket.accept() print(“&lt;&lt; new connection from”, addr) th = threading.Thread(target=sub_connection, args=(connection_socket,addr,file_dict)) th.daemon = True th.start() def sub_connection(connection_socket,addr,file_dict): def check_new_file(peer,remote_file_dict,file_dict): 解析命令行用我自己的def say_hello(peers,file_dict): # 这里是客户端 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136---文件list区别：file1 A只有file1，B C 完全空file2 A有file1 B有file1+file2+一个新文件夹 C有file1file3 A有file1+2+一个新文件夹 B有file1+file2+一个新文件夹 C有file1+2+一个新文件夹+file3修改前0.1%file3 A有file1+2+一个新文件夹+file3,B有file1+2+一个新文件夹+file3,C有file1+2+一个新文件夹+修改过的file3---对添加/修改的file3-判断文件有么有改变可以使用lastmodifytime然后task2是要重传，最好是续传，反正最后是要重新获取到完整的文件，你能续传自然快---三个虚拟机 三份代码 全部开启两个ipVMA开启一直跑while true 手动ctrl c结束，跑的时候不能报错误。在VMA项目代码文件夹中add file1 大概10mb到 VMA的“共享文件夹”。【共享在项目代码那个文件夹里】VMB开启无报错，VMB里的应用将拿到他add的file1 然后把它放到VMB的share文件夹中。他要检查VMB里的file1的md5,记录时间VMC开启无报错，VMC里的应用将拿到他add的file1 然后把它放到VMB的share文件夹中。他要检查VMC里的file1的md5,记录时间他要add 1个G的file2 和 一个任何名字的文件夹(装了50个文件) 到VMB的share文件夹中。1个G的file2 和 一个任何名字的文件夹(装了50个文件) 要同步到VMA和VMC的共享文件夹里在他把 1个G的file2 和 一个任何名字的文件夹(装了50个文件) 装到VMB之后，2s过后，他会手动结束掉VMA上的程序所有文件和文件夹会被同步到VMC。他会检查file2的md5,和文件夹中所有文件的md5，和记录file2和文件夹的时间他重启VMA上的程序，那么所有文件夹和文件应该和VMC上的一样，他会检查VMA上的md5他会add 200mb的file3 到VMC的共享文件夹200mb的file3要同步到VMA和VMB他会把VMC上的file3从第一个字节开始的 0.1%部分替换成其他的二进制数据。更新的file3文件会部分同步更新在VMA和VMB. 他会检查VMAVMB上的md5. 记录同步过去的时间压缩不会直接测试，但是file2(1个g)可以被压缩到很小的size数据安全性不会直接测试，他会检查代码。因为加密会浪费时间，请使用“--encryption yes”参数打开加密函数。每个app开两个ip是拿来找另外两台虚拟机的。设置接收两个Ip.file1,2,3是任意名字。尝试获取file最新的修改的时间去检测文件的更新。当一个新file已经完全被添加/更新了之后就开始传输。不要input()函数，自动启动自己分割他启动的ip 用argparse格式：For each virtual machine, your app will be started as:python3 main.py --ip 192.168.xxx.xxx,192.168.xxx.xxxVMA 开VMB 和VMC 的ipVMB 开VMA 和VMC 的ipVMC 开VMA 和VMB 的ip自己测试的时候用 paramiko ---要求Python socket实现大型的文件共享格式：任何格式，包括隐藏文件和文件夹大小：单个文件高达1GB自动：更改的文件可以自动同步部分更新：部分更改的文件可以部分更新 比如把他分成10blocks，对比md5就知道那部分是更新的，只更新那部分。压缩：压缩可用于减小总尺寸 压缩虽然要用cpu但是可以减轻带宽，你可以用?去决定这部分是需要压缩还是不压缩。对于bmp图片文件，可以压缩到非常小。用到压缩可以在下面测试中用更少的时间IP地址应设置为参数从中断中恢复：老师的办法：在这个host接收别的host传过来的文件的时候，建立两个文件，一个是data,一个是record.如果文件传输中断了，你可以读record知道到哪一个block了，然后重新接收这个block.任何文件无错误:老师会检查每个文件的md5错误恢复后不需要重新传输 自己找方法，他说是lecture学的数据传输安全 网上有很多方法，拿来用就能拿到分数应用层协议：您可以设计自己的协议传输层协议： TCP；或UDP；或混合。C/S(简单)可使用20000到30000之间的任何端口；您可以使用一个或多个端口。 老师建议一个note可以用十个多个port，可以加快传输速度多个py文件，老师建议这样做让代码更清晰，但是只有一个入口main.py但只有一个应用程序。“客户机”和“服务器”没有区别。通用模块：os, sys, socket, struct, hashlib, math, tqdm, numpy用于加密的任何模块任何压缩模块Struct: 使用struct模块将文件名和大小转化为二进制串发送给接收方---1. Any code error, any code error!!!A: I will not help you with any code error. You are learning network module. You are using the Internet to send me an email and you can search and debug using the Internet. Try google, StackOverflow and Github. 2. About resending files after unexpected interruption:A: Please refer to “Code testing steps”- 93. Why 2 IP addresses are given for testing the code?A: These 2 IP addresses are used to find the other two machines. Actually, it is better for you to support a flexible number of machines. But, let’s do it simply. I only test the case of three machines. 4. Don’t know how to start.A: Firstly, open PyCharm. Secondly, start to write something. Thirdly, run, and debug your code. Flowchart and FSM will help you and make your mind clear. Maybe a cup of espresso will also make you better. BTW, my office hour is prepared for you. Come to talk with me without an appointment during office-hour.5. Filename problem.A: Normally, we don’t include space in the file name. So, File 1 will not be the name. I will use any file name. 6. How to start transmission?A: Start to transfer when a new file is already added or updated (try to get the last modification time of a file to detect the updating). After running your code (app), I will not directly operate your app, which means I will not input any command to your app. All the functions of your app should be auto.7. How to add a file to the “share” folder of CWD?A: For me, I will use soft link of Linux (ln -s) to add a file withing coping tile. If you want to simulate this operation. Please use “ln -s /xxx/xxx/file_xxx.big /xxx/xxx/CWD/share/file_xxx.big”. If you want to update the original file. Please “rm” the link and add the link again: rm /xxx/xxx/file_xxx.big /xxx/xxx/CWD/share/file_xxx.bigln -s /xxx/xxx/file_xxx.big /xxx/xxx/CWD/share/file_xxx.big8. How to transfer a big file from your computer to the virtual machine (core CW1)?A: As the space of the root of the virtual machine is not very big, you should mount another driver to the home folder. Open the terminal of virtual machine and follow me please: cd ~ mkdir data sudo mount /mnt/sda1 ~/data/ sudo chown tc ~/data Back to your OS: For macOS, open terminal: scp big_file tc@192.168.53.x:/home/tc/data/ For Windows, pscp can be found in a full putty package. pscp big_file tc@192.168.53.x:/home/tc/data/or xshell is better but not free. 12345678910111213149. About hidden file:A: No hidden file will be tested.10. How to understand server and client:A: Your app can send a file to another machine and can receive it from another machine. Don&apos;t play word games### 进展- 11.16压缩加传输：client: 把filename压缩到tar_file路径再向服务器发送tar_file filename = “D:\\材料-公众号-爬虫小说\\py爬取的文件\\小说\\慎言bl” 压缩tar_file = “D:\\大三上学期\\CAN201 网络\\Projects作业1\\文件传输测试\\客户端\\中文压缩.tar.gz”compressB.compress(tar_file,[filename]) 1serve: 最后一行 把接收的文件filename(在py项目下面)解压到文件解压后小说文件夹(在py项目下面) compressB.decompress(filename, “解压后小说”)``` 材料1.py-csdn-第一个速度慢讲解tcp udp https://blog.csdn.net/qq_38898129/article/details/89300413tcp代码 https://blog.csdn.net/qq_38898129/article/details/89481229udp代码 https://blog.csdn.net/qq_38898129/article/details/89319767 handbook管理他们的操作，成功的计算机网络的设计和组织原则，以及当代互联网中使用的关键协议和技术。[A] 计算基本网络性能统计数据（例如平均吞吐量），给定网络配置和参数。[B] 应用标准网络算法，如（距离向量、ARP发现，虚拟电路设置）针对具体问题，演示中间和最终州。[C] 分析并实现标准网络协议的简单版本。[D] 在给定一组期望的网络参数的基础上，设计新的协议来解决该网络的具体目标[E] 为给定问题选择并使用现有的网络安全协议 lab每周二上午11点 SC464做python和networking, 有签到 syllabus课程安排w1: networking基础理论 编译器w2: application layer应用层 principles,web,http 基本语法w3: application layer应用层 email,dns,p2p,多媒体协议protocols 数据结构：列表和字典w4: 传输层 multiplexing,udp,可靠数据传输 文件操作，网络编程w5: 传输层 tcp,堵塞 协议，解析包w6: 网络层 router,internet,IPv4,IPv6 模块，PIPw8: 网络层 routing算法，control plane OOPw9: 连接层 error correction,ethernet 平行计算w10: 连接层 link visualization 课上test 应用w11: 物理层 硬件交流媒体 intro,switch setupw12: 网络安全 公钥，授权 配置switch接口w13: 网络安全 公钥，授权 VLAN 配置w14: 复习和quiz router setup lecturew1 networking基础理论1.什么是internet2.什么是协议 Protocols define format, order ofmessages sent and received amongnetwork entities, and actions taken onmessage transmission, receipt (All communication activity inInternet governed by protocols) 3.看不下去了4.网络安全 网络带宽是指在单位时间（一般指的是1秒钟）内能传输的数据量。 w4w5w6lablab6 MODOULE,PIP模块：Python 提供了一个办法，把这些定义存放在文件中，为一些脚本或者交互式的解释器实例使用，这个文件被称为模块。 怎么用模块：import module_namefrom module_name import methods A.pyimport A就可以用 A.方法名() A.pyfrom A import 方法1名就可以用 方法1() 调用A中的这个方法 文件夹-A.pyfrom 文件夹名 import A 就可以用 A.方法名()并行计算：import multiprocessing 进程库import threading 线程库 multiprocessing 在处理高并行任务时进程间不需要相互通信，除了将初始化数据送到进程池的时候和收集结果的时候。thread 和 process的代码非常相似 复制粘贴尝试lab6的代码用thread 或者 process 老师喜欢process进程作业1注意老师用mac path /a/bwindows是\\a\\b 王道考研第一章 计算机网络的功能： 1.数据共享2.资源共享3.分布式处理 多台计算机共同承担同一工作任务的不同部分 hadoop平台4.提高可靠性 一台崩了有替代机5.负载均衡 分布式处理达到的效果，工作任务均衡的分配给各台计算机 计算机网络的组成 1.组成部分 硬件，软件，协议2.工作方式 边缘部分(用户直接使用)：c/s方式-客户端服务器；p2p对等方式 核心部分： 为边缘部分服务3.通信子网，资源子网 计算机网络的分类 1.分布范围分类： 广域网WAN(跨国)，城域网MAN(跨城)，局域网LAN(千米)，个人区域网PAN2.按照使用者分：共用网，专用网3.按交换结构分：电路，报文，分组交换4.按拓扑结构分 5.按传输技术分标准化性能指标：利用率 信道利用率速率带宽 理想条件下吞吐量 1s能接受多少数据 throughput: min{Rc , Rs , R/10}时延 传播，传输过程时延带宽积 传播时延带宽相乘 网络带宽是指在单位时间（一般指的是1秒钟）内能传输的数据量。 往返时间网络结构-分层结构：协议[水平]：对等实体之间的功能的规定，规定他们之间可以做什么事情，有什么功能，所有是水平协议协议的三个约定：语法(传输数据格式)，语义(完成的功能)，同步(数据报操作顺序) 接口：上层使用下层的入口 仅仅在相邻层直接有接口，为上层提供接口，屏蔽细节 服务[垂直]：下层为相邻上层提供功能调用 每一个中间层次都是为上层提供服务，用下层所有层次的服务总和 ISO/OSI参考模型 理论成功，市场失败TCP/IP模型 和 五层参考模型王道考研 第二章 物理层王道考研 第六章 应用层https://blog.csdn.net/vip97yigang/article/details/78306837?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param https://blog.csdn.net/FanceFu/article/details/79357105?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param Application architectures​ 1.client-server 客户端-服务器：​ 应用：web,文件传输FTP,远程登录，电子邮件 2.P2P 对等模型： 网络中的传输内容都不会保存在服务器上，每个节点都有上传/下载的功能。每个主机可以提供服务也可以请求服务。任意节点之间都可以直接通讯。网络健壮性强(一个结点坏掉不影响)。 • Application service requirements• reliability, bandwidth, delay• Internet transport service model• connection-oriented, reliable: TCP • unreliable, datagrams: UDP • Specific protocols: HTTP SMTP, POP, IMAP DNS P2P: BitTorrent 电子邮件系统SMTP, POP, IMAP一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件发送协议和读取协议。发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。 POP3 简单读取POP3 的特点是只要用户从服务器上读取了邮件，就把该邮件删除。从接受邮件服务器读取邮件到用户代理(客户端) IMAP 比pop3复杂IMAP 协议中客户端和服务器上的邮件保持同步，如果不去手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。IMAP 协议也支持创建自定义的文件夹。从接受邮件服务器读取邮件到用户代理(客户端) SMTPSMTP 只能发送 ASCII 码(不能传送可执行文件/对象)，而互联网邮件扩充 MIME 可以发送二进制文件。MIME协议 并没有改动或者取代 SMTP，而是增加邮件主题的结构，定义了非 ASCII 码的编码规则(让他能传非ASCII 码)。 SMTP简单邮件传送协议过程：1.连接建立2.邮件发送3.连接释放 域名系统DNS (DNS服务器给域名返回ip地址)例：某用户通过主机A浏览西安交大的主页 www.xjtu.edu.cn A向本地域名服务器DNS查询 如果DNS上有www.xjtu.edu.cn的记录，就立即返回IP地址给主机A(cn顶级域名，edu二级域名，xjtu三级域名，www四级域名) 如果DNS上没有该域名记录，则DNS向根域名服务器发出查询请求 根域名服务器把负责cn域的顶级域名服务器B的IP地址告诉DNS DNS向B查询获得二级域名服务器C的IP地址，最终迭代查询到www.xjtu.edu.cn的ip直接返回DNS 递归查询Recursive query(靠别人一条线查下去再原路返回给主机,比较少用)：主机发出DNS查询请求-去 跟域名服务器 查顶级域名的ip地址(com/edu/org)-去找对应的 顶级域名服务器 查顶级域名注册的所有二级域名的ip(baidu.com)-权限域名服务器 迭代查询Iterated query(靠自己)：主机找y.abc.com的ip地址-本地域名服务器找根域名服务器-根域名服务器告诉找哪个顶级域名服务器-本地域名服务器去找顶级域名服务器-顶级域名服务器告诉应该找哪个权限域名服务器-查到ip地址-返回给本地域名服务器-返回给主机。（实现给域名返回ip地址） • Socket programming: 传输协议是UDP还是TCPFTP文件传送协议(提供不同种类主机系统之间的文件传输能力 上传/下载)运输层使用UDP和TCP协议的各种应用和应用层协议应用 应用层协议 运输层协议名字转换 DNS(域名系统) UDP文件传送 TFTP(简单文件传送协议) UDP路由器选择协议 RIP(路由信息协议) UDPIP地址配置 DHCP(动态主机配置协议) UDP网络管理 SNMP(简单网络管理协议) UDP远程服务器 NFS(网络文件系统) UDP多播 IGMP(网际组管理协议) UDP电子邮件 SMTP(简单邮件传送协议) TCP远程终端 TELNET(远程终端协议) TCP万维网 HTTP(超文本传送协议) TCP文件传送 FTP(文件传送协议) TCP 网络电话 UDP 万维网WWW是无数个网页的集合URL形式(不分大小写)： &lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt; 超文本传输协议 1.W3CWorld Wide Web Consortium(万维网联盟)Web技术领域的国际中立性技术标准机构 2.W3C标准结构化标准语言(html,xml)表现性标准语言(css) 行为标准(dom文档对象模型,ecmascript JS的规范) 认识http,https http: 超文本传输协议（用TCP） 以明文形式传输 效率更高，但是不安全 https: http + ssl(TCP的加强版，称为安全套接字层（Secure Sockets Layer，SSL）) 传输之前数据先加密，之后解密获取内容 效率较低，但是安全 http协议之请求报文 1.请求行 get url http/1.1 || 方法 url 版本 CRLF(回车换行) 2.请求头： host:域名，不是ip connection：keep-alive 客户端告诉服务端我们支持使用长连接，不频繁的建立、断开连接。只在最开始建立，最后断开。(服务器在发送响应后保持该TCP连接打开，后续的请求和响应报文能通过相同的连接进行发送。)只需要进行一次 TCP 连接就能进行多次 HTTP 通信。HTTP/1.1开始，所有的连接默认都是持久连接。 cache-control: max-age=0 缓存控制。客户端告诉服务端不做任何缓存 user-agent: 浏览器的身份标识。对方服务器知道你是什么浏览器在请求服务器。 cookie: 保存浏览器本地的用户信息。访问网站带上cookie。如果要请求登录之后才能访问的网站就要处理cookie. 3.请求体 例子：Remote Address:116.57.254.104:80 Request URL:http://hr.tencent.com/ Request Method:GET Status Code:200 OK Request Headers GET / HTTP/1.1 Host: hr.tencent.com Connection: keep-alive Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,/;q=0.8 User-Agent: Mozilla/5.0 http协议之响应报文 初始状态行（status line），首部行（header line）和实体体（entity body），实体体部分是报文的主要部分，即它包含了所请求的对象本身。状态行有三个字段：协议版本字段（the protocol version field）、状态码(statuscode)和相应状态信息(corresponding status message)。 1.响应头 set-cookie: 对方服务器通过该字段设置cookie到本地 2.响应体 url地址对应的响应 秦jiajun-应用层一、应用层核心原理Principles of Network Applications （Eng.verP112, 中译版P54-55）研发网络应用程序的核心是写出能够运行在不同的端系统和通过网络彼此通信的程序。当研发新应用程序时，不需要写在网络核心设备如路由器或链路层交换机上运行的软件，因为网络核心设备并不在应用层上起作用，而仅在较低层起作用。 网络应用程序体系结构（主流有两种）Ⅰ. 客户-服务器体系结构（client-server architecture）服务器Server：一台总是打开的主机有固定的、周知的地址性能高客户Client：与服务器连接来请求服务间歇性连接网络有动态的地址客户互相之间不直接通信Ⅱ.P2P体系结构（P2P architecture）主机对之间使用直接通信，这些主机被称为对等方（peers）对等方从其他对等方请求服务，并向其他对等方提供服务。自拓展性（Self-scalability）：具体见（Eng.verP115, 中译版P57）对等方之间间歇连接IP地址是动态的（P2P有自拓展性，其体系结构成本效率高，因为是点对点的模型，其传输速度更加快速，类似文件共享、对等方协助下载器（如迅雷）、网络视频电话等都用P2P体系结构） 进程（Process）通信（Eng.verP116-118, 中译版P57-59）1）Processesin different/same hosts:当进程运行在同一个端系统（host）上时，它们使用进程间通信机制相互通信。当进程运行在不同的端系统上时，它们通过跨越计算机网络的报文（message）相互通信在一对进程之间的通信会话场景中，发起通信的进程被标识为客户（Client），在会话开始时等待联系的进程是服务器（Sever）在某些P2P应用中，一个进程可能既是客户也是服务器。2）进程寻址（Addressing Processes）为了接收进程，需要定义两种信息①主机的地址：在因特网中，主机有单独的唯一标识的32-bit（IPV4）and/or128-bit（IPV6）的量叫做IP地址（IP Address）②在目的主机中指定接收进程（更具体应为接收套接字socket）的标识符：目的地端口号port number）Q: Can a process have multiple network identifiers?A: Yes. 可供应用程序使用的运输服务四类应用程序服务要求： [1]四类应用程序服务要求(ppt16页)选择的网络应用要求： [2]选择的网络应用要求(ppt17页)4.因特网提供的运输服务（详见Eng.verP121-124, 中译版P60-62）Ⅰ.TCPTCP提供可靠的数据传送服务TCP具有拥塞控制机制TCP具有面向连接服务TCP不提供timing,minimum throughput guarantee, security的保证。Ⅱ. UDPUDP服务是一种不提供不必要服务的轻量级运输协议。它仅提供最小服务。UDP是无连接的也就是说通信之前没有握手；UDP不提供数据的可靠传输；UDP也没有拥塞控制机制。注：看起来UDP服务并不是很好，但仍然有应用首先选择UDP服务（如因特网电话应用），因为它们能够容忍某些丢失但要求达到一定的最小速率才能有效工作，运行在UDP上能够设法避开TCP的拥塞控制机制和分组开销。但同时也因许多防火墙被配置成阻挡（大多数类型的）UDP流量，所以因特网电话应用通常设计成如果UDP通信失败就用TCP作为备份（详见Eng.verP123, 中译版P62） [3]流行的因特网应用及其应用层协议和支撑的运输协议(ppt12页)5.SSL（详见Eng.verP122, 中译版P61）简单来说，TCP和UDP都没有提供任何加密机制，而隐私和其他安全问题对许多应用而言至关重要，所以因特网界研发出了TCP的加强版，称为安全套接字层（Secure Sockets Layer，SSL）。注意，SSL并不是与TCP和UDP在同层次上的第三种运输协议，而是一种对TCP的加强，其强化在应用层上实现。用SSL加强后，TCP不仅能够做传统TCP所能做的一切，而且提供了关键的进程到进程的安全性服务。二、Web和HTTP1.HTTP概况1）HTTP——超文本传输协议（Hyper Text Transfer Protocal），它是Web的应用层协议，是Web的核心。HTTP有两部分实现，一个客户端程序一个服务器程序。2）Web页面（WebPage）是由对象（object）组成，它们通过一个URL地址进行寻址。多数Web页面含有一个HTML基本文件（base HTML file）以及几个引用对象。URL地址由两部分组成：存放对象的服务器主机名和对象的路径名。客户和服务器交互的核心思想是客户通过HTTP请求对服务器发出对Web页面的请求报文，服务器收到该报文后将返回包含该对象的HTTP响应报文。（详细解释和例子见Eng.verP126-127，中译版P64-65）3）HTTP使用TCP作为它的支撑运输协议。步骤：①HTTP客户首先发起一个与服务器的TCP连接，port80②服务器接受TCP连接③HTTP报文从客户端（browser）和服务器（Webserver）之间传递。④关闭TCP连接HTTP是无状态协议（statelessprotocol）——服务器根据请求作出响应，但是不存储任何关于该客户的状态信息。2.非持续连接和持续连接（Non-Persistentand Persistent Connections）（详见Eng.verP128-131，中译版P65-67）非持续连接：每个请求/响应（request/response）经一个单独的TCP连接发送持续连接：所有的请求及响应经相同的TCP连接发送HTTP在其默认情况下使用持续连接，但也可配置成非持续连接。Ⅰ. 采用非持续连接的HTTP：从服务器向客户传送一个Web页面的步骤（步骤和例子详见Eng.ver P129，中译版P66）每个TCP连接在服务器发送一个对象后就会关闭，即每个TCP只传送一个请求报文和响应报文。往返时间（Round-TripTime, RTT）——timefor a small packet to travel from client to server and back roundtrip time 该时间是指一个短分组从客户到服务器然后再返回客户所花的时间。 [4] 请求并接收一个HTML文件所需的时间估算(ppt34页)上图为请求并接收一个HTML文件所需的时间估算。浏览器在它和Web服务器之间发起一个TCP连接，即为“三次握手（three-way handshake）”的过程，即客户向服务器发送一个小TCP报文段，服务器用一个小TCP报文段做出确认和响应，最后客户向服务器返回确认。三次握手中前两部分耗时一个RTT。客户结合第三次握手（确认）向该TCP连接发送一个HTTP请求报文，一旦该请求报文到达服务器，服务器便在该TCP连接上发送HTML文件。该HTTP请求/响应用去另一个RTT。粗略地说，总的响应时间为两个RTT加上服务器传输HTML文件的时间。Ⅱ.采用持续连接的HTTP非持续连接大致有两个缺点：1）必须为每一个请求的对象建立和维护一个全新的连接，这可能给Web服务器带来严重的负担。2）每一个对象经受两倍RTT的交付时延。持续连接的特点：服务器在发送响应后保持该TCP连接打开，后续的请求和响应报文能通过相同的连接进行发送。对对象的请求可以一个接一个地发出，而不必等待对未决请求的回答。对于所有引用的对象几乎只需要一个RTT。Q:Is persistent HTTP perfect?A:No. It depends on the environment. If you want to save bandwidths,the persistent HTTP is better, but if you want to increase the speed,the non-persistent HTTP is better. (毕竟用户能够配置现代浏览器来控制连接的并行度，详见Eng.verP129，中译版P66) 3.HTTP报文格式（HTTP Message Format）(Eng.verP131-136，中译版P67-70)HTTP报文有两种：请求报文和响应报文。Ⅰ.HTTP请求报文（HTTPrequest message） [5]典型的HTTP请求报文（PPT37-38页）HTTP请求报文的第一行叫做请求行（requestline），其后继的行叫做首部行（headerline）。请求行有三个字段：方法字段、URL字段和HTTP版本字段。 [6]一个HTTP请求报文的通用格式(ppt第41页)HTTP1.1 的方法： [7]HTTP 1.0 1.1的方法字段的值（PPT43页）HTTP报文内容及方法用法需要看Eng.verP131-133，中译版P67-68.Ⅱ.HTTP响应报文（详见Eng.verP133-136，中译版P69-70） [8]一个HTTP响应报文的通用格式http请求报文格式和响应报文格式https://blog.csdn.net/bamboo_cqh/article/details/90403740响应报文有三个部分：初始状态行（status line），首部行（header line）和实体体（entity body），实体体部分是报文的主要部分，即它包含了所请求的对象本身。状态行有三个字段：协议版本字段（the protocol version field）、状态码(statuscode)和相应状态信息(corresponding status message)。一些常见的状态码和相关的短语：200 OK：请求成功，信息在返回的响应报文中。301 MovedPermanently：请求的对象已经被永久转移了，新的URL定义在响应报文的Location：首部行中。客户软件将自动获取新的URL。400 Bad Request：一个通用差错代码，指示该请求不能被服务器理解。404 Not Found：被请求的文档不在服务器上。505 HTTP Version Not Supported：服务器不支持请求报文使用的HTTP协议版本。接下来就是查看真实的HTTP响应报文，安装好Telnet工具后，详情见Eng.verP135，中译版P69-70，PPT第52页。 4.用户与服务器的交互：Cookies User-Server Interaction: CookiesHTTP是无状态协议，但是Web站点为了识别用户,或者限制用户的访问，或者它希望把内容与用户身份联系起来，为此HTTP使用了Cookie。cookie技术的4个组件：①在HTTP响应报文中的一个cookie首部行；②在HTTP请求报文中的一个cookie首部行；③在用户端系统中保留有一个cookie文件，并由用户的浏览器进管理；④位于Web站点的一个后端数据库。详情和例子于PPT55页，Eng.verP136-138，中译版P70-71Cookies可用于：标识一个用户，在无状态的HTTP之上建立一个会话，购物车，购物时的推荐。Cookie的使用是有争议的，因为它们被认为是对用户隐私的一种侵害（想象某宝上买完物品后，各种APP浏览器上全是有关物品的相关推荐，更严重的是个人信息会被记录甚至会泄露，平时使用需要多加注意删除cookies文件）。 5.Web缓存WebCaching（Eng.verP138-144，中译版P72-75）1）Web缓存器（Web cache）也叫作代理服务器（proxy server），它是能代表初始Web服务器来满足HTTP请求的网络实体。可以配置用户的浏览器，使得用户的所有HTTP请求首先指向Web缓存器，一旦某浏览器被配置，每个对某对象的浏览器请求首先被定向到该Web缓存器。如果浏览器正在请求某对象，如果对象副本在缓存器中，则返回该对象；若不存在，缓存器则会从初始服务器请求该对象，并返回该对象给客户。（详见Eng.verP138-139，中译版P72）。[9]客户通过Web缓存器请求对象（PPT60页）2）Web缓存器既是服务器又是客户，接受浏览器的请求并响应时是服务器，向初始服务器发出请求并接收响应时是客户。Web缓存器通常由ISP购买并安装。部署Web缓存器的原因：①Web缓存器可以大大减少对客户请求的响应时间。②Web缓存器能够大大减少一个机构的接入链路到因特网的通信量。通过减少通信量，该机构就不必急于增加带宽，因此降低了费用。③Web缓存器能从整体上大大减低因特网上的Web流量，从而改善了所有应用的性能。书上的例子，详见Eng.verP140-142，中译版P73-74，PPT62-66页。 6.条件GET方法The Conditional GET(Eng.ver P142-144，中译版P74-75)缓存器会带来问题，例如保存在服务器中的对象自该副本缓存在客户上以后可能已经被修改了（即过时了），为了不发送该过时对象，条件GET（Conditional GET）机制就有了意义。cache: specify date of cached copy in HTTP requestIf-modified-since:server: response contains no object if cached copy is up-to-date:HTTP/1.0304 Not Modified注意最后的响应报文中，状态行中为304 Not Modified，它告诉缓存器可以使用该对象，能向请求的浏览器转发它缓存的该对象副本。 三、因特网中的电子邮件Electronic Mail in the Internet(Eng.ver P144-154，中译版P75-83)因特网电子邮件系统由3个部分组成：用户代理（useragent）、邮件服务器（mail server）和简单邮件传输协议（SimpleMail Transfer Protocol, SMTP）邮件服务器构成了电子邮件系统的核心。每个接收方在某个邮件服务器上有一个邮箱（mail box）。一个典型的电子邮件发送过程为：从发送方的用户代理开始，传输到发送方的邮件服务器，再传输到接收方的邮件服务器，然后在这里被分发到接收方的邮箱中。 [10]因特网电子邮件系统的总体描述 1.SMTPSMTP是因特网电子邮件中主要的应用层协议，是因特网电子邮件的核心。SMTP有两个部分：运行在发送方邮件服务器的客户端和运行在接收方邮件服务器的服务器端。当一个邮件服务器向其他邮件服务器发送邮件时，他就表现为SMTP的客户；当邮件服务器从其他邮件服务器上接收邮件时，他就表现为一个SMTP的服务器。SMTP的基本操作及例子，详见Eng.verP146-147，中译版P77。 [11]When sending an email, how the email works. (PPT 71页)SMTP一般不使用中间邮件服务器发送邮件，即使这两个邮件服务器位于地球的两端也是如此。若A向B发送邮件，如果B的邮件服务器没有开机，该报文会保留在A的邮件服务器上并等待进行新的尝试，这意味着邮件并不在中间的某个邮件服务器存留。SMTP将一个报文从发送邮件服务器传送到接收邮件服务器的过程，见Eng.verP147-148，中译版P77-78.2.与HTTP的对比共同点：两个协议都用于从一台主机向另一台主机传送文件。当进行文件传送时，持续的HTTP和SMTP都使用持续连接。不同点：①HTTP主要是一个拉协议（pull protocol），特别是TCP连接是由想接收文件的机器发起时。而SMTP基本上是一个推协议（push protocol），特别是TCP连接是由想要发送文件文件的机器发起的。（详意见Eng.verP149，中译版P78-79）。②SMTP要求每个报文采用7-bitASCII码格式，HTTP数据不受这种限制。③对于处理一个既包含文本，又包含图形的文档，HTTP把每个对象封装到自己的HTTP响应报文中；而SMTP则把所有报文对象放在一个报文之中。 3.邮件报文格式Mail Message Formats (Eng.ver P149-150，中译版P79)典型的报文首部看起来如下：From:alice@crepes.frTo:bob@hamburger.eduSubject:Searching for the meaning of life 邮件访问协议Mail Access Protocols(Eng.ver P150-154，中译版P79-83)现代的邮件访问使用了一种客户-服务器体系结构，及典型的用户通过在用户端系统上运行的客户程序来阅读电子邮件（然而这种方便的结构需要解决其带来的和引发的问题，这里讨论的邮件访问协议便提供了帮助，详情看书）。需注意，SMTP是邮件服务器之间发送邮件报文的协议，并不是用户通过代理和邮件服务器之间通信的协议。而目前流行的一些邮件访问协议，包括第三版邮局协议（Post Office Protocol-Version3, POP3）、因特网邮件访问协议（InternetMail Access Protocol, IMPA）以及HTTP解决了这个问题。 [12]电子邮件协议及实体通信（PPT74页）上图总结了应用于因特网电子邮件的一些协议：SMTP用来将邮件从发送方的邮件服务器传输到接收方的邮件服务器；SMTP也用来将邮件从发送方的用户代理传送到发送方的邮件服务器。如POP3这样的邮件访问协议用来将邮件从接收方的邮件服务器传送到接收方的用户代理。有关POP3、IMAP、基于Web的电子邮件需看书Eng.verP151-154，中译版P81-83.","categories":[],"tags":[]},{"title":"INT201 决策计算与语言(编译原理)","slug":"INT201-决策计算与语言","date":"2020-09-07T03:09:54.000Z","updated":"2020-11-27T13:57:00.837Z","comments":true,"path":"2020/09/07/INT201-决策计算与语言/","link":"","permalink":"https://lucifinil-x.github.io/2020/09/07/INT201-决策计算与语言/","excerpt":"作业和考试INT201 决策计算与语言 AssCW x2 + 网上开卷考试(2h) = 10分x2 + 80分","text":"作业和考试INT201 决策计算与语言 AssCW x2 + 网上开卷考试(2h) = 10分x2 + 80分 复习计划首先阅读中文卷子。作为复习https://wenku.baidu.com/view/5189a6e3524de518964b7d50.htmlttl,ass所有题背过程和格式。期末卷做，对答案 资源学什么 自动机 编译原理 离散1.定义语言2.建立编译器去识别语言3.识别语言特征4.识别两种描述是不是同一种语言 自动机1.自动机是什么自动机是一种理想化的“机器”，它只是抽象分析问题的理论工具，并不具有实际的物质形态。它是科学定义的演算机器，用来表达某种不需要人力干涉的机械性演算过程。根据不同的构成和功能，自动机分成以下4种类型：有限自动机（finite automata, FA）、下推自动机（pushdown automata, PDA）、线性界限自动机（linear-bounded automata）和图灵机（Turing machine）。 四种自动机https://www.jianshu.com/p/f1e279a47b04 Lectureweek1如何让自动机识别词语transition diagram 画图DFA/NFA week3闭包{a,b}* {c,d}*word可以是 aaabbbaabaaaccccdccdd a在b前面，c在d前面A={a,b}{a,b}* aaa{a,b}* = A* aaa A*这个包含一个aaa的substring. b* ab* ab* ab* :strings with 3 a’s 因为只有3个a A* aA* aA* aA* :strings with at least 3 a’s 因为有3个单独的a,A闭包里也有aEn:EEEEE…(n个E) E+:EE* 或 E* E (至少一个单独的E)闭包运算的等式以及证明lecture4-p18 123456[是并集，(R*)* = R*R(R*) = (R*)RR(R*) [ * = R*R(SR)* = (RS)*R(R [ S)* = (R* [ S*)* = (R*S*)* = R*(S(R*))* 闭包的包含子字符串：(ab)* =ababab 以a开头，以b结尾(ba)* =bababa 以b开头，以a结尾(ab)* 里包含子字符串ab, (ba)* 里包含不子字符串ab！许博:你就当 a b是包含单个字母的字符表就是了 许博:比如，a就只包含a，b就只包含b 许博:ab就是ab 许博:ba就是ba 许博:ab怎么可能等于ba 翻译图像路径成字符串lecture5-p6向下箭头为暂停当前短路径，一个{}里装的是转折结点前的几个路径。 编译原理视频前后文无关文法和语言A^0 = {空集}， A^1=A, A^2=AA正闭包 A+ = A^1 + A^2 + … +A^n自反传递闭包 A* = A^0 + A^1 + A^2 + … +A^n = A^0 + 正闭包 = {空集} + 正闭包 形式语言与自动机 定义FA = finite automaton自动机DFA：确定的有穷状态自动机 对任意的q∈Q，a∈∑,δ(q,a)都可以跳到确定的值而且唯一 确定有限自动机(DFA)：自动机的每个状态都有对字母表中所有符号的转移。 正则语言能被DFA识别的语言=正则语言 https://blog.csdn.net/xiaokui008/article/details/6843471DFA（Deterministic Finite Automation ）：确定的有限自动机 表达式：M=（S，∑，f，So，Z） 1.S为一个有限状态集合 2.∑是一个字母表，它所包含的的每个元素称为一个输入字符； 3.f是一个从SX∑（笛卡尔乘积）至S的单值部分映射。f（S，a）=s’意味着当现在的状态为s，输入字符a时，将转换到下一状态s’.s’为s的一个后继状态。 4.So∈S，是唯一的初态； 5.Z⊆S，是一个终态集。 NFA（Nondeterministic Finite Automata）：不确定的有限自动机 如果理解了有限自动机，则无限自动机和它的区别就是上面的第四项。 So⊆S，它的初态不是唯一的，而是一个集合。 这里的:Q 是状态的非空有穷集合。∑ 是符号的有限集合，我们称为这个自动机接受的语言的字母表。 输入字符串都是∑上的字符串δ 是状态转移函数(对于非确定自动机，空串是允许的输入)。q0 是开始状态，就是说自动机在还未处理输入的时候的状态(明显的 q0∈ Q)。 F 是终止状态集合，也叫做接受状态的 Q 中的状态的集合(就是 F⊆Q)。NFA M=（S，∑，f，So，Z） M=(状态集，字符表，状态转换函数，初态，终态) {}隔开例： 设NFA M=（{q0,q1},{0,1},,{q0}{q1}）两个状态：q0,q1能够识别两个符号：0,1开始状态：q0终止状态：q1q0—–q1 q0通过 0 是在q0上转一圈回到q0q0通过 1 是从q0到q1 从q0到q1：1.可以通过很多次0，再1 -&gt; 0* 12.可以通过很多次0，再很多次1 -&gt; 0* 1* (闭包)3.可以通过很多次0，再很多次1,再很多次0 -&gt; 0* 1* 0*关键点：通过0无法到达终态，必须要有1所以这个自动机识别的语言是：至少包含一个1的二进制串。 编译原理看这一篇就够了https://blog.csdn.net/LeeDuoZuiShuai/article/details/104882488?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param 文法与语言2.1 符号串和语言2.1.1 字母表1.定义：字母表是有穷非空的符号集合。2.表示：通常用字母表大写字母A，B，…Z和希腊字母Σ表示。eg：A={0,1}，Σ={a,b,c,d}3.说明1）字母表包含了语言中所允许出现的一切符号。2）字母表中的符号也称字符。 2.1.2 符号串1.定义：由字母表中的符号组成的有穷序列。2.表示：通常由t，u，v，w，x，y，z等小写英文字母来表示。3.说明 1）符号串由构成的符号的种类、数量、顺序共同决定。 2）不包含任何符号的符号串称为空符号串，简称空串，用ε表示。4.对于给定的字母表Σ，符号串的递归定义如下： 1）ε是Σ上的一个符号串。 2）若x是Σ上的符号串，a是Σ的符号，则xa是Σ上的符号串。并规定εa=a，aε=a。 3）y是Σ上的符号串，当且仅当y由1）和2）导出。5.子符号串：一个非空符号串中若干连续符号组成的部分。6.字符串的前缀和后缀 若z=abd是字母表Σ={a,b,c,d}上的符号串，则ε，a，ab，abd都是z的前缀；ε，d，bd，abd都是z的后缀。7.符号串之间的运算 1）连接：符号串x，y的连接xy就是把符号串y写在x后面得到的字符串。 eg：若x=ab，y=cd，则xy=abcd，yx=cdab。 2）方幂：若x是符号串，xn表示n个按顺序连接。当n=0时，x0是空符号串ε。 2.1.3 语言1.定义：由字母表上的一些符号串组成的集合。2.说明 空集Ø是一个语言，仅含一个空符号串的集合{ε}也是一个语言。Ø和{ε}是不同的语言。3.符号串集合之间的运算 1）并集 设A和B是符号串的集合，则A和B的并集定义为 A∪B = {x | x∈A or x∈B}。 2）乘积 设A和B是符号串的集合，则A和B的乘积定义为 AB = {xy | x∈A and y∈B}。 eg：若A={a,b}，B={b,c}，则AB = {ab,ac,bb,bc}。 对任意符号串集合A，有{ε}A = A{ε} = A。 3）幂运算 设A是符号串的集合，则A的幂运算定义为 A0 = {ε} A1 = A An = AAn-1（n&gt;0） eg：若A={0,1}，则A0={ε}，A1={0,1}，A2={00,01,10,11}。 4）正闭包与闭包 设A是符号串的集合，则集合A的正闭包A+和闭包A定义为 A+ = A1∪A2∪…∪An∪… A = A0∪A1∪…∪An∪… eg：若A={0,1}，则A+={0,1,00,01,10,11,000,001,…}，A * ={ε,0,1,00,01,10,11,000,001,…}。 2.2 文法和语言的形式化定义2.2.1 文法的形式化定义1.产生式规则 1）定义：一个产生式规则是一个有序对(A，α)。通常写作A→α或A::=α。 ”→”或”::=”表示“定义为”、“由…组成”、“生成”。 2）含义： A→α表示左部符号A生成右部符号串α。 3）若A→α；A→β，则可以写成A→α|β。”|”表示“或”。 4）非终结符号：产生式规则左部出现的符号。 5）终结符号：不是非终结符号的符号。 6）非终结符号既可以出现在产生式规则的左部，也可以出现在产生式规则的右部。终结符号不能出现在产生式规则的左部。 7）非终结符号通常用大写字母或尖括号括起来的部分表示。2.文法 1）定义：产生式规则的非空有穷集合。由四元组G=(VN，VT，P，Z)组成。 2）VN：是一个非空有穷集合。它的每个元素称为非终结符号。且VN∩VT=Ø。 3）VT：是一个非空有穷集合。它的每个元素称为终结符号。 4）P：是文法规则(产生式规则)的非空有穷集合，每个产生式规则的形式是A→α或A::=α，其中A∈VN，α∈(VN∪VT)* 。 5）Z：是一个非终结符号。称为开始符号或识别符号。它至少要在一条产生式规则的左部出现。有它开始识别定义的语言。 6）通常不必将文法的四元组显式地表示出来，而仅需给出文法的产生式规则集。 7）对于两个不同的文法G[Z]和G’[E]，若这两个文法生成的语言相同，则称这两个文法是等价的。 2.2.2 语言的形式化定义1.直接推导与推导 1）直接推导：令G=(VN，VT，P，Z)，若A→γ∈P，且α,β∈(VN∪VT)，则称αAβ直接推导出αγβ，表示成αA ⇒ βαγβ。 2）推导：若存在一个直接推导序列：α0⇒α1⇒α2⇒…⇒αn，则称这个序列是一个从α0至αn的长度为n的推导。 当n&gt;0时，α0至αn的推导记为α0 ⇒+ αn，表示从α0出发，经过1步或者若干步可推导出αn。 当n≥0时，α0至αn的推导记为α0 ⇒ αn，表示从α0出发，经过0步或者若干步可推导出αn。2.句型和句子设有文法G[Z]，Z是文法G的开始符号。 1）句型：若Z ⇒* x，x∈(VN∪VT)* ，则称符号串x为文法G[Z]的句型。 2）句子：若Z ⇒* x，x∈VT* ，则称符号串x为文法G[Z]的句子。 3）句子一定是句型，句型不一定是句子。3.语言 1）定义：文法G[Z]产生的所有句子的集合称为文法G所定义的语言，记为L(G[Z])，简写为L(G)。L(G)={x| Z ⇒+ x且x∈VT * }。 2）语言L(G)是VT * 的子集。 3）L(G)中的每一个符号串均由终结符号组成，且该符号串能由开始符号Z推导出来。4.递归规则(直接递归) 1）定义：一个产生式规则中，出现在左部的非终结符也出现在其右部。 2）种类：左递归、右递归、递归。 3）左递归：A→A… 4）右递归：A→…A 5）递归：A→…A…5.文法递归 1）定义：对于文法中的任一非终结符，若能建立一个推导过程，在推导所得的符号串中又出现该终结符本身，则称文法是递归的。 2）种类：左递归、右递归、递归。 3）左递归：A ⇒+ A… 4）右递归：A ⇒+ …A 5）递归：A ⇒+ …A… 2.2.3 短语、直接短语、句柄设G[Z]是一个文法，假定αβδ是文法G的一个句型。 1）短语：若存在Z ⇒+ αAδ且A ⇒+ β，则称β是句型αβδ相对于非终结符A的短语。【所有组成部分】 2）直接短语：若存在Z ⇒+ αAδ且A⇒β，则称β是句型αβδ相对于产生式规则A→β的直接短语。【+ 连接的几个部分】 3）句柄：一个句型的最左直接短语称为该句型的句柄。【+左边】 例题1、对于文法G(E): (8分) ET|E+T TF|TF F(E)|i 1. 写出句型(T F+i)的最右推导并画出语法树。 2. 写出上述句型的短语，直接短语、句柄和素短语。 答： 1. (4分) ETF(E) (E+T) (E+F) (E+i) (T+i) (T* F+i) 2. (4分) 短语：(TF+i), T*F+i, T F, i 直接短语：T* F, i 句柄：T* F 素短语：T* F, i 例题2：给出句型 (E+T)* i+F 的短语，素短语和最左素短语。短语 i, F, E+T, (E+T), (E+T)i, (E+T)i+F 素短语 i, E+T 最左素短语 E+T 2.2.4 规范推导和规范归约1.最左推导：对一个推导序列中的每一步直接推导α⇒β，都是对α中的最左非终结符进行替换。2.最右推导(规范推导)：对一个推导序列中的每一步直接推导α⇒β，都是对α中的最右非终结符进行替换。3.规范句型：由规范推导得到的句型。4.最左归约(规范归约)：规范推导的逆过程。 2.3 语法分析树与文法的二义性2.3.1 语法分析树1.语法分析树：一个句型推导过程的树形表示称为语法分析树，简称语法树。2.满足条件：设G=(VN，VT，P，Z)是一个上下文无关文法。 1）根节点的标记为Z。 2）根节点外的每个节点也有一个标记，它是VN∪VT∪{ε}中的符号。 3）每一个内部节点的标记A必在VN中。 4）若某个内部节点标记为A，其孩子节点的标记从左到右分别为X1，X2，…，Xn，则A→X1X2…Xn必为P中的一条产生式规则。 5）若节点有标记ε，则该节点为叶子，且是它父亲唯一的孩子。3.构造步骤：已知文法G[Z]，对于w，若Z ⇒* w，则 1）以开始符号Z为标记的根节点。 2）对每一步推导，根据使用的产生式规则生成一颗子树，直到所有叶子节点从左到右的标记符号连接为w为止。 若产生式规则为A→X1X2…Xn，则生成以A为根节点的子树，其孩子节点从左到右分别为X1，X2，…，Xn。 eg：设文法G[E]： E→E+T|E-T|T T→TF|T/F|F F→(E)|i 推导句型T+i(F-i)的语法树。 语法树就是把推导过程化成树的层次。https://wenku.baidu.com/view/1b65b98b7d192279168884868762caaedd33ba80.html2.3.2 文法的二义性1.定义：若一个文法存在某个句子对应两棵不同的语法树，则称这个文法是二义的。【L(G)的某个句子对应不只一个最左/最右推导】2.特点：为编译程序的执行带来不确定性。 2.3.4 二义性的消除1.不改变文法：通过附加限制性条件消除二义性。寻找充分不必要条件，当文法满足这些条件时可确保文法是无二义性的。2.改变文法：改写原有文法，把排除二义性的规则合并到原文法消除二义性。 2.4 文法的化简1.若一个非终结符不能推导出终结字符串，则该非终结符是无用的，删除所有包括该非终结符的产生式规则。2.若一个符号不能出现在文法的任何句型中，则该符号是无用的，删除所有包括该符号的产生式规则。 2.5 语言的分类1.0型文法(短语文法) 1）定义：若文法G[Z]=(VN，VT，P，Z)中的每个产生式规则的形式为：α→β，其中α∈(VN∪VT)且至少含有一个非终结符号，而β∈(VN∪VT)，则G[Z]为0型文法。 2）特点：0型文法的能力相当于图灵机，识别能力最强。2.1型文法(上下文敏感文法) 1）定义：若文法G[Z]=(VN，VT，P，Z)中的每个产生式规则的形式为：αAβ→αvβ，其中α,β∈(VN∪VT)，A∈VN，v∈(VN∪VT)+，则G[Z]为1型文法。3.2型文法(上下文无关文法) 1）定义：若文法G[Z]=(VN，VT，P，Z)中的每个产生式规则的形式为：A→v，其中A∈VN，v∈(VN∪VT)，则G[Z]为2型文法。 2）特点：语法结构上下文无关，一般用于识别程序设计语言的语法结构。4.3型语言(正规文法) 1）种类：右线性文法、左线性文法 2）右线性文法：若文法G[Z]=(VN，VT，P，Z)中的每个产生式规则的形式为：A→αB或A→α，其中A,B∈VN，α∈(VN∪VT)，则G[Z]为右线性文法。 3）左线性文法：若文法G[Z]=(VN，VT，P，Z)中的每个产生式规则的形式为：A→Bα或A→α，其中A,B∈VN，α∈(VN∪VT)，则G[Z]为左线性文法。 4）特点：作为定义程序设计语言规则的文法 5）正规语言：3型文法定义的语言。 第三章 词法分析与有限自动机3.1 词法分析器的设计3.1.1 词法分析器的任务1.功能：输入源程序，输出单词符号。 3.1.2 词法分析器的输出格式单词是程序的基本语言单位。通常，输出的单词符号表示成二元式：(单词种类，单词符号的属性值)。单词种类：关于单词种类的整数编码。单词符号的属性值：反应单词符号特性或特征的值。1.单词的种类 1）关键字：eg：while、if、else 2）标识符：eg：变量名、数组名、函数名… 3）常数：eg：80、1.23、“Hello“… 4）运算符：eg：算术运算符、逻辑运算符、关系运算符… 5）界限符：eg：,、:、[、]、{、}…除了五类单词，还包括空格符、回车符、换行符等。 3.2 词法分析器的手工构造3.2.1 确定的有限自动机1.定义：一个确定的有限自动机(DFA) M是一个五元组：M=(S，Σ，δ，s0，F)，其中： 1）S是一个有限集，它的每一个元素称为一个状态。 2）Σ是一个有穷字母表，它的每个元素称为一个输入字符。 3）δ是一个从S×Σ到S的单值部分映射。δ(s，a)=s’表示在目前状态s下输入字符为a时，将转换到下一个状态s’。s’被称为s的一个后继状态。 4）s0∈S，s0是唯一的初态。 5）F ⊆S，F是一个终态集，可以为空。2.DFA的状态转移矩阵 DFA可用一个二维矩阵表示，矩阵的行表示状态，列表示输入字符，矩阵元素表示δ(s，a)的值。3.DFA的状态转换图 若设DFA M含有m个状态和n个输入字符，则这个图含有m个状态结点，每个结点至多有n条箭弧射出与其它的状态结点相连接，每个箭弧用Σ中的一个不同输入字符作为标记。整张图含有唯一的初态结点和若干终态结点。4.DFA识别字符串 1）对Σ上的任何符号串w∈Σ* ，若存在一条从初态结点到某一终态结点的通路，且该通路上所有弧的标记符连接成的字符串等于w，则称w可被DFA M所识别。若M的初态结点同时又是终态结点，则空字符串ε被M所识别。 2）DFA与语言的关系：DFA M所能识别的符号串的全体记为L(M)。 eg：设DFA M=({0,1,2,3}，{a,b}，δ，{3})，其中，δ定义为： δ(0，a)=1，δ(0，b)=2，δ(1，a)=3，δ(1，b)=2，δ(2，a)=1，δ(2，b)=3，δ(3，a)=3，δ(3，b)=3。 δ的递归扩展定义 对一个DFA M，其识别的语言L(M)={w|w∈Σ，若存在Z∈F，使δ(s0，w)=Z}，其中：w=ua∈Σ，则δ(s，ε)=s，δ(s，ua)= δ(δ(s，u)，a)。 3.3 有限自动机及其化简有限自动机包括 确定有限自动机 和 不确定有限自动机。 3.3.1 不确定有限自动机1.定义：一个不确定有限自动机(NFA) M是一个五元组：M=(S，Σ，δ，S0，F)，其中： 1）S是一个有限集，它的每一个元素称为一个状态。 2）Σ是一个有穷字母表，它的每个元素称为一个输入字符。 3）δ是一个从S×Σ到S的子集的映射，即δ：S×Σ→2S 4）S0⊆S，S0是一个非空初态集。 5）F ⊆S，F是一个终态集，可以为空。2.NFA的状态转换图 若设NFA M含有n个状态和m个输入符号，则这个图含有n个状态结点，每个结点可射出若干箭弧与其它的状态结点相连接。对于w∈{ε}∪Σ，若δ(q0，a)={q1，q2，…，qk}(k≥0)，则从q0出发，分别到q1，q2，…，qk的k条弧，弧上均标记为a。整张图含有唯一的初态结点和若干终态结点。4.NFA识别字符串 1）对Σ*上的任何符号串，若存在一条从某一初态结点到某一终态结点的通路，且该通路上所有弧的标记符号依次连接成的字符串等于w，则称w可被NFA M所识别。若M的某些结点同时又是终态结点，则空字符串ε被M所识别。 2）NFA与语言的关系：Σ 中所有可被NFA M所识别的符号串的集合记为L(M)。5.DFA和NFA的关系 1）DFA是NFA的特例，NFA是DFA概念的推广。 2）NFA能识别的语言都能被一个DFA识别。 3）DFA相对NFA的识别程序更容易实现。 3.3.2 不确定有限自动机的化简1.NFA的确定化：对任给的NFA M。都能相应地构造一个DFA M‘，使得L(M’)=L(M)。2.NFA的化简思路：DFA的每一个状态代表NFA状态集合的某个子集，构造的DFA使用它的状态去记录NFA读入输入符号之后可能到达的所有状态的集合。3.闭包：若q为一初始状态s0，让a为ε，则δ(s0，a)={q1，q2，…，qk}为所有等价的状态结点构成的集合，这个集合被称为s0的ε闭包。记为ε-Closure(s0)。4.推广：集合I的ε-Closure(I)设I是NFA M的状态集的子集，定义I的ε闭包ε-Closure(I)： 1）若q∈I，则q∈ε-Closure(I)。 2）若q∈I，则从q出发经过任意条ε弧而能到达的任何状态q’，有q’∈ ε-Closure(I)。 eg：将下图NFA M确定化。 【图】根据终态和非终态划分为两个子集：Π1={A，B，F}，Π2={C，D，E，G}。 对Π1，输入b，状态A、B经过b可到达终态，而F经过b不能到达终态。因此Π1划分为两个子集Π11={A，B}和Π12={F}。 对Π11，输入bb，A经过bb可到达终态，而B不能，所以A和B是可区别的两个状态。 故Π1划分为{A}、{B}、{F}三个子集。 对Π2，输入b，划分成两个子集Π21={C，E}和Π¬22={D，G}。 对Π21，输入a，划分成两个子集{C}和{E}。 故Π2划分成{C}、{E}、{D，G}。 最终状态集合划分成：{A}、{B}、{F}、{C}、{E}、{D，G}。 【图】","categories":[],"tags":[]},{"title":"python爬虫小说","slug":"python爬虫小说","date":"2020-09-03T15:37:45.000Z","updated":"2021-02-18T13:44:57.665Z","comments":true,"path":"2020/09/03/python爬虫小说/","link":"","permalink":"https://lucifinil-x.github.io/2020/09/03/python爬虫小说/","excerpt":"爬虫是什么爬虫是一个程序，能够拿到信息，可见即可爬先爬一章-一本-全站编译器安装b站视频安装，公众号安装包D:\\python\\ (b2)pycharm安装，python环境搭建 -&gt;安装包D:\\Python3.7.2 -&gt;python自己D:\\PyCharm2019\\PyCharm Community Edition 2019.1.3 -&gt;pycharm编译器D:\\PyCharm2019\\Python Project -&gt;py项目仓库","text":"爬虫是什么爬虫是一个程序，能够拿到信息，可见即可爬先爬一章-一本-全站编译器安装b站视频安装，公众号安装包D:\\python\\ (b2)pycharm安装，python环境搭建 -&gt;安装包D:\\Python3.7.2 -&gt;python自己D:\\PyCharm2019\\PyCharm Community Edition 2019.1.3 -&gt;pycharm编译器D:\\PyCharm2019\\Python Project -&gt;py项目仓库 用css选择器爬一章小说需要的函数库 import requests找不到这个库，需要在setting里安装：project interpreter 点+号查找https://blog.csdn.net/qq_41838901/article/details/89885475 requests是http请求库， 互联网建立在http协议上 审查元素-networking-all-ctrl+r-点开一行-点header-request method查看请求方式：get/post url统一资源定位符 相当于门牌号，根据url就可以请求到内容 from pyquery import PyQuery网页解析器(css解析)需要在setting里安装 封装爬一本小说一章节的方法def get_one_chapter(chapter_url=None, name=None): ip池57分钟 爬一整本(反叛)问题两个函数都没问题，爬一本的时候出不来。因为获取的links里第一条不是url所以改变获取url的css选择器(直接在标题那个地方右键复制选择器) 但是前面两个还是没有用反叛的大魔王 https://www.liuzhishu.com/反叛的大魔王 https://www.liuzhishu.com/book22983/反叛的大魔王 https://www.liuzhishu.com/book22983/4135499.html反叛的大魔王 https://www.liuzhishu.com/book22983/4135501.html 所以要去掉前面的链接for link in links.items(): # 这个links里包含前面两个链接 下面这个进行强制类型转换成列表，去掉前面两个for link in list(links.items())[2:]: 爬全站1：20 爬一本练习(被爱幻想) 目录 https://m.ruochenwx.com/131382/审查元素-networking-all-ctrl+r点击本页面html,Request URL: https://m.ruochenwx.com/131382/ Request Method: GET 改def get_index():1.目录参数 index_url2.每章超链接选择器参数 links = doc(‘ul.read a’)3.书名选择器参数 name = doc(‘p.name’).text()4.遍历列表的去除数字 for link in list(links.items())[1:]:5.补全每章链接 /131382/21107531.html -&gt; https://m.ruochenwx.com/131382/21107531.html 改def get_one_chapter(chapter_url=None, name=None):1.每行选择器参数 content = doc(‘div.content p’).text()2.每章名字选择器参数 title = doc(‘.headline’).text() 问题：目录上每章只有一个html,但是每章有分页，必须找到每章的所有链接 编程思路： 寻找分页地址的变动规律 解析网页，获取内容，放入自定义函数中 调用函数，输出分页内容 用css选择器爬囚徒(有分页，自己分段)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import requestsfrom pyquery import PyQueryimport refrom lxml import etreedef get_one_chapter(chapter_url=None, name=None): response = requests.get(url=chapter_url) doc = PyQuery(response.text) # body &gt; div.article_title &gt; div.main &gt; div.chapter p contentAll = doc(&apos;div.chapter p&apos;).text() # 所有p标签里的内容都在contentAll contentLines = contentAll.split(&quot; &quot;) #把contentAll里分段存到数组contentLines # #chapter &gt; h1 class=headline title = doc(&apos;div.article_title &gt; h1&apos;).text() with open(file=name + &quot;.txt&quot;, mode=&quot;a+&quot;, encoding=&quot;utf-8&quot;) as f: f.write(title + &quot;\\n\\n&quot;) for contentLine in contentLines: # forin循环取出数组中的每一行 后面加\\n contentLine += &quot;\\n&quot; f.write(contentLine)def get_index(): index_url = &apos;http://www.77nt.win/74717/&apos; text = requests.get(url=index_url).text doc = PyQuery(text) links = doc(&apos;dl a&apos;) # dl标签 a后代 name = &apos;囚徒&apos; # http://www.77nt.win/74717/1.html 章节第一页 # http://www.77nt.win/74717/1-2.html 章节第二页 for link in list(links.items())[9:]: strXuanzeqiGet = link.attr.href # /74717/1.html strinfo = re.compile(&apos;.html&apos;) # print(strinfo) b = strinfo.sub(&apos;&apos;, strXuanzeqiGet) # strXuanzeqiGet去掉&apos;.html&apos; # b= /74717/1 urls = [&apos;.html&apos;, &apos;-2.html&apos;] #每一章的几页的url /74717/1 之后的 数组 for url in urls: #chapter_url = &quot;http://www.77nt.win&quot; + /74717/1 + .html #chapter_url = &quot;http://www.77nt.win&quot; + /74717/1 + -2.html chapter_url = &quot;http://www.77nt.win&quot; + b + url print(name, chapter_url) # 囚徒 /74717/1.html 所以要加上http://www.77nt.win get_one_chapter(chapter_url=chapter_url, name=name)get_index() 用xpath爬狱警与黑老大开始的乱码要删掉啊，不然运行多少次都不会覆盖上的 123456789101112131415161718192021222324252627282930313233343536373839404142434445import requestsfrom pyquery import PyQueryimport refrom lxml import etreedef get_one_chapter(chapter_url=None, name=None): response = requests.get(url=chapter_url) response.encoding = &quot;utf-8&quot; res_xpath = etree.HTML(response.text) content = res_xpath.xpath(&apos;//*[@id=&quot;chaptercontent&quot;]/text()&apos;) title = res_xpath.xpath(&apos;//title/text()&apos;) with open(file=name + &quot;.txt&quot;, mode=&quot;a+&quot;, encoding=&quot;utf-8&quot;) as f: w = str(title[0]) + &quot;\\n&quot; for con in content: w += str(con) w += &apos;\\n&apos; f.write(w)def get_index(): index_url = &apos;http://m.qiliuxs.com/29_29125/all.html&apos; text = requests.get(url=index_url).text doc = PyQuery(text) # #chapterlist &gt; p:nth-child(2) &gt; a links = doc(&apos;#chapterlist a&apos;) # &lt;title&gt;武林豪杰皆我奴-v文章节目录,武林豪杰皆我奴-v文最新章节全集_7766小说网手机版&lt;/title&gt; name = &apos;武林豪杰皆我奴&apos; for link in list(links.items())[1:]: str1 = link.attr.href strinfo = re.compile(&apos;.html&apos;) b = strinfo.sub(&apos;&apos;, str1) print(b) urls = [&apos;_&#123;&#125;.html&apos;.format(str(i)) for i in range(1, 4)] for url in urls: chapter_url = &apos;http://m.qiliuxs.com&apos; + b + url print(name, chapter_url) get_one_chapter(chapter_url=chapter_url, name=name)get_index() 用css选择器爬御宅屋特点：总目录页分页，每章分页 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import requestsfrom pyquery import PyQueryimport re# 关键字参数，指定了None,调用函数时候这两个变量就可以互换位置。不写None的话调用函数必须准守参数位置# chapter_url章节url name书名def get_one_chapter(chapter_url=None, name=None): response = requests.get(url=chapter_url) doc = PyQuery(response.text) # 拿到的text进行解析 content = doc(&apos;body p&apos;).text() # 拿到.article里的内容 title = doc(&apos;h1&apos;).text() # #nr_title contentLines = content.split(&quot; &quot;) # 把contentAll里分段存到数组contentLines with open(file=name + &quot;.txt&quot;, mode=&quot;a+&quot;, encoding=&quot;utf-8&quot;) as f: f.write(title + &quot;\\n\\n&quot;) for contentLine in contentLines: # forin循环取出数组中的每一行 后面加\\n contentLine += &quot;\\n&quot; f.write(contentLine)# 获取一本书所有章节的url+书名，把拿到的每章的链接丢到上面get_one_chapter函数中就能拿到所有的章内容def get_index(index_url=None): # 目录 text = requests.get(url=index_url).text doc = PyQuery(text) # PyQuery(text)解析 links = doc(&apos;li a&apos;) # #jsList1 &gt; li:nth-child(1) &gt; a 用li标签的后代 a # name = doc(&apos;h1&apos;).text() name = &quot;斯德哥尔摩by花臂熊猫&quot; for link in list(links.items()): chapter_url = link.attr.href # 提取出a标签中的href属性(链接)/read/69571/7502147.html # 每一章里有分页 两个分页。目标：/read/69571/7502147.html -&gt; /read/69571/7502148_1.html /read/69571/7502148_2.html reHtml = re.compile(&apos;.html&apos;) after_re = reHtml.sub(&apos;&apos;, chapter_url) #after_re = /read/69571/7502147 add_urls = [&apos;_1.html&apos;, &apos;_2.html&apos;] for add_url in add_urls: print(&apos;https://yzwbl.com&apos;+after_re+add_url) get_one_chapter(chapter_url=&apos;https://yzwbl.com&apos;+after_re+add_url, name=name)# 目录页https://yzwbl.com/indexlist/69571/0/ 到 https://yzwbl.com/indexlist/69571/6/# 写入文件是追加模式，这里已经有0了 从1到6运行 range(1,7)def main(): index_urls_list = [] for num in range(1,7): index_urls_list.append(&apos;https://yzwbl.com/indexlist/69571/&apos; + str(num) + &apos;/&apos;) print(index_urls_list) for index_url in index_urls_list: get_index(index_url=index_url)main() 做两次跳转的函数这个网站需要搜索关键词然后爬，这个链接是POSThttp://m.qiliuxs.com/s.php 用.text()抓取下来的文字乱码https://www.zhihu.com/question/394323691.检查网页用的字符集 123# Requests 推测的文本编码（也就是网页返回即爬取下来后的编码转换）与源网页编码不一致，由此可知其正是导致乱码原因。print(res.encoding) #查看网页返回的字符集类型 ISO-8859-1print(res.apparent_encoding) #自动判断字符集类型 utf-8 当源网页编码和爬取下来后的编码转换不一致时，如源网页为gbk编码的字节流，而我们抓取下后程序直接使用utf-8进行编码并输出到存储文件中，这必然会引起乱码，即当源网页编码和抓取下来后程序直接使用处理编码一致时，则不会出现乱码，此时再进行统一的字符编码也就不会出现乱码了。最终爬取的所有网页无论何种编码格式，都转化为utf-8格式进行存储。 2.乱码的解决方法解决一： 获取到response之后直接指定res.encoding = “utf-8” 12345678示例：import requestsurl = &quot;http://search.51job.com&quot;res = requests.get(url)res.encoding = &quot;utf-8&quot;html = res.textprint(html) http/https介绍详细完整https://www.cnblogs.com/woai3c/p/12902325.html 认识http,https http: 超文本传输协议 以明文形式传输 效率更高，但是不安全 https: http + ssl(TCP的加强版，称为安全套接字层（Secure Sockets Layer，SSL）) 传输之前数据先加密，之后解密获取内容 效率较低，但是安全 http协议之请求 1.请求行 get … http/1.1 2.请求头： host:域名 connection：keep-alive 客户端告诉服务端我们支持使用长连接，不频繁的建立、断开连接。只在最开始建立，最后断开。(服务器在发送响应后保持该TCP连接打开，后续的请求和响应报文能通过相同的连接进行发送。)只需要进行一次 TCP 连接就能进行多次 HTTP 通信。HTTP/1.1开始，所有的连接默认都是持久连接。 cache-control: max-age=0 缓存控制。客户端告诉服务端不做任何缓存 user-agent: 浏览器的身份标识。对方服务器知道你是什么浏览器在请求服务器。 cookie: 保存浏览器本地的用户信息。访问网站带上cookie。如果要请求登录之后才能访问的网站就要处理cookie. 3.请求体 http协议之响应 1.响应头 set-cookie: 对方服务器通过该字段设置cookie到本地 2.响应体 url地址对应的响应 爬虫是模仿浏览器去发送请求 抓包：看浏览器发送了什么请求 get和post请求的区别 get请求没有请求体，post有，get请求吧数据放到url地址中 post请求常用于登录注册/传输大文本 Cookie和Session 两个数据存放在哪里？cookie数据存放在客户的浏览器上；session数据放在服务器上。 cookie的特点和限制是什么？ cookie不是很安全，因为别人可以分析存放在本地的COOKIE并进行COOKIE欺骗。 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。 两个数据里能存什么？cookie里只能存放字符串；session里能存放任何类型的数据，如字符串、集合、类、对象。 用户能看见吗？cookie对用户可见；session对用户不可见(透明) 有效期的差别？ 比如浏览器上百度账号登录信息长期有效？cookie可以容易的达到登录信息长期有效，只要把有效期设为很大的数字；session不能长期有效，容易导致服务器的内存溢出。比如说我们项目使用jwt设置了有效期7天。 并发访问的用户多的时候，用哪个来追踪用户会话？用cookie。因为一个用户就会产生一个session/cookie. session存在服务器端，产生的session量过大会消耗大量的内存。 cookie存在客户端，不占用服务器端的资源，一个用户手里拿一个cookie。所以像百度这种只能用cookie来存储用户的登录信息，用cookie来追踪用户会话。 为什么百度贴吧、百度云盘、百度搜索都可以共用我的登录信息呢(不用重复登录)？因为cookie支持跨域名访问，以“.biaodianfu.com”为后缀的一切域名均能够访问该Cookie。但是session就不支持跨域名访问，如果用session,都要重新登录。 session在服务器端由谁来管理？存在哪里？session由shiro来管理，shiro六大作用之一就是Session会话管理。在ShiroConfig(shiro配置类)中就有会话管理对应的函数-SessionManager. 现在用cookie和session吗？前后端没分离的时候用cookie和session来验证用户的真实性；现在前后端分离了，我们使用shiro这个安全框架来规定用户的操作，使用token和jwt来验证用户的真实性。 post-有道翻译网页检查1.动态页面用networking-xhr-headers中找Request URL: http://fanyi.youdao.com/translate_o?smartresult=dict&amp;smartresult=rule Form Data(post的表单)：i: 重复from: AUTOto: AUTOsmartresult: dictclient: fanyideskwebsalt: 16121560255974sign: c94d4735db490259191c1678221aadc1lts: 1612156025597bv: e915c77f633538e8cf44c657fe201ebbdoctype: jsonversion: 2.1keyfrom: fanyi.webaction: FY_BY_REALTlME 2.用networking-xhr-preview/response里找post返回的字典中的翻译结果在哪里。 程序步奏1.用控制台输入待翻译词语2.设定待请求的url3.建立post表单(字典形式)4.发起post请求5.接收响应结果，解析提取6.打印出翻译的结果 程序代码1234567891011121314151617181920212223242526272829303132import requestsimport jsonwhile True: content = input(&quot;输入要翻译的词语:&quot;) # 退出机制-无字符空字符 if content == &quot;&quot;: print(&quot;无有效输入，退出。&quot;) break url = &quot;http://fanyi.youdao.com/translate?smartresult=dict&amp;smartresult=rule&quot; # 网站反扒措施translate_o，改成translate post_form = &#123;&apos;i&apos;: content, &apos;from&apos;: &apos;AUTO&apos;, &apos;to&apos;: &apos;AUTO&apos;, &apos;smartresult&apos;: &apos;dict&apos;, &apos;client&apos;: &apos;fanyideskweb&apos;, &apos;salt&apos;: &apos;16121560255974&apos;, &apos;sign&apos;: &apos;c94d4735db490259191c1678221aadc1&apos;, &apos;lts&apos;: &apos;1612156025597&apos;, &apos;bv&apos;: &apos;e915c77f633538e8cf44c657fe201ebb&apos;, &apos;doctype&apos;: &apos;json&apos;, &apos;version&apos;: &apos;2.1&apos;, &apos;keyfrom&apos;: &apos;fanyi.web&apos;, &apos;action&apos;: &apos;FY_BY_REALTlME&apos; &#125; # 提交post请求后会返回响应，然后解析响应的text属性为json response = requests.post(url,data=post_form) response_json = response.text # json变成dict对象才能提取里面的东西. # 网页的东西&#123;translateResult: [[&#123;tgt: &quot;Have a hair&quot;, src: &quot;发发发&quot;&#125;]], errorCode: 0, type: &quot;zh-CHS2en&quot;,…&#125;从里面提取tgt res_dict = json.loads(response_json) result = res_dict[&quot;translateResult&quot;][0][0][&quot;tgt&quot;] print(result) 豆瓣读书网址分析豆瓣读书-小说页面-分页页面https://book.douban.com/tag/小说?start=80&amp;type=T 分析分页链接url的规律MIN start=0MAX start=980一页 start += 20 中文字符串-&gt;ASCII码123456789import urllib.request# url复制过来是中文变成ascii码 https://book.douban.com/tag/%E5%B0%8F%E8%AF%B4?start=20&amp;type=T# urllib.request库中的quote函数将中文字符串转换成ascii码key1 = &quot;小说&quot;key2 = &quot;novel&quot;key_ASCII1 = urllib.request.quote(key1)key_ASCII2 = urllib.request.quote(key2)print(key_ASCII1)print(key_ASCII2) 爬取小说页面所有分页html.py12345678910111213141516171819import urllib.requestimport requests# url复制过来是中文变成ascii码 https://book.douban.com/tag/%E5%B0%8F%E8%AF%B4?start=20&amp;type=T# urllib.request库中的quote函数将中文字符串转换成ascii码key1 = &quot;小说&quot;key_ASCII1 = urllib.request.quote(key1)url = &quot;https://book.douban.com/tag/&quot; + key_ASCII1 + &quot;?start=&quot; + str(0) + &quot;&amp;type=T&quot;# 换一种for range()# requests.get(url,headers=headers) 用User-Agent做headers伪装浏览器才能爬取到，不然爬下来的打开空白 .这样做很快headers = &#123; &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.83 Safari/537.36&quot;&#125;for i in range(0,50): paging_url = &quot;https://book.douban.com/tag/&quot; + key_ASCII1 + &quot;?start=&quot; + str(i*20) + &quot;&amp;type=T&quot; response = requests.get(paging_url,headers=headers) data = response.text file_path = &quot;D:\\材料-公众号-爬虫小说\\py爬虫-豆瓣读书\\小说分页内容\\第&quot; + str(i) + &quot;页.html&quot; with open(file_path, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f: f.write(data) 使用BeautifulSoup+css选择器从一整个html中提取内容 和之前爬虫小说的区别在于：爬虫小说直接根据css选择器拿到所有的链接/文本再删减。 (css选择器用的是后代的规律)使用BeautifulSoup也是用css选择器拿，只不过拿所有的方法更加精确(使用了循环，css选择器是整个)。 步奏：为了拿到书名 1.拿到一个分页页面的html2.用BeautifulSoup解析网页3.用css选择器拿到内容标签对象(根据css选择器的规律做循环提取) 1&lt;class &apos;bs4.element.ResultSet&apos;&gt; 3.2 “#subject_list &gt; ul &gt; li:nth-child(1) &gt; div.info &gt; h2 &gt; a” “#subject_list &gt; ul &gt; li:nth-child(20) &gt; div.info &gt; h2 &gt; a”规律:nth-child从1到203.3 字符串中的变量占位两种： 1.f” {i} “ 2. “ “+str(i)+” “4.从提取标签中的text文本5.根据文本情况处理掉换行和空格bug: 有些页面的选择器规律是1到19.这样到20的时候就会报错。解决1：用try except解决。让报错跳过。解决2：报错是因为取list时候的[0].没有这个list就取不到。用for in 循环取(虽然最多只有一个元素) 代码123456789101112131415161718for i in range(0,50): paging_url = &quot;https://book.douban.com/tag/&quot; + key_ASCII1 + &quot;?start=&quot; + str(i*20) + &quot;&amp;type=T&quot; response = requests.get(paging_url,headers=headers) data = response.text # BeautifulSoup(响应数据,&quot;html.parse&quot;解析网页的意思) soup = BeautifulSoup(data,&quot;html.parser&quot;) try: # 解决1 for i in range(1,21): # 从1到20 # a = soup.select(f&quot;#subject_list &gt; ul &gt; li:nth-child(&#123;i&#125;) &gt; div.info &gt; h2 &gt; a&quot;) # 用a标签拿到的是列表，要把里面的标签内容取出来 a = soup.select(&quot;#subject_list &gt; ul &gt; li:nth-child(&quot;+str(i)+&quot;) &gt; div.info &gt; h2 &gt; a&quot;) # print(type(a)) # &lt;class &apos;bs4.element.ResultSet&apos;&gt; #a_list_0 = a[0] # 取出的是一个a标签整体 for one in a: # 解决2 book_name = one.get_text() # 取出的是a标签的内容(文字)，里面有很多换行和空格，需要去掉 book_name = book_name.replace(&quot;\\n&quot;,&quot;&quot;).replace(&quot; &quot;,&quot;&quot;) # 换行和空格 替换成 没有&quot;&quot; print(book_name) except: pass 完整版代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134import urllib.requestimport requestsfrom bs4 import BeautifulSoupimport csvkey1 = &quot;小说&quot;key2 = &quot;novel&quot;key_ASCII1 = urllib.request.quote(key1)key_ASCII2 = urllib.request.quote(key2)print(key_ASCII1)print(key_ASCII2)# 用for循环把中文list-&gt;ASCII listkey_list = [&quot;小说&quot;,&quot;散文&quot;,&quot;诗歌&quot;]key_ASCII_list = []for key in key_list: key_ASCII_list.append(urllib.request.quote(key))# print(key_ASCII_list)# url使用字符串拼接(全部用str()转换)url = &quot;https://book.douban.com/tag/&quot; + key_ASCII1 + &quot;?start=&quot; + str(0) + &quot;&amp;type=T&quot;# 换一种for range()# requests.get(url,headers=headers) 用User-Agent做headers伪装浏览器才能爬取到，不然爬下来的打开空白 .这样做很快headers = &#123; &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.83 Safari/537.36&quot;&#125;# 为了拿到书名# 1.拿到一个分页页面的html# 2.用BeautifulSoup解析网页# 3.用css选择器拿到内容标签对象(根据css选择器的规律做循环提取) &lt;class &apos;bs4.element.ResultSet&apos;&gt;# 3.2 &quot;#subject_list &gt; ul &gt; li:nth-child(1) &gt; div.info &gt; h2 &gt; a&quot; &quot;#subject_list &gt; ul &gt; li:nth-child(20) &gt; div.info &gt; h2 &gt; a&quot;规律:nth-child从1到20# 3.3 字符串中的变量占位两种： 1.f&quot; &#123;i&#125; &quot; 2. &quot; &quot;+str(i)+&quot; &quot;# 4.从提取标签中的text文本# 5.根据文本情况处理掉换行和空格# bug: 有些页面的选择器规律是1到19.这样到20的时候就会报错。# 解决1：用try except解决。让报错跳过。# 解决2：报错是因为取list时候的[0].没有这个list就取不到。用for in 循环取(虽然最多只有一个元素)book_name_list = []author_list = []publisher_list = []publish_time_list = []price_list = []score_list = []evaluation_list = []for i in range(0,50): # (0,50) paging_url = &quot;https://book.douban.com/tag/&quot; + key_ASCII1 + &quot;?start=&quot; + str(i*20) + &quot;&amp;type=T&quot; response = requests.get(paging_url,headers=headers) data = response.text # BeautifulSoup(响应数据,&quot;html.parse&quot;解析网页的意思) soup = BeautifulSoup(data,&quot;html.parser&quot;) try: # 解决1 for i in range(1,21): # 从1到20 (1,21) # 1.拿书名(第一行) a = soup.select(f&quot;#subject_list &gt; ul &gt; li:nth-child(&#123;i&#125;) &gt; div.info &gt; h2 &gt; a&quot;) # 用a标签拿到的是列表，要把里面的标签内容取出来 #a = soup.select(&quot;#subject_list &gt; ul &gt; li:nth-child(&quot;+str(i)+&quot;) &gt; div.info &gt; h2 &gt; a&quot;) # print(type(a)) # &lt;class &apos;bs4.element.ResultSet&apos;&gt; #a_list_0 = a[0] # 取出的是一个a标签整体 for one in a: # 解决2:把东西从列表中取出后，才能取出标签中的文字 book_name = one.get_text() # 取出的是a标签的内容(文字)，里面有很多换行和空格，需要去掉 book_name = book_name.replace(&quot;\\n&quot;,&quot;&quot;).replace(&quot; &quot;,&quot;&quot;) # 换行和空格 替换成 没有&quot;&quot; # print(book_name) book_name_list.append(book_name) # 2.拿作者...(第二行) book_info = soup.select(f&quot;#subject_list &gt; ul &gt; li:nth-child(&#123;i&#125;) &gt; div.info &gt; div.pub&quot;) for one in book_info: book_info = one.get_text() book_info = book_info.replace(&quot;\\n&quot;,&quot;&quot;).replace(&quot; &quot;,&quot;&quot;) author_time_price_list = book_info.split(&quot;/&quot;) # 余华/作家出版社/2012-8-1/20.00元. [日]东野圭吾/刘姿君/南海出版公司/2013-1-1/39.50元 # 正取作者，反取出版社，时间，价格. 如果元素少于4个，手动增加元素 if len(author_time_price_list) &gt;=4: author = author_time_price_list[0] publisher = author_time_price_list[-3] publish_time = author_time_price_list[-2] price = author_time_price_list[-1].replace(&quot;元&quot;,&quot;&quot;).replace(&quot;CNY&quot;,&quot;&quot;) else: author = author_time_price_list[0] publisher = &quot;null&quot; publish_time = &quot;null&quot; price = &quot;null&quot; author_list.append(author) publisher_list.append(publisher) publish_time_list.append(publish_time) price_list.append(price) # print(author_time_price_list,author_list,publisher_list,publish_time_list,price_list) # 3.拿评价(第三行) score = soup.select(f&quot;#subject_list &gt; ul &gt; li:nth-child(&#123;i&#125;) &gt; div.info &gt; div.star.clearfix &gt; span.rating_nums&quot;) for one in score: score = one.get_text() score = score.replace(&quot;\\n&quot;,&quot;&quot;).replace(&quot; &quot;,&quot;&quot;) score_list.append(score) # print(score_list) evaluation = soup.select(f&quot;#subject_list &gt; ul &gt; li:nth-child(&#123;i&#125;) &gt; div.info &gt; div.star.clearfix &gt; span.pl&quot;) for one in evaluation: evaluation = one.get_text() evaluation = score.replace(&quot;\\n&quot;,&quot;&quot;).replace(&quot; &quot;,&quot;&quot;).replace(&quot;(&quot;,&quot;&quot;).replace(&quot;人评价)&quot;,&quot;&quot;) evaluation_list.append(evaluation) # print(evaluation_list) except: pass# 保证每个list的信息一一对应print(len(book_name_list))print(len(author_list))print(len(publisher_list))print(len(publish_time_list))print(len(price_list))print(len(score_list))print(len(evaluation_list))# 以字典方式写入csvcsv_file_path = &quot;D:\\材料-公众号-爬虫小说\\py爬虫-豆瓣读书\\csv文件\\豆瓣小说分页.csv&quot;with open(csv_file_path,&quot;w&quot;,newline=&quot;&quot;,encoding=&quot;utf-8-sig&quot;) as f: # 不空行，中文不乱码 field_dict_name = [&quot;书名&quot;,&quot;作者&quot;,&quot;出版社&quot;,&quot;出版时间&quot;,&quot;价格(元)&quot;,&quot;评分&quot;, &quot;评价&quot;] # csv的表头 f_csv = csv.DictWriter(f,fieldnames=field_dict_name) # 文件变量 f_csv.writeheader() # 写表头 # 写入每一行 for i in range(0, len(book_name_list)): f_csv.writerow( &#123; &quot;书名&quot;: book_name_list[i], &quot;作者&quot;: author_list[i], &quot;出版社&quot;: publisher_list[i], &quot;出版时间&quot;: publish_time_list[i], &quot;价格(元)&quot;: price_list[i], &quot;评分&quot;: score_list[i], &quot;评价&quot;: evaluation_list[i] &#125; )","categories":[],"tags":[]},{"title":"css3","slug":"css3","date":"2020-08-31T08:16:05.000Z","updated":"2021-02-27T02:08:27.256Z","comments":true,"path":"2020/08/31/css3/","link":"","permalink":"https://lucifinil-x.github.io/2020/08/31/css3/","excerpt":"css介绍学习步奏：1.css是什么2.css怎么用3.css选择器(重难点)4.美化网页(文字美化，阴影，超链接，列表)5.盒子模型6.浮动7.定位8.网页动画(特效效果)9.学完css也做不出来，缺乏美工，缺乏大量的仿照练习","text":"css介绍学习步奏：1.css是什么2.css怎么用3.css选择器(重难点)4.美化网页(文字美化，阴影，超链接，列表)5.盒子模型6.浮动7.定位8.网页动画(特效效果)9.学完css也做不出来，缺乏美工，缺乏大量的仿照练习 基础常识1.1 什么是cssCascading Style Sheet层叠样式表CSS: 表现层，美化网页，字体，颜色，边框，高度，宽度，背景图片，网页定位，网页浮动 1.2 发展史 css基础结构1.3 快速入门 css语法： 选择器{ 声明1; 声明2; }html文件中： 1234567891011&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; h1&#123; color: blue; &#125; &lt;/style&gt;&lt;/head&gt; 分离后：html+csshtml文件中: 1&lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot;&gt; css文件中(建一个文件夹装css)： 123h1&#123; color: blue;&#125; css的优势1.4 css的优势1.内容和表现分离2.网页结构表现统一，可以实现复用3.样式十分丰富4.建议使用独立于html的css文件5.利用SEO，容易被搜索引擎收录。 css的三种导入方式1.内部样式： head-style标签2.外部样式： css文件，head-link标签3.行内样式： body-标签内部 三种导入同时出现，优先级：就近原则，谁离h1代码最近 1234567891011121314151617&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;!--内部样式--&gt; &lt;style&gt; h1&#123; color: greenyellow; &#125; &lt;/style&gt;&lt;!-- 外部样式链接 --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;!--优先级：就近原则，谁离h1代码最近--&gt;&lt;!--行内样式，在标签元素中编写style样式--&gt;&lt;h1 style=&quot;color: red&quot;&gt;我是标题&lt;/h1&gt;&lt;/body&gt; 选择器选择器作用：选择页面上的某一个或者某一类元素 基本选择器(重要)1.标签选择器2.类选择器 class 3.Id选择器1.标签选择器 标签{} 选择一类标签 123456&lt;style&gt; /*标签选择器会选择页面上所有这个标签(h1)的元素*/ h1&#123; color: rgba(123, 212, 120, 0.58); &#125;&lt;/style&gt; 2.类选择器 .类的名称{} 好处：可以多个标签用一个class,可以复用类名，可以跨标签归类 1234567891011121314151617181920&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt;/*&lt;!--类选择器： .类的名称&#123;&#125;好处：可以多个标签用一个class,可以复用类名，可以跨标签归类 --&gt;*/ .谢俞&#123; color: azure; &#125; .秦涫&#123; color: crimson; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 class=&quot;秦涫&quot;&gt;标题1&lt;/h1&gt;&lt;h1 class=&quot;谢俞&quot;&gt;标题2&lt;/h1&gt;&lt;p class=&quot;秦涫&quot;&gt;段落&lt;/p&gt;&lt;/body&gt; 3.Id选择器 #id名称{} id要保证元素唯一，不能复用 123456789101112131415161718192021 &lt;style&gt; /*id选择器： #id名称&#123;&#125; id要保证元素唯一，不能复用*/ #x&#123; color: crimson; &#125; .style1&#123; color: green; &#125; h1&#123; color: blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;x&quot;&gt;标题1&lt;/h1&gt;&lt;h1 id=&quot;xx&quot;&gt;标题2&lt;/h1&gt;&lt;h1 class=&quot;style1&quot;&gt;标题3&lt;/h1&gt;&lt;h1 class=&quot;style1&quot;&gt;标题4&lt;/h1&gt;&lt;/body&gt; 基本选择器顺序选择器优先级固定：id选择器&gt;class选择器&gt;标签选择器 层次选择器标签就像倒着的树，写分层次的标签就要有那个层次结构的图 1.后代选择器 在某个元素的后面所有代2.子选择器 后面第一代3.相邻兄弟选择器 第一个类下面一条同级的4.通用选择器 第一个类下面所有同级的 代码见idea-CSS-cssStudy-4.层次选择器 12345678910111213141516171819202122&lt;style&gt; 后代选择器，body-p-ul body p&#123; background: crimson; &#125; 子选择器，第一代 body&gt;p&#123; background: blue; &#125; 相邻兄弟选择器，class名的下一行；如果有两个这个class只会选择第一个class的邻居 .active+p&#123; background: aqua; &#125; 通用选择器,第一个class名向下的所有同级标签 .active~p&#123; background: red; &#125;&lt;/style&gt; 结构伪类选择器父标签 子标签:nth-child(?){} //选择第几个子标签 伪类：加了条件结构：定位元素 1234567891011121314151617181920212223 ul li:first-child&#123; background: blue; &#125; ul li:nth-child(2)&#123; background: red; &#125; ul li:last-child&#123; background: rgba(200, 92, 90, 0.62); &#125; body p:nth-child(2)&#123; background: rgba(51, 155, 19, 0.41); &#125;&lt;body&gt;&lt;p class=&quot;active&quot;&gt;p0&lt;/p&gt;&lt;p&gt;p1&lt;/p&gt;&lt;p&gt;p2&lt;/p&gt;&lt;p &gt;p3&lt;/p&gt;&lt;ul &gt; &lt;li&gt; &lt;p&gt;p4&lt;/p&gt; &lt;/li&gt; 属性选择器(常用)标签[属性名=属性值(可以用正则匹配)]{} 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;style&gt; .demo a&#123; float: left; display: block; height: 50px; width: 50px; border-radius: 10px; text-align: center; color: rgba(210, 59, 34, 0.53); text-decoration: none; margin-right: 5px; font: bold 20px/50px Arial; background: blanchedalmond; &#125; /*属性选择器：标签[属性名=属性值(可以用正则匹配)]&#123;&#125;*/ a[id=first]&#123; background: red; &#125; /*正则，class属性中含有links*/ a[class*=links]&#123; background: yellow; &#125; /*正则，href属性以images开头*/ a[href^=images]&#123; background: rgba(123, 190, 65, 0.41); &#125; /*正则，href属性以doc结尾*/ a[href$=doc]&#123; background: rgba(148, 53, 150, 0.27); &#125; &lt;/style&gt;&lt;p class=&quot;demo&quot;&gt;&lt;!-- class和id和target这些是属性--&gt; &lt;a href=&quot;https://hao.360.com/&quot; class=&quot;links item first&quot; id=&quot;first&quot;&gt;1&lt;/a&gt; &lt;a href=&quot;&quot; class=&quot;links item active&quot; target=&quot;_blank&quot; title=&quot;test&quot; &gt;2&lt;/a&gt; &lt;a href=&quot;images/123.html&quot; class=&quot;links item &quot;&gt;3&lt;/a&gt; &lt;a href=&quot;images/123.png&quot; class=&quot;links item &quot;&gt;4&lt;/a&gt; &lt;a href=&quot;images/123.jpg&quot; class=&quot;links item &quot;&gt;5&lt;/a&gt; &lt;a href=&quot;abc&quot; class=&quot;links item &quot;&gt;6&lt;/a&gt; &lt;a href=&quot;/a.pdf&quot;&gt;7&lt;/a&gt; &lt;a href=&quot;xx.doc&quot;&gt;8&lt;/a&gt; &lt;a href=&quot;xx.doc&quot;&gt;9&lt;/a&gt;&lt;/p&gt; 美化网页元素为什么要美化网页1.有效的传递页面信息2.页面漂亮吸引用户3.凸显页面主题4.提高用户体验 字体样式约定俗成字体用span标签，然后用id/class选择器去自定义样式 1欢迎学习 &lt;span id=&quot;title1&quot;&gt;java&lt;/span&gt; 常见字体样式(font-属性)： font-family:字体 font-size:大小 font-weight:粗细 color:颜色字体风格： 斜体 粗细 字体大小 字体样式 (font: oblique bold 50px 楷体;) text文本样式(重点)1.颜色 rgb,rgba(a透明度)2.文本对齐方式3.首行缩进4.行高5.下划线(装饰decoration)6.文本图片水平对齐：p,img{vertical-align: middle;}7.超链接去下划线： text-decoration: none; text-align: center;排版，居中 text-indent: 2em;段落首行缩进 当(文字)行高=块的高度一样时，文字就可以上下居中 height: 300px;line-height: 300px; text-decoration: underline;下划线text-decoration: line-through;中划线text-decoration: overline;上划线 超链接伪类a:hover正常情况下，会用到a:hover，鼠标悬浮放上去改变的颜色，实现动画效果. 1234567891011121314151617181920&lt;style&gt; a&#123; text-decoration: none; color: blue; &#125; /*鼠标放上去改变的颜色，实现动画效果.只需要记住hover*/ a:hover&#123; color: blanchedalmond; font-size: 50px; &#125; /*鼠标点击按住未释放的状态*/ a:active&#123; color: green; &#125; /*阴影：阴影颜色 横坐标 竖坐标 半径*/ #price&#123; text-shadow: aqua 10px -10px 10px ; &#125;&lt;/style&gt; list列表样式list-style: none取消点 circle空心圆 decimal无序列表变成有序列表的数字1234 square正方形的点 1234567ul li&#123; height: 30px; list-style: none;/* 行缩进*/ text-indent: 1em;&#125; 背景图片没弄好background-repeat: no-repeat;不重复background-position: 图片位置渐变背景去网页里面找代码 盒子模型和边框使用margin:外边距padding:内边距 border:边框边框：1.边框的粗细2.边框的样式3.边框的颜色 123456789101112131415161718192021222324252627 form&#123; background: blueviolet; &#125; /*父：子&gt;inout 伪类和子选择器定位到用户名*/ div:nth-of-type(1)&gt;input&#123; border: 2px solid black; &#125; div:nth-of-type(2)&gt;input&#123; border: 2px solid red; &#125; div:nth-of-type(3)&gt;input&#123; border: 2px solid aquamarine; &#125;&lt;form action=&quot;&quot;&gt; &lt;div&gt; &lt;span&gt;用户名：&lt;/span&gt; &lt;input type=&quot;text&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;密码：&lt;/span&gt; &lt;input type=&quot;password&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;邮箱：&lt;/span&gt; &lt;input type=&quot;email&quot;&gt; &lt;/div&gt;&lt;/form&gt; 现在写html最外面都套一个div写css从外往里写(顺序从上到下) padding: 0 21px; 内边距 左右0 上下21. 内外边距和div居中外边距margin可以让整个id=box的div标签中的东西居中 12345678#box&#123; width: 300px; /*border粗细样式颜色*/ border: 1px solid red; /*两个值时是上下/左右 这样是居中 四个值是顺时针*/ margin: 0 auto;&#125; 盒子的计算方式px盒子的计算方式： 你这个元素到底多大margin+border+padding+内容宽度=盒子宽 圆角边框&amp;阴影border-radius box-shadow圆角边框：border-radius: 左上 右上 右下 左下 顺时针 两个值 对角线 这个的左上 右上 右下 左下的px都只管四分之一圆也就是四分之一直径 ?px也就是圆角的大小 123456img&#123; width: 1000px; height: 1000px; border: 10px solid red; border-radius: 1000px;&#125; 阴影：box-shadow: 10px 10px 100px yellow; display横向排列和float浮动标准文档流块级元素：独占一行h1-h6 p div ul li行内元素：不独占一行,文字有多少就只占多大span a img strong 行内元素可以被包含在块级元素中 displaydisplay可以吧行内元素变成块元素，横向排列display: inline-block;又是行内元素又是块元素 应用：写链接导航栏，li标签是块元素，写出来会是竖着的，用display: inline-block; li的链接就可以变成一行大小，并排在一行 这个是一种实现行内元素排列的方式，但是我们很多情况都是用float.方向不可以控制 float浮动float: left;设置左浮/右浮浮动起来会脱离标准文档流，要解决父级边框塌陷的问题 清除浮动： clear 定位1.相对定位 position: relative;相对于没有写这个代码的时候自己本身的位置，进行上下左右距离偏移px四个属性 1234567/* 相对top距离-20 相对left距离40 * /position: relative; top: -20px; left: 40px; --- bottom: -10px; right: 20px 原来的位置仍然保留 5个链接方块相对定位作业我出现的问题：1.class.id选择器不能出现纯数字2.a标签相当于每个链接的父级，公共属性都写在这里，不同属性再覆盖3.position: relative ;的相对位置是相对于没有写这个代码的时候自己本身的位置，不是相对于前面的块级/边框的位置4.大边框的内容部分宽高都是盒子中间部分和border paddind无关 width/height设置实际需要的300px5.重复的css代码可以这样写：.a2,.a4{} 2.绝对定位 position: absolute;定位：基于xxx定位，上下左右偏移1.没有父级元素定位的前提下(父级css没有position:)，相对于浏览器定位，浏览器滑动也跟着滑动2.假设父级元素存在定位(position: relative;)，通常会相对于父级元素的边界进行偏移3.相对于父级/浏览器的绝对定位，他原来的位置不会被保留(不在标准文档流中) 3.固定定位 position: fixed;浏览器滑动不变 1234567891011121314151617181920body&#123; height: 1000px;&#125;div:nth-of-type(1)&#123; /*绝对定位：浏览器跑跟着跑*/ position: absolute; width: 200px; height: 200px; background: plum; bottom: 0px;&#125;div:nth-of-type(2)&#123; /*固定定位：一直在那*/ position: fixed; width: 150px; height: 150px; background: darkcyan; bottom: 0px;&#125; 4.z-index图层以及opacity透明度提高图片/文字的层级层级0-9999 不知道上限，越高越向上 z-index: 999; 在最上面设置透明度，就能看到下面的东西 opacity: 0.5;注意：网页都是图层堆叠的效果，但是需要有定位-&gt;才有图层 12345/*父 子选择器定位ul设置父级元素相对定位之后，子级元素就可以绝对定位了，可以跟着父级动*/#app ul&#123; position: relative;&#125; 动画看别人做的，几千行代码才能做一个网页动画 css小结例子cursor: pointer;鼠标移过来变成手型鼠标line-height: 10px;整个图标占的高度，图标小就会让图标置中","categories":[],"tags":[]},{"title":"2020下半年学习计划","slug":"2020下半年学习计划","date":"2020-08-26T17:03:20.000Z","updated":"2020-09-07T06:04:18.130Z","comments":true,"path":"2020/08/27/2020下半年学习计划/","link":"","permalink":"https://lucifinil-x.github.io/2020/08/27/2020下半年学习计划/","excerpt":"1.leedcode每日一题写暴力解和另外一解，总结2.150单词每日预计十月底结束雅思单词，每日清晨背","text":"1.leedcode每日一题写暴力解和另外一解，总结2.150单词每日预计十月底结束雅思单词，每日清晨背 3.前端html,css,js,jQuery,bootstrap每个周期三天学完 4.javaweb框架spring,springmvc,mybatis,springboot 5.java面试力扣java内存模型，GC,线程安全，线程池Arraylist,hashmap数据结构数据库索引原理，innodb特点springIOC AOP笔试算法题 冒泡排序，二分查找，二叉树三种遍历 CSE203 决策计算与语言 10+10ass 80期末 全是小问答题 CSE205 网络 40ass 15考试 45期末 全是小问答题CSE207 软件工程1 10+10ass 80期末选修 CSE209 计算机图形学 15+15courwork 70期末 CSE201 数据库设计（非关系数据库，解决数据库并发性）10+10ass 80期末 大三下CSE214 以人为中心的计算 交互界面 GUI 10+15+15report 60期末CSE204 复杂算法 5+5+10ass 80期末CSE210 java进阶 50ass 50期末 CSE208 小组工程 100作业CAN201 网络 icequiz x2 + 两部分CW = 15分x2 + 70分INT201 决策计算与语言 AssCW x2 + 网上开卷考试(2h) = 10分x2 + 80分CPT203 软件工程1 AssCW x3 + 网上考试(2h) = 15分x3 + 55分CPT205 计算机图形学 CW x2 + CW = 15分x2 + 70分共 quiz2 cw9 考试2 CPT203 软件工程1 AssCW x3 + 网上考试(2h) = 15分x3 + 55分Ass1 week4 requirementAss2 week8 modeling on regAss3 week11 uml CAN201 网络 icequiz x2 + 两部分CW = 15分x2 + 70分程序项目，用python3","categories":[],"tags":[]},{"title":"2020-9月leedcode","slug":"2020-9月leedcode","date":"2020-08-26T17:02:54.000Z","updated":"2020-08-26T18:25:35.518Z","comments":true,"path":"2020/08/27/2020-9月leedcode/","link":"","permalink":"https://lucifinil-x.github.io/2020/08/27/2020-9月leedcode/","excerpt":"8.27 1.两数之和 题目：给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。","text":"8.27 1.两数之和 题目：给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 初解：用时十多分钟，提交错误两次，n2暴力 问题：返回值为数组，这里不是先给你声明的数组，返回值需要自己new数组； 初解改进：返回数组可以直接return new int[]{i,j}; 数组大括号中可以用参数12345678910111213141516171819class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int i=0; int j; int len = nums.length; for(i=0;i&lt;len-1;i++)&#123; for(j=i+1;j&lt;=len-1;j++) &#123; if(nums[i]+nums[j]==target)&#123; int []twoSum=new int[2]; twoSum[0]=i; twoSum[1]=j; return twoSum; &#125; &#125; &#125; return null; &#125;&#125;","categories":[],"tags":[]},{"title":"微信小程序","slug":"微信小程序","date":"2020-08-15T15:46:26.000Z","updated":"2020-08-26T17:04:15.960Z","comments":true,"path":"2020/08/15/微信小程序/","link":"","permalink":"https://lucifinil-x.github.io/2020/08/15/微信小程序/","excerpt":"小程序特点用户体验1.体量小无需下载app2.微信特殊技术，控件用的是一些系统原生的组件，流畅。3.打开小程序时，代码已经存储在手机里了，做页面跳转不需要请求服务器。","text":"小程序特点用户体验1.体量小无需下载app2.微信特殊技术，控件用的是一些系统原生的组件，流畅。3.打开小程序时，代码已经存储在手机里了，做页面跳转不需要请求服务器。 开发者1.ios,安卓平台兼容。2.小程序开发是web开发技术，一般两个月时间。3.公众号也是跨平台，但是功能有限。 运营1.微信用户基数大。2.微信扫一扫就能进入小程序。 小程序开发的应用轻量级别：web多，app少1.工具类：打卡，外卖，共享单车2.咨询类：微博，新闻3.电商类：拼多多4.小游戏 前置技能html,js,css","categories":[],"tags":[]},{"title":"idea使用","slug":"idea使用","date":"2020-08-02T19:31:20.000Z","updated":"2021-01-30T16:49:44.682Z","comments":true,"path":"2020/08/03/idea使用/","link":"","permalink":"https://lucifinil-x.github.io/2020/08/03/idea使用/","excerpt":"快捷键https://blog.csdn.net/qq_38963960/article/details/89552704ctrl + / 注释","text":"快捷键https://blog.csdn.net/qq_38963960/article/details/89552704ctrl + / 注释 标签名字 + table 自动补全标签必填项 例：h1 + table 补全成闭合标签 选中代码块+Tab 整体右移 选中代码块+shift+Tab 整体左移 ctrl + o 继承类/接口后，出现可以重写的方法，ctrl多选 Alt + Insert 代码自动生成，如生成对象的 set / get 方法，构造函数，toString() 等 ALT + F12 在idea里面打开terminal(cmd的终端)，会自动定位到当前项目目录 Ctrl+Alt+I 将选中的代码进行自动缩进编排，这个功能在编辑 JSP 文件时也可以工作 ###IntelliJ Idea 常用快捷键列表 Ctrl+Shift + Enter，语句完成“！”，否定完成，输入表达式时按 “！”键Ctrl+E，最近的文件Ctrl+Shift+E，最近更改的文件Shift+Click，可以关闭文件Ctrl+[ OR ]，可以跑到大括号的开头与结尾Ctrl+F12，可以显示当前文件的结构Ctrl+F7，可以查询当前元素在当前文件中的引用，然后按 F3 可以选择Ctrl+N，可以快速打开类Ctrl+Shift+N，可以快速打开文件Alt+Q，可以看到当前方法的声明Ctrl+P，可以显示参数信息Ctrl+Shift+Insert，可以选择剪贴板内容并插入Alt+Insert，可以生成构造器/Getter/Setter等Ctrl+Alt+V，可以引入变量。例如：new String(); 自动导入变量定义Ctrl+Alt+T，可以把代码包在一个块内，例如：try/catchCtrl+Enter，导入包，自动修正Ctrl+Alt+L，格式化代码Ctrl+Alt+I，将选中的代码进行自动缩进编排，这个功能在编辑 JSP 文件时也可以工作Ctrl+Alt+O，优化导入的类和包Ctrl+R，替换文本Ctrl+F，查找文本Ctrl+Shift+Space，自动补全代码Ctrl+空格，代码提示（与系统输入法快捷键冲突）Ctrl+Shift+Alt+N，查找类中的方法或变量Alt+Shift+C，最近的更改Alt+Shift+Up/Down，上/下移一行Shift+F6，重构 – 重命名Ctrl+X，删除行Ctrl+D，复制行Ctrl+/或Ctrl+Shift+/，注释（//或者/**/）Ctrl+J，自动代码（例如：serr）Ctrl+Alt+J，用动态模板环绕Ctrl+H，显示类结构图（类的继承层次）Ctrl+Q，显示注释文档Alt+F1，查找代码所在位置Alt+1，快速打开或隐藏工程面板Ctrl+Alt+left/right，返回至上次浏览的位置Alt+left/right，切换代码视图Alt+Up/Down，在方法间快速移动定位Ctrl+Shift+Up/Down，向上/下移动语句F2 或 Shift+F2，高亮错误或警告快速定位Tab，代码标签输入完成后，按 Tab，生成代码Ctrl+Shift+F7，高亮显示所有该文本，按 Esc 高亮消失Alt+F3，逐个往下查找相同文本，并高亮显示Ctrl+Up/Down，光标中转到第一行或最后一行下Ctrl+B/Ctrl+Click，快速打开光标处的类或方法（跳转到定义处）Ctrl+Alt+B，跳转到方法实现处Ctrl+Shift+Backspace，跳转到上次编辑的地方Ctrl+O，重写方法Ctrl+Alt+Space，类名自动完成Ctrl+Alt+Up/Down，快速跳转搜索结果Ctrl+Shift+J，整合两行Alt+F8，计算变量值Ctrl+Shift+V，可以将最近使用的剪贴板内容选择插入到文本Ctrl+Alt+Shift+V，简单粘贴Shift+Esc，不仅可以把焦点移到编辑器上，而且还可以隐藏当前（或最后活动的）工具窗口F12，把焦点从编辑器移到最近使用的工具窗口Shift+F1，要打开编辑器光标字符处使用的类或者方法 Java 文档的浏览器Ctrl+W，可以选择单词继而语句继而行继而函数Ctrl+Shift+W，取消选择光标所在词Alt+F7，查找整个工程中使用地某一个类、方法或者变量的位置Ctrl+I，实现方法Ctrl+Shift+U，大小写转化Ctrl+Y，删除当前行Shift+Enter，向下插入新行psvm/sout，main/System.out.println(); Ctrl+J，查看更多Ctrl+Shift+F，全局查找Ctrl+F，查找/Shift+F3，向上查找/F3，向下查找Ctrl+Shift+S，高级搜索Ctrl+U，转到父类Ctrl+Alt+S，打开设置对话框Alt+Shift+Inert，开启/关闭列选择模式Ctrl+Alt+Shift+S，打开当前项目/模块属性Ctrl+G，定位行Alt+Home，跳转到导航栏Ctrl+Enter，上插一行Ctrl+Backspace，按单词删除Ctrl+”+/-”，当前方法展开、折叠Ctrl+Shift+”+/-”，全部展开、折叠【调试部分、编译】Ctrl+F2，停止Alt+Shift+F9，选择 DebugAlt+Shift+F10，选择 RunCtrl+Shift+F9，编译Ctrl+Shift+F10，运行Ctrl+Shift+F8，查看断点F8，步过F7，步入Shift+F7，智能步入Shift+F8，步出Alt+Shift+F8，强制步过Alt+Shift+F7，强制步入Alt+F9，运行至光标处Ctrl+Alt+F9，强制运行至光标处F9，恢复程序Alt+F10，定位到断点Ctrl+F8，切换行断点Ctrl+F9，生成项目Alt+1，项目Alt+2，收藏Alt+6，TODOAlt+7，结构Ctrl+Shift+C，复制路径Ctrl+Alt+Shift+C，复制引用，必须选择类名Ctrl+Alt+Y，同步Ctrl+~，快速切换方案（界面外观、代码风格、快捷键映射等菜单）Shift+F12，还原默认布局Ctrl+Shift+F12，隐藏/恢复所有窗口Ctrl+F4，关闭Ctrl+Shift+F4，关闭活动选项卡Ctrl+Tab，转到下一个拆分器Ctrl+Shift+Tab，转到上一个拆分器【重构】Ctrl+Alt+Shift+T，弹出重构菜单Shift+F6，重命名F6，移动F5，复制Alt+Delete，安全删除Ctrl+Alt+N，内联【查找】Ctrl+F，查找Ctrl+R，替换F3，查找下一个Shift+F3，查找上一个Ctrl+Shift+F，在路径中查找Ctrl+Shift+R，在路径中替换Ctrl+Shift+S，搜索结构Ctrl+Shift+M，替换结构Alt+F7，查找用法Ctrl+Alt+F7，显示用法Ctrl+F7，在文件中查找用法Ctrl+Shift+F7，在文件中高亮显示用法 在idea一个窗口开两个项目-不要用1.先打开一个项目：file-open-文件夹-从存在的资源2.再file-project structure-modules-上面加号-下一个项目文件夹-ok idea打开别人的项目file-open项目根目录再进行下面的修改 idea里文件有红色时钟标识https://blog.csdn.net/moneyshi/article/details/813640831.file-project structure/使用快捷键Ctrl+alt+shift+s打开窗口，2.modules-source3.点开src-main-java-右键标注为sourece4.点开src-main-resources-右键标注为resources5.点开src-test-右键标注为test6.之后注解爆红-右侧maven-重新导入maven 注解，包全部爆红右侧边栏-maven-加号-选择为项目的pom.xml第一个转圈圈符号-reimport all maven project-等待加载就好了","categories":[],"tags":[]},{"title":"html","slug":"html","date":"2020-07-17T16:00:50.000Z","updated":"2020-09-20T11:51:10.370Z","comments":true,"path":"2020/07/18/html/","link":"","permalink":"https://lucifinil-x.github.io/2020/07/18/html/","excerpt":"初识html1.什么是html？ 超文本标记语言 Hyper Text Markerup Language","text":"初识html1.什么是html？ 超文本标记语言 Hyper Text Markerup Language 2.超文本包括：文字、图片、音频、视频、动画。 3.现在用的版本html5+css3 4.html5特性提供新的网页功能，不需要安装插件就能用网页播放视频，使用网页动态渲染图标、图形、图形动画 5.html5的优势各个浏览器都支持html5,相当于天然的依靠浏览器就能跨平台(java跨平台用的是jvm) 6.浏览器浏览器就是智能的IDE,它会智能的解析html代码 7.html是网页的结构，css是网页的表现，js是网页的交互 W3C标准1.W3CWorld Wide Web Consortium(万维网联盟)Web技术领域的国际中立性技术标准机构 2.W3C标准结构化标准语言(html,xml)表现性标准语言(css)行为标准(dom文档对象模型,ecmascript JS的规范) 网页基本信息,html结构1.DOCTYPE 123&lt;!-- DOCTYPE:告诉浏览器，我们使用的是html规范 --&gt;&lt;!DOCTYPE html&gt; 2.html 总标签html代码写在html标签内部 3.head 头部标签head代表网页头部 3.1 meta标签meta描述性标签，它用来描述我们网站的一些信息meta一般用来做SEO(搜索引擎优化,对网站进行内部及外部的调整优化，改进网站在搜索引擎中的关键词自然排名) 1234&lt;!--meta描述性标签，它用来描述我们网站的一些信息--&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;keywords&quot; content=&quot;学习网站&quot;&gt; &lt;meta name=&quot;description&quot; content=&quot;每日学习打卡&quot;&gt; 3.2 title标签title网页标题 4.body标签body代表网页主体，我们写的东西都在body里 网页基本标签h1 h2 h3 几级标题p 分段，展示一行内容br/ 换行，段落无间距，单标签hr/ 水平线标签，单标签strong 粗体，标签内文字变成粗体 em 斜体，标签内文字变成斜体 特殊符号： &amp; ; 1234&amp;nbsp; 空格&amp;gt; 大于&amp;lt; 小于&amp;copy;版权所有xxx 版权符号 图像标签 img1.常见的图像格式JPGGIFPNGBMP 2.img标签参数 1&lt;img src=&quot;路径&quot; alt=&quot;失败文字&quot; title=&quot;悬停文字&quot; width=&quot;宽度&quot; height=&quot;高度&quot;&gt; src必填: 图片地址 相对路径/绝对路径 相对路径：相对于当前html文件的路径，../ 返回上一级的文件夹 ../../返回两级文件夹 alt必填: 图片加载失败时显示的文字 title 鼠标悬停显示的文字 width 图片宽度，可以加变量参数 hight 图片高度 其他的图片属性空格之后idea有提示 超链接标签 a1.普通链接-通过文字/图片跳转页面1.跳转页面超链接标签参数 1&lt;a href=&quot;链接路径&quot; target=&quot;链接在哪个窗口打开&quot;&gt;链接文本或图像&lt;/a&gt; href必填 target:_ blank 链接在新标签页打开_ self 链接在当前页面打开(不写target,默认为self) 2.文字超链接 1&lt;a href=&quot;https://bns.qq.com/&quot; target=&quot;_blank&quot;&gt;跳转剑灵&lt;/a&gt; 3.图片超链接(内置图片标签) 123&lt;a href=&quot;https://bns.qq.com/&quot;&gt; &lt;img src=&quot;../../source/image/&#123;0CD3A208-38C5-D227-DB52-F9A1DB0C7D73&#125;.png&quot; alt=&quot;龙族幻想&quot; title=&quot;零&quot;&gt;&lt;/a&gt; 2.锚链接-通过页面中的超链接定位到页面的具体位置锚链接实现页面中跳转定位的两个要素：1.锚标记 12&lt;!--name的属性TOP作为锚链接的标记，顶部是在页面显示的文字--&gt;&lt;a name=&quot;TOP&quot;&gt;顶部&lt;/a&gt; 2.跳转链接 12&lt;!--链接处为#+锚标记--&gt;&lt;a href=&quot;#TOP&quot;&gt;回到顶部&lt;/a&gt; 使用场景：1.本页面内部定位2.定位到另外页面的具体位置(锚标记位置) 12&lt;!-- 超链接+#+链接页面的锚标记--&gt;&lt;a href=&quot;链接标签.html#DOWN&quot; target=&quot;_blank&quot;&gt;跳转链接&lt;/a&gt; 3.功能性链接-打开邮箱/添加qq之类邮件链接 href=”mailto:邮箱名字” 添加qq qq推广官网复制代码 123&lt;a target=&quot;_blank&quot; href=&quot;http://wpa.qq.com/msgrd?v=3&amp;uin=&amp;site=qq&amp;menu=yes&quot;&gt; &lt;img border=&quot;0&quot; src=&quot;http://wpa.qq.com/pa?p=2::53&quot; alt=&quot;点击联系我qq&quot; title=&quot;点击联系我qq&quot;/&gt;&lt;/a&gt; 行内元素和块元素1.行内元素元素都在一行中显示 span标签是超文本标记语言（HTML）的行内标签，被用来组合文档中的行内元素。span没有固定的格式表现。当对它应用样式时，它会产生视觉上的变化。 2.块元素 每个元素分行显示块级元素：独占一行h1-h6 p div ul li行内元素：不独占一行,文字有多少就只占多大span a img strong 行内元素可以被包含在块级元素中 列表1.有序列表(1 2 3 4) ol 2.无序列表(点) ul 3.自定义列表(无序号和点，有列表名称) dl 12345678910111213141516171819202122232425&lt;!--有序标签,应用：试卷，问答--&gt;&lt;ol&gt; &lt;li&gt;c&lt;/li&gt; &lt;li&gt;运维&lt;/li&gt; &lt;li&gt;前端&lt;/li&gt;&lt;/ol&gt;&lt;hr/&gt;&lt;!--无序列表,应用：导航，侧边栏--&gt;&lt;ul&gt; &lt;li&gt;c&lt;/li&gt; &lt;li&gt;java&lt;/li&gt; &lt;li&gt;前端&lt;/li&gt;&lt;/ul&gt;&lt;hr/&gt;&lt;!--自定义列表,dl标签，dt列表名称，dd列表选项。应用：网站底部--&gt;&lt;dl&gt; &lt;dt&gt;自定义列表&lt;/dt&gt; &lt;dd&gt;java&lt;/dd&gt; &lt;dd&gt;python&lt;/dd&gt; &lt;dd&gt;运维&lt;/dd&gt; &lt;dt&gt;位置&lt;/dt&gt; &lt;dd&gt;成都&lt;/dd&gt;&lt;/dl&gt; 表格 table table标签：单元格 table； 边框 border 行 tr列 td； td标签中跨行 rowspan； td标签中跨列 colspan 1234567891011121314151617181920212223&lt;table border=&quot;1px&quot; &gt; &lt;tr&gt; &lt;td colspan=&quot;3&quot;&gt;学生成绩&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td rowspan=&quot;2&quot;&gt;狂神&lt;/td&gt; &lt;td&gt;语文&lt;/td&gt; &lt;td&gt;100&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;数学&lt;/td&gt; &lt;td&gt;100&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td rowspan=&quot;2&quot;&gt;秦涫&lt;/td&gt; &lt;td&gt;语文&lt;/td&gt; &lt;td&gt;100&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;数学&lt;/td&gt; &lt;td&gt;100&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 媒体元素 标签：音频 audio 视频 video src:资源路径controls:控制条autoplay:自动播放 12&lt;video src=&quot;../../source/video/xxx.mp4&quot; controls autoplay&gt;&lt;/video&gt;&lt;audio src=&quot;../../source/video/xxx.mp3&quot; controls autoplay&gt;&lt;/audio&gt; 网页结构header 标题头部区域内容(页面中一块区域)footer 标记脚部区域内容(页面中一块区域) section web页面中一块独立区域article 独立的文章内容aside 相关内容或应用(侧边栏) nav 导航类辅助内容 iframe内联框架在一个网页里面嵌套另外一个成形的页面 123&lt;!--内联框架标签iframe可以作为容器，下面锚链接打开的页面就会出现在 锚标记的位置；本来是放置的百度的页面，点击跳转 新页面会覆盖百度--&gt;&lt;iframe src=&quot;https://www.baidu.com/?tn=62095104_28_oem_dg&quot; name=&quot;baidu&quot; frameborder=&quot;0&quot; width=&quot;1000px&quot; height=&quot;3000px&quot;&gt;&lt;/iframe&gt;&lt;a href=&quot;我的第一个网页.html&quot; target=&quot;baidu&quot;&gt;点击跳转&lt;/a&gt; 表单post和get提交表单 form form标签action: 表单提交的位置，可以是网站，也可以是一个请求处理地址method: post,get 两种提交方式 input标签：文本输入框type: 框内输入的类型(比如text,password，submit,reset),会根据类型显示不同，默认为textname: 自定义文本框控件的名字value: 初始值，type为radio时必须指定一个值size: 表单元素(文本框)的初始长度maxlength: type为text或password时，输入的最大字符数checked: type为radio或checkbox时，指定按钮是否被选中 1234567891011&lt;form action=&quot;我的第一个网页.html&quot; method=&quot;post&quot;&gt; &lt;h2&gt;注册&lt;/h2&gt; &lt;p&gt; 名字：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;/p&gt; &lt;p&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;passw&quot;&gt; &lt;/p&gt; &lt;input type=&quot;submit&quot;&gt; &lt;input type=&quot;reset&quot;&gt;&lt;/form&gt; 提交方式 get post get方式提交：我们可以在表单提交位置的那个网页url中看到我们提交的信息。不安全，高效。 post方式提交：url中没有参数信息。比较安全，传输大文件。post的信息在 右键审查元素-network-点击name下的码-headers-from data-这里能看到提交的名字和密码。 键值对提交：name=”” + value=””/标签中间的内容； form表单内容单选框，多选框，按钮单选框和多选框的值都是定义好的value radio单选框标签是input type=”radio” 的一个单选标签，需要写type,value(单选框的值),name(name相同的进行分组，可以进行单选,提交的信息只会交一组中的一个)，标签后的文字。 checked默认选择 1234&lt;p&gt; 性别：&lt;input type=&quot;radio&quot; value=&quot;boy&quot; name=&quot;gender&quot; checked&gt; 男 &lt;input type=&quot;radio&quot; value=&quot;girl&quot; name=&quot;gender&quot;&gt;女&lt;/p&gt; checkbox多选框标签type=”checkbox”需要写value,name,后面的文字用name进行分组checked默认选择123456&lt;p&gt;爱好： &lt;input type=&quot;checkbox&quot; value=&quot;sleep&quot; name=&quot;hobby&quot; checked&gt;睡觉 &lt;input type=&quot;checkbox&quot; value=&quot;sleep&quot; name=&quot;hobby&quot;&gt;写代码 &lt;input type=&quot;checkbox&quot; value=&quot;sleep&quot; name=&quot;hobby&quot;&gt;聊天 &lt;input type=&quot;checkbox&quot; value=&quot;sleep&quot; name=&quot;hobby&quot;&gt;游戏&lt;/p&gt; 按钮和图片点击有个提交效果，因为input标签是写在form表单标签中的，有一个提交给网页的动作。 1234&lt;p&gt; &lt;input type=&quot;button&quot; name=&quot;anniu&quot; value=&quot;点击变长&quot;&gt; &lt;input type=&quot;image&quot; src=&quot;../../source/image/&#123;0CD3A208-38C5-D227-DB52-F9A1DB0C7D73&#125;.png&quot;&gt;&lt;/p&gt; 下拉框 select 下拉框标签option 下拉框元素选择标签 123456789 &lt;p&gt;下拉框： &lt;select name=&quot;列表名称&quot;&gt; &lt;option value=&quot;china&quot;&gt;中国&lt;/option&gt; &lt;option value=&quot;America&quot;&gt;美国&lt;/option&gt; &lt;option value=&quot;rth&quot; selected&gt;瑞士&lt;/option&gt;&lt;!-- selected默认选择--&gt; &lt;option value=&quot;india&quot;&gt;印度&lt;/option&gt; &lt;/select&gt; &lt;/p&gt; textarea 可填写文本域标签 123&lt;p&gt;可填写文本域： &lt;textarea name=&quot;文本域&quot; id=&quot;&quot; cols=&quot;50&quot; rows=&quot;30&quot;&gt;填文本，可拉动&lt;/textarea&gt;&lt;/p&gt; input type=”file”提交选择文件域 1234 &lt;p&gt;提交选择文件域 &lt;input type=&quot;file&quot; name=&quot;文件域&quot;&gt;&lt;!-- &lt;input type=&quot;button&quot; name=&quot;长传&quot; value=&quot;上传&quot;&gt;--&gt; &lt;/p&gt; input标签 邮箱、url、数字的自动验证、滑块、搜索框 123456789101112131415&lt;p&gt;邮箱自动验证 &lt;input type=&quot;email&quot; name=&quot;邮件&quot;&gt;&lt;/p&gt;&lt;p&gt;url自动验证 &lt;input type=&quot;url&quot; name=&quot;网址&quot;&gt;&lt;/p&gt;&lt;p&gt;数字验证/商品数量： &lt;input type=&quot;number&quot; name=&quot;num&quot; max=&quot;100&quot; min=&quot;0&quot; step=&quot;10&quot;&gt;&lt;/p&gt;&lt;p&gt;滑块/音量大小 &lt;input type=&quot;range&quot; name=&quot;voice&quot; min=&quot;0&quot; max=&quot;100&quot; step=&quot;1&quot;&gt;&lt;/p&gt;&lt;p&gt;搜索框： &lt;input type=&quot;search&quot; name=&quot;搜索&quot; &gt;&lt;/p&gt; 表单的应用标签中的权限： readonly 只读，无法修改(文本框) checked 默认勾选(单/多选) disabled 禁用 hidden 隐藏域(隐藏框)，虽然框还在那个位置但是不能输入value,但是可以默认写value,也可以提交 label标签:label标签用id指向文本框，增强鼠标可用性/鼠标移动到前面的文字就可以落到文本框中 1234&lt;p&gt;label标签用id指向文本框，增强鼠标可用性/鼠标移动到前面的文字就可以落到文本框中 &lt;label for=&quot;mark&quot;&gt;你点我试试&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;mark&quot;&gt;&lt;/p&gt; 表单初级验证验证作用：在前端进行验证，减轻压力，保证数据的安全性 常用方式(写在标签中)： placeholder=”xxx” 提示信息xxx(用在文本框中) required 表单不能为空，提交时候会提示(用在文本框中) pattern 正则表达式，正确格式 1234正则表达式去百度：常用的正则表达式 &lt;p&gt;正则表达式判断邮箱正确 &lt;input type=&quot;text&quot; name=&quot;自定义邮箱&quot; pattern=&quot;：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$&quot;&gt; &lt;/p&gt;","categories":[],"tags":[]},{"title":"一些基础和vueblog细节","slug":"一些基础和vueblog细节","date":"2020-07-04T21:11:07.000Z","updated":"2020-07-06T20:27:25.692Z","comments":true,"path":"2020/07/05/一些基础和vueblog细节/","link":"","permalink":"https://lucifinil-x.github.io/2020/07/05/一些基础和vueblog细节/","excerpt":"HashMap hashmap在jdk1.7和jdk1.8版本的区别 数据结构不同： 1.7中的HashMap是数组+链表的结构 1.8中的HashMap是数组+链表+红黑树的结构","text":"HashMap hashmap在jdk1.7和jdk1.8版本的区别 数据结构不同： 1.7中的HashMap是数组+链表的结构 1.8中的HashMap是数组+链表+红黑树的结构 链表插入方式不同： 1.7使用的是头插法,头插法在进行扩容时存在线程安全问题导致链表死循环 1.8使用的是尾插法 扩容后重新计算索引的方式不同： 1.7将会使用扩容后的大小重新与hash计算索引 1.8会判断之前hash中需要加入计算索引位置是0还是1，是0则保持原位，1则在现在索引的基础上加上新增的容量则是计算后的索引 什么时候创建数组？为什么？数组是在map.put(key,value )的时候创建的。数组并不是在new HashMap对象的时候创建的,因为创建对象就会在堆内存里占用连续的内存空间 数组+链表的结构怎么存放键值对数据？Put进键值对时，是在hashmap的16格(0-15)中加入键值对，当新加入的键值对所在的数组格子位置里有值的时候，就会和格子里的键值对形成链表，这个叫做hash冲突。数组查询时间复杂度是O(1),链表查询复杂度是O(n).所以要提高查询效率，就要减少链表的长度，当数组容量使用超过16x0.75时，就会进行数组扩容，减少hash冲突，提高查询效率。 什么时候引入红黑树？是为了什么？当链表长度大于8时，如果数组容量超过64，数组格子里的链表结构转换为红黑树如果数组容量小于64，只会进行数组扩容引入红黑树为了增加查询效率时间复杂度变成对数阶O(log2n) 怎么确定键值对在数组中的位置？key的hash值与数组最大索引进行与运算 hashmap存储过程=hashmap的工作原理？ 根据key计算一个hash值 在put时判断数组是否存在，如果不存在调用resize()创建默认容量为16的数组 key的hash值与数组最大索引进行位运算(与运算)，确定node在数组中的位置 判断该位置是否有元素，如果没有元素，会新建一个node放在该位置；如果有元素，判断key是否完全相同，吧原来的node赋值给一个变量 此时再判断该node的位置是红黑树还是链表 如果是红黑树，以红黑树的方式将node放在红黑树上(特别的二叉树) 如果是链表，尾插法：遍历链表，将node放在最后一位 放完以后，就要判断当链表长度大于8时，如果数组容量超过64，数组格子里的链表结构转换为红黑树；如果数组容量小于64，只会进行数组扩容 返回被覆盖的值 判断整个数组是否需要扩容 hashmap的扩容为什么每次都是2次幂？减少hash碰撞 hashmap的线程安全问题发生在哪个阶段？线程安全问题产生的原因：多个线程访问同一个资源。发生在put放值(链表/红黑树放结点)进行判断的时候，p.next=newNode().多个线程都进来了，newNode()在赋值的时候就会漏点。 如何解决线程安全问题？concurrentHashMap就是使用锁分段技术专门用来实现线程安全的底层采用分段的数组+链表实现，线程安全。ConcurrentHashMap是使用了锁分段技术来保证线程安全的。 锁分段技术：首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。 位运算有哪些？左移 0011-&gt;0110右移 0110-&gt;0011或运算 一真则真与运算 一假则假按位取反 1变0异或运算 相同为0 不同为1 apache shiro shiro是什么？shiro是强大且易用的java安全框架，执行 身份验证(登录)、授权、会话管理、密码学。 shiro的六大作用是什么？ Authentication 认证 -用户登录 Authorization 授权 -给用户哪些权限 Cryptography 安全数据加密 Session Managment 会话管理 Web intergration web 系统集成 Interations 集成其他的应用 -比如集成spring/缓存框架redis shiro的核心API(接口/是都需要重写的函数！)都是什么？有什么作用？ Subject: 用户主体 (把操作交给SecurityManager,要关联它) SecurityManager: 安全管理器 （关联Reaml） Realm: Shiro连接数据的桥梁,shiro想要查询数据库/配置文件获取用户信息，这些事情都要靠realm来完成。realm中执行认证和授权。认证中具体实现用户名和密码匹配 以上shiro三个API之间的关系？ Subject关联SecurityManager,SecurityManager关联Realm SecurityManager关联Realm：DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(accountRealm); SecurityManager关联Subject：关联函数：A.setB 如：securityManager.setSubjectDAO(subjectDAO); 怎么整合shiro-redis-springboot? 导shiro-redis-springboot依赖和jwt工具包和hutool工具包 写shiro的配置类ShiroConfig： 让shiro的权限数据和会话信息存在redis中，引入了redisSessionDAO、redisCacheManagersecurityManager.setSessionManager(sessionManager.setSessionDAO(redisSessionDAO));//简写securityManager.setCacheManager(redisCacheManager);//配置redis缓存 重写SessionManager和DefaultWebSecurityManager，关闭shiro自带的session方式，这样用户就不再能通过session方式登录shiro。后面将采用jwt凭证登录。DefaultWebSecurityManager中Subject关联SecurityManager,SecurityManager关联Realm。 所有的路由都需要经过JwtFilter这个过滤器，然后判断请求头中是否含有jwt的信息，有就登录，没有就跳过。跳过之后，有Controller中的shiro注解进行再次拦截，比如@RequiresAuthentication，这样控制权限访问。 写shiro进行登录或者权限校验的逻辑类AccountRealm：重写3个方法，分别是：supports：为了让realm支持jwt的凭证校验doGetAuthorizationInfo：权限校验doGetAuthenticationInfo：登录认证校验 -拿到需要验证的token，解析token拿到用户id,根据id去拿到用户对象，判断用户状态。将登陆成功的用户对象中的信息复制到profile对象中，然后返回一个登录成功(已认证)的用户信息载体对象SimpleAuthenticationInfo)(shiro里的) 用户登录信息-Session-shiro-redis小小总结：用户登录信息存放在Session中；Session被shiro管理；shiro的信息(权限数据、会话管理信息)存放在redis中。 将shiro内部构建展示出来，上面这些连接变成了：用户登录信息-Session-subject-securitymanager-redis-realm-mysql jwt jwt的构成 = 加密header+加密payload+加密signature 这三个拼在一起的字符串 头部（header)：声明类型，这里是jwt；声明加密的算法。 载荷（payload, 存放有效信息类似于飞机上承载的物品)：标准中注册的声明；公共的声明；私有的声明 签证（signature)：用header中声明加密的算法对(加密后的header+加密后的payload+secret)组合加密 认为jwt=token 用户登录和请求的流程用户使用用户名密码来请求服务器服务器进行验证用户的信息服务器通过验证发送给用户一个token客户端存储token，并在每次请求时附送上这个token值服务端验证token值，如果验证通过就会返回相应的资源(给接口)这个token必须要在每次请求时传递给服务端，它应该保存在请求头里 项目中是用的jwt凭证登录。 jwt不需要在服务端保存会话信息Session, 用户信息ession保存在客户端 每次请求校验，通过服务端的私钥和过期时间(定义在yml里面)来校验合法性 项目中的jwtUtil是jwt的工具类。四个注解：@Slf4j -为类提供一个 属性名为log 的 log4j 日志对象，调用打印日志@Data -提供类所有属性的 getting 和 setting 方法，此外还提供了equals、canEqual、hashCode、toString 方法@Component -组件@ConfigurationProperties(prefix = “example.demo.jwt”) -外部化配置，在配置文件/配置类外面写配置相关的。这里绑定和验证一些外部属性（.Properties文件中example.demo.jwt下面配置的三个属性） 三个属性：header expire secret. 三个方法： 生成jwttoken: 那三个组成拼起来的字符串 获取jwttoken的信息： 解析jwt 判断token是否过期： 过期时间before当前时间-&gt;过期-&gt;返回true 在AccountRealm中使用了工具类就是要先注入这个类@Autowired，就不用new对象了。 Cookie和Session 两个数据存放在哪里？cookie数据存放在客户的浏览器上；session数据放在服务器上。 cookie的特点和限制是什么？ cookie不是很安全，因为别人可以分析存放在本地的COOKIE并进行COOKIE欺骗。 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。 两个数据里能存什么？cookie里只能存放字符串；session里能存放任何类型的数据，如字符串、集合、类、对象。 用户能看见吗？cookie对用户可见；session对用户不可见(透明) 有效期的差别？ 比如浏览器上百度账号登录信息长期有效？cookie可以容易的达到登录信息长期有效，只要把有效期设为很大的数字；session不能长期有效，容易导致服务器的内存溢出。比如说我们项目使用jwt设置了有效期7天。 并发访问的用户多的时候，用哪个来追踪用户会话？用cookie。因为一个用户就会产生一个session/cookie. session存在服务器端，产生的session量过大会消耗大量的内存。 cookie存在客户端，不占用服务器端的资源，一个用户手里拿一个cookie。所以像百度这种只能用cookie来存储用户的登录信息，用cookie来追踪用户会话。 为什么百度贴吧、百度云盘、百度搜索都可以共用我的登录信息呢(不用重复登录)？因为cookie支持跨域名访问，以“.biaodianfu.com”为后缀的一切域名均能够访问该Cookie。但是session就不支持跨域名访问，如果用session,都要重新登录。 session在服务器端由谁来管理？存在哪里？session由shiro来管理，shiro六大作用之一就是Session会话管理。在ShiroConfig(shiro配置类)中就有会话管理对应的函数-SessionManager. MySQL 分布式数据库是什么？分布式数据库是指数据在物理上分布而逻辑上集中管理的数据库系统。 MySQL 群集是什么？MySQL 群集是一种技术。MySQL群集技术在分布式数据库系统中为MySQL数据提供了冗余特性，增强了安全性，使得单个MySQL服务器故障不会对系统产生巨大的负面效应，系统的稳定性得到保障。 MySQL 群集作用白话：MySQL群集技术让分布式数据库系统稳定性得到保障，(因为它为mysql数据增加安全性，)所以当单个mysql服务器故障时，分布式数据库系统不会产生巨大影响 MySQL 群集的三种结点有什么用？ 管理结点：能对结点进行关闭启动等操作，能监视结点状态。 数据结点：存数据。 SQL结点： 对外提供SQL功能。","categories":[],"tags":[]},{"title":"vue","slug":"vue","date":"2020-07-02T09:24:56.000Z","updated":"2021-03-20T08:46:05.377Z","comments":true,"path":"2020/07/02/vue/","link":"","permalink":"https://lucifinil-x.github.io/2020/07/02/vue/","excerpt":"新建项目 vue项目根目录文件夹中，shift+右键打开windows powershellc窗口 执行vue ui 注意：新建的项目里只有创建项目时勾选的依赖(vue ui中查看)，需要其他插件的话，要在项目路径下面使用命令行安装(很简单) 新建vue项目：左侧-任务-serve-运行-输出(点击查看)-App ready 想要新建项目的话需要点左下角的小房子或者左下角的文件夹，选择要放置新项目的文件夹。 输入项目名称(不能有中文)-手动配置项目-选择功能Bable,Router,Vuex-创建-创建项目，不保存预设 打开eclipse-file-导入项目","text":"新建项目 vue项目根目录文件夹中，shift+右键打开windows powershellc窗口 执行vue ui 注意：新建的项目里只有创建项目时勾选的依赖(vue ui中查看)，需要其他插件的话，要在项目路径下面使用命令行安装(很简单) 新建vue项目：左侧-任务-serve-运行-输出(点击查看)-App ready 想要新建项目的话需要点左下角的小房子或者左下角的文件夹，选择要放置新项目的文件夹。 输入项目名称(不能有中文)-手动配置项目-选择功能Bable,Router,Vuex-创建-创建项目，不保存预设 打开eclipse-file-导入项目 启动vue项目 cmd到项目路径 d: cd D:\\vue学习练习\\vueLearn-kuangshen\\vue01(这是狂神基础学习的代码练习)然后 npm run serve 或者：idea中打开vue的项目文件夹，ALT + F12 在idea里面打开terminal(cmd的终端)，会自动定位到当前项目目录，然后 npm run serve .vue中快捷键 style里面用 ctrl+shift+/ 用错了会报错的 js里面都可以 // html里面用ctrl+shift+/ 在vue源码中搭建环境两种办法1.用idea打开vue项目，命令行npm install,启动npm run dev2.cmd里到项目根目录，命令行npm install,启动npm run dev vue主要写的东西是些什么 components 页面html 公共区域需要抽取出来的 router 路由/网址路径 跳转到哪个组件/页面 views 页面开发 store-xxx.js 数据管理的地方所有组件都监听store中的内容，通过这里面的内容更新之后会通知每一个组件，达到每个组件数据之间的同步(更新)。 app.vue 入口组件这个里面的Home About按钮点击时没有刷新页面，只是将router-view里的标签切换了。比如说点击home按钮时， 1&lt;router-link to=&quot;/&quot;&gt;Home&lt;/router-link&gt; | 会在router-index.js找到path: ‘/‘， 123456 const routes = [&#123; path: &apos;/&apos;, name: &apos;Home&apos;, component: Home&#125;, 然后把对应的组件Home添加展示到app.vue中的这个标签里。 1&lt;router-view/&gt; vue是只有一个页面的，Header是顶部框不变的部分，下面的view是切换的不一样的页面展示(每个view要展示Header的话需要header的import文件路径，并且写上Header标签) vue项目里东西都放在哪里，都是干嘛的1.src-views开发页面的xxx.vue(Login.vue, Blogs.vue)全都放在view里面. xxx.vue这个叫做vue component. 不需要的about,home删掉。 src-views-xxx.vue文件xxx.vue 文件1.template 里面装html代码 里面只能有一个大标签，一般用div先装着。所有元素只能放在这个div标签里面，不能再写多个同级标签 2.script 里面装js代码 3.style 里面装css样式 2.src-router路由中心，控制路由/网址路径，会跳转到哪个组件/页面里面放index.js src-router-index.js文件index.js文件1.importimport 所有页面组件页面的xxx.vue文件每一个都需要import例如：导入login.vue文件import “name” from ‘vue文件所在路径’ 1import Login from &apos;../views/Login.vue&apos; //../返回上一级文件夹 2.Vue.use(VueRouter);//安装路由 3.const routes = [{路由1},{路由2}] const routes内容写这里，导出在后面4route这是一个数组， {路由}结构: 12345678910&#123; path: &apos;/&apos;, //路由路径 name: &apos;Index&apos;, //给这个&#123;&#125;路由起个名字 redirect: &#123;name:&apos;Login&apos;&#125; // path: &apos;/&apos;会重定向到name是&apos;Login&apos;的路由页面 &#125;, &#123; path: &apos;/login&apos;, name: &apos;Login&apos;, //这个路由叫login component: Login //跳转的组件，组件需要在最上面导入import &#125; 注意：路由1，路由2的访问是有先后顺序的。如果两个路由的path结构一样会先路由到上面的路由。 4.export default router配置导出路由，在其他类里就能用 怎么用路由： 1.main.js中 1234import router from &apos;./router&apos; //只用导文件夹，自动扫描里面的文件，里面文件取名router//显示声明使用router 这里是import router的Vue.use(router); 2.App.vue中加入标签router-view //p15 21:39 1234567&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-view&gt; &lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt; 3.src-App.vue入口组件1.template 只有两种标签1.router-link标签：就像href,点击跳转链接的.会去配的router里找path,再找component找到vue页面组件.不同的是，vue-link是单页跳转，就是说页面内容会局部填充到这些标签下面，这些标签一直会显示在所有页面上 2.router-view标签:是输入url跳转链接的.会去配的router里找path,再找component找到vue页面组件.页面内容完全填充整个页面 1234567891011&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-link to=&quot;/&quot;&gt;首页&lt;/router-link&gt; &lt;router-link to=&quot;/content&quot;&gt;内容页&lt;/router-link&gt; &lt;router-link to=&quot;/login&quot;&gt;登录页&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt; 2.script 3.style 里面装全局控制的css样式，不需要就删掉 4.src-main.js1.import用到的模块和插件都要导入基本的： 1234import Vue from &apos;vue&apos;import App from &apos;./App.vue&apos;import router from &apos;./router&apos; //只用导文件夹，自动扫描里面的文件，里面文件取名routerimport store from &apos;./store&apos; 之后要用的再继续在main.js中导入 2.Vue.use(xxx);//导入之后要显示声明使用routerVue.use(router); 各种步奏添加页面-配置路由1.添加src-views-xxx.vue文件2.src-router-index.js里面import vue组件，写一个路由3.App.vue中templete里面加入router-view或者router-link to 安装插件element-ui1.控制台vue项目文件夹路径下cnpm install element-ui –save2.项目中main.js 导入依赖之后就可以在项目中(xx)全局复制使用elementui的组件代码。 main.js 导入依赖：import Element from ‘element-ui’main.js 导入element-ui的css样式：import “element-ui/lib/theme-chalk/index.css” main.js 声明使用: Vue.use(Element);运行不成功安装提示的命令行安装 路由嵌套路由1234567891011121314151617&#123; path: &quot;/main&quot;, name: &apos;main&apos;, component: main, //children[&#123;&#125;,&#123;&#125;,&#123;&#125;]嵌套路由 外面大路由里面小路由 在main页面里面跳转 8080/user/profile 展示局部页面 children: [ &#123;path: &quot;/user/profile&quot;, name: &apos;profile&apos;, component: UserProfile &#125;, &#123; path: &quot;/user/list&quot;, name: &apos;list&apos;, component: UserList //写成功了ctrl+左键能点进vue组件 &#125; ] &#125; 页面局部展示 局部页面跳转用router-link to 12345678&lt;el-submenu index=&quot;1&quot;&gt; &lt;template slot=&quot;title&quot;&gt;&lt;i class=&quot;el-icon-message&quot;&gt;&lt;/i&gt; &lt;router-link to=&quot;/user/profile&quot;&gt;用户信息&lt;/router-link&gt;&lt;/template&gt; &lt;/el-submenu&gt; &lt;el-submenu index=&quot;2&quot;&gt; &lt;template slot=&quot;title&quot;&gt;&lt;i class=&quot;el-icon-menu&quot;&gt;&lt;/i&gt;&lt;router-link to=&quot;/user/list&quot;&gt;用户列表&lt;/router-link&gt;&lt;/template&gt; &lt;/el-submenu&gt; 局部页面展示写在el-main里面 123&lt;el-main&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/el-main&gt; url传递参数解释： 接收多个参数的url链接用数组，还要改路由. {name: ‘地址’, params:{参数: 参数值}. vm双向绑定，to需要绑定,v-bind:设置元素的属性. name是组件名(路由里设置的name),params传递参数需要对象，通过v-bind: 绑定对象，对象由路由里的path接收.第一种流程： 1.main页面router-link链接params传递参数 id:1. 2.路由path接收参数/:id. 3.跳转到的页面组件取出参数展示 1.主页面： 123&lt;template slot=&quot;title&quot;&gt;&lt;i class=&quot;el-icon-message&quot;&gt;&lt;/i&gt; &lt;router-link :to=&quot;&#123;name: &apos;profile&apos;, params:&#123;id:1&#125;&#125;&quot;&gt;用户信息&lt;/router-link&gt;&lt;/template&gt; 2.路由： 123456789101112&#123; path: &quot;/main&quot;, name: &apos;main&apos;, component: main, //children[&#123;&#125;,&#123;&#125;,&#123;&#125;]嵌套路由 外面大路由里面小路由 在main页面里面跳转 8080/user/profile 展示局部页面 children: [ &#123;path: &quot;/user/profile/:id&quot;, name: &apos;profile&apos;, component: UserProfile &#125; ] &#125; 3.跳转页面 1234567&lt;template&gt; &lt;div&gt; &lt;h1&gt;用户信息&lt;/h1&gt;&lt;!-- 数据双向绑定，取值展示到页面，取值用route--&gt; &#123;&#123;$route.params.id&#125;&#125; &lt;/div&gt;&lt;/template&gt; 第二种流程： 1.修改路由配置 props 2.页面组件添加 props,取值展示 1.路由 12345&#123;path: &quot;/user/profile/:id&quot;, name: &apos;profile&apos;, component: UserProfile, props: true //第二种绑定传参数 &#125;, 2.页面 123456789&lt;!-- 第二种方式props: [&apos;id&apos;]和path/:id绑定起来，html里面就可以取出来用了--&gt; &#123;&#123;id&#125;&#125;export default &#123; //路由那边props: true允许了id参数，组件这边props接收参数id // props: [&apos;id&apos;]和path/:id绑定起来，html里面就可以取出来用了 props: [&apos;id&apos;], name: &quot;&quot; &#125; 第三种流程(多参数不清楚)： 1.改main中params 2.改路由path: “/user/profile”,props: true 13.子页面props和取值&#123;&#123;id&#125;&#125;&#123;&#123;name&#125;&#125; props: [&apos;id&apos;, &apos;name&apos;], 路由push登录跳转到main页面带上用户的表单信息1.login组件 12345if (valid) &#123; alert(&apos;submit!&apos;); //进内容页main,登录push进当前用户的年龄 this.$router.push(&quot;/main/&quot; +this.ruleForm.age); &#125; 2.main的路由 1234path: &quot;/main/:age&quot;, name: &apos;main&apos;, component: main, props: true, 3.main组件 12&lt;span&gt;&#123;&#123;age&#125;&#125;&lt;/span&gt;props: [&apos;age&apos;], 写vue页面组件页面局部显示跳转页面1.子路由 123456789101112&#123; path: &apos;/vue&apos;, name: &apos;vuelearn&apos;, component: vue总结, children: [ //children写错没有提示 &#123; path: &apos;/vue01&apos;, name: &apos;vue01&apos;, component: vue01 &#125; ] &#125;, 2.主页面，没有router-view就不会展示子页面 12&lt;router-link to=&quot;/vue01&quot;&gt;01基本语法&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; vue页面结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;template&gt; &lt;div class=&quot;container&quot;&gt; &lt;/div&gt;&lt;/template&gt;&lt;script type=&quot;text/ecmascript-6&quot;&gt;export default &#123; data()&#123; return&#123; // 数据 &#125;; &#125;, components:&#123; // 组件注册 &#125;, beforeCreate()&#123; // 在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。 &#125;, create()&#123; // 实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。 &#125;, beforeMount()&#123; // 在挂载开始之前被调用：相关的 render 函数首次被调用。 &#125;, mounted()&#123; // el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。 &#125;, beforeUpdate()&#123; // 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。 你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。 &#125;, updated()&#123; // 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。 // 当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环 &#125;, beforeDestroy()&#123; // 实例销毁之前调用。在这一步，实例仍然完全可用。 &#125;, destroyed()&#123; // Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用。 &#125;, computed:&#123; // 计算属性 &#125;, watch:&#123; // 数据监听 &#125;, methods:&#123; // 方法定义 &#125;, created()&#123; //页面创建完成后执行的东西 &#125;,&#125;&lt;/script&gt;&lt;style&gt; // css 样式&lt;/style&gt; datadata:组件内的data必须是函数，这样每个组件就形成独立的函数作用域，彼此不冲突。 1.绑定文本数据info 123&lt;div class=&quot;wrap&quot;&gt; &lt;p&gt;&#123;&#123;info&#125;&#125;&lt;/p&gt; &lt;/div&gt; 2.绑定成为html元素的属性，需要使用v-bind指令(简写方式是 : ) 1&lt;p v-bind:title=&quot;info&quot;&gt;&#123;&#123;info&#125;&#125;&lt;/p&gt; 3.绑定多个属性值可以使用对象 123456789&lt;p v-bind=&apos;&#123;id: elemId, class: elemClass, &quot;data-cusData&quot;: cusData&#125;&apos;&gt;&#123;&#123;info&#125;&#125;&lt;/p&gt;data () &#123; return &#123; info: &apos;Hello vue!&apos;, elemId: &apos;pId&apos;, elemClass: &apos;pClass&apos;, cusData: &apos;hello world&apos; &#125;&#125; 指令 绑定数据 1234- 绑定事件 v-on### v-bind 绑定属性绑定html标签属性和vue实例的(data)属性，让他们保持一致 //这里显示的是Hello vue!这个页面加载于2020/11/3 下午8:19:39 鼠标在这里悬停几秒 //这里是鼠标放上去有提示这个页面加载于2020/11/3 下午8:19:39 info: ‘Hello vue!这个页面加载于’ + new Date().toLocaleString(), 123### v-if 判断是否显示标签v-if=&quot;表达式&quot; 表达式为true就显示这行v-if=&quot;表达式&quot; 表达式为false就不会显示这一行 显示 不显示 ok: 3&gt;2, 1234567```&lt;!-- 是js中的=== 类型和值都一样才是true--&gt; &lt;h1 v-if=&quot;type===&apos;A&apos;&quot;&gt;type是A&lt;/h1&gt; &lt;h1 v-else-if=&quot;type===&apos;b&apos;&quot;&gt;type是b&lt;/h1&gt; &lt;h1 v-else&gt;type不知道&lt;/h1&gt;type: &apos;b&apos;, v-for 循环显示标签v-for=”元素自己起名 in 数组名” v-bind:key=”元素” 1&#123;&#123;元素.键&#125;&#125; 这里是用键取值 v-for=”” v-bind:key=””两个指令写在一起的 1234567&lt;li v-for=&quot;item in items&quot; v-bind:key=&quot;item&quot;&gt; &#123;&#123;item.message&#125;&#125;&lt;/li&gt;//数组 &#123;键：值&#125;items:[&#123;message:&quot;lalalal&quot;&#125;,&#123;message: &quot;bbbbb&quot;&#125;], v-for=”(元素自己起名,index) in 数组名” v-bind:key=”元素” 1&#123;&#123;元素.键&#125;&#125; 这里index是它本身就有的，数组的索引。就是像占位符，里面可以进行数字运算/字符串拼接 12&lt;li v-for=&quot;(item, index) in items&quot; v-bind:key=&quot;item&quot;&gt; &#123;&#123;item.message &#125;&#125; + &#123;&#123;index&#125;&#125; 里面可以进行数字运算/字符串拼接 12345&lt;li v-for=&quot;(num, index) in nums&quot; v-bind:key=&quot;num&quot;&gt; &#123;&#123;num.num&#125;&#125; + &#123;&#123;index&#125;&#125; = &#123;&#123;num.num+index&#125;&#125;&lt;/li&gt;nums:[&#123;num:1&#125;,&#123;num: 2&#125;], v-on 绑定事件产生的方法v-on:jq的事件=”自定义方法名” 12345678&lt;button v-on:click=&quot;sayhi&quot;&gt;点击我&lt;/button&gt;methods:&#123; sayhi :function()&#123; alert(this.message); &#125;&#125; v-model 双向绑定vue是一个数据双向绑定的框架，即当数据发生变化的时候，视图也就发生变化；当视图发生变化的时候，数据也会跟着同步变化 v-model指令在表单form input textarea select 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。 输入框里输入，后面的message跟着输入变化 12345&lt;!-- --&gt;&lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt; &#123;&#123;message&#125;&#125;&lt;textarea name=&quot;&quot; id=&quot;&quot; cols=&quot;30&quot; rows=&quot;10&quot; v-model=&quot;message&quot;&gt;&lt;/textarea&gt; message: &quot;123123&quot; 上面选择之后qinSex值就会变成value的值，在这里取值出来 12345678910&lt;p&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot; v-model=&quot;qinSex&quot;&gt;男 &lt;/p&gt; &lt;p&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot; v-model=&quot;qinSex&quot;&gt;女 &lt;/p&gt;&lt;!-- 上面选择之后qinSex值就会变成男/女，在这里取值出来--&gt; &lt;p&gt;选中了谁：&#123;&#123;qinSex&#125;&#125;&lt;/p&gt;qinSex: &apos;&apos;, select下拉框 1234567891011下拉框ABCD：&lt;select v-model=&quot;ABCDSelect&quot;&gt; &lt;option value=&quot;&quot; disabled&gt;--请选择---&lt;/option&gt; &lt;option value=&quot;A&quot;&gt;A&lt;/option&gt; &lt;option value=&quot;B&quot; selected&gt;B&lt;/option&gt; &lt;!--selected 默认选择--&gt; &lt;option value=&quot;C&quot;&gt;C&lt;/option&gt; &lt;option value=&quot;D&quot;&gt;D&lt;/option&gt;&lt;/select&gt;&lt;p&gt;选中了谁：&#123;&#123;ABCDSelect&#125;&#125;&lt;/p&gt;ABCDSelect: &apos;&apos; v-model只能在在表单form input textarea select 元素上创建双向数据绑定。 只有v-bind:能缩写成： element-ui的主标签el-form绑定v-model只能写：model=”表单对象”，不然提交会收不到值 组件讲解拼装组合在页面上的版块 组件放在components里面items(数据数组)–&gt;item(遍历出来的数据)–&gt;qin(把遍历出来的数据放进模板) v-bind:qin=”item” 把item绑定以模板li显示,绑定之后可以动态刷新组件之间不能访问(component和data之间不能访问)，通过v-for把item遍历出来，通过v-bind把item和(component中的)qin绑定，通过props接收item向component传递的参数组件component是view,item是model. view 和 model之间关联需要viewmodel,所以需要v-bind去绑定理解为function,qin是function的形参，item是里面的实参。function是模板展示的功能，我们要把item展示出来，需要给function传递参数：qin=”item”,这样qin的位置就由item来占据代替，item就显示出来了。v-bind就是调用function时候的传值! function(qin=”item”) 12345678&lt;名字 v-for=&quot;item in items&quot; v-bind:qin=&quot;item&quot;&gt;&lt;/名字&gt;component:名字 props:[&apos;qin&apos;], template: &apos;&lt;li&gt;&#123;&#123;qin&#125;&#125;&lt;li&gt;&apos; 模板(自定义的展示方式)data: items:[1,2,3,4] axios异步通信vue不包含ajax的通信功能， 我们开发的接口大部分都是采用json格式 vue的生命周期从创建到销毁。 vue是先加载模板再把数据渲染上去，那么加载的过程是再变成data. 会有一个闪烁覆盖的过程1.安装axios: npm install axios –save2.main.js: import axios from ‘axios’ Vue.prototype.$axios = axios //定义之后在其他组件里面就可以直接使用$http3.然后在mounted(){}直接this.$axios就可以发起请求 this.$axios.post(‘/本页面’, this.ruleForm).then(response=&gt;{方法体}) this.$axios.get(东西).then(res =&gt; {方法体})【高亮！】json xhr 404原因： json文件位置错误解决：1.json文件需要存在public文件夹下，cli3之后public才是存放静态资源的地方,内置服务器对外暴露静态资源的位置，而不是之前的static了 2.请求时，直接写axios.get(‘/student.json’,{})即可，/ 直接指向项目下的public文件夹实例：json里数据拿到模板里面展示//info对象里面是data.json对应的数据//前端 请求的返回参数必须和json字符串一样//可以不写/少写，但是单词不要写错//钩子函数，链式编程。//this.$axios.get()拿到数据 .then(res=&gt;{}); 给出响应 12345678910111213141516171819202122232425262728&#123;&#123;info.name&#125;&#125;&#123;&#123;info.address.city&#125;&#125;data()&#123; return&#123; message: &quot;lalalalheloo&quot;, //info对象里面是data.json对应的数据 //前端 请求的返回参数必须和json字符串一样 //可以不写/少写，但是单词不要写错 info: &#123; name: null, address:&#123; street: null, city: null, country: null &#125; &#125; &#125;; &#125;,mounted()&#123; this.$axios.get(&apos;/data.json&apos;).then(res=&gt;&#123; console.log(res.data); &#125;); this.$axios.get(&apos;/data.json&apos;).then(res=&gt;&#123; this.info= res.data; //只用写data里的一级数据，info里的都对应了 &#125;);&#125;, 计算属性计算属性重点突出在属性两个字上，计算的结果放在属性里面。内存中运行：虚拟dom.它就是一个能够将计算结果缓存起来的属性(将行为转换成了静态的属性).调用方法的时候每次都需要进行计算，既然有计算过程就必定会产生系统开销。如果这个结果是不经常变化的，就把这个结果缓存起来，用计算属性computed，节约系统开销 12345678910111213141516&lt;!-- 通过方法调用--&gt; &lt;p&gt;当前的时间戳1：&#123;&#123;currentTime1()&#125;&#125;&lt;/p&gt;&lt;!-- 通过属性调用--&gt; &lt;p&gt;当前的时间戳2：&#123;&#123;currentTime2&#125;&#125;&lt;/p&gt;methods:&#123; currentTime1:function () &#123; return Date.now(); //返回一个时间戳 &#125; &#125;, computed:&#123; // 计算属性 currentTime2:function () &#123; return Date.now(); //返回一个时间戳 &#125; &#125;, 黑马vue快速入门vue特点 页面由数据生成，函数中用this.xxx修改数据,在展示模板中使用的元素会同步更新。 data:{}中像结构体那样写数据用,隔开 最后一个属性不加, 数据xxx: 值 xxx:function(){}中写java代码 每行用;隔开 最后一行也要写; 标签意思href=”” 超链接span 区域br 换行li 有序列表ul 无序列表div 区块 .vue文件template - 展示模板 html代码script - 导入组件，写数据，写函数(挂载到template内部id)style - css样式 (挂载到template内部id) 模板语法Vue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统： 123456789&lt;div id=&quot;app&quot;&gt; &#123;&#123; message &#125;&#125;&lt;/div&gt;var app = new Vue(&#123; el: &apos;#app&apos;, data: &#123; message: &apos;Hello Vue!&apos; &#125;&#125;) 基本结构的作用script里面写的是js语法，var app = new Vue({ })这里面写模板语法，吧数据渲染到上面的内容里Vue对象里面能渲染的是el挂载的元素标签内部 括号内：el:”#app”, 这个是告诉当前Vue对象他要管理的是div id=”app” div 之间的对象。data:{ }里放要渲染上去的数据，数据名与 div div中的数据名命中 data:{}数据对象Vue中用到的数据定义在data中data中可以写复杂类型的数据：字符串，数组，结构体 123456message: &quot;hello&quot;, school:&#123; name:&quot;黑马程序员&quot;, mobile:&quot;400800&quot; &#125;,compus:[&quot;北京校区&quot;,&quot;上海校区&quot;,&quot;深圳校区&quot;] 本地应用Vue指令内容绑定，事件绑定Vue指令：v-text v-html v-on基础 v-text:绑定文本 123&lt;h2 v-text=&quot;info+&apos;!&apos;&quot;&gt;深圳&lt;/h2&gt; //这里只会打印出&quot;info+&apos;!&apos;&quot;，h2标签里的深圳就被覆盖掉了&lt;h2&gt;啦啦啦&#123;&#123;message&#125;&#125;&lt;/h2&gt;//这里只会部分替换掉&#123;&#123;&#125;&#125;中的内容 v-html:绑定html结构的字符串，显示成html格式的。 12345678910111213&lt;div id=&quot;app&quot;&gt; &lt;h2 v-html=&quot;content&quot;&gt;深圳&lt;/h2&gt; 深圳不显示&lt;/div&gt;&lt;script&gt;var app = new Vue(&#123; el:&quot;#app&quot;, data:&#123; content:&quot;&lt;a href=&apos;https://lucifinil-x.github.io/&apos;&gt;我的博客&lt;/a&gt;&quot; //html语言，href是吧后面的内容变成跳转超链接 &#125; &#125;)&lt;/script&gt; v-on:为元素绑定事件, v-on:动作=”函数名” 123456789101112131415161718192021222324&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;演示指令&quot; v-on:click=&quot;doIt&quot;&gt; //按钮绑定click事件，做doIt:function()&#123;&#125; &lt;input tyep=&quot;button&quot; value=&quot;演示简写指令&quot; @click=&quot;doIt&quot;&gt; //v-on：可以简写为@ 后面的不变 &lt;input type=&quot;button&quot; value=&quot;双击事件+函数&quot; @dblclick=&quot;doIt&quot;&gt; //dblclick双击才弹窗 &lt;h2 @click=&quot;changeFood&quot;&gt;&#123;&#123;food&#125;&#125;&lt;/h2&gt; //没有超链接的文字也可以点，food值会更新&lt;/div&gt;&lt;script&gt;var app = new Vue(&#123; el:&quot;#app&quot;, methods:&#123; doIt:function()&#123; alert(&quot;做It&quot;); //alter是弹窗显示字符串 &#125;, changeFood:function()&#123; this.food+=&quot;好好吃&quot;; //console.log(this.food); &#125; &#125;&lt;/script&gt; 显示切换，属性绑定Vue指令：v-show v-if v-bind v-show:根据表达值的真假，切换元素的显示和隐藏(操作样式)频繁切换的元素用v-showv-show=”” 这里面的值最终转换成布尔值，true元素显示，false隐藏 1234567891011121314151617181920212223242526&lt;div id=&quot;vue_det&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;切换显示&quot; @click=&quot;change&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;切换显示2&quot; @click=&quot;addage&quot;&gt; &lt;img v-show=&quot;isShow&quot; src=&quot;https://s1.ax1x.com/2020/06/07/t29ldg.md.png&quot; alt=&quot;&quot;&gt; &lt;img v-show=&quot;age&gt;=18&quot; src=&quot;https://s1.ax1x.com/2020/06/07/t29ldg.md.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:&apos;#vue_det&apos;, data:&#123; isShow:false, age=17 &#125;, methods:&#123; change:function()&#123; this.isShow=!this.isShow; &#125;, addage:function()&#123; this.age++; &#125; &#125; &#125;) &lt;/script&gt; v-if:根据表达值的真假，切换元素的显示和隐藏(操纵dom元素)不频繁切换的元素用v-if 1234 &lt;input type=&quot;button&quot; value=&quot;切换显示&quot; @click=&quot;change&quot;&gt; &lt;p v-if=&quot;isShow&quot;&gt;黑马&lt;/p&gt;&lt;p v-show=&quot;isShow&quot;&gt;黑马11&lt;/p&gt; v-bind:设置元素的属性(都写在元素的内部):绑定，v-bind可以省略 1234&lt;img v-bind:src=&quot;imgsrc&quot; alt=&quot;&quot; v-bind:title=&quot;titlesrc+&apos;!!&apos;&quot;&gt; //title是鼠标移上去的提示&lt;br&gt;&lt;img :src=&quot;imgsrc&quot; alt=&quot;&quot;&gt; //可以省略v-bind &lt;img :src=&quot;imgsrc&quot; alt=&quot;&quot; v-bind:class=&quot;isActive?&apos;active&apos;:&apos;&apos;&quot; @click=&quot;toggleActive&quot;&gt; 这里的&apos;active&apos;是style样式 列表循环，表单元素绑定Vue指令：v-for v-on补充 v-model v-for:根据数据生成列表结构 123&lt;li v-for=&quot;(it,index) in arr&quot;&gt;&#123;&#123;index+1&#125;&#125;黑马程序员校区：&#123;&#123;it&#125;&#125;&lt;/li&gt; v-model: 数据双向绑定 12&lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt;&lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; 小黑记事本1.新增：生成列表结构(v-for 字符串数组) ，获取用户输入(v-model 双向绑定)，回车 新增数据(v-on .enter 添加数据) 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;body&gt; &lt;section id=&quot;小黑记事本&quot;&gt; &lt;header class=&quot;header&quot;&gt; &lt;h1&gt;小黑记事本&lt;/h1&gt; &lt;input v-model=&quot;inputValue&quot; v-on:keyup.enter=&quot;add&quot; autofocus=&quot;autofocus&quot; autocomplete=&quot;off&quot; placeholder=&quot;请输入任务&quot; class=&quot;newtodo&quot;&gt; &lt;/header&gt; &lt;section class=&quot;main&quot;&gt; &lt;ul class=&quot;todolist&quot;&gt; &lt;li class=&quot;todo&quot; v-for=&quot;(item,index) in list&quot;&gt; &lt;div class=&quot;view&quot;&gt; &lt;span class=&quot;index&quot;&gt;&#123;&#123;index+1&#125;&#125;.&lt;/span&gt; &lt;label&gt;&#123;&#123;item&#125;&#125;&lt;/label&gt; &lt;button class=&quot;destory&quot;&gt;&lt;/button&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/section&gt; &lt;footer class=&quot;footer&quot;&gt; &lt;/footer&gt; &lt;/section&gt; &lt;footer class=&quot;info&quot;&gt; &lt;/footer&gt;&lt;script&gt;var app = new Vue(&#123; el: &quot;#小黑记事本&quot;, data: &#123; list:[&quot;写代码&quot;,&quot;吃饭饭&quot;,&quot;睡觉觉&quot;], inputValue:&quot;好好学习，天天向上&quot; &#125;, methods:&#123; add:function()&#123; this.list.push(this.inputValue); &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt; 2.删除： 点击按钮删除指定内容(v-on splice 索引) 123456789101112131415161718192021222324252627282930313233343536373839404142434445 &lt;section id=&quot;小黑记事本&quot;&gt; &lt;header class=&quot;header&quot;&gt; &lt;h1&gt;小黑记事本&lt;/h1&gt; &lt;input v-model=&quot;inputValue&quot; v-on:keyup.enter=&quot;add&quot; autofocus=&quot;autofocus&quot; autocomplete=&quot;off&quot; placeholder=&quot;请输入任务&quot; class=&quot;newtodo&quot;&gt; &lt;/header&gt; &lt;section class=&quot;main&quot;&gt; &lt;ul class=&quot;todolist&quot;&gt; &lt;li class=&quot;todo&quot; v-for=&quot;(item,index) in list&quot;&gt; &lt;div class=&quot;view&quot;&gt; &lt;span class=&quot;index&quot;&gt;&#123;&#123;index+1&#125;&#125;.&lt;/span&gt; &lt;label&gt;&#123;&#123;item&#125;&#125;&lt;/label&gt; &lt;button class=&quot;destory&quot; @click=&quot;remove(index)&quot;&gt;&lt;/button&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/section&gt; &lt;footer class=&quot;footer&quot;&gt; &lt;/footer&gt; &lt;/section&gt; &lt;footer class=&quot;info&quot;&gt; &lt;/footer&gt;&lt;script&gt;var app = new Vue(&#123; el: &quot;#小黑记事本&quot;, data: &#123; list:[&quot;写代码&quot;,&quot;吃饭饭&quot;,&quot;睡觉觉&quot;], inputValue:&quot;好好学习，天天向上&quot; &#125;, methods:&#123; add:function()&#123; this.list.push(this.inputValue); &#125;, remove:function()&#123; console.log(&quot;删除&quot;); console.log(index); this.list.splice(index,1); &#125; &#125; &#125;)&lt;/script&gt;","categories":[],"tags":[]},{"title":"Postman使用","slug":"Postman使用","date":"2020-06-30T18:51:36.000Z","updated":"2020-06-30T19:09:20.432Z","comments":true,"path":"2020/07/01/Postman使用/","link":"","permalink":"https://lucifinil-x.github.io/2020/07/01/Postman使用/","excerpt":"","text":"使用 左上角New-Request 填写Request name, 下面选择一个文件夹或者Creat Folder 初次使用需要在下图位置添加键值对Content-Type application/json，不然会有utf-8的报错 Body中写username和password进行测试，选择raw和JSOPN。链接左侧选择POST，然后Send。具体信息在Param中查看","categories":[],"tags":[]},{"title":"vueblog的bug解决","slug":"vueblog的bug解决","date":"2020-06-30T18:10:38.000Z","updated":"2020-07-03T17:17:57.345Z","comments":true,"path":"2020/07/01/vueblog的bug解决/","link":"","permalink":"https://lucifinil-x.github.io/2020/07/01/vueblog的bug解决/","excerpt":"15-2login提交404login.vue中用axios post请求传参的时候提交浏览器显示404 not found","text":"15-2login提交404login.vue中用axios post请求传参的时候提交浏览器显示404 not found 12345678910111213141516171819202122232425262728293031323334methods: &#123; submitForm(formName) &#123; this.$refs[formName].validate((valid) =&gt; &#123; if (valid) &#123; const _this = this var params = new URLSearchParams(); this.$axios.post(&apos;/login&apos;, this.ruleForm).then(res =&gt; &#123; console.log(res.data) const jwt = res.headers[&apos;authorization&apos;] const userInfo = res.data.data // 把数据共享出去 _this.$store.commit(&quot;SET_TOKEN&quot;, jwt) _this.$store.commit(&quot;SET_USERINFO&quot;, userInfo) // 获取 console.log(_this.$store.getters.getUser) _this.$router.push(&quot;/blogs&quot;) &#125;) &#125; else &#123; console.log(&apos;error submit!!&apos;); return false; &#125; &#125;); &#125;, resetForm(formName) &#123; this.$refs[formName].resetFields(); &#125; &#125; &#125; 解决 vue项目中的代码没有任何问题 404的问题是出在后端的项目上 首先用POSTMAN测试后端的login有没有问题(/login需要200操作成功)。使用POSTMAN步奏指路：https://lucifinil-x.github.io/2020/07/01/Postman%E4%BD%BF%E7%94%A8/ 配置文件application.yml中少写了shiro-redis,需要补上如下(这里的host数值是固定的)： 1234567891011121314151617181920mybatis-plus: mapper-locations: classpath*:/mapper/**Mapper.xmlserver: port: 8081//这里有提示倒是没问题shiro-redis: enabled: true redis-manager: host: 127.0.0.1:6379//这里没有com.example.demo,不然就登录400base64-encoded secret key cannot be null or empty.example.demo: jwt: # 加密秘钥 secret: f4e2e52034348f86b67cde581c0f9eb5 # token有效时长，7天，单位秒 expire: 604800 header: Authorization 并且在pom.xml中添加： 12345&lt;dependency&gt; &lt;groupId&gt;org.crazycake&lt;/groupId&gt; &lt;artifactId&gt;shiro-redis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.2.1&lt;/version&gt;&lt;/dependency&gt; 这里最主要的是项目demo的前缀没写全example.demo: 检查这里非常重要，同样要检查resources-mapper下面两个xml，util-jwtUtils.java POSTMAN登录测试的时候，密码正确但触发”密码不正确”(密码和用户名是和数据库中匹配的没有问题)。用户名正确没有这种问题。原因：controller-AccountController.java中用了加密函数SecureUtil.md5，一边加了密一边没加密,equal一直为false.123if(!user.getPassword().equals(SecureUtil.md5(loginDto.getPassword())))&#123; return Result.fail(&quot;密码不正确&quot;); &#125; 改成： 123if(!user.getPassword().equals(loginDto.getPassword()))&#123; return Result.fail(&quot;密码不正确&quot;); &#125; 修改以上的地方再进行POSTMAN的登录测试就可以200操作成功了。然后在后端项目运行的状态下运行vue项目/login就可以顺利提交跳转到blogs页面没有404啦。(而且后端的localhost和vue的localhost不用一样) 15-3blogs页面的退出连接400不能到login页面 页面Could not get a resource from the pool后端控制台redis connection fail远程连接不上 我以为是yml里的shiro-redis有问题，检查了pom.xml，没有问题。 是因为没有安装redis,没有运行redis,也没有访问服务器到127.0.0.1:6379 安装指路：https://www.runoob.com/redis/redis-install.html 我安装到C:\\redis 打开cmd2命令行cd到 C:\\redis 然后运行 redis-server.exe redis.windows.conf 打开cmd3命令行cd到 C:\\redis 然后运行 redis-cli.exe -h 127.0.0.1 -p 6379 就能连接到redis远程服务端127.0.0.1:6379 回到blogs页面点退出连接就能回到login页面 注意：这两个cmd要一直打开不然又要400 17 Blogs.vue提示：[vue/valid-v-for] Custom elements in iteration require ‘v-bind:key’ directives. 1&lt;el-timeline-item :timestamp=&quot;blog.created&quot; placement=&quot;top&quot; v-for=&quot;blog in blogs&quot;&gt; 意思是v-for循环缺少键值对的key解决： 在v-for后面加 :key=’blog’ 这里的key就是 前面的 xx in blogs 1&lt;el-timeline-item :timestamp=&quot;blog.created&quot; placement=&quot;top&quot; v-for=&quot;blog in blogs&quot; :key=&apos;blog&apos;&gt; 修改之后页面控制台报错有红；不改页面没事，项目有红 改项目名字吓死我了，一片红 还是不要轻易改好了。做好备份 安装位置相关 element-ui: vue项目的根目录 mavon-editor: vue项目的根目录 node.js: d盘 redis: d盘 lombok插件jar包： eclipse.exe的根目录，附带ini最后两行 md样式插件： vue项目的根目录 windows powershell: c盘 errorError creating bean with name ‘UserController’https://blog.csdn.net/qq_38701478/article/details/88808628?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase 我的问题是/vueblog/src/main/java/com/example/demo/config/MybatisPlusConfig.java复制过来没有改@MapperScan(“com.example.demo.mapper”) 教训：不要质疑代码生成器给的类的注解。 另外注意：UserService类上不加注解；UserServiceImpl类上加@Service注解 还有一个问题是application.yml中dataSource不应该加之前写的type http://localhost:8080/user/index 查询出来空白{}他的有id=1的信息格式。这个项目里没找到index.html AccountRealm.java里的爆红 user.getstatus()爆红：the method is not defined for the type User. 首先user类中是没有这个函数的。这个东西是应该在lombok里面。 在eclipse和，maven仓库里搜索lombok,找到文件夹中的jar包，安装路径选择eclipse.exe所在的文件夹路径。 重要的是安装之后eclipse.exe所在的文件夹的ini文件最后一行自动添加了一行，这时候eclipse直接打不开了。 删除最后一行换成这两行 javaagent:lombok.jar Xbootclasspath/a:lombok.jar log.info()爆红：这是日志输出的函数，需要导入import lombok.extern.slf4j.Slf4j;，在类名上面加@Slf4j注解。 特别恶心的是eclipse有时候爆红消不掉，明明没有错/已经改好了。比如log爆红，需要剪切导入的包再粘贴一遍就好了。 他妈的，今天eclipse又卡不开了 ，删掉了昨天加的两行 打开eclipse之后又出现爆红，关掉再开运行出错 选中当前项目，右击“项目”→选择Properties，在弹出的对话框左侧列表中选择Java Build Path，如下图所示：选择Add External JARs，就可以逐个添加第三方引用jar包。 加了最新的jar没用 那些get()set()方法其实就是gettersetter,手动在User类中添加；lombok就是简化这些简单的函数 无法启动因为路径有中文 安装之后再次启动依旧爆红！ 因为eclipse不能自动刷新import的包，必须手动刷新！ 删除import的lombok保存，再粘贴保存！ 有些本身函数是调用另外一个类的，需要在另外那个类中刷新 第二天eclipse又打不开。ini文件删掉最后两行在保存在粘贴在保存就能打开 要认证后才能访问 在UserController的index页面上面添加注解@RequiresAuthentication(要认证后才能访问的接口)再启动项目，就会看到页面上的全局异常抛出的信息1&#123;&quot;code&quot;:401,&quot;msg&quot;:&quot;The current Subject is not authenticated. Access denied.&quot;,&quot;data&quot;:null&#125; 注解/包cannot resoloved to a type 因为eclipse没有下载相关maven包。 点fix project set up选择然后ok 就会下载了包然后import进来 启动失败a bean BlogService could not be found. 就是BlogService找不到 找不到因为没找到这个bean. 说明注解有问题：我的BlogServiceIpl实现类上面没加@Service 另外注意@Service只加在实现类上面，service类加这个注解没有用，不用加任何注解。 eclipse中加入vue插件 安装报错Unable to read repository at http://downloads.genuitec.com/downloads/products/codemix/updates/cm20200407/plugins/pack.core.win_3.6.0.202001241725.jar 原因：网络不稳定 问题的解决方法是：直接把上面的连接放入浏览器直接下载，或放入下载工具进行下载好。 再把下载好的文件放入eclipse的安装目录下的plugins文件夹下。再重新安装，问题就解决了。","categories":[],"tags":[]},{"title":"vue-vueblog","slug":"vue-vueblog","date":"2020-06-29T17:32:18.000Z","updated":"2020-11-09T07:45:09.638Z","comments":true,"path":"2020/06/30/vue-vueblog/","link":"","permalink":"https://lucifinil-x.github.io/2020/06/30/vue-vueblog/","excerpt":"启动vue项目 cmd到项目路径 d: cd D:\\vue博客项目\\vueblog然后 npm run serve 或者：idea中打开vue的项目文件夹，ALT + F12 在idea里面打开terminal(cmd的终端)，会自动定位到当前项目目录，然后 npm run serve","text":"启动vue项目 cmd到项目路径 d: cd D:\\vue博客项目\\vueblog然后 npm run serve 或者：idea中打开vue的项目文件夹，ALT + F12 在idea里面打开terminal(cmd的终端)，会自动定位到当前项目目录，然后 npm run serve 启动顺序 vueblog后端springbootapp cmd1命令行 启动vue前端项目(上面启动命令行/idea中命令行/右键+powershell) cmd2(新的cmd)命令行 cd C:\\redis然后运行 redis-server.exe redis.windows.conf (两行全部复制不要复制漏了) cmd3(新的cmd)命令行 cd C:\\redis然后运行 redis-cli.exe -h 127.0.0.1 -p 6379就能连接到redis远程服务端127.0.0.1:6379(注意是两个cmd! cmd23要一直打开) 安装位置相关 element-ui: vue项目的根目录 mavon-editor: vue项目的根目录 node.js: d盘安装包 c盘安装位置 搜索运行C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Node.js redis: d盘安装包 c盘安装位置 lombok插件jar包： eclipse.exe的根目录，附带ini最后两行 md样式插件： vue项目的根目录 windows powershell: c盘 前期准备当前文件夹中打开windows powershellc窗口 注意 只是右键是看不到这个的，要用shift+右键 但是直接这样就报错：无法加载文件 C:\\Users\\A\\AppData\\Roaming\\npm\\vue.ps1，因为在此系统上禁止运行脚本 需要修改权限。搜素powershell,然后执行：set-ExecutionPolicy RemoteSigned；查看执行策略：get-ExecutionPolicy vue ui没反应 查看vue的命令列表中没有ui这个命令 vue -h 必须要安装3.0以上的，老师给的代码安装的是2.9 1.$npm uninstall vue-cli -g //卸载vue-cli旧版本2.$npm install -g @vue/cli //安装新版本3.$npm vue -V //查看版本3.vue -h //查看vue cli安装的版本中有什么命令 解决博客https://blog.csdn.net/Demo__/article/details/89404235 和vue相关的依赖插件都可以在执行vue ui后的localhost页面中查看 新建vue项目：左侧-任务-serve-运行-输出(点击查看)-App ready 想要新建项目的话需要点左下角的小房子或者左下角的文件夹，选择要放置新项目的文件夹。 输入项目名称(不能有中文)-手动配置项目-选择功能Bable,Router,Vuex-创建-创建项目，不保存预设 eclipse中加入vue插件 安装中途报错暂停Unable to read repository at http://downloads.genuitec.com/downloads/products/codemix/updates/cm20200407/plugins/pack.core.win_3.6.0.202001241725.jar 原因：网络不稳定，没有下载下来 问题的解决方法是：直接把上面的连接放入浏览器直接下载，或放入下载工具进行下载好。 再把下载好的文件放入eclipse的安装目录下的plugins文件夹下。eclipse中workplace搜索vue再重新安装，问题就解决了。 eclipse导入已经创建好的vue项目 file-openproject 然后看看能不能识别vue element-ui安装 控制台vue项目文件夹路径下cnpm install element-ui –save 项目中main.js 导入依赖之后就可以在项目中全局复制使用elementui的组件代码。main.js 导入依赖：import Element from ‘element-ui’main.js 导入element-ui的css样式：import “element-ui/lib/theme-chalk/index.css”main.js 声明使用: Vue.use(Element); (安装SASS加载器，没有用 cnpm install sass-loader node-sass –save-dev) vue主要写的东西是些什么 components 页面html 公共区域需要抽取出来的 router 路由/网址路径 跳转到哪个组件/页面 views 页面开发 store-xxx.js 数据管理的地方所有组件都监听store中的内容，通过这里面的内容更新之后会通知每一个组件，达到每个组件数据之间的同步(更新)。 app.vue 入口组件这个里面的Home About按钮点击时没有刷新页面，只是将router-view里的标签切换了。比如说点击home按钮时， 1&lt;router-link to=&quot;/&quot;&gt;Home&lt;/router-link&gt; | 会在router-index.js找到path: ‘/‘， 123456 const routes = [&#123; path: &apos;/&apos;, name: &apos;Home&apos;, component: Home&#125;, 然后把对应的组件Home添加展示到app.vue中的这个标签里。 1&lt;router-view/&gt; vue是只有一个页面的，Header是顶部框不变的部分，下面的view是切换的不一样的页面展示(每个view要展示Header的话需要header的import文件路径，并且写上Header标签) .vue文件标签(直接写标签显示不出来) template：模板里面必须有一个div标签作为他的主标签(只能是单个元素，所有元素只能放在单个元素里面)， script：放样式 注释 用//注释 ctrl shift c全部注释 routerimport 所有页面组件12import Vue from &apos;vue&apos;import VueRouter from &apos;vue-router&apos; 1import Login from &apos;../views/Login.vue&apos; path细节 要编辑需要传过来一个id,这里加: blogId就会作为一个参数，页面就会获取到这个参数 1path: &apos;/blog/:blogId/edit&apos;, path为/blog/:blogId’的这个结构体要放在/blog/:blogId/edit的前面因为路径较短 注意path:/blog/add一定放在path: ‘/blog/:blogId’之前，因为add和:blogId是有可能匹配上的。如果add放在blogId后面，访问add的时候会先路由到blogId里面而不是add里面。 写.vue页面Login.vue 1.选择第一种element的布局容器：上下布局head和main 写在template-div标签里面，之后都在el-header，el-main标签中填充内容。 1234&lt;el-container&gt; &lt;el-header&gt;Header&lt;/el-header&gt; &lt;el-main&gt;Main&lt;/el-main&gt;&lt;/el-container&gt; 2.选择复制element的布局容器中给的样式style,分条装在el-header或者el-main标签里面 12345678&lt;el-container&gt; &lt;el-header&gt; 这里写标题/放图片，可以调整图片的位置距离上方的高度 &lt;/el-header&gt; &lt;el-main&gt;Main&lt;/el-main&gt;&lt;/el-container&gt; 3.Form表单和验证规则(如果不填名字密码，在下方会有提示) 只要用户名 密码 提交框(登录 重置) Header.vue Header: 头部栏，写在这个vue里的都是头部栏里能看能点的东西 最上面 h3: 最上面的标题 div-block: 标题下面的那个图片参数：size:图片大小；src：user里的图片信息；div标签：图片下面的一行字(用户名) 头像下面的三个能跳转的链接 主标签div class=”maction” 主页el-link:超链接标签； herf：跳转到的路径el-divider:分开主页、发布文章、登录/退出的分割线； direction:分割线的方向(这里用的垂直) 发表文章span: 状态标签，这里没东西 可以不写el-link:超链接标签； 链接的属性(名称-会对应不同的颜色)； herf：跳转到的路径 : disabled: 不能跳转的情况；el-divider:分开主页、发布文章、登录/退出的分割线； direction:分割线的方向(这里用的垂直) 登录/退出span v-show:展示登录还是退出的条件登录： el-link:超链接标签； type:链接的属性(名称-会对应不同的颜色)； herf：跳转到的路径退出： el-link:超链接标签； type:链接的属性(名称-会对应不同的颜色)； @clink:这里是对应一个方法(写在下面的script标签里) scriptmethods 这里写的是退出里的@clink=”logout”的方法。简而言之：删掉用户信息，再回写除了密码之外的信息。这里我们用的是jwt,后端的jwt是无状态的，没有存到redis里进行状态的处理。所有这里的退出可以直接把localstore里的信息删掉就行了，可以不请求后端。如果后端的jwt token信息是有状态的，就需要去请求后端(用axios发起请求)。而且后端的Logout是需要授权的，这里就需要对headers进行配置，添加token信息(通过localstore获取)1heards:&#123;&quot;Authorization&quot;: Localstoreage.getItem(&quot;token&quot;) &#125; 后端需要删除token信息和清除state状态信息，调用后端的REMOVE_INFO方法。然后用router跳转到/login界面。清除之后要创建新的用户信息，写方法created():如果用户名不为空的时候，进行用户名、头像、登录状态的回写。 blog.vuevuelog博客思路技术栈 后端： SpringBoot Mybatis Plus shiro redis hibernate validator jwt 前端：vue element-ui axios 博客功能 用户登录 用户退出 blog主页列表(element-ui样式) blog详情页(md格式展示) blog编辑/发表(markdown格式mavon-editor编辑器) 技术对应作用 SpringBoot：基础框架，在未来易拓展，适合微服务化体系 Mybatis Plus：让项目能完成基本的增删改查操作，节省大量时间 Shiro：作为权限(验证)，使用简单配置简单 Redis: 会话等信息需要共享,Redis是现在主流的缓存中间件，适合项目 jwt: json web token因为前后端分离，所以使用jwt作为用户身份凭证 devtools：项目的热加载重启插件 lombok：简化代码的插件工具vueelement-uiaxiosmavon-editormarkdown-itgithub-markdown-css vue前端 vue整合element-ui axios(命令行安装) 页面：登录页面，博客列表页面，博客详情页面，博客编辑页面 前端路由权限拦截 判断哪些路由需要权限（/add /edit）meta: { requireAuth: true}, 路由前置拦截axios在发起请求之前有一个前置拦截判断该路由的meta里信息如果是true的话就需要权限，然后判定有无token。如果有Token就跳转到下一个路由 next（）；如果没有token-&gt;跳转到login界面 但是项目中没有用跳转用的是禁止，直接访问没有跳转到login 为了让这个错误弹窗能运用到所有的地方，所以我对axios做了个后置拦截器，就是返回数据时候，如果结果的code或者status不正常，那么就有对应的弹窗提示。 登录页面-登录逻辑 前端页面提示需要输入用户名和密码 前端页面提交时axios发起请求(axios发起请求的时候都会有一个域名/当前页面url) 后端进行密码校验，如果正常，生成jwt，返回给用户 从返回的结果请求头中获取到token的信息，然后使用store提交token和用户信息的状态。完成操作之后，我们跳转到到了/blogs路由，即博客列表页面。 存储token，用的是localStorage; 存储用户信息，我们用的是sessionStorage。 博客列表页面 页面头部我们需要把用户的信息展示出来，因为很多地方都用到这个模块，所以我们把页面头部的用户信息单独抽取出来作为一个组件。 头部的用户信息，应该包含三部分信息：id，头像、用户名，而这些信息我们是在登录之后就已经存在了sessionStorage。因此，我们可以通过store的getters获取到用户信息。 上面代码created()中初始化用户的信息，通过hasLogin的状态来控制登录和退出按钮的切换，以及发表文章链接的disabled，这样用户的信息就能展示出来了。 退出逻辑：在methods中有个logout()方法，逻辑比较简单，直接访问/logout，因为之前axios.js中我们已经设置axios请求的baseURL，所以这里我们不再需要链接的前缀了哈。因为是登录之后才能访问的受限资源，所以在header中带上了Authorization。返回结果清除store中的用户信息和token信息，跳转到登录页面。 项目综述SpringBoot+vue的博客项目基本功能：用户登录页面，用户退出，blog主页列表(element-ui样式)， blog详情页(markdown格式展示)，blog编辑/发表(markdown格式mavon-editor编辑器)使用技术：SpringBoot作为基础框架，Mybatis Plus：让项目能完成基本的增删改查操作，省去自己写mapper、service, Shiro：权限校验、登录认证，Redis: 储存shiro的权限数据和会话信，jwt: 作为前后端分离的用户身份凭证；vue项目使用：element-ui，axios，mavon-editor，markdown-it，github-markdown-css功能逻辑：使用用户名密码登录axios发起请求，后端进行密码校验，如果正常，生成jwt，返回给用户。从返回的结果请求头中获取并提交token的信息跳转到blog主页列表。如果异常，全局异常捕获，页面弹窗异常信息。Blog主页做了页面头部将用户的信息展示出来，element-ui时间线样式做列表，还有分页。Blog详情页使用插件markdown-it将markdown格式的内容渲染展示出来。使用mavon-editor编辑器进行blog的编辑，点击按钮提交表单。","categories":[],"tags":[]},{"title":"面试准备-java","slug":"面试准备-java","date":"2020-06-22T17:26:48.000Z","updated":"2021-03-16T06:08:03.798Z","comments":true,"path":"2020/06/23/面试准备-java/","link":"","permalink":"https://lucifinil-x.github.io/2020/06/23/面试准备-java/","excerpt":"String判断指向地址or值 只要记住一点！1.编译期决定 -&gt; 一定指向常量池2.运行时决定(且不是intern()) -&gt; 一定指向堆3.== 判断地址是否相同 编译期进入常量池： String a = “123”; “1”+”2”+”3”;运行期堆上分配： String b = new String(“123”); a+a+a;a==b判断的是指向的对象的地址，虽然a b对象的值相同，但是a指向常量池中对象的地址，b指向堆内存上对象的地址。 123456System.out.println(a == b); //falseSystem.out.println(a ==&quot;1&quot;+&quot;2&quot;+&quot;3&quot;);//trueString s1=&quot;1&quot;;String s2=&quot;2&quot;;String s3=&quot;3&quot;;System.out.println(a ==s1+s2+s3);//false a在常量池，s1+s2+s3是运行时堆上分配 final Stirng s1 = “1”;final是类可被继承(函数不能重写)，变量不可被修改；这时的编译期s1指向的就是常量池中的”1”. 12345String s0=&quot;12&quot;;final String s1 = &quot;1&quot;; //常量池String s2=&quot;2&quot;+s1; //直接常量池System.out.println(s0 == s2);//true 常量池==常量池System.out.println(s0 == &quot;1&quot;+s1);//true String s1 = new String(“abc”);s1.intern()会去常量池中找相同值的对象，如果有返回常量池地址,没有a==b返回false. 1234String a = &quot;123&quot;; //常量池String b = new String(&quot;123&quot;); //堆System.out.println(a == b); //falseSystem.out.println(a == b.intern()); //true 常量池==常量池","text":"String判断指向地址or值 只要记住一点！1.编译期决定 -&gt; 一定指向常量池2.运行时决定(且不是intern()) -&gt; 一定指向堆3.== 判断地址是否相同 编译期进入常量池： String a = “123”; “1”+”2”+”3”;运行期堆上分配： String b = new String(“123”); a+a+a;a==b判断的是指向的对象的地址，虽然a b对象的值相同，但是a指向常量池中对象的地址，b指向堆内存上对象的地址。 123456System.out.println(a == b); //falseSystem.out.println(a ==&quot;1&quot;+&quot;2&quot;+&quot;3&quot;);//trueString s1=&quot;1&quot;;String s2=&quot;2&quot;;String s3=&quot;3&quot;;System.out.println(a ==s1+s2+s3);//false a在常量池，s1+s2+s3是运行时堆上分配 final Stirng s1 = “1”;final是类可被继承(函数不能重写)，变量不可被修改；这时的编译期s1指向的就是常量池中的”1”. 12345String s0=&quot;12&quot;;final String s1 = &quot;1&quot;; //常量池String s2=&quot;2&quot;+s1; //直接常量池System.out.println(s0 == s2);//true 常量池==常量池System.out.println(s0 == &quot;1&quot;+s1);//true String s1 = new String(“abc”);s1.intern()会去常量池中找相同值的对象，如果有返回常量池地址,没有a==b返回false. 1234String a = &quot;123&quot;; //常量池String b = new String(&quot;123&quot;); //堆System.out.println(a == b); //falseSystem.out.println(a == b.intern()); //true 常量池==常量池 Validate验证器闲话 我认为我现在面对的是各个主体之间错综复杂的关系。我需要用逻辑去找到各个主体之间的联系与怎样联系。再找到主体之间的起始通路与终点。就像是容器中的组件，一个连接另一个，一个注入另一个。好的文章通过(作者的逻辑)带着我们从始到终，解释个体之间的联系。 equals 和 ==== 比较的索引地址。equals比较值 “string” == “string”; //trueString x = “string”;String z = new String(“string”);x == z; //false HashMap hashmap在jdk1.7和jdk1.8版本的区别 数据结构不同： 1.7中的HashMap是数组+链表的结构 1.8中的HashMap是数组+链表+红黑树的结构 链表插入方式不同： 1.7使用的是头插法,头插法在进行扩容时存在线程安全问题导致链表死循环 1.8使用的是尾插法 扩容后重新计算索引的方式不同： 1.7将会使用扩容后的大小重新与hash计算索引 1.8会判断之前hash中需要加入计算索引位置是0还是1，是0则保持原位，1则在现在索引的基础上加上新增的容量则是计算后的索引 什么时候创建数组？为什么？数组是在map.put(key,value )的时候创建的。数组并不是在new HashMap对象的时候创建的,因为创建对象就会在堆内存里占用连续的内存空间 数组+链表的结构怎么存放键值对数据？Put进键值对时，是在hashmap的16格(0-15)中加入键值对，当新加入的键值对所在的数组格子位置里有值的时候，就会和格子里的键值对形成链表，这个叫做hash冲突。数组查询时间复杂度是O(1),链表查询复杂度是O(n).所以要提高查询效率，就要减少链表的长度，当数组容量使用超过16x0.75时，就会进行数组扩容，减少hash冲突，提高查询效率。 什么时候引入红黑树？是为了什么？当链表长度大于8时，如果数组容量超过64，数组格子里的链表结构转换为红黑树如果数组容量小于64，只会进行数组扩容引入红黑树为了增加查询效率时间复杂度变成对数阶O(log2n) 怎么确定键值对在数组中的位置？key的hash值与数组最大索引进行与运算 hashmap存储过程=hashmap的工作原理？ 根据key计算一个hash值 在put时判断数组是否存在，如果不存在调用resize()创建默认容量为16的数组 key的hash值与数组最大索引进行位运算(与运算)，确定node在数组中的位置 判断该位置是否有元素，如果没有元素，会新建一个node放在该位置；如果有元素，判断key是否完全相同，吧原来的node赋值给一个变量 此时再判断该node的位置是红黑树还是链表 如果是红黑树，以红黑树的方式将node放在红黑树上(特别的二叉树) 如果是链表，尾插法：遍历链表，将node放在最后一位 放完以后，就要判断当链表长度大于8时，如果数组容量超过64，数组格子里的链表结构转换为红黑树；如果数组容量小于64，只会进行数组扩容 返回被覆盖的值 判断整个数组是否需要扩容 hashmap的扩容为什么每次都是2次幂？减少hash碰撞 hashmap的线程安全问题发生在哪个阶段？线程安全问题产生的原因：多个线程访问同一个资源。发生在put放值(链表/红黑树放结点)进行判断的时候，p.next=newNode().多个线程都进来了，newNode()在赋值的时候就会漏点。 如何解决线程安全问题？concurrentHashMap就是使用锁分段技术专门用来实现线程安全的底层采用分段的数组+链表实现，线程安全。ConcurrentHashMap是使用了锁分段技术来保证线程安全的。 锁分段技术：首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。 位运算有哪些？左移 0011-&gt;0110右移 0110-&gt;0011或运算 一真则真与运算 一假则假按位取反 1变0异或运算 相同为0 不同为1 同步 cynchronized关键字保证同步，同步代码块和同步函数的区别？同步函数: 用this作锁，因为函数必须被对象调用；线程任务只需要一个同步时可以用。同步代码块： 任意对象作锁；线程任务需要多个同步 时，必须用不同的锁来区分。 所以同步代码块比较常用。 饿汉式和懒汉式饿汉式不会有多线程并发问题，在类创建的同时就已经创建好一个静态的对象供系统使用,以后不在改变。懒汉式在线程任务中new对象，并发访问就有安全隐患，应该加入同步机制解决安全问题。 一个线程不能多次start，会报错.IllegalThreadStateException redis redis是什么？redis是内存数据库(key-value 非关系型 没有SQL)，存放经常被访问的数据(热数据)。缓存中间件(有redisCacheManager)单进程单线程模型的KV数据库。value的类型：string,list,hash,set,sorted set.但是规避set操作，会影响性能 redis可以拦截一部分请求，降低接触mysql的频率 在你的项目中redis是如何运用的？ 目前我的项目里整合了shiro-redis，为之后的集群和负载均衡(mysql数据库系统不会因为单个崩溃而崩溃)做准备。但是目前项目很简单，数据量也比较少，还没有做集群和负载均衡。 现在是用redis来存储shiro的权限数据和会话信息(Session会话管理是shiro的作用之一，体现在ShiroConfig中的SessionManager函数)。 磁盘寻址：毫秒级别，慢内存寻址：纳秒级别，快文件存储是线性的，文件读取就要把文件从头开始全部读一遍。文件读取是全量IO,磁盘IO. 磁盘IO:百兆级别100mb 缓存击穿请求缓存中没有但数据库中有的同一条数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据解决：一般不解决 缓存穿透(击穿和雪崩的本质)用户一直发起请求查找缓存(redis)和数据库中都没有的数据,导致每次请求都要mysql数据库中查找，流量大的时候mysql数据库就挂了解决1：布隆过滤器，用一定的(拦截)错误率换取空间解决2：查询的value返回null,存在redis中 缓存雪崩redis缓存中不同数据大批量到过期时间，去数据库中查询，就崩了解决：缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。设置热点数据永远不过期。二级缓存 apache shiro shiro是什么？shiro是强大且易用的java安全框架，执行 身份验证(登录)、授权、会话管理、密码学。 shiro的六大作用是什么？ Authentication 认证 -用户登录 Authorization 授权 -给用户哪些权限 Cryptography 安全数据加密 Session Managment 会话管理 Web intergration web 系统集成 Interations 集成其他的应用 -比如集成spring/缓存框架redis shiro的核心API(接口/是都需要重写的函数！)都是什么？有什么作用？ Subject: 用户主体 (把操作交给SecurityManager,要关联它) SecurityManager: 安全管理器 （关联Reaml） Realm: Shiro连接数据的桥梁,shiro想要查询数据库/配置文件获取用户信息，这些事情都要靠realm来完成。realm中执行认证和授权。认证中具体实现用户名和密码匹配 以上shiro三个API之间的关系？ Subject关联SecurityManager,SecurityManager关联Realm SecurityManager关联Realm：DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(accountRealm); SecurityManager关联Subject：关联函数：A.setB 如：securityManager.setSubjectDAO(subjectDAO); 怎么整合shiro-redis-springboot? 导shiro-redis-springboot依赖和jwt工具包和hutool工具包 写shiro的配置类ShiroConfig： 让shiro的权限数据和会话信息存在redis中，引入了redisSessionDAO、redisCacheManagersecurityManager.setSessionManager(sessionManager.setSessionDAO(redisSessionDAO));//简写securityManager.setCacheManager(redisCacheManager);//配置redis缓存 重写SessionManager和DefaultWebSecurityManager，关闭shiro自带的session方式，这样用户就不再能通过session方式登录shiro。后面将采用jwt凭证登录。DefaultWebSecurityManager中Subject关联SecurityManager,SecurityManager关联Realm。 所有的路由都需要经过JwtFilter这个过滤器，然后判断请求头中是否含有jwt的信息，有就登录，没有就跳过。跳过之后，有Controller中的shiro注解进行再次拦截，比如@RequiresAuthentication，这样控制权限访问。 写shiro进行登录或者权限校验的逻辑类AccountRealm：重写3个方法，分别是：supports：为了让realm支持jwt的凭证校验doGetAuthorizationInfo：权限校验doGetAuthenticationInfo：登录认证校验 -拿到需要验证的token，解析token拿到用户id,根据id去拿到用户对象，判断用户状态。将登陆成功的用户对象中的信息复制到profile对象中，然后返回一个登录成功(已认证)的用户信息载体对象SimpleAuthenticationInfo)(shiro里的) 用户登录信息-Session-shiro-redis小小总结：用户登录信息存放在Session中；Session被shiro管理；shiro的信息(权限数据、会话管理信息)存放在redis中。 将shiro内部构建展示出来，上面这些连接变成了：用户登录信息-Session-subject-securitymanager-redis-realm-mysql jwt jwt的构成 = 加密header+加密payload+加密signature 这三个拼在一起的字符串 头部（header)：声明类型，这里是jwt；声明加密的算法。 载荷（payload, 存放有效信息类似于飞机上承载的物品)：标准中注册的声明；公共的声明；私有的声明 签证（signature)：用header中声明加密的算法对(加密后的header+加密后的payload+secret)组合加密 认为jwt=token 用户登录和请求的流程用户使用用户名密码来请求服务器服务器进行验证用户的信息服务器通过验证发送给用户一个token客户端存储token，并在每次请求时附送上这个token值服务端验证token值，如果验证通过就会返回相应的资源(给接口)这个token必须要在每次请求时传递给服务端，它应该保存在请求头里 项目中是用的jwt凭证登录。 jwt不需要在服务端保存会话信息Session, 用户信息ession保存在客户端 每次请求校验，通过服务端的私钥和过期时间(定义在yml里面)来校验合法性 项目中的jwtUtil是jwt的工具类。四个注解：@Slf4j -为类提供一个 属性名为log 的 log4j 日志对象，调用打印日志@Data -提供类所有属性的 getting 和 setting 方法，此外还提供了equals、canEqual、hashCode、toString 方法@Component -组件@ConfigurationProperties(prefix = “example.demo.jwt”) -外部化配置，在配置文件/配置类外面写配置相关的。这里绑定和验证一些外部属性（.Properties文件中example.demo.jwt下面配置的三个属性） 三个属性：header expire secret. 三个方法： 生成jwttoken: 那三个组成拼起来的字符串 获取jwttoken的信息： 解析jwt 判断token是否过期： 过期时间before当前时间-&gt;过期-&gt;返回true 在AccountRealm中使用了工具类就是要先注入这个类@Autowired，就不用new对象了。 Cookie和Session 两个数据存放在哪里？cookie数据存放在客户的浏览器上；session数据放在服务器上。 cookie的特点和限制是什么？ cookie不是很安全，因为别人可以分析存放在本地的COOKIE并进行COOKIE欺骗。 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。 两个数据里能存什么？cookie里只能存放字符串；session里能存放任何类型的数据，如字符串、集合、类、对象。 用户能看见吗？cookie对用户可见；session对用户不可见(透明) 有效期的差别？ 比如浏览器上百度账号登录信息长期有效？cookie可以容易的达到登录信息长期有效，只要把有效期设为很大的数字；session不能长期有效，容易导致服务器的内存溢出。比如说我们项目使用jwt设置了有效期7天。 并发访问的用户多的时候，用哪个来追踪用户会话？用cookie。因为一个用户就会产生一个session/cookie. session存在服务器端，产生的session量过大会消耗大量的内存。 cookie存在客户端，不占用服务器端的资源，一个用户手里拿一个cookie。所以像百度这种只能用cookie来存储用户的登录信息，用cookie来追踪用户会话。 为什么百度贴吧、百度云盘、百度搜索都可以共用我的登录信息呢(不用重复登录)？因为cookie支持跨域名访问，以“.biaodianfu.com”为后缀的一切域名均能够访问该Cookie。但是session就不支持跨域名访问，如果用session,都要重新登录。 session在服务器端由谁来管理？存在哪里？session由shiro来管理，shiro六大作用之一就是Session会话管理。在ShiroConfig(shiro配置类)中就有会话管理对应的函数-SessionManager. 现在用cookie和session吗？前后端没分离的时候用cookie和session来验证用户的真实性；现在前后端分离了，我们使用shiro这个安全框架来规定用户的操作，使用token和jwt来验证用户的真实性。 mybatis mybatisplus xml文件如何和接口进行绑定？mapper.xml和mapper.java绑定通过xml中的namespace=”xxxx.xxxmapper”mapper.java的路径名 MySQL 分布式数据库是什么？分布式数据库是指数据在物理上分布而逻辑上集中管理的数据库系统。 MySQL 群集是什么？MySQL 群集是一种技术。MySQL群集技术在分布式数据库系统中为MySQL数据提供了冗余特性，增强了安全性，使得单个MySQL服务器故障不会对系统产生巨大的负面效应，系统的稳定性得到保障。 MySQL 群集作用白话：MySQL群集技术让分布式数据库系统稳定性得到保障，(因为它为mysql数据增加安全性，)所以当单个mysql服务器故障时，分布式数据库系统不会产生巨大影响 MySQL 群集的三种结点有什么用？ 管理结点：能对结点进行关闭启动等操作，能监视结点状态。 数据结点：存数据。 SQL结点： 对外提供SQL功能。 mysql的索引是什么？索引的数据结构是什么？索引是数据结构，帮助数据库高效获取数据。数据结构主要支持hash和B+tree.hash不支持范围查询，B+tree支持范围查询。MyISAM和InnoDB两种数据存储引擎都支持hash和B+tree.(MySQL数据库支持多种索引类型，如BTree索引，哈希索引，全文索引等等。) 什么时候简历索引？对应唯一性较高，经常作为查询或者过滤条件或者排序条件的字段，建立索引。对应唯一性较差，频繁更改的字段，不建立索引。 每张表的建立索引的限制？单张表最多对16个字段建立索引 sql语句使得索引失效的情况(索引无法使用)？SARG (Searchable Arguments)操作，因为它通常是指一个特定的匹配，一个值得范围内的匹配或者两个以上条件的AND连接。1、Like语句是否属于SARG取决于所使用的通配符的类型如：name like ‘张%’ ，这就属于SARG而：name like ‘%张’ ,就不属于SARG。原因是通配符%在字符串的开通使得索引无法使用。2、or 会引起全表扫描 Name=’张三’ and 价格&gt;5000 符号SARG，而：Name=’张三’ or 价格&gt;5000 则不符合SARG。使用or会引起全表扫描。3、非操作符、函数引起的不满足SARG形式的语句 不满足SARG形式的语句最典型的情况就是包括非操作符的语句，如：NOT、!=、&lt;&gt;、!&lt;、!&gt;、NOT EXISTS、NOT IN、NOT LIKE等，另外还有函数。下面就是几个不满足SARG形式的例子：ABS(价格)&lt;5000Name like ‘%三’有些表达式，如：WHERE 价格*2&gt;5000sql server也会认为是SARG，SQL SERVER会将此式转化为：WHERE 价格&gt;2500/2但我们不推荐这样使用，因为有时sql server不能保证这种转化与原始表达式是完全等价的。4、IN 的作用相当与OR语句：Select * from table1 where tid in (2,3)和Select * from table1 where tid=2 or tid=3是一样的，都会引起全表扫描，如果tid上有索引，其索引也会失效。5、尽量少用NOT6、exists 和 in 的执行效率是一样的 mysql怎么提高速度的？用分治和索引。分治:将数据分成一格一格的。索引是一个排序的列表，在这个列表中存储着索引的值和包含这个值的数据所在行的物理地址。 mysql的索引类型？1、主键索引：即主索引，根据主键pk_clolum（length）建立索引，不允许重复，不允许空值；ALTER TABLE ‘table_name’ ADD PRIMARY KEY pk_index(‘col’)； 2、唯一索引：用来建立索引的列的值必须是唯一的，允许空值ALTER TABLE ‘table_name’ ADD UNIQUE index_name(‘col’)； 3、普通索引：用表中的普通列构建的索引，没有任何限制ALTER TABLE ‘table_name’ ADD INDEX index_name(‘col’)； 4、全文索引：用大文本对象的列构建的索引ALTER TABLE ‘table_name’ ADD FULLTEXT INDEX ft_index(‘col’)； 5、组合索引：用多个列组合构建的索引，这多个列中的值不允许有空值ALTER TABLE ‘table_name’ ADD INDEX index_name(‘col1’,’col2’,’col3’)； mysql用的存储引擎？MyISAM和InnoDB数据存储引擎 java 面向过程和面向对象 面向过程就是不断的使用函数。 现在将所有的功能/函数进行封装，我们面对的就是封装了功能的对象，这就是面向对象。只要找到了对象，就可以使用对象中的功能。 所有我们在实践的时候，先找到对象以及对象的功能。 如果没有，就自己创建对象并将所需的功能定义到该对象中。 面向对象的好处 面向对象更符合人们思考的习惯。 面向对象就像是指挥者，指挥对象做事情。 面向对象将复杂的问题简单化。 举例： 面试官您就是用面向对象的思想在思考问题。您本身就可以开发项目，但是如果项目比较大，开发周期长。为了提高效率，就需要更多具备能力的人帮助您做事情。这个人就是您需要的对象。您作为指挥者，只需要调用这个对象的开发功能就可以完成项目。 jvm回收机制使用引用计数算法判断对象是否死亡是否应该对这个对象进行回收。(没有引用指向该对象时，对象死亡，计数器为0)垃圾回收算法：标记清除，标记整理，复制算法，分代收集。 标记清除/整理： 每个对象有一个标记位，标记对象存活或者死亡。 清除：清除死亡对象。 整理：整理存活对象，放到另一处空间，清除剩下对象。 复制：内存分为两半，一半内存满了的时候，将存活的对象复制到另外一半内存，清空当前内存。 finalfinal关键字作用【修饰类不可继承，修饰方法不可重写，修饰对象无法重新赋值】 RuntimeException有哪些1， ClassCastException类型强制转换异常Object x = new Integer(0); System.out.println((String)x);当试图将对象强制转换为不是实例的子类时，抛出该异常 2，ArithmeticException算术异常类int a=5/0;一个整数“除以零”时，抛出异常 3, NullPointerException空指针异常类String s=null;int size=s.size();当应用程序试图在需要对象的地方使用 null 时，抛出异常 4, StringIndexOutOfBoundsException“hello”.indexOf(-1);指示索引或者为负，或者超出字符串的大小，抛出异常 5，NegativeArraySizeException数组负下标异常数组大小为负值异常。当使用负数大小值创建数组时抛出该异常String[] ss=new String[-1];如应用程序试图创建大小为负的数组，则抛出异常 6，IllegalArgumentException参数异常抛出的异常表明向方法传递了一个不合法或不正确的参数 7，NumberFormatException数字格式异常当试图将一个String转换为指定的数字类型，而该字符串确不满足数字类型要求的格式时，抛出该异常 8，ArrayIndexOutOfBoundsException数组下标越界异常当使用的数组下标超出数组允许范围时，抛出该异常 9,ClassNotFoundException找不到类异常当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常 10,ArrayStoreException数组存储异常当向数组中存放非数组声明类型对象时抛出 11，NoSuchMethodException 方法未找到异常 12，FileNotFoundException 文件未找到异常 操作系统 线程和进程的区别进程是系统资源分配的基本单位，线程是cpu调度的基本单位。 进程有独立的代码和数据空间，进程之间切换开销较大；同一进程中的线程共享代码和数据空间，线程之间切换较小。 系统在运行的时候会为每个进程分配不同的内存空间；系统不会为线程分配内存，线程之间只能共享资源。 线程是进程的一部分，线程被称为轻量级进程。 线程池是什么线程池，其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源 乐观锁/悲观锁乐观锁：总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。 悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。 CAS：即compare and swap（比较与交换），是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。 网络 get和post的区别get是从服务器上获取数据，post是向服务器传送数据。get的参数可以在url上面看到，post看不到get安全性非常低，post安全性较高。get请求比Post请求效率高，Post请求需要服务器返回100再发送数据处理，Get请求直接是通过URL。 @Getmapping该注解将HTTP Get 映射到 特定的处理方法上 java实现HTTP请求的三种方式java原生HttpURLConnectionapache HttpClient3.1apache httpClient4.5 TCP和UDPTCP：面向连接的安全可靠的传输层协议。客户和服务器交换数据前，必须现在双方之间建立一个TCP连接，之后才能传输数据。并且提供超时重发，丢弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源。慢，效率低。UDP: 面向数据报的不可靠的传输层协议。UDP在传输数据报前不用在客户端和服务器之间建立一个连接，且没有超时重发等机制，所以传输速度很快。只是把数据发送出去，不保证能够到达目的地。快，效率高。 spring IOC AOPSpring拥有两大特性：IoC和AOP。IoC，英文全称Inversion of Control，意为控制反转。AOP，英文全称Aspect-Oriented Programming，意为面向切面编程。 Spring核心容器的主要组件是Bean工厂（BeanFactory），Bean工厂使用控制反转（IoC）模式来降低程序代码之间的耦合度，并提供了面向切面编程（AOP）的实现。 简单来说，Spring是一个轻量级的控制反转（IoC）和面向切面编程（AOP）的容器框架 IOC:控制反转，简单点说，就是创建对象的控制权，被反转到了Spring框架上。通常，我们实例化一个对象时，都是使用类的构造方法来new一个对象，这个过程是由我们自己来控制的，而控制反转就把new对象的工作交给了Spring容器。 AOP:AOP把所有共用代码都剥离出来，单独放置到某个类中进行集中管理，在具体运行时，由容器进行动态织入这些公共代码。 同步异步同步异步 ， 举个例子来说，一家餐厅吧来了5个客人，同步的意思就是说，来第一个点菜，点了个鱼，好， 厨师去捉鱼杀鱼，过了半小时鱼好了给第一位客人，开始下位一位客人，就这样一个一个来，按顺序来 相同， 异步呢，异步的意思就是来第一位客人，点什么，点鱼，给它一个牌子，让他去一边等吧，下一位客人接着点菜，点完接着点让厨师做去吧，哪个的菜先好就先端出来， 同步的优点是：同步是按照顺序一个一个来，不会乱掉，更不会出现上面代码没有执行完就执行下面的代码， 缺点：是解析的速度没有异步的快； 异步的优点是：异步是接取一个任务，直接给后台，在接下一个任务，一直一直这样，谁的先读取完先执行谁的， 缺点：没有顺序 ，谁先读取完先执行谁的 ，会出现上面的代码还没出来下面的就已经出来了，会报错； java基础选择题A、 由高向低分别是：()、!、算术运算符、关系运算符、逻辑运算符、赋值运算符； a = 6;System.out.print(a++); 答案为6","categories":[{"name":"面试","slug":"面试","permalink":"https://lucifinil-x.github.io/categories/面试/"}],"tags":[]},{"title":"文章更新更改备份日志","slug":"文章更新更改备份日志","date":"2020-06-06T18:33:00.000Z","updated":"2020-06-17T14:10:11.308Z","comments":true,"path":"2020/06/07/文章更新更改备份日志/","link":"","permalink":"https://lucifinil-x.github.io/2020/06/07/文章更新更改备份日志/","excerpt":"插入本地图片的备份文章 2020-6-7 “算法” 更换为blog中路径的图片，但是大部分的路径是“\\”,能在本地显示，不能在网页显示。现在部署的文章换成图片链接，但是备份还未更换。","text":"插入本地图片的备份文章 2020-6-7 “算法” 更换为blog中路径的图片，但是大部分的路径是“\\”,能在本地显示，不能在网页显示。现在部署的文章换成图片链接，但是备份还未更换。 post到网页的更新文章 2020-6-7 “算法” 全部修改更换路过图床图片链接 2020-6-17 “操作系统”全部修改更换路过图床图片链接 2020-6-17 “人工智能”由于每小时只能上传30张图片，还没有更换图片 使用路过图床添加图片如果你要插入的图片，是一个外部的 src 链接地址，比如该图片存放在 CDN 上，或某某图床上面，那就使用 Markdown 默认的插入图片的方式，方法和插入链接很像，只是前面多了一个感叹号，如下： 1![alt](https://ws3.sinaimg.cn/large/005BYqpgly1g29eohl7qhj31c00u0dkz.jpg) 先在本地备份文件-图片中根据文章名打包图片，然后上传到路过图床对应相册中，再添加进文章。注意相册分类。 https://imgchr.com/lucifinil/albums路过图床网址","categories":[],"tags":[]},{"title":"测试","slug":"测试","date":"2020-04-30T10:14:10.000Z","updated":"2020-04-30T10:15:18.529Z","comments":true,"path":"2020/04/30/测试/","link":"","permalink":"https://lucifinil-x.github.io/2020/04/30/测试/","excerpt":"操作系统的特征1.并发（执行）： 多个事件交替发生，某一时刻最多发生一个事件2.共享（资源）： 互斥共享和同时共享","text":"操作系统的特征1.并发（执行）： 多个事件交替发生，某一时刻最多发生一个事件2.共享（资源）： 互斥共享和同时共享 互斥共享：一个时间段内只允许一个进程访问该资源 例子： 摄像头只能被qq或微信使用。 同时共享：一个时间段内允许多个进程访问该资源 （都是cpu交替访问） 例子： qq和微信同时发送文件 ，这两个进程交替着访问硬盘资源。 【特征之间的关系】 并发与共享互为存在条件，是最基本的两个特征 3.虚拟： 虚拟技术的空分复用技术（虚拟存储器技术）： 程序需要的内存远大于系统内存；内存不够分内存。 虚拟技术的时分复用技术（虚拟处理器技术）： 实际上只有一个cpu,用户感觉有多个cpu在服务；处理器不够分处理器。 【特征之间的关系】 没有并发性就谈不上虚拟性 4.异步： 多个程序并发执行时，进程的执行走走停停，不可预知每次运行多久停，可能导致运行结果的不确定性。 【特征之间的关系】 只有系统有并发性，才可能导致异步性 操作系统的发展和分类 操作系统的几个发展阶段1.手工操作阶段： 读纸带条； 缺点：人输入速度慢 2.批处理阶段： 单道批处理系统： 读纸带存到磁带上，计算机读取磁带，输出磁带，再到纸带。 缺点：cpu大量时间是在等待输入输出。 多道批处理系统（操作系统正式诞生）： 每次往内存中输入多道程序，并发执行，共享计算机资源。资源利用率大幅提升。 缺点：用户提交完作业后，只能等待计算机处理完成，中间用户不能控制自己的作业执行。 资源利用率大幅提升原因： 输入、计算、输出都在流水线工作，不会等待。 内核态 用户态两种处理器状态：(cpu是处理器)1.用户态： cpu只能执行非特权指令2.核心态： cpu可以执行特权指令，也可以执行非特权指令 PSW程序状态寄存器：标识cpu处理器状态—– 0为用户态，1为核心态两种程序：1.应用程序： 只能执行非特权指令；程序在用户态运行 2.内核程序： 可以执行特权指令，也可以执行非特权指令；程序在核心态运行操作系统功能=内核功能+非内核功能内核： 计算机上配备的底层软件 注：原语是一种特殊的程序，是最接近硬件的部分，原语这种程序的运行具有原子性（一旦执行就会执行完，不会中断）操作系统体系结构 = 企业管理内核 = 企业管理层，负责重要工作（特权指令）； 普通员工只能执行非特权指令。用户态与核心态之间的切换 = 普通员工和管理层之间的工作交接 大内核：效率高，难维护； 比如小企业，管理层管大部分事情 功能都放在内核，核心态运行微内核：效率低，易维护； 比如大企业，管理层管最核心的工作 只有基本功能放在内核，频繁的在核心态和用户态之间切换 中断和异常中断： 中断发生时，cpu立刻从用户态进入核心态，操作系统获得计算机的控制权；当前进程暂停，操作系统根据不同的中断信号进行不同的处理。【有中断才有多道程序并发执行】【中断是cpu从用户态到核心态的唯一途径】 1.内中断：信号来自cpu内部，也称异常；比如指令中断，故障，软件报错2.外中断：信号来自cpu外部；比如外设发出的信号，用户终止进程 系统调用把调用硬件的办法封装成系统调用，供人通过应用程序间接的操作硬件。 系统调用发生在用户态；系统调用的处理发生在核心态。 执行陷入指令会产生内中断，使cpu从用户态立即进入核心态 进程进程的定义，组成，组织方式，特征进程：进程是资源分配、接受调度的基本单位，是进程实体的运行过程。 PCB: 每个进程运行之前，操作系统会配置一个数据结构 PCB（进程控制块），来存储进程的各种信息（程序代码的存放位置，数据段的位置，见图）。和进程管理有关的数据肯定是放在PCB里面的。 进程实体 = 程序段+数据段+PCB； 进程实体是进程需要的数据的集合，它是静态的；进程是进程实体运行的过程，它是动态的。 创建进程 = 创建进程实体中的PCB；撤销进程 = 进程组织方式：用队列或者索引表，下面是队列的用几种指针组织进程（组织PCB）：1.执行指针2.就绪队列指针：优先级高的放在队列头3.阻塞队列指针 进程特征：动态性；并发性；独立性（进程是资源分配、接受调度的基本单位）；异步性（进程的执行走走停停，不可预知每次运行多久停，可能导致运行结果的不确定性。）；结构性。 进程状态为了方便操作系统进行进程的管理分成了五种状态。 三种基本状态：1.运行态running: 占用cpu资源，在cpu上运行2.就绪态ready: 万事俱备，只差cpu.具备运行条件，但没有空闲cpu。(有除了处理机之外的所有需要的资源，一旦获得处理机cpu，立即进入运行态)3.阻塞态/等待态waiting/blocking: 因为某些事件而暂时不能运行 另外两种状态：1.创建态new: 创建进程，操作系统给进程分配资源，初始化PCB2.终止态terminated: 进程从操作系统中撤销，回收资源，撤销PCB 进程状态的转换：主要注意只能是 运行态-&gt;阻塞态-&gt;就绪态 进程控制进程控制: 是实现进程状态之间的转换，用原语实现。 需要做的事情：1.更新PCB信息2.将PCB插入对应的进程状态PCB队列3.回收/分配资源 怎么做上面的三件事情： 用几个原语实现进程控制：原语是一种特殊的程序； 原语采用“关中断和开中断的特权指令”； 执行期间不会被中断，一气呵成；“关中断和开中断指令”的权限非常大，是只能在核心态执行的特权指令（原语在核心态运行）。 相关原语（对进程操作的特权指令）：创建原语，终止原语，阻塞原语，唤醒原语，切换原语。阻塞和唤醒要成对出现 进程通信进程通信： 进程之间的信息交换 线程和多线程模型线程相当于轻量级进程，便于创建销毁。 线程增加了并发度，让qq应用（一个进程）中边聊天边发送文件得以实现。 cpu则服务于进程中的线程。 同一线程中的线程切换不需要切换进程的运行环境，系统开销变小。 多线程模型：1.多对一： 多个用户线程映射到一个内核级线程。 处理机调度调度基础知识调度：选择哪个先调。 作业： 程序、项目。挂起状态：内存不够，不能获得cpu就先掉到外存去，与阻塞状态不同的是阻塞时还是在内存中。 进程调度时机","categories":[],"tags":[]},{"title":"操作系统原理中文版","slug":"操作系统中文版","date":"2020-04-24T13:30:27.000Z","updated":"2020-06-17T14:01:57.696Z","comments":true,"path":"2020/04/24/操作系统中文版/","link":"","permalink":"https://lucifinil-x.github.io/2020/04/24/操作系统中文版/","excerpt":"概念题高频考点Cache缓存空间很贵，每次只从main memory里取出有用的PCB进程管理器virtual(logical) address &amp; physics address","text":"概念题高频考点Cache缓存空间很贵，每次只从main memory里取出有用的PCB进程管理器virtual(logical) address &amp; physics address virtual(logical) address:用户看到的，我们假设的physics address：数据在硬盘上实际储存的位置 virtual(logical) address: The user can view the logical address of a program. /The user uses the logical address to access the physical address. / Set of all logical addresses generated by CPU in reference to a program is referred as Logical Address Space. physics address: The user can never view physical address of program /The user can not directly access physical address. /Set of all physical addresses mapped to the corresponding logical addresses is referred as Physical Address. process &amp; threadsfragments 储存碎片化外部碎片：外面东西塞进冰箱没法完整塞进来内部碎片：冰箱分层，一层没塞满 hashed page table把页和页用链表数据结构存储，每一页有一个数据用来指向下一页位置。这样不用存储文件，不用存储所有页码。但是不能从任意地方开始读，不能从中间往上读，但是往下读就很方便。通过目录只能从第一页开始读。 RAIDRAID level0-5都要背 principle of least privilege 最小获知代价？每个进程或用户只需要知道他们需要知道的，如果删除任何一个他们目前已知的东西都会导致他们无法完成任务。 CIA Triad信息安全部分 SecurityConfidentiality 机密性：未授权的用户“不能看”Integrity 完整性：未授权的操作，“不能改”Availability 可用性：授权的用户，可以“一直用”。更新软件之后可以一直用以前的数据。 There are four levels at which a system must be protected: Physical - The easiest way to steal data is to pocket the backup tapes. Also, access to the root console will often give the user special privileges, such as rebooting the system as root from removable media. Even general access to terminals in a computer room offers some opportunities for an attacker, although today’s modern high-speed networking environment provides more and more opportunities for remote attacks. Human - There is some concern that the humans who are allowed access to a system be trustworthy, and that they cannot be coerced into breaching security. However more and more attacks today are made via social engineering, which basically means fooling trustworthy people into accidentally breaching security. Phishing involves sending an innocent-looking e-mail or web site designed to fool people into revealing confidential information. E.g. spam e-mails pretending to be from e-Bay, PayPal, or any of a number of banks or credit-card companies. Dumpster Diving involves searching the trash or other locations for passwords that are written down. ( Note: Passwords that are too hard to remember, or which must be changed frequently are more likely to be written down somewhere close to the user’s station. ) Password Cracking involves divining users passwords, either by watching them type in their passwords, knowing something about them like their pet’s names, or simply trying all words in common dictionaries. ( Note: “Good” passwords should involve a minimum number of characters, include non-alphabetical characters, and not appear in any dictionary ( in any language ), and should be changed frequently. Note also that it is proper etiquette to look away from the keyboard while someone else is entering their password. ) Operating System - The OS must protect itself from security breaches, such as runaway processes ( denial of service ), memory-access violations, stack overflow violations, the launching of programs with excessive privileges, and many others. Network - As network communications become ever more important and pervasive in modern computing environments, it becomes ever more important to protect this area of the system. ( Both protecting the network itself from attack, and protecting the local system from attacks coming in through the network. ) This is a growing area of concern as wireless communications and portable devices become more and more prevalent. Deadlock造成死锁条件4个缺一不可：Mutual Exclusion:一个资源同时只能被一个进程使用Hold and Wait:得不到资源的进程就会挂起No preemption:一个进程执行完毕会释放他拥有的资源Circular wait:循环，A等B,B等C,C等A 哲学家就餐问题 Starvation五个人圆桌吃饭，五个餐具，只有左右手都有餐具才会吃饭。不然就不吃，会饿死。解决办法：只有左右手能拿到餐具才会拿起餐具，不然都不拿餐具。 计算题多练 保证一分不丢 page frames 物理页面1.FIFO LRU OPR replacement 例题：字符串a b c d a d demanded page with 3 frames,求出现多少次page faults(帧上数据改变)（缺页中断） FIFO first in first out :一共三帧（三个格子装字符，满了就要把先装进来的踢出去），每次用分号隔开，每次对应题目上字符串一个字符进来。a(改变); a b（改变）; a b c（改变）; d b c(踢掉a换成d 改变)； d a c(踢掉b换成a 改变)； d a c(d有了，不改变)。所以一共改变5次。 LRU least recent use技巧为找前面次数最少且最远的： 三层帧都满了时，踢掉这时候要加进来的字符的前面 找字符串里离当前进来字符前面最后出现的（都一样/没出现的时候，默认踢掉最先进来的）这种字符串和FIFO情况是一样的。a; a b; a b c; d b c; d a c; d a c. OPR optimal page replacement技巧找当前需要加进来的页面的后面“访问页面”次数最远出现的踢掉：三层帧都满了时a; a b ; a b c; a d c(d后面没有bc先踢b); a d c; a d c. 练习题1： 7,0,3,1,3,5,3,4,6,5 三帧FIFO：7(√)；7 0(√)；7 0 3(√)； 1 0 3(√)；1 0 3;1 5 3(√)；1 5 4(√)；6 5 4(√)；6 5 4.所以是7次page faults occur. LRU（看前面，找字符串里当前进来最远的）: 7(√)；7 0(√)；7 0 3(√)；1 0 3(√)；1 0 3；1 5 3(√ 0最远踢掉)；1 5 3；4 5 3(√ 1次数比3小=最远)；4 6 3(√ 4和5都只有一次，5比4远踢掉)；4 6 5(√ 视频里说3最远？？？迷惑？？是最远啊但是出现次数多啊，而且之前怎么不先踢3 要踢1？？).所以是次page faults occur. OPR: 2.易错点头三次都要算，变化做标记。 3.对比 scheduling algorithms调度算法Process进程 Burst time运行时间 Arrival time出现时间没有给Arrival time出现时间，默认全部一起出现。Gantt chart甘特图: 用于计算的左右下标图就是正规的甘特图 0.时间关系 时间下标全部从0秒开始 用格子左右下标计算(间隔时间直接做减法，右下标-左下标，开始执行的左下标-上次停止执行的右下标) 等待时间waiting time = 开始执行时间(左下标)-到达时间(表格上数据) + 之后的开始执行时间(左下标)-上次停止时间(右下标)； （ 也就是说到达的那个秒数如果没有立即执行（别的p在执行）是算在等待时间+1s.） 等待时间=周转时间-运行时间 周转时间rurn around time = 运行完成时间(右下标) - 到达时间(表格上数据) 求的是平均时间，都要除以总进程数量 response time反应时间 = 第一次运行时间(左下标)-到达时间(表格上) throughput吞吐量生产量 = 所有进程的执行时间/进程数量 1.FCFS first come first serve先来的先运行P1,P2,P3顺序，P1先运行，P2等待P1运行完再运行，P2等待时间=P1运行时间 2.shortest job first先运行最短的计算平均等待时间：每个进程等待时间是他之前先运行的进程运行时间总和 3.shortest remaining time first先执行剩余需要执行时间最短的图要画好 一秒一秒的分析 当前秒数执行哪一个进程 当前秒数完了这个进程还剩多少秒。 下面表格为每个时间段执行的进程和时间；进程等待时间 = 进程开始执行的秒数-Arrival time；如果一个进程被打断多次需要分段考虑等待时间。 4.round robin每个依次执行相同时间Priority 优先执行顺序，优先1然后2 Time quantum = 5,每个依次执行5秒。画好格子图 正在执行的进程，执行时间，剩余时间。每个p的等待时间=开始执行时间下标-上次结束执行时间下标 5.priority scheduling按照给出的优先级别顺序执行优先级别1234，优先执行1-2-3-4. sale state 银行家问题 判断是否安全关键词解释process(P1 P2 P3)：进程,理解为工厂source type(A B C): ABC各自的资源数量，理解为三种不同的工人的总数量request source by P1: P1请求的资源,理解为P1需要增加的工人，如果available&gt;request就可以吧request加在P1的allocate中，同样的p1的need会动态减少max: 每个P最多容纳的资源，安全运行需要的资源，理解为每个工厂最多容纳每种工人数量，工厂要运作需要的工人数量allocate: 已分配的资源，理解为现在工厂里已有的工人need: max-allocate,理解为工厂满员还需要的工人available: 工人总数-allocate,理解为除去每个工厂里已经有的工人，剩下空闲的工人数量 第一步通过给出的source，allocate，max写出need，available 第二步拿着现在的available去找能够满足的need，也就是说能够满足need的P第一个执行； 然后会释放第一个执行完毕的allocate资源，那么此时的available=初始的available+已执行P的初始allocate。拿着现在的available去找能够满足的need，也就是说下一个能够满足need的P第二个执行。。。。同上如果拿着的available能够最终执行完所有P ,那么the system is in safe time in time T.如果拿着的available一个p的need都不够，那么就false. two-level-page相关概念fragment碎片:1.外部碎片：进程在操作系统中需要内存空间，就像是把东西放进冰箱，如果冰箱没有分层，东西乱放就会产生间隙。当我们需要再15mb的东西到冰箱里时，冰箱里只有10+10mb的小间隙是不能完整的放进15mb的东西(进程)的，这个进程不能连续的放在一个地方，此时就会产生外部碎片。2.内部碎片：比如把18mb的进程放进一层5mb大小的操作系统，就需要4层，但是放不满，多了2mb空隙，此时就会产生内部碎片。 page页：把操作系统分层，就像是把冰箱分层放东西，比如一个格子5mb大小。 outer page table(一阶list): 像是存放很多本书，书名的合集page table(二阶list): 像是存放每本书的首页和末尾页memory: 存放书的地方，每本书的首页和末尾页指向memory中的内存地址 two-level-page题把解题过程背下来pagesize=4096byte=4x1024byte=4kb这个是每个实体大小每页page大小= 2^10x每个实体大小=1024x4kb=4mb一共要存8+12=20mb需要20/4=5页二阶list如果这里除不尽，保留小数。 levels of page table题目Consider a system using multilevel paging scheme. The page size is 1 MB. The memoryis byte addressable and virtual address is 64 bits long. The page table entry size is 4 bytes.Find: How many levels of page table will be required? Give the divided physical address and virtual address. 第一问解答：按照这个比这做 Given条件 • Virtual Address = 64 bits • Page size = 1 MB • Page table entry size = 4 bytes 1.求Number of Bits in Frame Number We have, Page table entry size= 4 bytes = 32 bits Thus, Number of bits in frame number = 32 bits Number of Frames in Main Memory We have, Number of bits in frame number = 32 bits Number of frames in main memory = 2^32 frames 2的32次方 Size of main memory = Total number of frames x Frame size = 2^32 x 1 MB = 2^52 B (1 MB=2^20B) Thus, Number of bits in physical address = 52 bits Number of Bits in Page Offset We have, Page size = 1 MB = 2^20 B Thus, Number of bits in page offset = 20 bits Alternatively, Number of bits in page offset = Number of bits in physical address – Number of bits in frame number = 52 bits – 32 bits = 20 bits disk schedulinghttps://www.gatevidyalay.com/disk-scheduling-disk-scheduling-algorithms/六种调度和例题 基本词汇sector: 部门，扇形，指光盘的最小存储单元cluster: 群，聚集，指多个sector拼在一起track: 道，指光盘的一圈 disk queue: 数字队列，数组 1.FCFSqueue:98,183,37,122 head start at 53读取顺序就是53 98 183 57 122 2.shortest time seek first类似贪心算法，每次选择与自己差值最小的，先把序列中从小到大排序，然后沿着一个方向选择queue:98, 183, 41, 122, 14, 124, 65, 67 head start at 53读取顺序就是53-65-67-41-14-98-122-124-183Total head movements incurred while servicing these requests的计算与例题一致。 3.SCAN (LOCK)往一个方向读，向小moving down或向大moving up到最外，才能回头。。queue:98, 183, 41, 122, 14, 124, 65, 67 head start at 53读取顺序就是53-65-67-98-122-124-183-199(向大到最大)-41-14(向小到最小) 4.C-SCAN往一个方向读，然后到0，再从0向一个方向读98, 183, 41, 122, 14, 124, 65, 67.从53读取顺序就是53-65-67-98-122-124-183-199-0-14-41 5.C-LOCK往一个方向读，然后到剩下的最小数，再向一个方向读98, 183, 41, 122, 14, 124, 65, 67.从53读取顺序就是53-65-67-98-122-124-183-14-41 6.例题Consider a disk queue with requests for I/O to blocks on cylinders 98, 183, 41, 122, 14, 124, 65, 67. The FCFS scheduling algorithm is used. The head is initially at cylinder number 53. The cylinders are numbered from 0 to 199. The total head movement (in number of cylinders) incurred while servicing these requests is ___. 53，98, 183, 41, 122, 14, 124, 65, 67. Total head movements incurred while servicing these requests = (98 – 53) + (183 – 98) + (183 – 41) + (122 – 41) + (122 – 14) + (124 – 14) + (124 – 65) + (67 – 65) = 45 + 85 + 142 + 81 + 108 + 110 + 59 + 2 = 632 linked scheme - mapping address这个就是用指针把每一页的首尾连接起来，这样就相当于冰箱分层了，不存在外部碎片了。注意：最后一个block pointer(页尾格指针)不用指向下一页但是要留出来页尾格指针位置，是空的 题目the block size is 512 words, 每个entry of index table 占用1 word.(页指针) 地址在635109理解： level-1 index page有512个实体，level-2也有512个实体，但是最后一个实体放指针。指向在level-1的位置。1.求index table 的block number： 在第几个level-1级别的书页上:635109/(512x511)=2 取整数部分 求displacement into block of index page：先求第一问除法的余数是111845，然后111845/512=218 取整数部分 求displacement into block of file: 111845%512=229 取余数部分 用逻辑地址求物理地址&lt;0,430&gt;: 0是号码，430是给出的数据表格上length用来求段offset的极限：[0到length-1],只要430小于等于length-1就不会触发陷阱。那么这个物理地址=表格上的base+430 c语言解答题lab13 链表，link librarylab 14 make file ,threadlab15 race condition ,pthread,mutex设计题非常难，但熟记并且理解流程图一样拿分 one-time padECBCBCOFB操作系统的特征1.并发（执行）： 多个事件交替发生，某一时刻最多发生一个事件 2.共享（资源）： 互斥共享和同时共享 互斥共享：一个时间段内只允许一个进程访问该资源 例子： 摄像头只能被qq或微信使用。 同时共享：一个时间段内允许多个进程访问该资源 （都是cpu交替访问） 例子： qq和微信同时发送文件 ，这两个进程交替着访问硬盘资源。 【特征之间的关系】 并发与共享互为存在条件，是最基本的两个特征 3.虚拟： 虚拟技术的空分复用技术（虚拟存储器技术）： 程序需要的内存远大于系统内存；内存不够分内存。 虚拟技术的时分复用技术（虚拟处理器技术）： 实际上只有一个cpu,用户感觉有多个cpu在服务；处理器不够分处理器。 【特征之间的关系】 没有并发性就谈不上虚拟性 4.异步： 多个程序并发执行时，进程的执行走走停停，不可预知每次运行多久停，可能导致运行结果的不确定性。 【特征之间的关系】 只有系统有并发性，才可能导致异步性 操作系统的发展和分类 操作系统的几个发展阶段1.手工操作阶段： 读纸带条； 缺点：人输入速度慢 2.批处理阶段： 单道批处理系统： 读纸带存到磁带上，计算机读取磁带，输出磁带，再到纸带。 缺点：cpu大量时间是在等待输入输出。 多道批处理系统（操作系统正式诞生）： 每次往内存中输入多道程序，并发执行，共享计算机资源。资源利用率大幅提升。 缺点：用户提交完作业后，只能等待计算机处理完成，中间用户不能控制自己的作业执行。 资源利用率大幅提升原因： 输入、计算、输出都在流水线工作，不会等待。 内核态 用户态两种处理器状态：(cpu是处理器)1.用户态： cpu只能执行非特权指令2.核心态： cpu可以执行特权指令，也可以执行非特权指令 PSW程序状态寄存器：标识cpu处理器状态—– 0为用户态，1为核心态两种程序：1.应用程序： 只能执行非特权指令；程序在用户态运行 2.内核程序： 可以执行特权指令，也可以执行非特权指令；程序在核心态运行操作系统功能=内核功能+非内核功能内核： 计算机上配备的底层软件内核程序： 实现内核功能的程序，内核功能如下图： 注：原语是一种特殊的程序，是最接近硬件的部分，原语这种程序的运行具有原子性（一旦执行就会执行完，不会中断）操作系统体系结构 = 企业管理内核 = 企业管理层，负责重要工作（特权指令）； 普通员工只能执行非特权指令。用户态与核心态之间的切换 = 普通员工和管理层之间的工作交接 大内核：效率高，难维护； 比如小企业，管理层管大部分事情 功能都放在内核，核心态运行微内核：效率低，易维护； 比如大企业，管理层管最核心的工作 只有基本功能放在内核，频繁的在核心态和用户态之间切换 中断和异常中断： 中断发生时，cpu立刻从用户态进入核心态，操作系统获得计算机的控制权；当前进程暂停，操作系统根据不同的中断信号进行不同的处理。【有中断才有多道程序并发执行】【中断是cpu从用户态到核心态的唯一途径】 1.内中断：信号来自cpu内部，也称异常；比如指令中断，故障，软件报错2.外中断：信号来自cpu外部；比如外设发出的信号，用户终止进程 系统调用把调用硬件的办法封装成系统调用，供人通过应用程序间接的操作硬件。 系统调用发生在用户态；系统调用的处理发生在核心态。 执行陷入指令会产生内中断，使cpu从用户态立即进入核心态 进程进程的定义，组成，组织方式，特征进程：进程是资源分配、接受调度的基本单位，是进程实体的运行过程。 PCB: 每个进程运行之前，操作系统会配置一个数据结构 PCB（进程控制块），来存储进程的各种信息（程序代码的存放位置，数据段的位置，见图）。和进程管理有关的数据肯定是放在PCB里面的。 进程实体 = 程序段+数据段+PCB； 进程实体是进程需要的数据的集合，它是静态的；进程是进程实体运行的过程，它是动态的。 创建进程 = 创建进程实体中的PCB；撤销进程 = 撤销进程实体中的PCB；PCB是进程存在的唯一标志！ 进程组织方式：用队列或者索引表，下面是队列的用几种指针组织进程（组织PCB）：1.执行指针2.就绪队列指针：优先级高的放在队列头3.阻塞队列指针 进程特征：动态性；并发性；独立性（进程是资源分配、接受调度的基本单位）；异步性（进程的执行走走停停，不可预知每次运行多久停，可能导致运行结果的不确定性。）；结构性。 进程状态为了方便操作系统进行进程的管理分成了五种状态。 三种基本状态：1.运行态running: 占用cpu资源，在cpu上运行2.就绪态ready: 万事俱备，只差cpu.具备运行条件，但没有空闲cpu。(有除了处理机之外的所有需要的资源，一旦获得处理机cpu，立即进入运行态)3.阻塞态/等待态waiting/blocking: 因为某些事件而暂时不能运行 另外两种状态：1.创建态new: 创建进程，操作系统给进程分配资源，初始化PCB2.终止态terminated: 进程从操作系统中撤销，回收资源，撤销PCB 进程状态的转换：主要注意只能是 运行态-&gt;阻塞态-&gt;就绪态 进程控制进程控制: 是实现进程状态之间的转换，用原语实现。 需要做的事情：1.更新PCB信息2.将PCB插入对应的进程状态PCB队列3.回收/分配资源 怎么做上面的三件事情： 用几个原语实现进程控制：原语是一种特殊的程序； 原语采用“关中断和开中断的特权指令”； 执行期间不会被中断，一气呵成；“关中断和开中断指令”的权限非常大，是只能在核心态执行的特权指令（原语在核心态运行）。 相关原语（对进程操作的特权指令）：创建原语，终止原语，阻塞原语，唤醒原语，切换原语。阻塞和唤醒要成对出现 进程通信interprocess communication IPC进程通信： 进程之间的信息交换 三种通信：1.共享存储shared memory： 设置一个共享空间；互斥的访问共享空间；用数据结构（存取要完全符合这个数据结构）/ 基于存储区的共享（内存中画出一块共享存储区，没有严格要求）2.管道通信pipe： 一个管道只能单向传输，双向要两个管道；各进程互斥访问；没写满不能读，没读空不能写；3.消息传递message passing：进程通过操作系统提供的“发送消息/接收消息”两个原语进行数据交换；直接通信（消息挂到接收方队列中）/间接通信（消息先发送到信箱）。 线程和多线程模型线程相当于轻量级进程，便于创建销毁。 线程增加了并发度，让qq应用（一个进程）中边聊天边发送文件得以实现。 cpu则服务于进程中的线程。 线程是cpu调度的基本单位；进程是资源分配的基本单位。 同一进程中的线程切换（并发）不需要切换进程的运行环境，系统开销变小。同一进程中的线程共享进程的资源。线程几乎不拥有资源，只拥有极少量的资源（线程控制块TCB、寄存器信息、堆栈等）。 计算机中的透明是看不见的意思。 用户级线程（User-Level Thread, ULT）:线程切换可以在用户态下即可完成， 无需操作系统干预。内核级线程（Kernel-Level Thread, KLT）: 内核级线程的管理工作由操作系统内核完成。线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。 内核级线程才是cpu分配的单位。多线程模型：1.多对一： 多个用户线程映射到一个内核级线程。 优点：进程管理开销小，效率高； 缺点：一个（用户）线程被堵塞，一个进程中所有线程被堵塞，并发度低。 2.一对一： 一个用户线程映射到一个内核级线程。 优点：进程管理开销大； 缺点：一个线程对应一个内核线程，分配到多核cpu并行执行，单个线程不影响其他线程，并发度高。 2.多对多： n个用户线程映射到m个内核级线程。(n&gt;=m) 集二者之所长。 CPU调度调度基础知识调度：选择哪个进程分配cpu。(注意：线程是cpu调度的基本单位) 作业： 程序、项目。挂起状态suspend：内存不够，暂时不执行，不能获得cpu的进程就先掉到外存去，与阻塞状态不同的是阻塞时还是在内存中。 三种调度：（低级高频发生，高级低频发生）1.作业调度（高级调度）： 选择作业从外存调入内存并创建进程。2.内存调度（中级调度）： 选择进程从挂起队列中调回内存。3.进程调度（低级调度）： 选择进程从就绪队列中分配cpu。 进程调度（低级调度）时机（什么时候可以/不可以 分配cpu）广义的进程调度： 选择一个进程+一个进程让出cpu,另一个进程占用cpu =选择一个进程+进程切换。 什么时候需要进程调度： 1.主动放弃 2.被动放弃什么时候不能进程调度： 1.处理中断时 2.在内核程序临界区中 3.原语 临界资源： 只能一个进程使用的资源临界区： 访问临界资源的那段代码内核程序临界区： 访问内核数据结构的代码， 进程调度的方式：1.非剥夺调度方式（非抢占式）： 只允许进程主动放弃cpu; 主动：终止/主动进入阻塞态。2.剥夺调度方式（抢占式）： 操作系统可以剥夺当前进程的cpu。 cpu分配给更紧迫的进程。 适合实时、分时操作系统。 进程切换与进程调度的区别进程切换： 一个进程让出cpu,另一个进程占用cpu. 保存原来进程PCB中的数据，恢复新的进程PCB中的数据。 所以进程切换是有时间代价的，如果频繁的进程切换/调度，系统的效率会降低。（时间花在切换上，执行进程的时间减少）。狭义的进程调度： 从就绪队列中选择一个要运行的进程.广义的进程调度： 选择一个进程+进程切换。 CPU利用率CPU利用率= cpu忙碌的时间/总时间 进程同步，进程异步，进程互斥 p17进程异步：程序并发运行，并发必然导致异步性。cpu切换执行进程的顺序，次序，执行到多少是不可预知的。进程同步：两个或多个进程需要按照一定的执行顺序来完成一个任务是，就需要达到进程同步，有顺序的执行。 资源共享方式：1.互斥共享：qq用了摄像头，微信就不能用2.同时共享：b站用了播放器，龙族同时可以用播放器 进程互斥实现代码：do{ entry section; 进入区 若可以访问临界资源就上锁 critial section; 临界区 访问临界资源（只能被一个进程访问的资源）的代码 exit section; 退出区 解锁临界资源 remainder section; 剩余区 做其他的处理} 进程互斥软件实现方法：1.单标志法：未被空闲让进2.双标志法：解决忙则等待，违背空闲让进和有限等待，造成死锁flag[1]=true;while(flag[2]);3.Peterson算法：主动争取，主动谦让，检查地方是否想进，自己是否谦让。如果双方都想进入临界区，可以进程1主动让进程2先进入临界区。cpu切换时，有很多种排列组合会导致每个进程运行到第三行代码是turn值不一样。while等待条件一个不满足就能进入临界区。P1进程：flag[1]= true //自己想进临界区turn=1; //不让while(flag[2] &amp;&amp; turn==1);P2进程：flag[2]= true //自己想进临界区turn=0; //不愿意while(flag[1] &amp;&amp; turn==0);//循环等待代码：当对方想进，愿意让出 进程互斥硬件实现方法：1.disable interrupt关中断：关中断；//不允许当前进程被中断、切换临界区；开中断；2.test and set指令：用硬件实现，不能中断while(TSL(&amp;lock)) //检查上锁临界区；lock = false; //解锁剩余区；3.swap指令：和TSL差不多 剩下的没写完的课程图片：https://imgchr.com/album/UAUbT","categories":[{"name":"记忆性学习","slug":"记忆性学习","permalink":"https://lucifinil-x.github.io/categories/记忆性学习/"}],"tags":[]},{"title":"spring cloud 项目","slug":"spring-cloud-项目","date":"2020-04-14T11:07:30.000Z","updated":"2020-06-24T11:54:40.836Z","comments":true,"path":"2020/04/14/spring-cloud-项目/","link":"","permalink":"https://lucifinil-x.github.io/2020/04/14/spring-cloud-项目/","excerpt":"外面点餐系统项目需求 客户端： 针对普通用户，用户登录，用户退出，菜品订购，我的订单 后台管理系统：针对管理员，管理员登录，管理员退出，添加菜品，查询菜品，修改菜品，删除菜品，订单处理，添加用户，查询用户，删除用户","text":"外面点餐系统项目需求 客户端： 针对普通用户，用户登录，用户退出，菜品订购，我的订单 后台管理系统：针对管理员，管理员登录，管理员退出，添加菜品，查询菜品，修改菜品，删除菜品，订单处理，添加用户，查询用户，删除用户 功能拆分 acoount 提供账户服务： 用户和管理员的登录退出 menu 提供菜品服务： crud操作 添加菜品，查询菜品，修改菜品，删除菜品 order 提供订单服务： 添加订单，删除订单，查询订单，处理订单 user 提供管理员对用户的管理服务： crud操作 添加用户，查询用户，删除用户 第一章微服务环境搭建第一步 写pom.xml 添加依赖 没有添加视频中jdk9相关依赖1234567891011&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Finchley.SR2&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; 第二步 项目中创建注册中心模块(一个子项目)： eurekaserver 先修改总项目pom.xml打包方式，不然不能添加maven module123&lt;artifactId&gt;springcloud-take-out-order&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; 写eureka server配置以下为未能启动的子项目，现在已经新建了starter项目才能启动，内容添加和下面一致 在总项目中创建maven module，他会出来一个文件夹和一个同名并列的项目，右键文件夹有一个go to project “registration”以下编辑在下面的项目中添加, 会同步到总项目中的同名文件夹（所有文件都同步了，只是文件夹有点多） registration子项目中添加依赖： pom.xml 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 写他的配置文件: application.yml 12345678server: port: 8761eureka: client: service-url: defaultZone: http://localhost:8761/eureka/ register-with-euraka: false #是否注册他自己 fetch-registry: false # 是否导入数据 写启动类： RegServerApplication.java项目为starter项目时，根本不用自己写启动类，自带有 12345678@SpringBootApplication@EnableEurekaServerpublic class RegServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(RegServerApplication.class,args); &#125;&#125; 第三步 子项目configServer第四步 创建服务提供者 子项目orderpom.xml 中有一个视频上是config 我的自动加的的config-server 第五步 测试启动先启动注册中心eureka,配置中心comfig,服务提供者order menu 第二章 创建服务提供者 menu子项目第一步 创建+配置pom 创建时添加依赖：mybatis-spring-boot-starter；spring-boot-starter-web；spring-cloud-starter-config（让他读取配置中心的配置文件）；mysql-connector-java（mysql版本可以写最新的，能兼容老版本）；spring-cloud-starter-netflix-eureka-client（让他在注册中心进行注册，让他成为一个服务） 有mysql mybatis的依赖，需要在配置文件中加入数据库的连接信息在configServer子项目中的menu-dev.yml加mydql信息 第二步 复制order里的bootstrap.yml配置文件 改name123456789spring: application: name: menu profiles: active: dev #这里是整合到在configServer里面的order-dev.yml cloud: config: uri: http://localhost:8762 #configServer的端口号 注意是uri不是url fail-fast: true 第三步 configServer中添加menu的配置文件123456789101112131415161718server: port: 8020spring: application: name: menu datasource: name: orderingsystem url: jdbc:mysql://localhost/orderingsystem?serverTimezone=UTC username: root password: zhangcaiyun driver-class-name: com.mysql.cj.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSourceeureka: client: server-url: defaultZone: http://localhost:8761/eureka/ instance: prefer-ip-address: true 目前问题 http://localhost:8020/menu/index访问不到 http://localhost:8020/访问不到 configServer中配置文件没有连接上 第四步 复制sql语句去数据库中创建+更新表格第五步 menu中关联数据库中的那几张表Menu表entity包中写Menu表格的实体类：Menu1234567891011import lombok.Data;@Datapublic class Menu &#123; private long id; private String name; private double price; private String flavor; &#125; repository包中写Menu的接口（dao层）：MenuRepo 作用：定义操作数据库Menu表格的java方法123456789public interface MenuRepo &#123; public List&lt;Menu&gt; findAll(); //查询全部数据 public int count(); //查询记录条数 public Menu findById(long id); //用主键id查找记录，返回Menu对象，记录都成为Menu对象中的属性值 public void save(Menu menu); public void update(Menu menu); public void delectById(long id);//用主键删掉记录&#125; 用mybtis的Mapper写MenuRepo接口的实现类： Mapper.xml(包括MenuRepo.xml,TypeRepo.xml) 作用：实现作数据库Menu的接口方法的sql语句 resources路径下创建mapping文件夹：在同级文件夹上点击创建folder file configServer中menu-dev配置文件中添加mybtis 1234mybatis: mapper-locations: classpath:/mapping/*.xml type-aliases-package: com.example.demo.entity #提出menu下的entity包; 在mapping的xml文件中就不用再写包名 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.southwind.repository.MenuRepository&quot;&gt; &lt;resultMap id=&quot;menuMap&quot; type=&quot;Menu&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;mid&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;mname&quot;/&gt; &lt;result property=&quot;author&quot; column=&quot;author&quot;/&gt; &lt;result property=&quot;price&quot; column=&quot;price&quot;/&gt; &lt;result property=&quot;flavor&quot; column=&quot;flavor&quot;/&gt; &lt;!-- 映射type --&gt; &lt;association property=&quot;type&quot; javaType=&quot;Type&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;tid&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id=&quot;findAll&quot; resultMap=&quot;menuMap&quot;&gt; select m.id mid,m.name mname,m.price,m.flavor,t.id tid,t.name tname from t_menu m,t_type t where m.tid = t.id order by mid limit #&#123;param1&#125;,#&#123;param2&#125; &lt;/select&gt; &lt;select id=&quot;count&quot; resultType=&quot;int&quot;&gt; select count(*) from t_menu; &lt;/select&gt; &lt;insert id=&quot;save&quot; parameterType=&quot;Menu&quot;&gt; insert into t_menu(name,price,flavor,tid) values(#&#123;name&#125;,#&#123;price&#125;,#&#123;flavor&#125;,#&#123;type.id&#125;) &lt;/insert&gt; &lt;select id=&quot;findById&quot; resultMap=&quot;menuMap&quot;&gt; select id mid,name mname,price,flavor,tid from t_menu where id = #&#123;id&#125; &lt;/select&gt; &lt;update id=&quot;update&quot; parameterType=&quot;Menu&quot;&gt; update t_menu set name = #&#123;name&#125;,price = #&#123;price&#125;,flavor = #&#123;flavor&#125;,tid = #&#123;type.id&#125; where id = #&#123;id&#125; &lt;/update&gt; &lt;delete id=&quot;deleteById&quot; parameterType=&quot;long&quot;&gt; delete from t_menu where id = #&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; 启动类添加注解@MapperScan(“com.example.demo.repository”) 这是mybits的功能，在启动时把mapper.xml文件扫描进容器。容器中注入后就会有MenuRepo接口对象 之前的问题shared dev连不上我觉得是在创建项目的时候没有勾选DeveloperTool-DecTools","categories":[{"name":"springboot","slug":"springboot","permalink":"https://lucifinil-x.github.io/categories/springboot/"}],"tags":[]},{"title":"c语言","slug":"c语言","date":"2020-03-24T11:36:58.000Z","updated":"2020-04-30T09:54:18.131Z","comments":true,"path":"2020/03/24/c语言/","link":"","permalink":"https://lucifinil-x.github.io/2020/03/24/c语言/","excerpt":"字符数组问题 c语言中是没有字符串数组的；而且字符串的本质是字符数组。 strlen() 函数用于计算数组的长度。本质上是计算到’\\0’结束。那么当数组中没有存满时计算结果就会出错。则需要在填充数组之后手动加上 A[i]==’\\0’;再进行计算。 不能存很多字符串那怎么办呢？输入一个字符串，就遍历这个字符串对应的字符数组。12345char word[90];scanf(&quot;%s&quot;,word);while(word[m]!=&apos;\\0&apos;)&#123; m++; &#125;","text":"字符数组问题 c语言中是没有字符串数组的；而且字符串的本质是字符数组。 strlen() 函数用于计算数组的长度。本质上是计算到’\\0’结束。那么当数组中没有存满时计算结果就会出错。则需要在填充数组之后手动加上 A[i]==’\\0’;再进行计算。 不能存很多字符串那怎么办呢？输入一个字符串，就遍历这个字符串对应的字符数组。12345char word[90];scanf(&quot;%s&quot;,word);while(word[m]!=&apos;\\0&apos;)&#123; m++; &#125; 输入问题scanf输入一串字符不能结束的问题 scanf的结束占位符尚且不知道；而且EOF不能用回车结束 可以换成getchar()，它以回车结束输入12345678910 char A[30];char name;int i=0;while((name= getchar())!=&apos;\\n&apos;)&#123; A[i]= name; i++;&#125; scanf输入可以以空格或者回车结束指针传参问题 void reverseAB(int *arr, int a, int b) //注意传数组表示 int countFives(int A[], int num) //注意传数组表示","categories":[{"name":"c语言","slug":"c语言","permalink":"https://lucifinil-x.github.io/categories/c语言/"}],"tags":[]},{"title":"SpringBoot踩坑记录","slug":"SpringBoot踩坑记录","date":"2020-02-29T18:51:25.000Z","updated":"2020-06-24T20:16:12.157Z","comments":true,"path":"2020/03/01/SpringBoot踩坑记录/","link":"","permalink":"https://lucifinil-x.github.io/2020/03/01/SpringBoot踩坑记录/","excerpt":"代码对比完全一致，callback页面404，且控制台不打印 血的教训：所有java包和类放在启动类所在的包里，否则run不运行这些类，但控制台不报错。","text":"代码对比完全一致，callback页面404，且控制台不打印 血的教训：所有java包和类放在启动类所在的包里，否则run不运行这些类，但控制台不报错。 报错 BeanFactory 和bean一点关系也没有，原因： mapper映射文件中映射的mapper类的包名少写了一个mapper。而且这是最初没有写错的，是在试着改bug的时候改掉的。 1&lt;mapper namespace=&quot;com.example.demo.mapper.UserMapper&quot;&gt; 一定要先对照代码，特别是xml配置文件！写错没提示。 local网页自动跳转到我印象中没有写的页面toLogin 原本以为是之前运行的项目没关干净，测试了其他项目可以运行，网页跳转没有问题。那么一定是这个项目的代码哪里写错了。 发现并不是controller中的问题，是ShiroConfig类中粘贴代码没删掉拦截和自动跳转toLogin. 整合mybits实现用户登录，连接sql数据库。网页输入时控制台报错 目前正确配置文件的代码：12345678910spring.datasource.driverClassName=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost/springboot_shiro?serverTimezone=UTC //url这里不用写主机ip,不用写3306（3306加上也可以成功运行）spring.datasource.username=root //用户名在sqlyog的客户端里数据库上面写的root@localhost,@前面的就是用户名spring.datasource.password= //密码记在手机里了spring.datasource.type=com.alibaba.druid.pool.DruidDataSourcemybatis.type-aliases-package=com.example.demo.domain 报错 mysql access deny for 找了很久的报错 原因：spring.datasource.url=jdbc:mysql://localhost:3306/test 粘贴代码的时候没有改成自己的数据库名字，改回来就继续报错下面的问题，不过下面的问题都能百度到。 一定要检查代码每个字，在配置文件中写错是没有提示的而且很难发现，昨天的错误就是配置文件中少写了一个包名，报错提示完全和配置文件不沾边。 不知道是不是原因:之前没有添加jdbc的依赖 测试mysql数据库密码：搜索mysql会出来mysql的命令行打开就是要输入password控制台提示：Loading class com.mysql.jdbc.Driver&#39;. This is deprecated. The new driver class iscom.mysql.cj.jdbc.Driver’. 不会影响运行 在总配置文件中修改 报错com.alibaba.druid.pool.DruidDataSource: create connection error druid依赖版本/数据库连接池的包版本需要改成新版本 1234567&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.9&lt;/version&gt;&lt;/dependency&gt;``` 版本修改为： com.alibaba druid 1.1.10 1234- 以后报错还得改成更新版本### 报错The server time zone value &apos;�й���׼ʱ��&apos; is unrecogni- 在MySQL的URL后面加上“?serverTimezone=UTC” ，如下所示： spring.datasource.url=jdbc:mysql://localhost/springboot_shiro?serverTimezone=UTC 123## shiro授权过滤器没用- 键值对集合中只能一个key一个value，具体为什么不行我不知道。 filterMap.put(&quot;/add&quot;, &quot;authc&quot;);//authc必须认证才能访问 filterMap.put(&quot;/update&quot;, &quot;authc&quot;); //授权过滤器，登录过的user在add页面需要拿到add页面的授权才能访问 //在登录后点击添加时，就会进入授权逻辑 filterMap.put(&quot;/add&quot;, &quot;perms[user:add]&quot;);1修改为 filterMap.put(“/test”, “anon”); filterMap.put(“/login”, “anon”); //授权过滤器，登录过的user在add页面需要拿到add页面的授权才能访问 //在登录后点击添加时，就会进入授权逻辑 filterMap.put(“/add”, “perms[user:add]”); filterMap.put(“/*”, “authc”); 123456789101112## 一直标红其他代码没有问题- 删掉，重新自动添加方法就不红了。- 还是爆红，运行了没报错，不报红了## 报错 sql syntax error- sql语句 select xx from 中间没有逗号- 其他的部分大小写- 整数类型写int## 报错 server.port获取不到 ；还没有安全修改办法- 把server.port 改成 server:port @Value(“${server:port}”) private String port;``` 配置文件中 项目名大小写写错了一个 但是就不是配的8080了，变成8080,而且这个页面获取不到端口号 mysql,mybities数据库连接报错 控制台报错If you have database settings to be loaded from a particular profile you may need to activate it (no profiles are curren) 项目启动类上加@SpringBootApplication(exclude={DataSourceAutoConfiguration.class}) 因为menu的数据库配置代码在configServer中，现在还没有连接成功 ，暂时不知道数据库的问题 @Data cannot be resolved to a type 标红 因为没有lombok的包 解决：鼠标移动到标红 选最下面fix project setup 选择lombok的包 这样是在maven仓库中新加入lombok的包，就能在项目中导入包，就好了 报错Unsatisfied dependency expressed through field ‘menuRepo’ 这个是controller类中注入实现接口功能时的报错 检查步奏：1.启动类@MapperScan(“com.xx.xx”)2.pom 3.配置文件[这个不会标红，很多都是这里单词什么的写错了] 还没解决 代码生成器运行报错：Access denied for user ‘root’@’localhost’ (using password: YES) 一定是密码错误 原因：代码生成器中没有改mysql的密码。只改了用户名和数据库名。 Error creating bean with name ‘xxxxxController’https://blog.csdn.net/qq_38701478/article/details/88808628?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase 我的问题是/vueblog/src/main/java/com/example/demo/config/MybatisPlusConfig.java复制过来没有改@MapperScan(“com.example.demo.mapper”) 教训：不要质疑代码生成器给的类的注解。 另外注意：UserService类上不加注解；UserServiceImpl类上加@Service注解","categories":[{"name":"springboot","slug":"springboot","permalink":"https://lucifinil-x.github.io/categories/springboot/"}],"tags":[{"name":"bug","slug":"bug","permalink":"https://lucifinil-x.github.io/tags/bug/"},{"name":"解决办法","slug":"解决办法","permalink":"https://lucifinil-x.github.io/tags/解决办法/"}]},{"title":"人工智能入门学习","slug":"人工智能入门学习","date":"2020-02-23T18:21:16.000Z","updated":"2020-06-19T08:54:25.177Z","comments":true,"path":"2020/02/24/人工智能入门学习/","link":"","permalink":"https://lucifinil-x.github.io/2020/02/24/人工智能入门学习/","excerpt":"CSE112 鸡肋，过时，繁杂，背书只有30% 注意过程md-视图-搜索 或者 大纲-最上面有搜索栏word-开始-最右第一行-查找","text":"CSE112 鸡肋，过时，繁杂，背书只有30% 注意过程md-视图-搜索 或者 大纲-最上面有搜索栏word-开始-最右第一行-查找 ppt-开始-最右第一行-查找； ppt只能找下一个 pdf-搜索-小箭头-打开完整的Arc搜索 lecturesweek1 introduction 机器学习和AI技术的功能 Machine learning and Artificial intelligence will be used to analyze the data and provide a better service to human activities. AI covers a wide range of technologies including: image/speech recognization, language processing, user profiling剖析(data visualization), recommandation system. The boundaries between cloud computing and big data becomes blurred.变模糊 intelligent image captioning智能给图片加文字注解 It is evolving to learn from data. 什么是AI AI is the activity that is related to people’s thinking,such as decision making,problem solving, learning. 电脑语音合成 computer speech synthesis translate text to phonetic form week2 intelligent agent智能体，环境，问题 week AI &amp; strong AIstrong AI: 无意识，无认知能力，用于完成一个具体任务week AI: 有思维，像人 4 research perspectivesacting、thinking humanly: dulicate what human brain doesacting、thinking rationally: 取得最大化好处 intelligent agent 智能体 智能体是什么：一个可以感知并且做出动作的实体 agent= architecture + program 硬件（sensor,actuator）加代码 详细定义：agent is an entity that perceives and act OR is a function from percept to act. 通过感应器sensor感知perceives环境，通过执行器actuator做出动作action，最大化的达成目标 agent rationality:合理性task environment(PEAS)任务环境规范P: performance measure评判标准 - an objective criterion for success of an agent’s behavior 比如最少的能量干最多的事情E: environment 环境中有什么东西 比如固定的面积 不定的分布量distribution unkown 动作确定的deterministicA: actuators动作器 执行的动作 比如 左转右转 suck吮吸 noOpS: sensors感受器 比如 感知到所在位置和目标在的位置environment type环境类型： 1.Fully/Partially observable 传感器在所有时间点都可以获得环境的 完整/部分 状态。2.Single/Muti agent y一个环境中有 一个/多个 智能体。3.Deterministic确定的/Stochastic随机的 环境的一个状态由当前环境和智能体决定。/不能决定4.Episodic片段的/Sequential连续的 智能体的前后动作没有影响/有影响。5.Static/Dynamic 环境不随智能体改变。 /环境随智能体改变。6.Discrete离散的/Continuous连续的 感知和行为都是数量有限且定义明确的。 /数量无限 (最难的环境类型)真实世界的领域一般都是只能部分观察，不确定性，不静止，不连续Partially observable, stochastic, sequential, dynamic, continuous, and multi -agent. 重点：通过不同的环境设计不同的智能体。 agent type 主体（机器人）类型1.Table-Driven agent函数表驱动智能体 在函数表中查看当前感知，以找到最优动作2.Simple Reflex Agent简单反射智能体 Rule-based基于规则的,根据当前环境去匹配规则作出动作3.Model-Based Reflex agent基于模式的反射智能体 有一个外部环境模型Model of world。 感知历史的内部模型(像是有记忆的)，反射出当前无法预测的方面。 可以处理部分可观测的环境。4.Goal-based agent基于目标的智能体 选择通向目标的动作，考虑未来。takes future into account5.Utility-Based agent基于效用的智能体 两条路一条更便宜一条更快，用Utility function来计算效用值a utility value，从而选择更加高效的动作。6.Learning agent学习智能体 不断地修改智能体的决定机制，来提升效绩。 允许在未知环境中使用 学习是这个系统构建的方法。 Supervsied learning监督学习 Unsupervised learning非监督学习 Reinforcement learning强化学习：不断积累数据 ttl2 题目关键词 Turing Test图灵测试：判断是人还是机器。 agent定义，上面也有写。 rational agent定义：one that does the right thing. percept sequence感知序列：Everything that the agent has perceived so far. A simple reflex agent定义 环境和智能体匹配的题(1) Which type of agent is characterized with an internal state of the environment?Model-Based Reflex(2) What is the characterization of a static environment?静态环境特点The environment does not change while an agent is deliberating.(3) What type of environment is the most challenging for agents?Partially observable, stochastic, sequential, dynamic, continuous, and multi -agent.(4) Which type of intelligent agent takes future into account?Goal-based agents.(5) A cleaning agent goes from room to room, making sure not to clean the same room twice. What type of agent is this? And why?Model-based reflex agent, which remembers the past percepts(6) Discuss the important advantages of endowing an agent with learning capabilitiesLearning is essential for unknown environments；Learning is useful as a system construction method；Learning modifies the agent’s decision mechanisms to improve its performance。和上面学习智能体叙述一样。 解决问题 解决问题的考虑stateinitial stateactionsgoal testpath cost 问题求解的种类1.单一状态问题2.无传感器问题3.应急问题4.探索类问题 week3 搜索和prologAbstraction 抽象抽象：忽视无关细节 树搜索 通过搜索算法扩展 后续结点。 通用的树搜索算法结点存储在list，扩展结点，直到找到目标结点 搜索策略（如何选择下一个结点），四个“性质” 1.完整性Completeness:有限时间内总能找到一个解 2.时间复杂性Time complexity:生成的节点数量 3.空间复杂性Space complexity:内存中结点的最大数量 4.最优性Optimality:是否总可以找到最优解 8数码难题 状态：9x9棋盘，8个数字滑块占据一个方块，空格占据最后一个方块 初始状态：任意状态 动作：空格的移动：上下左右 模型转换：空格向左移动=棋子向右移动 目标检测：八个棋子在目标位置 路径代价：路径的步数，每一步为1代价 g(n)=已经移动砖块的次数 h(n)=当前错位砖块的个数 8皇后问题 8x8棋盘上放八个皇后，两两不能在同一行同一列同一斜角线上。 两种解决办法：1.一个一个放上去 2.任意放再调整位置 g(n)=到当前结点的距离 h（n）=到目标的直线距离 无信息搜索Uninformed search strategies无信息搜索1–图的宽度优先搜索算法 Breadth First 算法complete 但 内存expensive算法完整complete:保证算法在有限时间内找到一个解; 需要的时间短不能解决 指数复杂性问题，内存是很大问题。 先找完兄弟节点扩展最浅（上面）的扩展结点，同级扩展结点因为先从最上层判断没有就删除，所以用的队列，先进先出 空间复杂度：O(bm) 空间复杂度=内存中结点的最大数量(上面有提到)=一层b个结点，m层就是mb个 宽度优先搜索是统一成本搜索的一种特殊情况；当所有路径代价相同时，统一成本=宽度优先。 宽度优先搜索是完整的算法complete,但它不是最优optimal. 无信息搜索2–深度优先搜索 Depth first search 内存cheap but 算法incomplete时间长，空间（需要的内存）小 有兄弟结点和子节点时，完全搜索完子节点再回头搜索兄弟节点向下扩展结点，没有找到的话就从内存中删除因为最下面的是新加入判断的，没有就删除，所以用的堆栈，后进先出 空间复杂度：O(b^s bs) 最坏到s层 无信息搜索3–一致代价搜索算法UCS Uniform Cost Search = Dijkstra算法 宽度优先搜索是统一成本搜索的一种特殊情况；当所有路径代价相同时，统一成本=宽度优先。 统一成本搜索是无信息搜索的一种。 (UCS)：扩展的是路径消耗g(n)最小的节点n,用优先队列来实现，对解的路径步数不关心，只关心路径总代价。即使找到目标节点也不会结束，而是再检查新路径是不是要比老路径好，确实好，则丢弃老路径。 启发函数f： f（n）= g（n） Uniform Cost Search是a* 搜索的特例 怎么算长度： 一致代价的长度就等于出发点和某点的可以走通的直线距离（实际线段长度） prolog:描述性语言ttl3题目关键词 the stages of problem solving：1.formulates a goal and a problem. 指定目标和问题2.Search for a sequence of actions that would solve the problem，executes the actions one at a time. 搜索路径序列3.When this is complete, it formulates another goal and starts over.当问题解决目标达成后，制定下一个目标，再重复。 formulate problem制定问题:决定目标、状态、行动 optimal solution最优解： lowest path cost最小代价 好的抽象的properties财产：1.create an approximate, simplified, model建模(近似的简化的)2.retain all important details保留重要细节 状态和搜索结点的区别：state：physical configuration物理配置、布局node： 存储结点信息的数据结构 树搜索和图搜索的区别：扩展状态/ 图搜索是更一般的方法More general approach 宽度优先搜索和深度优先搜索区别Depth-first search always expands the deepest node in the current frontier of the search tree. The search proceeds immediately to the deepest level of the search tree, where the nodes have no successors. As those nodes are expanded, they are dropped from the frontier, so then the search “backs up” to the next deepest node that still has unexplored successors.Breadth-first search is a simple strategy in which the root node is expanded first, then all the successors of the root node are expanded next, then their successors, and so on. In general, all the nodes are expanded at a given depth in the search tree before any nodes at the next level are expanded. 对于BFS，space complexity空间复杂度问题更严重，内存空间需要更多。 BFS: Space complexity; DFS: Time complexity could be of a more serious issue. 食人族问题 和 水壶问题 week4 几个信息搜索算法总结：A* search最优最有效 DFS : 深度优先 BFD : 宽度优先 Depth limited search (DLS) 深度限制搜索 解释： 在进行深度优先搜索时，每条路径上在到达指定的步数后停止此条路径的搜索。 术语： 深度 = d ; 宽度 = b 适用情况： 已知解的最大深度； 解有深度范围 代码表示： if (depth(node) &lt; depth limit) 先判断小于深度限制，才能执行搜索代码。 Iterative deepening search (IDS) 迭代加深搜索 每次从头开始，第一次搜一层，第二次从头开始搜二层，第三次从头开始搜三层就是多次深度限制搜索，每次从头再来。 解释： 当宽度很大和深度未知时，不断的进行(DLS) 深度限制搜索，深度限制从0一直向上增加。 特点：时间换空间Trade off time for memory 用更多的时间，去节约很多内存空间。每次从头搜索时，会重新生成上一次生成过的节点。 迭代深化的深度优先搜索比宽度优先搜索占用更少的存储空间，但其渐近运行速度同样快。 IDS算法完整和最(更)优 时间复杂度: 𝑂(𝑏𝑑)—the same as BFS. 空间复杂度: O(bd). DLS 和 IDS 对比Nodes expanded with depth-limited search: 1+b+b2+b3+…+bd-1+bdNodes expanded with iterative deepening search: (d+1)1+(d)b+(d-1)b2+(d-2)b3+…+(2)bd-1+(1)bd IDS is complete and optimal IDS 算法完整和最优；DLS 和 IDS 改进了基础的宽度优先和深度优先搜索技术 Avoiding repeated states 避免重复状态Do not return to the state you have just come fromDo not create paths with cycles in them (do not create a node the same as any ancestor)Do not generate any state that was ever generated before Heuristic search启发式 h(n) 解释：基于问题考虑，选择最有可能的路径；一致代价搜索USC是当前结点的路径，启发式搜索是计算剩余路径 特点：启发式搜索是信息搜索的核心方法 Greedy search贪婪 比如八滑块问题：直接计算需要调整的滑块个数；或者替换错位滑块需要走的直线距离 启发函数f：f（n）= h（n） 特点：快速；可能找不到解；可能第一步错误；只从当前结点计算，忽略之前的结点 重点：未能远谋，不一定是最优长度（最短路径）； 只看期望长度（走横着竖着的格子，曼哈顿距离）；只选择下一个h最小的结点 Greedy first search greedy first只扩展hn最小的结点，一路走到头。不会比较，也不看gn. 所以，他可能找不到短的路径，叫贪婪搜索 一致代价搜索算法UCS 计算！：fn = gn + 0; 计算所有路径的gn,选择其中最短; (uniform cost就是A* 的hn等于0的情况) A* search A * 是一种典型的启发式搜索，是信息搜索的一种informed search strategy，是best-first search的一种。 计算！：fn = gn + hn；计算所有路径的fn,选择其中最短(走过的路径基本就是最短路径了;其实不是比所有路径，因为没具体到把所有路径都算一遍，只是在看边界节点fn是否小，如果再往下拓展fn比frontier队列里的节点的fn大就会换别的节点) 最优！，最小cost path 解释：结合了一致代价和贪婪搜索；注重于已用的成本和到目标的成本；为了最小化代价minimize the overall cost 启发函数f： f（n）=g（n）+h（n）= 开始到n结点的路径成本 + 从n 到目标的最短的解 = 一致代价+贪婪搜索比如8滑块问题， g(n)是空白滑块移动步数， h(n)是要调整的滑块个数 A* 的机制就导致它会比uniform cost更准确一些，然后走过的路径基本就是最短路径了 曼哈顿距离 h预估距离 某点到终点的 横着走几格，竖着走几格，加起来的距离 可以穿墙 斜边长度表示为直角两边的和a+b;不再用根号表示（虽然有误差，但是如果大家都这么算那么就变得比较好比较） 算横着走几格，竖着走几格，加起来 实际距离 g出发点和某点的可以走通的直线距离 斜着14 横着10，有拐点的要算两条直线和 启发式函数h(n)在A* 中的作用启发式函数可以用来控制A的行为。一种极端情况，如果h(n)是0，则只有g(n)起作用，此时A 算法演变成Dijkstra算法=一致代价搜索，就能保证找到最短路径。 如果h(n)总是比从n移动到目标的代价小（或相等），那么A* 保证能找到一条最短路径。h(n)越小，A* 需要扩展的点越多，运行速度越慢。 如果h(n)正好等于从n移动到目标的代价，那么A* 将只遵循最佳路径而不会扩展到其他任何结点，能够运行地很快。尽管这不可能在所有情况下发生，但你仍可以在某些特 殊情况下让h(n)正好等于实际代价值。只要所给的信息完善，A* 将运行得很完美。 如果h(n)比从n移动到目标的代价高，则A* 不能保证找到一条最短路径，但它可以运行得更快。 另一种极端情况，如果h(n)比g(n)大很多，则只有h(n)起作用，同时A* 算法演变成贪婪最佳优先搜索算法（Greedy Best-First-Search）。 ttl4 关键词智能体 智能体的 environment is accessible：If an agent’s sensory apparatus gives it access to the complete state of the environment如果一个特工的感觉器官能让他进入环境的完整状态， environment effectively accessible：detect all aspects that are relevant to the choice of action. A successor function定义(状态转换函数)：is a description of possible actions, a set of operators. 是对可能操作的描述，是一组运算符。It is a transformation function on a state representation, which converts it into another state。它是状态表示的转换函数，将其转换为另一个状态。后继函数定义了状态之间的可访问性关系。 BFS IDS UCS A IDS对比BFS:迭代深化的深度优先搜索比宽度优先搜索占用更少的存储空间，但其渐近运行速度同样快。 宽度优先搜索是统一成本搜索的一种特殊情况；当所有路径代价相同时，统一成本=宽度优先。 宽度优先搜索是完整的算法complete,但它不是最优optimal. 统一成本搜索是无信息搜索的一种。 A * 是一种典型的启发式搜索，是信息搜索的一种informed search strategy，是best-first search的一种。 解释深化迭代IDS怎么工作 特定的搜索策略已经完成=guaranteed to find a solution when there is one. BFS完成条件：As long as the shallowest goal node is at some finite depth d, breadth-first search will eventually find it after generating all shallower nodes (provided the branching factor b is finite), i.e. guarantee the completeness.只要最浅的目标节点位于某个有限的深度d，广度优先搜索将在生成所有较浅的节点（前提是分支因子b是有限的）之后最终找到它，即保证完整性。 BFS是最优的条件： if the path cost is a nondecreasing function of the depth of the node.路径代价是节点深度的非递减函数。 A* 搜素 A* 搜素和贪婪搜索的区别：Greedy-first search: f (n) = h(n). A* search: f (n) = g(n) + h(n). A* 搜素在什么条件下产生最优解(去年期末):1.h(n) be an admissible heuristic.h（n）是一个可容许的启发式2.consistency (or sometimes monotonicity)一致性（或有时是单调性); monotonicity is required only for applications of A* to graph search. 单调性用于图搜索。 admissible heuristic可容许的启发式什么意思：1.never overestimates the cost to reach the goal.永远不会高估达到目标的成本2.解释：Because g(n) is the actual cost to reach it along the current path, and f (n) = g(n) + h(n), we have as an immediate consequence that f (n) never overestimates the true cost of a solution along the current path through n.因为g（n）是沿着当前路径到达它的实际成本，而f（n）=g（n）+h（n），我们的直接结果是f（n）永远不会高估沿着当前路径通过n的解的实际成本。 选择哪个搜索，路径题过程怎么写 当（a）有一个大的搜索空间，（b）解的深度未知，（c）需要一个最优解，并且（d）有一个一致的可容许启发式算法可用时，首选A* 。 浅层，首选DFS 无限分支，首选IDS 如果结点代价=结点所在层数，BFS,UCS,DIS是最优。 DIS路径分层写：L0 A, L1 ABCD, L2 ABEFCG Greedy (只看h)：和A,UCS一样，每次选结点都是在所有能够扩展出的节点中选直到选完。不是一条通路。而且注意题目上说谁是goal,走到goal就结束。 A图路径题 和一致成本选择扩展点一样。 结点扩展过程怎么写 搜索总结迭代深度搜索一致代价搜索 最优 A搜索 最优 宽度搜索 week5、6 KR 知识表示，Rule-based Systems知识分类1.Facts陈述性知识：Male(x)2.Rules程序性知识/函数：Father(x,y)3.Control Strategy: meta-level元知识(自身表示知识)，super knowledge. 元知识Meta-knowledge is knowledge about knowledge. 元知识是知识本身。For example, knowledge about how an expert system makes decisions would be considered meta-knowledge.例如，关于如何专家系统做出的决策被认为是元知识。 元知识的例子：methods of planning, modelling, tagging, learning and every modification of a domain knowledge.元知识的例子是规划、建模、标记、学习和领域知识的每次修改的方法。 不同知识level1.知识水平knowledge level:描述与模型无关的内容2.逻辑水平logical level:KR模型中表示事实的陈述3.实施水平implementation level:表示知识被编译的方式 六种知识表示方法1.propositional logic命题逻辑2.Rule-based system 规则系统–Expert system3.Semantic Networks语义网络4.Frame5.Bayesian networks贝叶斯网络6.Knowlwdge graph知识图 rule-based system规则系统 形式：condition -! action: if条件 then 动作 知识 = 规则（rule）的集合 Rule-Based System的结构，重要组件(ttl5)：rule的集合，fact的集合，a rule fire. 专家系统，基于规则系统 什么是专家系统：An expert system is a computing system that is capable of expressing and reasoning about some domain of knowledge.专家系统是一个能够表达和推理的计算系统关于某个知识领域。 Rule-Based System的应用例子medical expert system：帮助医生用rule来推断诊断 专家系统优点(用医生专家系统来举例)：1) the knowledge for patient diagnosis;患者诊断的知识2) the diagnosis, i.e. provide prescription;诊断，即提供处方3) knowledge accumulation, i.e. learning new experience from patient cases.知识积累，即从患者案例中学习新经验 Expert system结构为 inference engine推理机器接口引擎，将知识库和数据库中的rule和fact联系起来 knowledge base知识库（规则的集合），规则为if then结构 database数据库，存储fact,对应if部分 explanation facilities解释机制：允许用户查询推理过程，从rule推理得出结论的过程解释 user interface用户接口、界面， 用户和专家系统之间交流通信 inference engine定义：The inference engine carries out the reasoning whereby the expert system reaches a solution. It links the rules given in the knowledge base with the facts provided in the database. 传统程序和专家系统区别很大：Program = algorithm + data；For example, the expert system is often designed to be able to solve problems or provide advice in a specific domain, whereas the general software systems are relatively less domain-driven。专家系统通常被设计成能够解决在一个特定领域中的问题或提供建议，而一般的软件系统是相对较少的领域驱动。 control scheme控制方案-前后链 已知一些规则，用他们去获得新知识(rule的集合)，有前向链接和反向链接两种方法 Forward chaining 前向链接：从事实推到结论。从fact开始，以fact来找需要用到的rule.(Data-driven search)适用情况：所有fact已知，goal的信息困难，一小部分初始状态，但有大量结论。 Backward chaining 后向链从(需证)结论推到前提(事实)。从要查找的结论，来找需要用到的rule.(Goal-driven search)适用情况：需要时获取数据（当数据采集成本很高时），容易形成假设/目标结论（比如医学诊断），少量factprolog使用后向链 二者区别：前向链接从已知事实开始，然后应用推理规则提取更多数据，然后继续向前移动直到到达目标；然后前向链接从目标开始，并使用推理规则确定后向链接满足目标的事实。前向链接称为数据驱动推理技术，后向链接称为目标驱动推理技术。正向链接称为向下搜索方法，而反向链接称为自上而下搜索方法。前向链采用广度优先搜索策略，后向链采用深度优先搜索策略。正向链接可用于规划、设计过程监控、诊断和分类任务，反向链接可用于分类和诊断任务。前向链接可能类似于穷举搜索，而后向链接则试图避免不必要的推理。在正向链接中，知识库中可能存在各种提问问题；在反向链接中，可能存在较少的提问问题。前向链接检查所有规则，因此速度较慢，而后向链接只检查一些必要的规则，因此速度较快。Forward chaining as the name suggests, start from the known facts and move forward by applying inference rules to extract more data, and it continues until it reaches to the goal, whereas backward chaining starts from the goal, move backward by using inference rules to determine the facts that satisfy the goal. The following points are helpful to better understand the difference between to two approaches:Forward chaining is called a data-driven inference technique, whereas backward chaining is called a goal-driven inference technique.Forward chaining is known as the down-up approach, whereas backward chaining is known as a top-down approach.Forward chaining uses breadth-first search strategy, whereas backward chaining uses depth-first search strategy.Forward chaining can be like an exhaustive search, whereas backward chaining tries to avoid the unnecessary path of reasoning.Forward chaining is slow as it checks for all the rules, whereas backward chaining is fast as it checks few required rules only. 规则和问题的特性，pdf中Semantic Networks语义网络 定义： 1.用图表示知识2.结点表示事实/概念，箭头表示概念之间的关系3.继承4.联系link:and/or/not/推导/相等图差不多就那么回事。 ttl5关键词 什么是knowledge: justified true belief.if you believesomething for an unassailable good reason, and if it is actually true, then you know it.正当的真实信念。如果你相信一个无可争辩的好理由，如果它是真的，那么你知道它。 什么类型的知识可以分类: Facts, rules and control strategies. 在人工智能中，我们需要讨论哪些不同层次的知识:Knowledge level, logical level and implementation level. 人工智能中，为什么没有选择自然语言：it is too ambiguous for automated reasoning and without clear semantics.它对于自动推理来说太模糊了，而且没有清晰的语义。 一个合适的KR方案的理想特性是什么：Representational adequacy; Inferential adequacy; Inferential efficiency; Well-definedsyntax &amp; semantics Naturalness.表征充分性；推理充分性；推理效率；定义明确的语法和语义自然。 rule-based system重要组件： A collection of rules; A collection of facts; A rule fires if a fact matches the condition of the rule. 什么是专家系统：An expert system is a computing system that is capable of expressing and reasoning about some domain of knowledge.专家系统是一个能够表达和推理的计算系统关于某个知识领域。 专家系统和一般软件系统的区别：For example, the expert system is often designed to be able to solve problems or provide advice in a specific domain, whereas the general software systems are relatively less domain-driven。专家系统通常被设计成能够解决在一个特定领域中的问题或提供建议，而一般的软件系统是相对较少的领域驱动。 ttl6关键词 什么是专家系统，比如说生产系统：The production system model (one basic expert system type) is based on the idea that humans solve problems by applying their knowledge (expressed as production rules) to a given problem represented by problem-specific information.生产系统模型（一种基本的专家系统类型）是基于这样一种思想，即人类通过将其知识（表示为生产规则）应用于由特定问题信息表示的给定问题来解决问题。 Why is knowledge acquisition often referred to as the ES ‘bottleneck’?为什么知识获取常常被称为ES的“瓶颈”？：Due to the difficulty in useful information extraction/retrieval. There are over a trillion pages of information on the Web, almost all of it in natural language, An agent that wants to do knowledge acquisition needs to understand (at least partially) the ambiguous, messy languages that humans use.因为有用信息的提取/检索困难。网络上有超过一万亿页的信息，几乎都是自然语言的，一个想要获取知识的代理需要理解（至少部分地）人类使用的模糊、混乱的语言。 前后链题：IF green THEN walka) the antecedent前因 of this rule? greenb) the consequent后因 of this rule? walkc) Which part of the rule will be matched against the working memory规则的哪个部分将与工作内存匹配？前因用于向前链接；后因用于向后链接。 Q9前后链推理题，用表格表示推理过程，值得注意的是后链是给出fact A,去找IF B THEN A，然后得到fact B,去找IF C THEN B…都是用结论找IF的fact ES(专家系统)可能犯的错误：Depending on the employment of different conflict resolution strategy, the expert system may make different decision with respect to the same query. However, there could only be one ground truth. This is one of the major challenges for expert system design till nowadays: just like human beings, we can make similar mistakes when there are options to choose. Also similar to human, the success rate for an expert system in decision-making can never be 100% given infinite amount data, i.e. it will eventually make mistake(s) while data increasing.根据使用不同的冲突解决策略，专家系统可能对同一查询做出不同的决策。然而，只有一个基本事实。这是目前专家系统设计面临的主要挑战之一：就像人类一样，在有选择的时候也会犯类似的错误。与人类相似，专家系统在决策中的成功率永远不可能是100%，也就是说，在数据不断增长的情况下，专家系统最终会犯错误。 AI主要问题，怎么管理：1）对于医学专家系统来说，成功诊断率是一回事，获得医患双方的信任是另一个更具挑战性的课题，这基本上甚至与技术无关。2） 如果军用人工智能或半人工智能系统，如无人机失去控制或被恐怖分子控制，潜在的损害可能比人类严重得多。 W7、8 命题逻辑和KR中的应用命题逻辑W8、9 propositional reasoning命题推理等价公式Normal Forms范式定义：逻辑形式正确，语法不同的式子。CNF:conjunctive normal form. CNF只用∧连接，括号中是另外那个符号：(A ⋁ C) ∧ (¬B ⋁ C) 重要的英语单词 disjunction：析取 或 ∨ conjunction：合取 和 ∧ conjunctive normal form.CNF只用∧连接，括号中是另外那个符号：(A ⋁ C) ∧ (¬B ⋁ C) 计算律 真值表 化简不出来立马换成真值表Let P, Q and R be three atomic prepositional assertions. Let X denote (P v Q) → R and Y denote (P → R) v (Q → R). Which one of the following is a tautology? Select one: a. ¬ Y → X b. X → Y c. X ≡ Y d. Y → X B是永真，画不出来立马上真值表！注意不要漏点 propositional language then = only if = → “if Paola is happy, then she paints a picture” = “Paola is happy only if she paints a picture” ​ 都是p→q; ​ “Carlo comes to the party only if Angelo and Bruno do not come” ​ C → ¬A ∧ ¬B if and only if = ↔ “Davide comes to the party if and only if Carlo comes and Angelo doesn’t come” ​ D ↔ (C ∧ ¬A) , but, = ∧ “Carlo comes to the party provided that Davide doesn’t come, but, if Davide comes, then Bruno doesn’t come” (¬D → C) ∧ (D → ¬B) neither A nor B = ¬A ∧ ¬B “Either Aldo is Italian and Bob is English, or neither Aldo is Italian nor Bob is English” (A ∧ B) ∨ (¬A ∧ ¬B) is that = →“A necessary condition for Angelo coming to the party, is that, if Bruno and Carlo aren’t coming, Davide comes”A → (¬B ∧ ¬C → D) 以上所有组合题目“Angelo, Bruno and Carlo come to the party if and only if Davide doesn’t come, but, if neither Angelo nor Bruno come, then Davide comes only if Carlo comes”(A ∧ B ∧ C ↔ ¬D) ∧ (¬A ∧ ¬B → (D → C) ttl8关键词Q8 用inference rules证明，排序 (很长的过程，慢慢分解开) 必考！！Assume that the following sentences are in our Knowledge Base (~A denotes the negation of A):~A~A =&gt; ~B ^ ~C~B =&gt; ~D ^ ~E~C =&gt; D v E v FUsing the inference rules that we studied in class for propositional logic, prove that “F is true”. When you derive F, specify exactly the sequence of inference rules that youused Q10 自然语言翻译成一元谓词与命题连接词 ttl9关键词 单选题Propositional logic uses syntax to stand for statements and:The relationships between statements disjunction：析取 ∨ 只有一个错的，全部的是对的 conjunction：合取 ∧ W9和10ppt一样？？satisfiable可满足的valid/tautologous有效的，还有另外三个可满足的是：there exists at least one interpretation for which the sentence is true.至少一个是真的。 The sentence is satisfied by at least one truth assignment. We say that a sentence is satisfiable if and only if it is valid or contingent. 有效valid/tautologous的是：it is true under all possible interpretations in all possible worlds.所有都为真，都满足。always true另外三个：falsifiable： if and only if it is unsatisfiable or contingent. contingent：有真有假 if and only if When the expression is sometimes true and sometimes false. unsatisfiable/Inconsistent: if and only if it is not satisfied by any truth assignment.用真值表，所有情况都是错的always false If a formula a is a valid then ¬a is unsatisfiable. entailment蕴含KB |= alpha if and only if (KB ⇒ alpha) is validKB |= alpha if and only if (KB ∧¬ alpha) is unsatisfiable KB |= a就是KB →a永真就是KB：¬KB⋁a永真，KB∧¬a永假 NNF：negation normal form 能移进括号里的¬全部移进 例子(¬ A ⋁ B) ∧ ¬ C CNF:conjunctive normal form. CNF 只用∧连接，括号中是另外那个符号：(A ⋁ C) ∧ (¬B ⋁ C) 例子(p ⋁ q) ∧ r ∧ (¬ p ⋁ ¬ r ⋁ s) is in CNF.¬(p ⋁ q) ∧ r ∧ (¬ p ⋁ ¬ r ⋁ s) is not in CNF.(p ⋁ q) ∧ r ∧( p →(¬ r ⋁ s) ) is not in CNF. ttl10转化成CNF格式Q7 ^-Elimination Modus Ponens 还不明白 必看W11 有效的命题推理KR的命题推理CNF=conjunctive normal form形式 A1^A2^…^An Resolution分解用分解的方式来命题推理 定义：分解是命题逻辑与一阶逻辑的证明方法 用法：判断一个公式 前提：我们可以将任意命题逻辑转化为等价的分句形式(clausal form) Resolution in FOL(FOL是谓词逻辑)详细内容：https://www.javatpoint.com/ai-resolution-in-first-order-logic Unification：联合两句同一证明 Resolution： 消解，有效地操作合取范式或子句范式 Clause: Disjunction of literals (an atomic sentence) is called a clause. It is also known as a unit clause.几个literal用∨连接称为子句。它也被称为单元子句 第一步：把英语句子写成FOL(谓词逻辑) 第二步：把FOL转写成CNF形式（换掉→，¬写进括号中，改变量名字保证变量不重复） 第三步：把Λ两边的语句分开，V连接的不变food(Apple) Λ food(vegetables)分解成food(Apple)和food(vegetables) 第四步(存疑)：否定要证明的语句要证明j. likes(John, Peanuts).否定它¬likes(John, Peanuts) 第五步：把以上列出的语句进行两两V连接，¬P ∨ Q 连接 P ∨ R=Q ∨ R（消掉了R） 分句形式(clausal form)literal: p 非p Order of Quantifiers量词顺序量词顺序不一致会改变意思！ Assume P(x,y) is (x + y = 10).1.任意x 存在y P(x,y) domain: real numbers “For all real numbers x there is a real number y such that x + y = 10.” True (y = 10 - x) 存在y 任意x P(x,y) domain: real numbers “There is a real number y such that for all real numbers x, x + y = 10.” FalseSo, 任意x 存在y P(x,y) and 存在y 任意x P(x,y) are not logically equivalent.ttl11把句子翻译成命题逻辑 w12 看到p46First-Order Logic (Predicate Logic)Universal QuantifierExistential QuantifierNested QuantifiersOrder of Quantifiers量词顺序量词顺序不一致会改变意思！ Assume P(x,y) is (x + y = 10).1.任意x 存在y P(x,y) domain: real numbers “For all real numbers x there is a real number y such that x + y = 10.” True (y = 10 - x) 存在y 任意x P(x,y) domain: real numbers “There is a real number y such that for all real numbers x, x + y = 10.” FalseSo, 任意x 存在y P(x,y) and 存在y 任意x P(x,y) are not logically equivalent.ttl12句子和逻辑互相翻译 w13Well-Formed Formula WFF不是所有句子都能代表谓词逻辑 检查表达式是否为WFF的一种方法是试着用英语说出来。如果你能把它翻译成正确的英语句子，那么它就是一个WFF。 WFF的条件： w13 p8 WFF例子 free and boundfree: 没有量词约束 p(x) ∧ q(x) bound:量词约束 ∀x · (p(x) ⇒ q(x)) p(x) ∧ ∃x · q(x)：p(x) free ∃x · q(x)bound ttl13用resolution rule证明prolog语言 W3 pptprolog语言是陈述性语言，用于描述陈述性知识。可以 表示事实与规则 swing-prolog使用 file-consult 之后一堆error不用管 然后打开xxx.pl文件 就加载上了；在里面输入命令就能用了 语句 定义rule:grandparent(X,Z):- parent(X,Y),parent(Y,Z).mother(X,Y):- parent(X,Y), female(X). 运行查询：?- mother(cathy,ian).true.% Who is Lucy’s parent??- parent(X,lucy).X = ian 函数sum2squares(X, Y, Result) :- square(X, X2), square(Y, Y2), Result is X2+Y2. Matching &amp; Backtracking W6MatchMatch:triangle(point(1,1), A, point(2,3)) = triangle(X, point(4,Y), point(2,Z)). match by:一一匹配，匹配成功就运行body,否则找下一个同名函数triangle = trianglepoint(1,1) = XA = point(4,Y)point(2,3) = point(2,Z) The resulting instantiation is:X = point(1,1)A = point(4,Y)Z = 3 BacktrackingProlog从上到下遍历事实/规则，试图找到匹配的规则或事实。但它会跟踪它的目的地，当任何事情失败时，它会返回并重试它证明的最后一个目标，然后在程序的后面用事实/规则找到另一种证明它的方法。 下面是匹配Bird x 是谁，先x=leo,去满足animal和hasFeather,发现不满足，就回溯到让x=tweety…:animal(leo).animal(tweety).animal(percy).animal(peter).hasFeathers(percy).hasFeathers(peter).bird(X) :- animal(X), hasFeathers(X).bird(freddy). ?- bird(B).Matches with head of first rule.Tries to satisfy animal(B).Matches animal(leo).Tries to satisfy hasFeathers(leo).Fails, so backtracks to try animal(B) again.Matches animal(percy).Tries hasFeathers(percy).Succeeds, so bird(B) succeeds/B = percy ;Going back and trying later animal facts (fails for “tweety”):B = peter;And trying later “bird” fact:B = freddy. 离散数学相关条件概率p = (已发生事件 和 未发生事件 同时发生的概率)/ 已发生事件的概率","categories":[{"name":"记忆性学习","slug":"记忆性学习","permalink":"https://lucifinil-x.github.io/categories/记忆性学习/"}],"tags":[]},{"title":"操作系统原理","slug":"操作系统原理","date":"2020-02-23T17:45:15.000Z","updated":"2020-05-13T11:44:10.457Z","comments":true,"path":"2020/02/24/操作系统原理/","link":"","permalink":"https://lucifinil-x.github.io/2020/02/24/操作系统原理/","excerpt":"CSE108 抽象难学80% 期末考，没有选择，全是大题：概念复述和计算概念题40+计算题40+设计题20","text":"CSE108 抽象难学80% 期末考，没有选择，全是大题：概念复述和计算概念题40+计算题40+设计题20 lecturesweek1 Introduction. Operating Systems Structures. 操作系统做什么 组织 结构 处理 进程管理 内存管理 长期储存管理 安全和保护 计算环境 开发资源处理系统 open-source operating system quiz:1.Multiprogramming of computer system increases CPU utilization 2.Main memory of computer system is known to be volatile 3.Multiprocessor system have advantage of Increased Throughput 4.Multi-processor systems of computer system has advantage of reliability 5.To start an I/O operation device driver loads appropriate register into is said to be Device Controller 6.Processor is often referred to Central Processing Unit 7.Cache memory is intended to provide memory access Fastest 8.Another type of multiple-CPU system is the Clustered System集群系统 9.The systems which allows only one process execution at a time, are called uniprogramming systems 单程序设计系统 10.What is operating system? b. link to interface the hardware and application programs c. system service provider to the application programs d. collection of programs that manages hardware resources 11.OS is responsible for transferring data to I/O devices 12.Symmetric multiprocessing architecture of computer system uses shared Buses &amp; Memory 13.In a multi-programming environment : the processor executes more than one process at a time 14.Environment for execution of programs is provided by operating system 15.One that is not a type of multiprocessor of computer system is single core week2 Process概念 concept 进程是什么，进程和程序的关系：进程是正在执行的程序，必须按顺序执行一个进程是一个活动的实体 active entity / 一个程序program是一个被动的实体 passive entity.当可执行文件加载进内存的时候，程序就变成进程。 操作系统执行多种程序：批处理系统 batch system – 批处理系统，又名批处理操作系统。批处理是指用户将一批作业提交给操作系统后就不再干预，由操作系统控制它们自动运行。这种采用批量处理作业技术的操作系统称为批处理操作系统。批处理操作系统分为单道批处理系统和多道批处理系统。批处理操作系统不具有交互性，它是为了提高CPU的利用率而提出的一种操作系统。 分时系统 time-shared system – user programs/tasks分时系统是指允许多个用户同时共享计算机资源的操作系统。系统必须通过CPU切换来执行多个任务 内核线程和用户线程用户线程指不需要内核支持而在用户程序中实现的线程，其不依赖于操作系统核心，用户进程利用线程库提供创建、同步、调度和管理线程的函数来控制用户线程。用户线程不需要用户态/核心态切换，速度快，操作系统内核不知道多线程的存在，因此一个线程阻塞将使得整个进程（包括它的所有线程）阻塞。由于这里的处理器时间片分配是以进程为基本单位，所以每个线程执行的时间相对减少为了在操作系统中加入线程支持，采用了在用户空间增加运行库来实现线程，用户线程是不能被操作系统所感知的。内核线程和用户线程都有自己的优势和缺点，一般配合使用 进程控制块PCB process control block 是什么：PCB是一种存储数据的数据结构。又被称作 进程的上下文context。每个进程都是由它自己的PCB控制。它自己的PCB都驻留在主内存中。所有进程的PCB展示在一个链表中。PCB在多程序环境中很重要，捕获同时运行程序的信息。 PCB关联的组件，PCB里存了些什么：进程状态：程序计数器： 指向（在任何）进程中执行的下一条指令的地址。寄存器信息： 与进程相关的各种寄存器调度信息： 是用于设置管理 进程的优先级的。内存管理信息： 分配给进程的内存记账accounting信息： 存储CPU的利用率，进程执行时间，启动的时钟时间，时间限制IO状态信息： 分配给处理器的IO设备，打开文件的列表 特征 调度 scheduling（设置管理 进程的优先级）进程调度器scheduler： 从内存中选择准备执行的进程，将CPU分配给它。1.短期调度器：选择下一个执行的进程并分配CPU2.长期（或job）调度器： 选择哪些放到准备队列中。控制内存中进程的数量。3.中期调度器：程序多了，需要减少的时候。就从内存中删掉程序，存到硬盘上。从硬盘上返回继续执行swapping 调度队列scheduling queues: 1.job队列–系统中所有进程的集合 2.ready队列： 准备，等待着被执行的进程的集合 3.设备对象：等待IO设备的进程的集合 进程大概分为： I0-bound(多IO少计算) ； CPU-bound(多计算少IO) context switch 上下文切换：CPU切换进程通过它。保存旧进程状态，加载新进程状态。 操作 系统必须提供一下机制mechanism:process creation; process termination 进程创造机制： 父进程创造子进程，形成进程树。资源共享选项： 1.父子共享所有资源 2.子共享父资源的一个分支 3.父子不共享资源执行选项： 1.父子同时执行 2. 子结束后父执行 进程终止机制：进程执行最后一条语句，然后操作系统通过系统调用exit()删掉它。父进程可以通过系统调用abort()关掉子进程。 进程间通信 interprocess communication IPC 进程分为：1.独立进程independent： 互不影响 2.合作进程cooperating： 可以互相影响. 进程之间需要交互 可以合作的原因：信息共享、计算加速、模块modularity、方便 共享内存 shared memory一个内存区域region由合作进程共享，可以读写入数据。 例子：复制粘贴，由操作系统加密。两种缓冲器区buffer可以使用：1.无界缓冲区unbounded-buffer：无大小限制 2.有界缓冲区bounded-buffer：有固定大小 消息传递（系统） message passing各个进程之间通过操作系统完成传递。 进程1封装信息（格式化）给OS，OS再把它给进程2。有两个操作：send(); operations(). 直接/间接communication: P-&gt;Q / P-&gt;mailbox-&gt;Q同步/异步communication：blocking/ non-blocking week3 Threadsquiz:1.__ is an entity corresponding to a user job or application that owns resources such as memory and open files.process 2.A process having multiple threads of control implies ___a. it can do more than one task at a time  3.If multiple threads are concurrently searching through a database and one thread returns the result then the remaining threads must be :cancelled 4.Because the kernel thread management is done by the Operating System itself :kernel threads are slower to create than user threads内核线程的创建速度比用户线程慢 5.Termination of the process terminates ___all threads within the process 6.If the kernel is single threaded, then any user level thread performing a blocking system call will:cause the entire process to block even if the other threads are available to run如果内核是单线程的，那么执行阻塞系统调用的任何用户级线程都将： 使整个进程阻塞，即使其他线程可以运行 7.The model in which one kernel thread is mapped to many user-level threads is called ___Many to One model 8.A thread is also called ___Light Weight Process(LWP) 9.A process can be ___both single threaded and multithreaded 一个进程可以单或多线程 10.The register context and stacks of a thread are deallocated when the thread:terminated当线程终止，线程的寄存器上下文和堆栈被释放 11.Multithreading on a multi – CPU machine ___increases concurrency 增加并发性 12.Resource sharing helps:a. share the memory and resources of the process to which the threads belong. b. reduce the address space that a process could potentially use c. an application have several different threads of activity all within the same address spacea、 共享线程所属进程的内存和资源。b、 减少进程可能使用的地址空间c、 一个应用程序有几个不同的活动线程，它们都在同一个地址空间内 13.下面都是对的b. Related kernel level threads can be scheduled on different processors in a multiprocessor systemc. Context switch time is longer for kernel level threads than for user level threadsd. User level threads do not need any hardware support 14.When a web page is loading, and the user presses a button on the browser to stop loading the page :the thread loading the page is cancelled 15.A thread shares its resources (like data section, code section, open files) with ___other threads that belong to the same process week4 Process Synchronization同步quiz:1.Select the correct statements regarding mutex lock to prevent race conditiona process must acquire the lock before entering a critical section;it releases the lock when it exits the critical section 2.Process synchronization can be done on __both hardware and software level 3.Which of the following Multithreading model also allows multiple threads to run in parallel on multiprocessorsOne to One model 4.What state does Thread enter in when it has been created and started?Running 5.A semaphore is a shared integer variable __大于等于0 6.Which of the following Multithreading model has action “creating a user thread requires creating the corresponding kernel thread”.One to One model 7.A Race condition refers to _____A situation where several processes access and manipulate the same data concurrently 8.What is valid point about threadThread are subdivision of Process. One or more Threads runs in the context of process. Threads can execute any part of process. And same part of process can be executed by multiple Threads 9.Peterson’s solution is restricted to ____ processes that alternate execution between their critical sections and remainder sections两个 10.Mutual exclusion can be provided by the __both mutex locks and binary semaphores 11.We use the mutex lock to protect critical regions and thus prevent race conditions. The term mutex is short formutual exclusion 12.If a process is executing in its critical section, then no other processes can be executing in their critical section. This condition is called?mutual exclusion 13.A non-preemptive kernel is essentially free from race conditions对的 14.User threadsare supported above the kernel and are managed without kernel support 15.Thread shares with other threads belonging to the same process itscode section and data section 16.Which of the following condition stands true for Mutual Exclusion？If process Pi is executing in its critical section, then no other processes can be executing in their critical sections 17.Which of the following condition stands true for Mutual Exclusion?Which of the following condition stands true for Mutual Exclusion? 18.Which one of the following is a synchronization tool?semaphore 19.Each process has a segment of code, called a ____, in which the process may be changing common variables, updating a table, writing a file, and so oncritical section 20.Kernel level threads are not needed in which of the following situationsTo make thread switching and scheduling fast and efficient week5 CPU Schedulingweek6 CPU Scheduling, Deadlocksweek8 考试week9 Memoryexercise9.2 Who founded the GNU project?Richard Stallman What programming language did Linus Torvalds use to write his Linux kernel?C In which year was the Turing Award (the highest distinction in the IT field) awarded to creators of UNIX and C?1983 Which key do you use to quit the program xmas in WebLinux? You have typed nano in WebLinux, and launched the nano text editor. Now, which of the following should be used to get help inside nano An operating system is the link between:programmer and hardware Why did Linus Torvalds create Linux?because he was frustrated with the proprietary licenses Which of these lines is the command prompt on WebLinux? Which operating system is not a UNIX derivative?Windows What is the pioneering project behind the UNIX operating systemMAC What happens if you run the htop command and then press the ctrl + c keys?this leaves htop and returns to the command prompt Which option of the du command is not available on WebLinux?(du is a command that means Disk Usage) Who are the creators of the UNIX operating system?Dennis Ritchie and Ken Thompson Who did the creators of UNIX work for?Bell Labs With whom did Dennis Ritchie write the book “The C Programming Language”?Brian Kernighan week10 Storage, IOweek11 Virtual Machines, Distributed Systemsweekk12 Protection, Securityweek13 Compilerweek14 考试大三上CSE203 决策计算与语言 10+10ass 80期末 全是小问答题 CSE205 网络 40ass 15考试 45期末 全是小问答题CSE207 软件工程 10+10ass 80期末选修 CSE209 计算机图形学 15+15courwork 70期末 CSE201 数据库设计（非关系数据库，解决数据库并发性）10+10ass 80期末 大三下CSE214 以人为中心的计算 交互界面 GUI 10+15+15report 60期末CSE204 复杂算法 5+5+10ass 80期末CSE210 java进阶 50ass 50期末CSE208 小组工程 100作业 网上资源了解操作系统和作用 作用：1、控制硬件 2、把调用硬件的办法封装成系统调用，供人通过应用程序间接的操作硬件 服务器操作系统：linux(安全稳定免费),windows server 移动设备操作系统：ios,安卓（linux衍生出来的） 虚拟机 是一个软件，可以用来安装一个新的操作系统，如果玩坏了，删掉重新装就好了，不会对现有系统造成任何影响和破坏。 内核如内存管理，多任务，IO的输入输出处理","categories":[{"name":"记忆性学习","slug":"记忆性学习","permalink":"https://lucifinil-x.github.io/categories/记忆性学习/"}],"tags":[]},{"title":"数据结构学习","slug":"数据结构学习","date":"2020-02-23T15:39:52.000Z","updated":"2020-06-19T09:09:50.918Z","comments":true,"path":"2020/02/23/数据结构学习/","link":"","permalink":"https://lucifinil-x.github.io/2020/02/23/数据结构学习/","excerpt":"CSE104 数据结构，介绍基本的数据结构和性质和用法。20% 不是考试，两个assignment写java代码，一定要尽可能的细致，对于每一个可能的样本输入情况都要考虑周全。80% 期末考试，四分之三25道选择题和一道数据结构的大题，大题每年相似度很高。背书课：lecture slides, Q&amp;As, in-class &amp; take-home exercises, assignments","text":"CSE104 数据结构，介绍基本的数据结构和性质和用法。20% 不是考试，两个assignment写java代码，一定要尽可能的细致，对于每一个可能的样本输入情况都要考虑周全。80% 期末考试，四分之三25道选择题和一道数据结构的大题，大题每年相似度很高。背书课：lecture slides, Q&amp;As, in-class &amp; take-home exercises, assignments 认识数据结构：用来组织和存储数据的集合分类 1.逻辑结构分类: 按照数据元素之间的关系分类 抽象 集合结构：元素之间没有关系 线性结构 ：元素之间一对一的关系，如链表 树形结构：一对多的关系， 图形结构：多对多的关系 2.物理结构分类： 逻辑结构真正在计算机上存储的方式 顺序结构： 连续的内存地址带着索引查找容易 用索引，插入删除难 链式结构： 内存单元可以是不连续的，数据单元之间用指针指向链接查找难 用遍历， 插入删除容易 链表队列队列实现先进先出，用单链表实现进队出队 by node的添加删除改变连接 优先队列(priority queue) 可以将优先级队列想象为已修改的队列，但是当一个人从队列中获取下一个元素时，将首先检索优先级最高的元素。 最小优先队列(min priority queue)中,查找操作用来搜索优先权最小的元素,删除操作用来删除该元素;对于最大优先队列(max priority queue),查找操作用来搜索优先权最大的元素,删除操作用来删除该元素.优先权队列中的元素可以有相同的优先权,查找与删除操作可根据任意优先权进行. 通常用堆实现 优先队列插入和删除元素的复杂度都是O(log2n)，所以很快 异常图论树树的定义 树是n个有限结点组成的一个具有层次关系的集合 术语：1.结点的度：结点下面一排上有几个子节点2.叶/终端结点： 无子节点的节点3.节点的层次：节点在第几排4.树的度：树的度=节点的度的最大值（子节点最多的节点的度）5.森林：去掉根节点6.子节点：A的直接前驱是B，A是B的子节点7.父节点：A的直接前驱是B，B是A的父/双亲节点8.双亲节点：两个节点的父节点相同 二叉树 二叉树中每个节点最多两个子节点；两个分叉 满二叉树： 每一层的节点数达到最大值（每个节点都有两个子节点） 完全二叉树： 每一层结点放满再放下一层；也就是说叶节点只会出现在最后一层或次下层。 用链表实现 二叉查找树 结点Node类 1234567891011121314151617public class Node&lt;Key,Value&gt; &#123; //存储键 public Key key; //用键找值 private Value value; public Node left; public Node right; public Node(Key key, Value value, Node left, Node right) &#123; this.key = key; this.value = value; this.left = left; this.right = right; &#125;&#125; 二叉树类：添加结点；以键查找结点；以键删除结点；查找二叉树中最小键；查找二叉树中最大键 [特点] 1.所有的方法都有同名重载方法：前面的是传入根节点的入口函数，后面是传入子节点的会使用递归的函数。 子树=结点下面所有结点123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166public class BinaryTree&lt;Key extends Comparable&lt;Key&gt;, Value &gt; &#123; //以后要用键来排序 //记录根节点 private Node root; //记录树中元素个数 private int N; //内部类 private class Node&#123; private Key key; private Value value; private Node left; //左节点 private Node right;//右节点 public Node(Key key, Value value, Node left, Node right) &#123; this.key = key; this.value = value; this.left = left; this.right = right; &#125; &#125; // 获取树中元素的个数 public int size()&#123; return N; &#125; //向树中添加元素键值对,第一次添加根节点 public void put(Key key, Value value)&#123; root = put(root, key, value); //添加根节点，返回赋值给树 根节点;此时x=null &#125; //向指定的子树x添加键值对，并且返回添加元素后的新树 public Node put(Node x,Key key, Value value)&#123; //1.如果x结点的子树为空,把添加的键值对作为x节点的子节点 if(x == null)&#123; N++; //节点个数+1 return new Node(key, value, null , null); //无左右子节点 &#125; //2.如果x节点的子树不为空 //2.1比较x结点的键和添加的key大小 //2.1.1如果key &lt; x结点的键，则继续找x结点的左子树 //2.1.2如果key &gt; x结点的键，则继续找x结点的右子树 //2.1.3如果key = x节点的键，则用添加的value替换x节点的原值. int cmp = key.compareTo(x.key); if(cmp&lt;0)&#123; //2.1.1 //这里是从x的左子节点下面插入键值对；完毕后将新的子树返回给x的左子节点 x.left = put(x.left, key, value); //递归调用只想它干了什么;这里会一直向下找直到找到子树为null时，创建新节点 &#125;else if(cmp&gt;0)&#123; //2.1.2 //这里是从x的右子节点下面插入键值对；完毕后将新的子树返回给x的右子节点 x.right = put(x.right, key, value); &#125;else&#123; //2.1.3 x.value = value; &#125; return x; //返回更新后的节点x信息 &#125; //用键找值 public Value get(Key key)&#123; return get(root, key);// 从根节点开始找 &#125; //从指定子树x中，用键找值 public Value get(Node x, Key key)&#123; //1.x树为null,没有找到 返回null就行 if(x == null)&#123; return null; &#125; //2.x不为null ,就要进行x树下面的键比较 （和上面添加方法的代码结构一样） int cmp = key.compareTo(x.key); if(cmp&lt;0)&#123; //2.1.1 键小与节点找左子树 return get(x.left, key); //这里是不仅要找，然后找了之后要返回找到的子树结点 &#125;else if(cmp&gt;0)&#123; //2.1.2 键大找右子树 return get(x.right, key); &#125;else&#123; //2.1.3 相等就找到了，返回键对应的值 return(x.value); &#125; &#125; //删除键值对结点。这是一个比较麻烦的操作，删除一个之后，要找一个结点来替换删除的节点 //因为左子树都小于右子树，新节点需要比左子树大，比右子树小。所以在右子树中找最左的节点（右子树中最小的节点） public void delete(Key key)&#123; delete(root, key); //入口，先从根节点开始判断删不删 &#125; //删除指定节点树x的键值对，返回新子树 public Node delete(Node x, Key key)&#123; //1.x树为null 安全检查 if(x ==null)&#123; return null; &#125; //2.x树不为null,就要进行x树下面的键比较 （和上面添加方法的代码结构一样） int cmp = key.compareTo(x.key); if(cmp&lt;0)&#123; //2.1键小找左子树,只是找相同的键 没有删 x.left = delete(x.left, key); //一直沿着左向下找 &#125;else if(cmp&gt;0)&#123; //2.2键大找右子树 x.right = delete(x.right, key); //一直沿着右向下找 &#125;else&#123; //2.3如果key = x结点的键，做真正的删除动作，删除x结点 N --; //元素个数-1,只要到了这一步先减个数 //我们要用右子树的最小结点替换x //1.如果x结点没有右子树,只需要让x的左子树成为x，这样是顺次，因为上一排的一定比下一排的键大 if(x.right == null)&#123; return x.left; &#125; //2.如果x结点没有左子树,只需要让x的右子树成为x ,这样是顺次，因为上一排的一定比下一排的键大 if(x.left == null)&#123; return x.right; &#125; //3.左右子树都不为空，找右子树的最小结点：找x右子树 左子树 左子树。。。一直到左子树的最后一个 Node minNode = x.right; //找到x右子树 while(minNode.left != null)&#123; //如果还有左子树的话，就还没有到左边的最后一个 minNode = minNode.left; // 找左子树 &#125; //删除最小结点：x右子树的左子树最后一个 Node n = x.right; while(n.left != null)&#123; if(n.left.left == null)&#123; //这时候n结点是左边倒数第二个结点，那么n.left就是最后一个结点，删除它 n.left = null; &#125;else&#123;//n结点没有到左边倒数第二个结点时，让n向下走一位 n = n.left; &#125; &#125; // 用最小结点minNode替换x: minNode连接左右结点和父结点 minNode.left = x.left; minNode.right = x.right; x = minNode; //绑定父结点，因为是递归调用。我也不懂记住就完了 //2.3else&#123;&#125;结束 &#125; return x; &#125; //查找整个树中最小的键 public Key min()&#123; return min(root).key; &#125; //找指定子树x中最小键所在的节点 = x子树的最左的那个节点 private Node min(Node x)&#123; if(x.left != null)&#123; return min(x.left); //返回更新x结点 &#125;else&#123; return x; &#125; &#125; //查找整个树中最大的键 public Key max()&#123; return max(root).key; &#125; //查找指定子树x中最大键的结点:最右边 private Node max(Node x)&#123; if(x.right != null)&#123; return max(x.right); &#125;else&#123; return x; &#125; &#125; &#125; 二叉树的基础遍历 - 深度优先 前中后顺序是指根节点放进队列的顺序 深度遍历的全用递归 算法特点在https://lucifinil-x.github.io/2020/02/24/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/#more 前序遍历 步奏： 1.把当前节点key放进队列 2.找到当前节点的左子树，不为空，递归遍历左子树 3.找到当前节点的左子树，不为空，递归遍历右子树 顺序特点：一层一层的来。先加根节点，再加下一层左根节点，再加下一层右根节点。遍历以上步奏 在BinaryTree类中添加代码 123456789101112131415161718192021222324252627282930//前序遍历：获取整个树中的所有的键,存在队列keys中 Ergodic：遍历 public Queue&lt;Key&gt; preErgodic()&#123; Queue&lt;Key&gt; keys = new Queue&lt;&gt;(); preErgodic(root, keys); return keys; &#125; //获取指定树x的所有键，并放到keys队列中。 //前序遍历就是先从左树开始向下，先把左子树的键放在队列再把右子树的键放在队列。 //因为是递归完成，所以只需要考虑一个二叉树的小分支 public void preErgodic(Node x, Queue&lt;Key&gt; keys)&#123; //x可能为null，代表的子树为空，直接返回 if(x == null)&#123; return; &#125; //把x结点的键放入队列keys keys.enqueue(x.key); //递归遍历x的左子树 //递归之前先判断有没有左子树 if(x.left !=null)&#123; preErgodic(x.left, keys); &#125; //递归遍历x的右子树 //递归之前先判断有没有右子树 if(x.right !=null)&#123; preErgodic(x.right, keys); &#125; &#125; 中序遍历 - 比较重要 步奏： 1.找到当前节点的左子树，如果不为空，递归遍历左子树 2.把当前节点key放进队列中 3.找到当前节点的右子树，如果不为空，递归遍历左子树 顺序特点： 键从小到大排列。 先加最下面最左边（最小键），再右边最小键，再加节点。 1234567891011121314151617181920212223242526272829//中序遍历 public Queue&lt;Key&gt; midErgodic()&#123; Queue&lt;Key&gt; keys = new Queue&lt;&gt;(); midErgodic(root, keys); return keys; &#125; public void midErgodic(Node x, Queue&lt;Key&gt; keys)&#123; //x可能为null，代表的子树为空，直接返回 if(x == null)&#123; return; &#125; //递归遍历x的左子树 //递归之前先判断有没有左子树 if(x.left !=null)&#123; midErgodic(x.left, keys); &#125; //把x结点的键放入队列keys keys.enqueue(x.key); //递归遍历x的右子树 //递归之前先判断有没有右子树 if(x.right !=null)&#123; midErgodic(x.right, keys); &#125; &#125; 后序遍历 步奏： 1.找到当前节点的左子树，如果不为空，递归遍历左子树 2.找到当前节点的右子树，如果不为空，递归遍历左子树 3.把当前节点key放进队列中 1234567891011121314151617181920212223242526272829//后序遍历 public Queue&lt;Key&gt; afterErgodic()&#123; Queue&lt;Key&gt; keys = new Queue&lt;&gt;(); afterErgodic(root, keys); return keys; &#125; public void afterErgodic(Node x, Queue&lt;Key&gt; keys)&#123; //x可能为null，代表的子树为空，直接返回 if(x == null)&#123; return; &#125; //递归遍历x的左子树 //递归之前先判断有没有左子树 if(x.left !=null)&#123; afterErgodic(x.left, keys); &#125; //递归遍历x的右子树 //递归之前先判断有没有右子树 if(x.right !=null)&#123; afterErgodic(x.right, keys); &#125; //把x结点的键放入队列keys keys.enqueue(x.key); &#125; 二叉树的高级遍历 - 层序遍历 - 广度优先 步奏：1.定义两个队列，分别存储树中的键和树中的结点2.结点队列加入根节点3.while循环（当结点队列不为空）： 从结点队列中取出一个结点，将这个结点的key加入键队列； 如果当前结点的左子结点不为空，把左子结点放进结点队列；如果当前结点的右子结点不为空，把右子结点放进结点队列 顺序特点：每一层从左到右 1234567891011121314151617181920212223//层序遍历，所有键 public Queue&lt;Key&gt; layerErgodic() throws InterruptedException&#123; //定义两个队列，分别存储树中的键和树中的结点 Queue&lt;Key&gt; keys = new Queue&lt;&gt;(); Queue&lt;Node&gt; nodes = new Queue&lt;&gt;(); //先放根节点 nodes.enqueue(root); //循环，结束条件为队列中没有元素 while(! nodes.isEmpty())&#123; //从队列中取出一个结点 Node n = nodes.dequeue(); keys.enqueue(n.key); //有无左子 if(n.left != null)&#123; nodes.enqueue(n.left); &#125; //有无右子 if(n.right != null)&#123; nodes.enqueue(n.right); &#125; &#125; return keys; &#125; 二叉树的最大深度问题 - 树有几层 深度遍历,关于递归调用中 变量的初始化在递归调用之前，每次都是递归调用时候停顿，所以每次返回值是递归调用下面的ruturn值，所以不会再执行初始化的赋值。1234567891011121314151617181920212223242526//获取整个树的最大深度 - 几层 public int maxDepth()&#123; return maxDepth(root); &#125; public int maxDepth(Node x)&#123; //安全 if(x == null)&#123; return 0; &#125; int max = 0; int maxLeft = 0; int maxRight = 0; //计算x结点左子树最大深度 if(x.left != null)&#123; maxLeft = maxDepth(x.left); &#125; //计算x结点左子树最大深度 if(x.right != null)&#123; maxRight = maxDepth(x.right); &#125; //取上面两个中大的值+1 max = maxLeft&gt;maxRight ? maxLeft+1 : maxRight+1; return max; &#125; 排序算法的消费贪婪算法的lecturesL1 abstraction Huffman编码https://blog.csdn.net/qinglongzhan/article/details/80983492 encapsulation 空间效率 时间效率 静态数据结构：创建的时候就固定了大小/内存空间，如:数组不会内存分配溢出，不能添加空间。必须保证有足够大的容量，可能装不下，可能浪费空间时间效率好 动态数据结构：在运行中可以删减大小/内存空间，如:集合、链表不需要知道具体大小，合理运用内存空间，添加内存会浪费时间空间效率好 L2 使用java 集合库 线性collection 层次collection 有哪些 有哪些库： util(集合的，数组的) io swing/awt Collection子类接口：List 有序集合 子类：ArrayList LinkedList vectorSet 无序无重复集合 子类： HashSet TreeSetQueue 有序集合 队列尾添加，队列头出Map 键值对 子类： HashMap TreeMap 接口特征，怎么样使用接口 parameterised typr泛型 ArrayList 的方法： 增删改查和属性 都是在本子上有的 L3 使用集合Collection 和list 和 迭代器 和泛型L4 Bag? Set Stack MapL5 使用Map, 队列和优先队列","categories":[{"name":"记忆性学习","slug":"记忆性学习","permalink":"https://lucifinil-x.github.io/categories/记忆性学习/"}],"tags":[]},{"title":"算法学习","slug":"算法学习","date":"2020-02-23T15:22:57.000Z","updated":"2021-03-12T03:05:58.790Z","comments":true,"path":"2020/02/23/算法学习/","link":"","permalink":"https://lucifinil-x.github.io/2020/02/23/算法学习/","excerpt":"CSE102 算法基础，介绍基础排序算法、查询算法、图论、p与np问题、算法思想（分治、动规、贪心）。期末全选择","text":"CSE102 算法基础，介绍基础排序算法、查询算法、图论、p与np问题、算法思想（分治、动规、贪心）。期末全选择 lecturesweek1 算法分析，数学归纳法 什么是算法algorithem: 根据一定的条件，对数据进行计算，得到需要的结果；程序=input+algorithem+output 算法分析：对于一个算法，我们首要关注的是它的时间复杂度，其次是空间复杂度，以及输出是否为最优或是否接近最优。 二分查找的步奏 算法分析：1、正确性 2、时间复杂度 3、空间复杂度（需要的内存空间） 4、算法优化 数学归纳法Induction: 他是一个分析技术,只能用于自然数。步奏： 1、Base case: 证k=0时，it is true. 2、Induction step: 设it is true for k=n. 3. 证it is true for k=n+1. week2 伪代码写法 程序=数据结构+算法 计算x的n次方：算法：1、set变量p=1 2、执行n次p=p * x 3、输出结果p伪代码： p=1; for i=1 to n do p=p* x; output p 伪代码写法：1、if else: 12345if ... then abs=aelse abs=-aoutput abs 2、 for loop: 1234567input nsum=0for i=1 to n dobegin sum=sum+iendoutput sum 3、 while loop: 123456789input nsum=0i=1while i&lt;=n dobegin sum=sum+i i=i+1endoutput sum 4、repeat until（do while） 123456sum=0repeat ask for a number sum=sum+numberuntil (user wants to stop)output sum 伪代码练习，一题三解 n个数中找最小数：比较次数 n-1. (三个人握手两次) week3思想Divide and Conquer 分治思想把难以解决的大问题分解成几个子问题，找到求出这几个子问题的解法后，再找到合适的方法，把它们组合成求整个问题的解法。 分治能解决的问题的特征： 问题规模小到一定程度就能容易解决。 问题可以分解为若干个规模较小的相同问题。 子问题的解可以合并到该问题的解。 子问题相互独立。【注】满足1.2.条，不满足3.可以考虑贪心算法或动态规划。 不满足4.用动态规划。 分治法基本步奏： 12345678divide and conquer(p) 递归问题p&#123; if(|p|&lt;= n0) adhoc(p); //问题的规模小到一定程度，直接求解。 divide p into smaller subinstances p1,p2..pk; //分解问题 for(i=1; i&lt;=k;i++) //循环遍历每个子问题，递归调用解决子问题 &#123;yi = divide and conquer(pi);&#125; return merge(y1,y2..yk); //把子问题的解合并为原问题的解&#125; 时间复杂度通用公式：T(n) = 2T(n/2) + 常数n2T(n/2)是分， 常数n是合并算出来是： T(n) = O(nlogn) 动态规划 DP问题 dynamic programming the idea of dynamic programming The basic idea of dynamic programming is to use a table to store the solutions of solved subproblems*. If you face a subproblem again, you just need to take the solution in the table without having to solve it again. Therefore, the algorithms designed by dynamic programming are very effective.*动态规划的基本思想是用一个表来存储求解子问题的解。如果您再次面临子问题，您只需将解决方案放入表中，而不必再次解决它。因此，用动态规划方法设计的算法是非常有效的。(不会像递归重复计算，速度很快) 用最少的硬币拼出27块钱问题 组成部分/步奏 1.最后一步(最优策略中使用的最后一枚银币是ak) 2.化成子问题(最少的硬币拼出更小的面值27-ak) 转移方程-重点 f[x]=min{f[x-1]+1,f[x-5]+1,f[x-7]+1} 初始条件和边界情况 f[0]=0,如果不能拼出Y，f[Y]=正无穷 计算顺序f[0],f[1],f[2]…f[27] 12345678910111213141516171819202122232425//返回几个硬币public int coinChange(int [] A, int M)//A=&#123;2,5,7&#125; //M=27&#123; int [] f = new int [M+1]; //要用到f[0]到f[27] 所以开一个[M+1]的数组 int n = A.length;//number of kind of coins f[0]=0;//initialization int i,j; for(i=1;i&lt;=M;i++)&#123;//1到27 f[0],f[1],f[2]...f[27] f[i] = Integer.MAX_VALUE;//先赋值无穷大，有情况比他好就更改 //last coin A[j] ,f[x]=min&#123;f[x-1]+1,f[x-5]+1,f[x-7]+1&#125; for(j=0;j&lt;n;j++)&#123; if(i&gt;=A[i] &amp;&amp; f[i-A[j]] != Integer.MAX_VALUE)&#123; //这个条件很重要，i大于硬币面额时才有可能拼的出来 f[i] = Math.min( f[i-A[j]] +1 , f[i]) &#125; &#125; &#125; if(f[M] == Integer.MAX_VALUE)&#123; f[M]=-1; &#125; return f[M];&#125; LCS 最长相同子串动态规划给出了递归计算公式，矩阵表格方便记录计算过程和结果。若左边和上面的字符相同，此格子数字=左上角斜着格子+1；不同，此格子数字=max(左边格子，上面格子) Alignment PSA算法 求the optimal global alignment of 两个字符串F(i,j)= max{c1,c2,c3} 算下面三个c,取最大值 C1=F(i-1,j-1) + s(xi, yj )=左上角斜着格子 + s给出矩阵字符对应数 C2=F(i,j-1)+d = 上面格子 + penalty值（会给出） C3=F(i-1,j) +d = 左边格子 + penalty值（会给出） Complexity 复杂度 分析算法的时间复杂度分析 关心核心计算操作次数和输入规模n的关系： 函数函数图像比较结论：1.随着输入规模n的增大，和n的最高次项相乘的常数可以忽略2.n的次方多，随着n变大，结果增长会特别快3.增长函数： n^3 &gt; n^2 &gt; ln(n) &gt; log(n) 这个底数多少趋势都差不多&gt; 1 n的最高次幂越小，算法效率越高 算法的空间复杂度分析 基本数据类型内存占用 (字节byte)byte 1 ,short 2, int 4, long 8, float 4, double 8, boolean 1, char 2 计算机访问内存方式都是一次一个字节 java的对象占用内存：1.一个引用变量占8byte Date date = new Date();中的date2.创建的一个对象占用的内存= 对象内部信息内存 + 对象本身头信息16byte3.如果对象一共占的内存不是8的倍数，那么会自动扩充到8的倍数4.数组对象占用 = 16头信息 + 4长度 + 4 * n个填充 一般java都是做服务器的，内存挺大，这些小的都不需要估算。一般对于算法都是分析时间复杂度 时间复杂度 P/NP/NPC 复杂度分为两个级别：他们后者的复杂度无论如何都远远大于前者 1.多项式级的复杂度 P: 它的规模n出现在底数的位置，如O(1),O(log(n)),O(n^a)等。 ​ 2.非多项式级的复杂度 NP： 它的规模n是指数级别，如O(a^n)和O(n!)型复杂度，它是非多项式级的，其复杂度计算机往往不能承受。 P问题一个问题可以找到一个能在多项式的时间里解决它的算法 NP问题NP问题是指可以在多项式的时间里验证一个解(不要求找出解)。NP问题的另一个定义是，可以在多项式的时间里猜出一个解的问题。但是NP问题在多项式时间内找不到解。比如只要我RP好，猜得准，我一定能在多项式的时间里解决这个问题。我猜到的方案总是最优的，不满足题意的方案也不会来骗我去选它。这就是NP问题。当然有不是NP问题的问题，即你猜到了解但是没用，因为你不能在多项式的时间里去验证它。 Hamilton回路问题根本不可能找到一个正确的算法来解决。这称之为“不可解问题”(Undecidable Decision Problem)。 P≠NP，因为NPC（NP-完全问题）问题的存在 约化 Reducibility ：A问题 约化 B问题 = 解决A的算法虽然简单、复杂度低但解决范围小，解决B的算法虽然难、复杂度高但解决范围广 = B的算法能够代替A的算法 来解决问题 = 可以用问题B的解法解决问题A 约化具有一项重要的性质：约化具有传递性。如果问题A可约化为问题B，问题B可约化为问题C，则问题A一定可约化为问题C。 NPC问题NPC问题满足条件：1.它得是一个NP问题 2.所有的NP问题都可以约化到它 既然所有的NP问题都能约化成NPC问题，那么只要任意一个NPC问题找到了一个多项式的算法，那么所有的NP问题都能用这个算法解决了，NP也就等于P 了。因此，给NPC找一个多项式算法太不可思议了。因此，前文才说，“正是NPC问题的存在，使人们相信P≠NP”。我们可以就此直观地理解，NPC问题目前没有多项式的有效算法，只能用指数级甚至阶乘级复杂度的搜索。 NP-Hard问题满足条件：所有的NP问题都可以约化到它，但不一定是个NP问题。 NP-Hard问题同样难以找到多项式的算法。即使NPC问题发现了多项式级的算法，NP-Hard问题有可能仍然无法得到多项式级的算法。 Efficiency追求两个目的：1、花最少的时间完成需求 2、占用最少的内存空间完成需求 Big-O 大O标记法–算法时间复杂度表示方法 时间空间通用 执行次数–大O表示3次– O(1)n+3次–O(n)2n^2+2次–O(n^2) 最高次项相乘的常数可以忽略2n^2+2n+2次–O(n^2) 常见的大O次数 从低到高 常数阶：O(1) 对数阶：O(logn)比如 2^x =100, x=log100 底数忽略 单次循环体 线性阶：O(n) 循环套循环 平方阶：O（n^2） 循环套循环套循环 立方阶：O(n^3) 指数方：O(2^n) 阶乘：O(n!) f(n) is O(g(n))• The statement “f(n) is O(g(n))” means that the growth rate of f(n) is no more than the growth rate of g(n). f(n)和g(n)都是时间复杂度函数，说f(n) is O(g(n))，则f(n)复杂度属于O(g(n)). 那么，g(n)增长更快。 说g(n) is O(f(n))，则g(n)复杂度属于O(f(n)). 那么，f(n)增长更快。 求f(n) is O(多少g(n)) 13 𝑛^3+ 7n log n + 3 is O(_ 𝑛^3_).Proof: 13 𝑛^3+ 7n log n + 3 ≤ 16 𝑛^3, for n ≥1这个16怎么得出：当n=1 : 13+ 7x0 + 3 = 16=16n^3.这个大O是16后面的n^3 3 log n + log log n is O(_log n ).Proof: 3 log n + log log n ≤ 4 log n, for n ≥ 2.这个大O是4后面的log n 270 is O(_ 1_).Proof: 270 ≤ 270 * 1, for n ≥1这个大O是270后面的1 分析算法的时间复杂度例子每一行写出当前行的时间复杂度，取最大的一行复杂度。lecture2例子:最大的是 1+2+3+…+n = (1+n)xn/2 = 1/2n^2 + 1/2n = O(n^2).这个大0是1/2后面的n^2. ？网上的 指worse-case下的时间复杂度。比如f(n)=13n^3+7nlogn的复杂度是O(n^3)，或者O(n^k)（k&gt;=3） Ω(n)和Θ(n)：前者是best-case下的时间复杂度。比如，f(n)=13n^3+7nlogn的复杂度是Ω(n^3)，或者Ω(n^2)，Ω(n)，Ω(1)等；后者是average-case下的时间复杂度，是O标记法与Ω标记法的结合：比如，f(n)=13n^3+7nlogn的复杂度是Θ(n^3)。 Sorting 排序实现comparable接口的对象 实际上比较常见的是对对象进行排序，比如对商品对象进行价格排序。那么在这些对象的类中就要提供自定义的排序规则，通过实现comparable接口，重写compareTo完成。我们排序的对象就是实现了Comparable接口的对象12345678910111213141516171819Studnet implements Comparable&lt;Student&gt;: public int compareTo(Student o) &#123; return this.getAge()-o.getAge(); &#125;Test:Comparable c =getmax(s1,s2); //c不是student对象，是comparable对象,不能用student的方法System.out.println(c); public static Comparable getmax(Comparable a,Comparable b)&#123; //这个是为了拿到对象 int result = a.compareTo(b); if(result&gt;0)&#123; return a; &#125; else &#123; return b; &#125; &#125; Selection/Bubble/insertion 选择排序/冒泡排序/插入排序这三个排序都很相似，时间复杂度都是 O(n^2); 适用于元素少的排序 Bubble冒泡排序API设计： 12345678910111213141516171819202122232425public class 冒泡排序 &#123; public static void sort(Comparable [] a)&#123; for(int i= a.length-1; i&gt;0; i--)&#123; for(int j=0; j&lt;i;j++)&#123; //每层递减 if(greater(a[j], a[j+1]))//如果前比后大就交换 &#123; exchange(a, j, j+1); &#125; &#125; &#125; &#125; private static boolean greater(Comparable a, Comparable b)&#123; return a.compareTo(b)&gt;0; &#125; private static void exchange(Comparable [] a, int i, int j)&#123; Comparable temp; temp = a[i]; a[i]= a[j]; a[j] = temp; &#125; &#125; 测试类： 12345public static void main(String[] args) &#123; Integer [] arr=&#123;4,5,6,3,2,1,2&#125;;//Integer这个包装类就有实现Comparable接口 冒泡排序.sort(arr);//要传实现了Comparable接口的对象 System.out.println(Arrays.toString(arr)); &#125; 算法分析：1.最坏情况为逆序：{6,5,4,3,2,1}2.核心代码为sort循环中的比较和交换3.比较次数为：n-1 + n-2 + …. + 1 = n^2/2 - n/2两两比较，次数逐层递减4.交换次数为：n-1 + n-2 + …. + 1 = n^2/2 - n/2最坏情况两两都要交换5.总执行次数=比较次数+交换次数 = n^2 - n6.时间复杂度：O(n^2); 所以冒泡排序适用于元素少的排序 Selection 选择排序 排序原理：遍历，选择最小元素防在第一位。遍历，选择次小元素放在第二位。。。。 过程:1.假设0索引的元素是min; 向后一位比较，小元素所在索引变成min; 遍历完之后拿到最小元素min所在的索引 2.将min索引的值与0索引的值交换3.第一次从索引0开始，第二次从索引1开始。。。。最后从倒数第二个索引开始。 Seclection API设计 1234567891011121314151617181920212223242526public class Seclection &#123; public static void sort(Comparable [] a)&#123; for(int i=0; i&lt;=a.length-2; i++)&#123; int minIndex=i; //这个变量记录最小元素所在的索引，先默认为第一位i for(int j= i+1; j&lt;a.length;j++)&#123; //j会与minIndex比较，j最后是最后一位元素的索引 if(greater(a[minIndex], a[j]))&#123; minIndex = j; &#125; &#125; //内层for循环完成后交换两值 exchange(a, i, minIndex);// i索引为每次的最小值位置 &#125; &#125; private static boolean greater(Comparable a, Comparable b)&#123; return a.compareTo(b)&gt;0; &#125; private static void exchange(Comparable [] a, int i, int j)&#123; Comparable temp; temp = a[i]; a[i]= a[j]; a[j] = temp; &#125; &#125; 测试类：同上 12345public static void main(String[] args) &#123; Integer [] arr =&#123;6,7,2,3,5,2,1,8,3,5&#125;; Seclection.sort(arr); System.out.println(Arrays.toString(arr)); &#125; 算法分析： 1.最坏情况为逆序：{6,5,4,3,2,1}2.核心代码为sort循环中的比较和交换3.比较次数为：n-1 + n-2 + …. + 1 = n^2/2 - n/2两两比较，次数逐层递减4.交换次数为：n-1 最后一次不需要交换，其他都交换一次，也是外层循环次数5.总执行次数=比较次数+交换次数 = n^2/2 - n/2 - 16.时间复杂度：O(n^2); 所以选择排序适用于元素少的排序 Insertion 插入排序 排序原理：从第二个数开始，比较第二和第一，将小的排在前面；从第三个数开始，比较第三和第二，需要交换的话还要再第二比较第一，不需要交换就继续比较第四和第三。。。 Insertion API设计 1234567891011121314151617181920212223242526public class Insertion &#123; public static void sort(Comparable [] a)&#123; for(int i=1; i&lt;a.length; i++)&#123; //从第二个数向前比较 for(int j=i; j&gt;0;j--)&#123; //一个一个向前面一个元素比较，如果前面的数大，就两两交换。比较到第一个数 if(greater(a[j-1], a[j]))&#123; exchange(a, j-1,j); &#125; else&#123; break; //只会结束内层循环。如果这个数比上一个大时，它就比前面的都大，因为前面的数都是排序好的 &#125; &#125; &#125; &#125; private static boolean greater(Comparable a, Comparable b)&#123; return a.compareTo(b)&gt;0; &#125; private static void exchange(Comparable [] a, int i, int j)&#123; Comparable temp; temp = a[i]; a[i]= a[j]; a[j] = temp; &#125;&#125; 算法分析： 1.最坏情况为逆序：{6,5,4,3,2,1}2.核心代码为sort循环中的比较和交换3.比较次数为：n-1 + n-2 + …. + 1 = n^2/2 - n/2两两比较，次数逐层递减4.交换次数为：n-1 + n-2 + …. + 1 = n^2/2 - n/2 最坏情况每次都要交换5.总执行次数=比较次数+交换次数 = n^2 - n6.时间复杂度：O(n^2); 所以插入排序适用于元素少的排序 Merge-sort 归并排序 先分组再合并； 分组叫分，合并叫治 分治思想的典型应用先把数组对半拆分到最小，而后两两比较排序后合并，重复这一步骤直至整个数组排序完成 在每个递归步骤中，划分每个子列表最多需要O(n)时间；合并每个级别中的所有列表最多也需要O(n)时间；递归需要的次数最多为O(log n)次。因此，MergeSort的运行时间为O(n log n)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class Merge &#123; private static Comparable [] assist; private static boolean less(Comparable a, Comparable b)&#123; return a.compareTo(b)&lt;0; &#125; //对数组a中的元素进行排序,入口函数 public static void sort(Comparable [] a)&#123; //初始化辅助数组assist assist = new Comparable[a.length]; //定义一个hi变量，一个lo变量，分别记录数组中最小的索引和最大的索引 int lo=0; int hi=a.length-1; //调用下面的sort方法，从索引lo到索引hi的元素的排序 sort(a,lo,hi); &#125; private static void sort(Comparable [] a,int lo, int hi)&#123; //这个就是递归分到最小组1个的情况 //安全性检测 if(hi&lt;=lo)&#123; return; &#125; //对lo-hi索引之间的数组分成2个组 int mid = lo+(hi-lo)/2; //中位索引，5-9的中位是7 分成567；89 //分别对分好的每一组数据进行排序 sort(a,lo,mid); sort(a,mid+1,hi); //递归完毕，再吧排好的这2个组组合起来，归并 merge(a, lo, mid, hi); &#125; //归并两组数据并进行排序：通过指针遍历比较两组数据，将每次比较的小值填充进辅助数组 private static void merge(Comparable [] a, int lo, int mid,int hi)&#123; //定义三个指针 int i=lo; int p1=lo; //5 int p2=mid+1; //8 //遍历小数组，移动p1 p2指针，比较对应索引处的值，找出小的值，放到辅助数组的对应索引处 while(p1&lt;=mid &amp;&amp; p2&lt;=hi)&#123; //p1和p2都没越界的时候遍历，一个指针遍历完就停止 if(less(a[p1], a[p2]))&#123; assist[i++] = a[p1++]; //p1小，放完p1之后，向右移动p1指针 &#125;else&#123; assist[i++] = a[p2++]; //p2小，放完p2之后，向右移动p1指针 &#125; &#125; //如果p1没有走完，就顺序移动p1指针，把对应元素放到辅助数组对应的索引处 while(p1&lt;=mid)&#123; //如果走完的话p1就会大于mid assist[i++] = a[p1++]; &#125; //如果p2没有走完，就顺序移动p2指针，把对应元素放到辅助数组对应的索引处 while(p2&lt;=hi)&#123; assist[i++] = a[p2++]; &#125; //将辅助数组中填充的元素拷贝到原数组中 for(int index=lo; index&lt;=hi; index++)&#123; a[index]=assist[index]; &#125; &#125; &#125; 算法分析： 1.数组拆分 + 归并：比如8个元素的数组：2^3=8. 每次除以2，他就会拆3次，也就是log8次。拆出来一共三层。拆到第k层，就会有2^k个子数组，每个子数组的长度为2^(3-k)；拆2次，就要4个子数组，每个子数组长度是2。 子数组有多长，最多就需要比较多少次。 2^k层=n个数， k = log2(n)那么归并最多需要比较次数= 层数 * 每层比较次数= 层数 * 每层子数组长度 = 3* （2^3） 2.n个元素的数组的归并时间复杂度= log2(n) * [2^(log2 n)] = log2(n) * n= O(nlogn) —大O标记法：去掉底数 因为n&gt;logn所以归并排序比上面三种排序n^2要小。 作业里面的归并排序计算时间复杂度：T(n)= 2(2T(n/4)+n/2)+n= 4T(n/4)+2n= 23 T(n/23) + 3n= 2i T(n/2i) + i* n= 2log n T(n/2log n) + n log n= n T(1) + n log n= O (nlogn) 3.归并排序的缺点： 需要用到辅助数组，导致空间复杂度提升，是典型的以空间换时间的操作。 Count sorting 计数排序 理解步奏：遍历这串数字，出现的数字对应的数组角标（索引）处存的数字加一。遍历数组，角标对应存放的值是多少就输出角标几次。 代码步奏: 1.一串数字中max-min+1取得这串整数的范围k 2.遍历一串数字，遍历到的数字-min的值对应到数组count[k]的下标，其值加一。 3.遍历数组count[k]，输出每个的值，重复值数次。123456789101112131415161718192021222324252627282930313233public static int[] countSort(int[] array) &#123; //1.得到数列的最大值与最小值，并算出差值d int max = array[0]; int min = array[0]; for (int i = 1; i &lt; array.length; i++) &#123; if (array[i] &gt; max) &#123; max = array[i]; &#125; if(array[i] &lt; min) &#123; min = array[i]; &#125; &#125; //2.创建统计数组并计算统计对应元素个数 int d = max - min; int[] countArray = new int[d + 1]; for (int i = 0; i &lt; array.length; i++) &#123; countArray[array[i] - min]++; //厉害.. &#125; //3.统计数组变形，后面的个数元素等于前面的元素个数之和 int sum = 0; for (int i = 0; i &lt; countArray.length; i++) &#123; sum += countArray[i]; countArray[i] = sum; &#125; //4.倒序遍历原始数组，从统计数组找到正确位置，输出到结果数组 int[] sortedArray = new int[array.length]; for (int i = array.length - 1; i &gt; 0; i--) &#123; sortedArray[countArray[array[i] - min] - 1] = array[i]; countArray[array[i] - min]--; &#125; return sortedArray; &#125; https://www.cnblogs.com/kyoner/p/10604781.html 如果原始数列的规模是N，最大最小整数的差值是M，由于代码中第1、2、4步都涉及到遍历原始数列，运算量都是N，第3步遍历统计数列，运算量是M，所以总体运算量是3N+M，去掉系数，时间复杂度是O(N+M)。 至于空间复杂度，如果不考虑结果数组，只考虑统计数组的话，空间复杂度是O(M)。 -两大局限性：1.当数列最大最小值差距过大时，并不适用于计数排序比如给定20个随机整数，范围在0到1亿之间，此时如果使用计数排序的话，就需要创建长度为1亿的数组，不但严重浪费了空间，而且时间复杂度也随之升高。 2.当数列元素不是整数时，并不适用于计数排序正是由于这两大局限性，才使得计数排序不像快速排序、归并排序那样被人们广泛适用。 它的复杂度为Ο(n+k)（其中k是整数的范围），它适用于一定范围的整数排序。在取值范围不是很大的情况下，它的性能在某些情况甚至快于任何比较排序算法O(nlogn)，例如快速排序、归并排序。 QuickSort 快速排序分治思想的另一种应用 遍历整个数组，将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小。然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 快速排序过程：初数组默认找第一个元素作为分组的分界值；把比分界元素小的放分界元素左边；大的放右边。 左子祖和右子组进行以上的递归：分界分组，递归，直到一组只有两个及以下元素。将有序的子组按照分界元素为中心，组合成新的数组，递归。 如何切分分组：左指针在第二个元素索引，右指针在最后一个元素再后一位的索引。左向右走，找比第一个大的元素；右向左走，找比第一个小的元素。找到后，左右元素交换位置。直到左指针=右指针，这时候这个元素和第一个元素交换位置。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class Quick &#123; private static boolean less(Comparable a, Comparable b)&#123; return a.compareTo(b)&lt;0; &#125; private static void exchange(Comparable [] a, int i, int j)&#123; Comparable temp; temp = a[i]; a[i]= a[j]; a[j] = temp; &#125; public static void sort(Comparable [] a)&#123; //入口函数 int lo=0; int hi=a.length-1; sort(a,lo,hi); //第一次对a数组中所有元素进行排序 &#125; private static void sort(Comparable [] a,int lo, int hi)&#123; //安全性检测 if(hi&lt;=lo)&#123; return; &#125; //对数组中lo索引到hi索引处的元素进行分组（分成左子组和右子组） int partition = partition(a,lo,hi); //分组函数,返回分界值在新子数组中所在的索引 //让左子组有序 sort(a,lo,partition-1); //让右子组有序 sort(a,partition+1,hi); &#125; //分组函数,返回分界值在新子数组中所在的索引 private static int partition(Comparable [] a, int lo,int hi)&#123; Comparable key = a[lo];//key是第一个元素 //定义两个左右指针， int left =lo; int right = hi+1; //切分 while(true)&#123; //右指针左移，找到一个比分界值小的元素，停止 while(less(key, a[--right]))&#123; if(right == lo)&#123; break; &#125; &#125; //左指针右移，找到一个比分界值大的元素，停止 while(less(a[++left], key))&#123; if(left == hi)&#123; break; &#125; &#125; //判断 如果左指针大于右指针，证明元素扫描完毕，结束循环; 如果不是，则交换左右元素 if(left &gt;= right)&#123;//必须是大于等于，不然会指针越界 break; &#125;else&#123; exchange(a, left, right); &#125; &#125; //当左大于等于右时结束循环，交换分界值右和第一个值,因为右指针值代表小值，与第一个交换 exchange(a, lo, right); return right; &#125;&#125; 算法分析：快速排序不是等分，所以需要分为1.最优情况：O(nlogn)2.最坏情况：O(n^2)3.平均情况：O(nlogn) 以上各种排序的比较 稳定性比较：（没有截图了） 时间复杂度：Insertion sort, O(n^2)Selection sort, O(n^2)Bubble sort, O(n^2)Merge sort, O(nlog n) Count sorting，O(n+k) k为整数max-min QuickSort, O(nlogn) 评价情况 ricky总结 堆 优先队列（2,4）Tree 最少两个子代，最多四个子代 每个子代最多三个key 储存了n个item的(2,4) tree的高度是Θ(logn) Search、insertion和deletion的复杂度都是O(logn)，其中search是从上向下(top-down)，insertion和deletion是自底向上(bottom-up) Priority Queue 优先队列 和普通的队列相比，是最高级先出 通过堆实现优先级的筛选 Heap 堆 可以理解为用数组实现的二叉树 除了根节点，每个节点的key值都大于等于父代的key值 堆的插入：新节点首先加入到该二叉堆最后的一个节点，依据最小堆的定义，自底向上，递归调整。 堆的删除：二叉堆的删除一般只讨论如何删除堆顶元素。方法是最后一个节点替换到根节点，然后自顶向下，递归调整。 Heap-Sorting：堆排序算法对有着n个可比较项的序列S进行排序，所需时间为O(nlogn)。自底向上构建具有n个元素的堆需要O(nlogn)时间，并且从堆中提取n个元素（以递增顺序）需要O(nlogn)时间。 Experimental analysis：运行时间对输入大小的依赖性，需要对样本输入适当选择，并进行适当数量的测试。缺陷在于必须先实现算法、必须在有限的输入和同一硬件软件的条件下进行实验。 Theoretical analysis：相比上一种分析方法，可以考虑所有的输入；可以比较多个算法的效率（与硬件环境无关）；可以通过伪代码来研究算法。 伪代码： high-level description 更结构化的描述 自然语言与编程语言的混合 Computational Model 计算模型：通过计算primitive operations的数量来估计算法的复杂度。 primitive operations：比如赋值、比较大小、条件判断、返回值等。 SearchingBinary- searching 二分查找 1、定义min、max、mid角标； 2、比较mid和查找数据大小： 数据大，min=mid+1;数据小, max=mid-1; 3、循环； 4、循环中判断查找的数据是否存在(存在条件max min之间有距离：min &lt;= max) 或者判断存在条件作为while循环条件，会更加简洁1234567891011121314151617181920212223242526272829public static void main(String[] args) &#123; int arr[] =&#123;9,12,15,24,36,41,59,68&#125;;//没排序的先排序 rank(arr); int a =binarySearch(arr, 41); System.out.println(\"第\"+(a+1)+\"个是:\"+arr[a]); &#125; public static int binarySearch(int arr[], int key) &#123; int min, max, mid; min=0; max = arr.length -1; mid = (min + max)/2; while(arr[mid] != key) &#123; if(arr[mid]&lt; key) &#123; min = mid +1; mid = (min + max)/2; &#125; else if(arr[mid]&gt; key) &#123; max = mid -1; mid = (min + max)/2; &#125; //判断查找元素是否存在 if(max&lt;min) return -1; &#125; return mid; &#125; StringString searchingHorspool’s algorithm匹配串 text模式串 pattern在匹配串中找（能够完全匹配上的）模式串。 shift table： 根据模式串中字母出现位置来标每个字母对应的数字。例如：模式串 P[0..5] =BAOBAB，分成P[0..4]和 最右边的字母.BA0BA B ；P[0..4]中从右向左每个字母第一次出现的位置 和最右边的字母的距离; 没有在模式串中出现的字母，对应的数字是模式串的长度 6. A最先出现，A距离B是1；然后B出现，B距离B是2；然后O出现，O距离B是3. 匹配过程：1.第一种理解（不用shift table）：对于每个文本搜索窗口，将窗口内的最后一个字符（C）与模式串的最后一个字符(c)进行比较。如果相等，则继续从后向前验证其他字符，直到完全相等或者某个字符不匹配。然后，无论匹配与否，都将根据在模式串的下一个出现位置将窗口向右移动。匹配串中的字符模式串中没有的话就移动模式串的长度。 匹配串：abcbcsdxzcxx 模式串：cbcac对齐比较最右字符，再从右到左，b-a不匹配，移动模式串，让模式串中的b和上面的b对齐。若末尾匹配，验证左边一位是否匹配。。。 2.第二种理解（要用shift table）：不匹配的位置b-a时，按照shift table中b（匹配串中b）对应的数字，把模式串向右移动多少位。如果下图第二次移动之后末端对齐了且不匹配，说明匹配串中没有模式串，不需要再进行移动。 AGCCGTGC AGTAA ​ AGTAA searchingAlignment/LCS 校准最优对齐子串/最长相同子串 写在动态规划思想下面。 Graph/Combinatory图的术语 图的DFS,BFSDFS： 先扩展字母小的，一直扩展，每个结点只写一次，如果当前结点的扩展出来的结点已经写出来了，则不扩展当前结点。BFS： 一样的，每个结点不重复写construct tree: 按照原来的图来画DFS BFS的路径。 图的最小生成树图的生成树： 是一棵含有其所有顶点的无环联通子图。图的最小生成树： 这棵树的边的权重的和最小。 生成树的性质 一棵生成树中，连接任意两个顶点都会产生一个环。 从生成树中删除任意一条边，都会得到两颗独立的树。 切分定理 切分： 按照某些规则，把图的所有顶点分成两个 飞空且没有交集的集合。（两个独立的树） 横切边： 连接两个不同集合的边。 切分定理：连接两个独立树的横切边权重最小者必然属于图中的最小生成树。 贪心算法 –计算图的最小生成树算法 用贪心算法找最小生成树的过程：把所有顶点分成两个集合，找相连接两个集合的横切边中最小的； 再分成不同的集合再找最小横切边；直到选出来的最小横切边连接了所有顶点。 无序的切分找横切边，直到连接完。 prim算法 –贪心算法的一种特殊情况 用prim算法找最小生成树的过程：先任意拿一个顶点加入“已选集合” ，其他顶点组成另一个集合；选这两个集合的最小横切边；这个最小横切边连接的顶点放进“已选集合” ； 再继续重复选横切边、加入顶点。 有序的一个一个找顶点之间的横切边。 有可能横切边长度一样的时候，就会有不只一个最小生成树。 Kruskal算法 –贪心算法的一种特殊情况 用kruskal算法找最小生成树的过程：先把图中所有的边存储进最小优先队列，按照大小排序；选第一小的边，连接边的两个顶点；选第二小的边，连接边的两个顶点；直到连接完所有顶点。不能成环，有环就跳过，找下一条边。 最短路径算法们Dijkstra算法 求最短路径要求：边的权值均为非负 怎么做：和一致搜索算法一模一样 设计和时间复杂度：Dijkstra 算法采用贪心算法（Greedy Algorithm）范式进行设计，普通实现的时间复杂度为 O(V2)。 其中 V 为顶点数量，E 为边的数量。 Bellman-Ford算法 求有向图最短路径意思是求从a 到各个顶点的值，次次loop更新其他顶点的值，直到不变/如果有负环 会永远loop(路径经过负环会一直减小，更新) 更新每个顶点的值时，找这个点连接的上一条边 要求：对于带权有向图 G = (V, E)，Bellman-Ford算法能适应一般的情况（即存在负值边的情况). 设计和时间复杂度：Bellman-Ford 算法采用动态规划（Dynamic Programming）进行设计，实现的时间复杂度为 O(V * E)，其中 V 为顶点数量，E 为边的数量。 Floyd-Warshall算法 求有向图或负权的最短路径每次加入一个结点，更新每两点之间通路的最短路径 Backtracking 回溯Subset-Sum Problem子集元素和问题For example: S ={ 3, 5, 6, 7} d=15 What is the state-space?所有满足元素和为d的S的子集 解： 3–5–6=14 错 3–5–7=15 对 3–6–7=16 错 3–7=10 错 5–6–7=18 错 全部列举 Assignment Problem工作分配问题每个人一个job，job列对应的人不能重复 Job 1 Job 2 Job 3 Job 4 Person a 9 2 7 8 Person b 6 4 3 7 Person c 5 8 1 8 Person d 7 6 9 4Lower bound：每行找最小值之和/每列找最小值之和解：用Lower bound的思想，一个人一个人的讨论情况走通路。先讨论 a=9时bcd用Lower bound，bcd就依次选择剩下job中值最小的；a=2时bcd用Lower bound；… 选择上面四个abcd通路最小的继续讨论b=6/4/3/7.直到讨论到d. 对应练习题： TSP问题 用Lower boundlow bound=(每个点出发，选最短的两条边之和)/2low bound要求如果答案有小数向上取整 解：和Assignment Problem工作分配问题一样，用Lower bound的思想，a点出发，固定a-b边(在a、b点选择两条边的时候其中一条一定要是a-b的边，然后在选择剩下较小的边)，找剩下顶点b c d e中较小的两条边; a-c边通路; a-d边通路。对于第一步a-b：固定a-b-c/a-b-d/a-b-e.永远先扩展lb小的 对应练习题：102ttl week11 Q4 二次绕树twice-around-the-tree从A点出发，找最短路径到下一个点，再到下一个点，如果在找下一个点的路径时发现这个路径比上一个点到自己的路径都要长就原路返回A点，选择第二段的路径开始，经过剩下没有经过的点。经过完了直接返回A点。 然后删掉路径中重复的点，计算新路径的长度 Euclidean graph欧几里得图（真实存在的图）两边之和大于第三边 图的应用：拓扑排序 将非顺序的线性结构形成有顺序的结构。 用AOV网可以解决如下问题： 判定工程的可行性，有回路的话 整个工程就无法结束。 确定各项活动在整个工程执行中的先后顺序，先后顺序成为拓扑有序序列。 算法手写怎么分析 涉及递归的算法，手写出树的图，这样清晰明了，返回到哪一步都能看得清楚。 大三下-INT202算法实例斐波那契递归实现java: 1234567891011121314151617/** * 返回斐波那契数第n个值,n从0开始 * 实现方式，基于递归实现 * @author zxy * @since 2018年8月18日上午9:41:30 */ public static int getFib(int n)&#123; if(n &lt; 0)&#123; return -1; &#125;else if(n == 0)&#123; return 0; &#125;else if(n == 1 || n ==2)&#123; return 1; &#125;else&#123; return getFib(n - 1) + getFib(n - 2); &#125; &#125; 伪代码： 123456int fib(int n)&#123; if n&lt;=2 return n; else return fib(n-1) + fib(n-2);&#125; 递归是最简单的实现方式，但递归有很多的问题，在n的值非常大时，会占用很多的内存空间递归的主要缺点 会有很多的重复计算,占用大量的内存空间可能造成栈溢出既然该数列定义F（n）=F(n-1)+F(n-2)（n≥2，n∈N * ），那么我们可以从头到尾进行计算，先计算前面的值，然后逐步算出第n个值。 斐波那契数组实现基于数组的实现以空间换时间 1234567891011121314151617181920212223/** * 返回斐波那契数第n个值,n从0开始 * 实现方式，基于数组实现 * @author zxy * @since 2018年8月18日上午9:41:30 */public static int getFib3(int n)&#123; if(n &lt; 0)&#123; return -1; &#125;else if(n == 0)&#123; return 0; &#125;else if (n == 1 || n == 2)&#123; return 1; &#125;else&#123; int[] fibAry = new int[n + 1]; fibAry[0] = 0; fibAry[1] = fibAry[2] = 1; for(int i = 3; i &lt;= n; i++)&#123; fibAry[i] = fibAry[i - 1] + fibAry[i - 2]; &#125; return fibAry[n]; &#125;&#125;","categories":[{"name":"记忆性学习","slug":"记忆性学习","permalink":"https://lucifinil-x.github.io/categories/记忆性学习/"}],"tags":[]},{"title":"常见问题&解决办法&小技巧","slug":"常见问题-解决办法-小技巧","date":"2020-02-20T19:05:22.000Z","updated":"2020-11-15T08:24:48.086Z","comments":true,"path":"2020/02/21/常见问题-解决办法-小技巧/","link":"","permalink":"https://lucifinil-x.github.io/2020/02/21/常见问题-解决办法-小技巧/","excerpt":"杀端口占用 输入win+R快捷键，输入cmd，打开命令行窗口 netstat -ano|findstr 9000 taskkill /f /t /im 监听号","text":"杀端口占用 输入win+R快捷键，输入cmd，打开命令行窗口 netstat -ano|findstr 9000 taskkill /f /t /im 监听号 sublime text3快捷键ctrl+f 查找ctrl+h 替换 eclipse使用 eclipse里创建的html文件编辑内容要右键openwith。 重启springboot项目前要在控制台那里点红色方框关闭上一次的启动，不然就会出现端口占用，启动失败。 窗口文件右键close可以全部关掉 双击窗口栏的文件会全屏显示，再双击就还原。 鼠标放在函数名上面就有解释。 Formatter代码格式设置：windows-preferences-找对应的语言 springboot项目运行控制台不显示/打开控制台：windows-showview-console 快捷键：alt shift s 添加getter setter toStringctrl shift o 添加删除包Ctrl+Shift+f 自动对齐(快捷键没有用)，必须选中-Source-Format，vue项目里没有alt / 补全代码main + alt / 主函数ctrl shift c 多行全部备注ctrl 鼠标移到包/类上就有下划线的链接可以跳转 vs使用 快捷键：ctrl+shift+/ 注释 cmd命令行 比如要查看node.js版本：node -v命令需要在node.js的安装文件夹下执行。安装什么的也是在文件夹路径下执安装命令。 先d: 在cd D:\\nodejs14.4(复制过去) 打开vueui界面 在vue项目文件夹中shift+邮件+打开powershell ；之后不能关闭powershell 输入vue ui 打开powershell中给的localhost网址 点击左侧任务栏，点击serve,点击运行，查看输出，输出里有此文件夹vue项目的跳转链接. github仓库托管代码 教程https://blog.csdn.net/hc_ttxs/article/details/79375788 ssh密匙之前blog的时候就有了，不用再添加。在本地文件夹git-repo为本地仓库，将代码添加进这个文件夹，右键git bush here,按照git命令提交。 我用的是http: https://github.com/Lucifinil-x/community-sringboot.git 提交本地代码命令 数据库，mysql,sqlyog 在表中更改了数据要右键更改保存。 创建表之后F5刷新当前数据库 不认识的单词 Toggle navigation：切换导航Toggle navigation 替换成名字 路西斐尔的尼伯龙根 placeholder：占位符搜索框里的灰体字","categories":[{"name":"应用使用要点","slug":"应用使用要点","permalink":"https://lucifinil-x.github.io/categories/应用使用要点/"}],"tags":[{"name":"bug","slug":"bug","permalink":"https://lucifinil-x.github.io/tags/bug/"},{"name":"解决办法","slug":"解决办法","permalink":"https://lucifinil-x.github.io/tags/解决办法/"}]},{"title":"springboot学习/项目","slug":"springboot学习","date":"2020-02-19T09:04:25.000Z","updated":"2020-11-06T15:38:40.358Z","comments":true,"path":"2020/02/19/springboot学习/","link":"","permalink":"https://lucifinil-x.github.io/2020/02/19/springboot学习/","excerpt":"注解@XXX的理解 spring引入注解，让注解与java bean紧密结合，减少了配置文件（.xml文件）的体积，增加了java bean的可读性和内聚性。","text":"注解@XXX的理解 spring引入注解，让注解与java bean紧密结合，减少了配置文件（.xml文件）的体积，增加了java bean的可读性和内聚性。 @Autowired注解：自动找和注入组件类、接口实现类，接着就能用他们了 1.自动注入java类，@Autowired注解回去寻找一个java bean组件（@Bean是给spring容器中添加组件，函数返回值添加进容器中） @Autowired private UserRepository userRepository; 如果bean定义给去掉了，spring容器找不到就会抛出异常。如果不想抛出异常，找不到就认为这个属性为null的话：required值设置 false @Autowired（required = false） private UserRepository userRepository; 但其实没有@Bean也能找到并且注入一个接口，而且直接可以调用实现接口的子类的方法 2.自动注入java接口的实现类： 比如：接口Car;实现类A implements Car;实现类B implements Car; @Service public class CarFactory { @Autowired @Qualifier(&quot;B&quot;) //两个实现类，指明调用B类的carName方法 private Car car; //多态 public String toString() { return car.carName(); } } @Resource注解：根据name和type找和注入组件类、接口实现类，接着就能用他们了 @Servicepublic class Zoo{ @Resource(name = &quot;tiger&quot;) private Tiger tiger; @Resource(type = Monkey.class) private Monkey monkey; public String toString() { return tiger + monkey; }} @Service注解： 声明Zoo.java是一个bean容器，其他类就能够@Autowired把zoo类当做是成员变量来使用; Zoo.java在bean中的id为”zoo”.(类名小写)Thymeleaf模板 Spring Boot 推荐使用 Thymeleaf 来代替 Jsp Thymeleaf 是一款用于渲染 XML/XHTML/HTML5 内容的模板引擎。类似 JSP,它也可以轻易的与 Spring MVC 等 Web 框架进行集成作为 Web 应用的模板引擎。能够直接在浏览器中打开并正确显示模板页面，而不需要启动整个 Web 应用。 页面即原型,整个页面直接作为 HTML 文件用浏览器打开，几乎就可以看到最终的效果，这大大解放了前端工程师的生产力，它们的最终交付物就是纯的 HTML/CSS/JavaScript 文件。 从springboot官方文档学习做helloXXX html页面 效果：运行后打开localhost:8080/greeting?name=xyt 这个网页页面就会显示出Hello, xyt! 官方文档https://spring.io/guides/gs/serving-web-content/ resources文件夹下放置静态文件，其中templates里放web文件 目前能够想到的组件，在spring官方文档里都是有的。复制粘贴。 pom.xml里加thymeleaf依赖 12345678910111213141516171819@Controller //允许这个类接收前端的请求public class GreetingController &#123; @GetMapping(&quot;/greeting&quot;) //网址的路径 public String greeting( @RequestParam(name=&quot;name&quot;, //@RequestParam()定义接收参数是什么，网址那里？name=xxx ,这个&quot;name&quot;就会以键值对的方式传到服务端，这样我们就会接收到这个value值。 required=false,没有接收到值也不会报错，默认值为world. required=false, defaultValue=&quot;World&quot;) String name, Model //接收到的值是String类型。这里逗号之前都是第一个参数 model) &#123; model.addAttribute(&quot;name&quot;, name); //model添加&quot;键&quot;值对的属性。Model则将获取到的值传递到这个页面上去显示，spring帮我们注入进去了。 return &quot;greeting&quot;; //return值&quot;greeting&quot;会去template中找同名的html文件:greeting.html，把他渲染成网页。这个需要自己去template中添加。 &#125;&#125; 在application.java的同一级或下一级的@Bean组件都能自动加载入容器中。 eclipse里创建的html文件编辑内容要右键openwith。12345678910&lt;!DOCTYPE HTML&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;title&gt;Getting Started: Serving Web Content&lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;&lt;/head&gt;&lt;body&gt; &lt;p th:text=&quot;&apos;Hello, &apos; + $&#123;name&#125; + &apos;!&apos;&quot; /&gt; //网页显示出Hello,XXX!&lt;/body&gt;&lt;/html&gt; 做社区网站项目第一章 网站网页的功能划分 导航（菜单栏），有很多功能分类：搜索，登录按钮 标签tag列表 话题列表，排序方式：时间倒序、推荐、热门、消灭零回复话题列表元素：发布人、发布时间、评论数、浏览数、回复数、关注数、 热门话题 热门用户 分页 第二章 做社区的菜单栏导航条 用UI框架Bootstrap快速搭建前端的站点。Bootstrap介绍：简洁、直观、强悍的前端开发框架，让web开发更迅速、简单 第一步 下载Bootstrap https://v3.bootcss.com/getting-started/#download下载并将文件粘贴到static文件夹下 第二步 写index.html 写入css,js文件 1234567891011&lt;!DOCTYPE HTML&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;title&gt;路西斐尔的尼伯龙根&lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/bootstrap.min.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/bootstrap-theme.min.css&quot;/&gt; &lt;script src=&quot;js/bootstrap.min.js&quot; type=&quot;application/javascript&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt; 在Bootstrap网页上找到组件页面，找导航条，将代码复制粘贴到index.html中的body中 根据实例中每个框框中的单词，将body中对应的单词改成自己的。 删掉不要的url，icon代码块 第三步 写IndexController.java12345678@Controllerpublic class IndexController &#123; @GetMapping(&quot;/&quot;) //根路径，代表8080就是index.html渲染出来的页面 public String index() &#123; return &quot;index&quot;; &#125;&#125; 第三章 申请github app登录授权 授权登记页面 https://github.com/settings/applications/1228484 第四章 做登录callback，拿到参数第一步 做登录按钮的github授权登录输账号密码页面 GitHub需要的内容文档 https://developer.github.com/apps/building-oauth-apps/authorizing-oauth-apps/ index.html登录那一行加入自己申请过的授权信息 1&lt;li&gt;&lt;a href=&quot;https://github.com/login/oauth/authorize?client_id=51a87c000499eea9d39a&amp;redirect_uri=http://localhost:8080/callback&amp;scope=user&amp;state=1&amp;&quot;&gt;登录&lt;/a&gt;&lt;/li&gt; 在输入密码之后会到callback页面，这时候显示404，因为还没做callback页面。http://localhost:8080/callback?code=57679f8624ad1ef794bd&amp;state=1网址上会显示一串code,之后就需要接收到这个参数code和参数state，用@RequestParam 第二步 做callback页面，接收到callback的code 新建AuthorizeController.java1234@GetMapping(&quot;/callback&quot;) //当他登录后到callback时，就让他跳转回index页面 public String callback( @RequestParam(name=&quot;code&quot;) String code , //第一个参数name为code，第二个为state @RequestParam(name=&quot;state&quot;) String state) &#123; return &quot;index&quot;; 第三步第五章 写配置文件，分离变量数据和固定代码第一步 将文件中的数据值用参数占位，在配置文件中赋值1234@Value(&quot;$&#123;github.client.id&#125;&quot;) //value中为键，他会去配置文件中找对应键的值，且赋值给参数clientId private String clientId;配置文件： github.client.id=51a87c000499eea9d39a //键值对 第六章 登录成功保持登录状态Session 和 Cookie Session:银行账户，账户所有信息都在银行数据库中（服务器就相当于银行） Cookie:银行卡，要操作账户中信息比如余额，需要知道银行卡 第七章 callback页面404，控制台不打印原因高亮！ 所有的文件和包一定要放在启动类/包下面，否则run时是不可能启动这些类的，控制台也不会打印。 springboot和shiro整合-权限管理实战第一章 Controller类1234567891011121314151617181920212223// 第一种getmapping注解 @GetMapping(&quot;/hello&quot;) public String hello() &#123; System.out.println(&quot;UserController.hello()&quot;); return &quot;ok&quot;; &#125; @GetMapping(&quot;/testThymeleaf&quot;) public String testThymeleaf(Model model) &#123; model.addAttribute(&quot;name&quot;,&quot;xyt&quot;); return &quot;test&quot;; &#125;//第二章requestmapping+requestbody @RequestMapping(&quot;/hello&quot;) @ResponseBody public String hello() &#123; System.out.println(&quot;UserController.hello()&quot;); return &quot;ok&quot;; &#125; @RequestMapping(&quot;/testThymeleaf&quot;) public String testThymeleaf(Model model) &#123; model.addAttribute(&quot;name&quot;,&quot;xyt&quot;); return &quot;test&quot;; &#125; @RequestMapping(“/hello”)@ResponseBody是返回字体（将实体类转化为json） @RequestMapping(“/hello”)是返回html 12345@RequestMapping(&quot;/update&quot;) public String update() &#123; System.out.println(&quot;UserController.hello()&quot;); return &quot;/user/update&quot;; &#125; 返回到update.html要加前面的路径。如：return “index”; index.html在trmplates包直接下面如：return “/user/update”;update.html在trmplates包下面user包下面 第二章shiro 核心APISubject: 用户主体 (把操作交给SecurityManager,要关联它)SecurityManager: 安全管理器 （关联Reaml）Realm: Shiro连接数据的桥梁,执行认证和授权。认证中具体实现用户名和密码匹配 第三章 springboot和shiro整合导入shiro和spring整合依赖12345&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt;&lt;/dependency&gt; 编写shiro配置类 @Configurartion 放在启动类子包Shiro子包Shiro中自定义Realm类，继承AuthorizingRealm类，实现认证和授权方法写shiro配置类 创建ShiroFilterFactoryBean对象，@Bean放入spring的环境，上面的方法就可以使用 创建DefaultWebSecurityManager对象，@Bean放入spring的环境 创建Realm对象，@Bean放入spring的环境 1234567891011121314151617181920212223@Configurationpublic class ShiroConfig &#123; @Bean //过滤拦截器 public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier(&quot;securityManager&quot;) DefaultWebSecurityManager securityManager ) &#123; ShiroFilterFactoryBean shiroFilterFactoryBean=new ShiroFilterFactoryBean(); shiroFilterFactoryBean.setSecurityManager(securityManager);//设置关联安全管理器 return shiroFilterFactoryBean; &#125; @Bean(name=&quot;securityManager&quot;) //安全管理器 public DefaultWebSecurityManager getDefaultWebSecurityManager(@Qualifier(&quot;userRealm&quot;)UserRealm userRealm) &#123; //@Qualifier合格者，去根据bean名字查找userRealm对象，拿一个 DefaultWebSecurityManager securityManager =new DefaultWebSecurityManager(); securityManager.setRealm(userRealm); //设置关联realm return securityManager; &#125; @Bean(name= &quot;userRealm&quot;) //执行授权器 public UserRealm getRealm() &#123; return new UserRealm(); &#125;&#125; 使用shiro内置过滤器，可实现页面权限相关的资源拦截 资源拦截逻辑：以键值对集合形式添加各个页面和对应的拦截规则。不同的拦截规则会跳转到（修改过的）不同的页面。authc：跳转到登录页面tologin(tologgin路径是login的html)，点击登录按钮后执行认证逻辑perms：进行授权逻辑，是否匹配perms字符串，不匹配跳转到拦截页面 在过滤拦截器中使用shiro内置过滤器，可以实现页面的拦截，和跳转页面。也可以用不同的过滤器放行一些页面。 常用的过滤器： anon:无需认证（登录）可以访问 authc:必须认证才可以访问 user:如果使用了rememberme的功能可以访问 perms:该资源必须授权资源权限才可以访问 role:该资源必须得到角色授权才可以访问 12345678910111213141516@Bean public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier(&quot;securityManager&quot;) DefaultWebSecurityManager securityManager ) &#123; ShiroFilterFactoryBean shiroFilterFactoryBean=new ShiroFilterFactoryBean(); //设置安全管理器 shiroFilterFactoryBean.setSecurityManager(securityManager); //添加shiro内置过滤器,将链接跳转页面和过滤器以键值对形式，加入hashmap集合 Map&lt;String,String&gt; filterMap = new LinkedHashMap&lt;String,String&gt;(); filterMap.put(&quot;/add&quot;, &quot;authc&quot;);//authc必须认证才能访问 filterMap.put(&quot;/update&quot;, &quot;authc&quot;); //修改跳转登录页面url, 每一个页面都要写一个controller，@RequestMapping对应路径 shiroFilterFactoryBean.setLoginUrl(&quot;/tologin&quot;); //安全管理器中添加集合的拦截，集合中添加的路径会按照键值对设置对应的拦截 shiroFilterFactoryBean.setFilterChainDefinitionMap(filterMap); return shiroFilterFactoryBean; 那么拦截成功就会自动跳转到http://localhost:8080/login，可自己修改跳转登录链接url如上，并且在controller类中写对应的@RequestMapping对应路径，并且写路径的页面html文件。（login.html） filterMap.put(“/test”, “anon”);让首页链接放行，无需认证（登录）可以访问，要注意顺序，这个在前面 filterMap.put(“/*”, “authc”); 这里可以让templates下面的全部资源使用过滤器，虽然他们都是user包下的，但是用根目录 超链接是写在首页test.html中,超链接点过去的跳转链接是写在Controller类中，并且写了return的html文件 12345678910111213&lt;!DOCTYPE HTML&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt; &lt;/meta&gt;&lt;title&gt;测试&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3 th:text=&quot;$&#123;name&#125;&quot;&gt;&lt;/h3&gt;&lt;hr/&gt;进入用户添加功能：&lt;a href=&quot;add&quot;&gt;用户添加&lt;/a&gt;&lt;br/&gt;进入用户更新功能：&lt;a href=&quot;update&quot;&gt;用户更新&lt;/a&gt;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt; 第四章 编写用户登录功能简单设计了一个登录页面login.html（之前的过滤拦截后的跳转页面，也是登录失败的返回页面）1234567891011121314151617&lt;!DOCTYPE HTML&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt; &lt;/meta&gt;&lt;title&gt;登录页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;这是拦截登录页面&lt;h3&gt;登录&lt;/h3&gt;&lt;h3 th:text=&quot;$&#123;msg&#125;&quot; style=&quot;color:red&quot;&gt;&lt;/h3&gt;&lt;form method = &quot;post&quot; action=&quot;login&quot;&gt; 用户名:&lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt;&lt;br/&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 为什么登录前后都用login.html?因为登录失败时model携带的msg信息才会与html中的msg匹配显示出来 点击登录按钮后跳转到login页面,编写login Controller的登录逻辑 接收 输入到login页面的用户名和密码，封装（添加）到token对象，吧token对象发给shiro。try catch判断登录成功或失败；成功返回test首页；失败 用model存储失败信息返回login页面。1234567891011121314151617181920212223//登录按钮后的跳转页面，实现逻辑处理 @RequestMapping(&quot;/login&quot;) //model中存入我们要return回login.html的信息,会吧存在里面的消息带回去，会在msg对应地方打印出错误消息 public String login(String name, String password, Model model) &#123; //使用shiro编写认证操作 //1.获取subject用户主体 Subject subject = SecurityUtils.getSubject(); //2.用token封装用户数据 UsernamePasswordToken token = new UsernamePasswordToken(name,password); //3.执行登录方法,执行过程中要传递用户的token给subject(就是传递给shiro) //如何判断是否信息无误：这段代码无任何异常 //shiro将异常/登录失败分的很清楚：UnknownAccountException e用户名不存在;IncorrectCredentialException密码错误 try &#123; subject.login(token); //无异常，登录成功跳转回首页test.html return &quot;test&quot;; &#125; catch (UnknownAccountException e) &#123; model.addAttribute(&quot;msg&quot;,&quot;用户名不存在&quot;); return &quot;redirect:/tologin&quot;;//重定向，请求到tologin路径,会执行tologin的controller,还是回到login.html &#125;catch(IncorrectCredentialsException e) &#123; model.addAttribute(&quot;msg&quot;, &quot;密码错误&quot;); return &quot;login&quot;;//所以直接回去也可以的 &#125; 编写realm的认证函数中：判断登录信息逻辑12345678910111213141516//执行认证逻辑,Authentication证明,这里接收到的就是controller中提交到shiro的token @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; System.out.println(&quot;认证&quot;); //现在先假设数据库的用户名和密码是 String name = &quot;xyt&quot;; String password = &quot;666&quot;; UsernamePasswordToken thistoken = (UsernamePasswordToken)token; //判断用户名和密码 if(!thistoken.getUsername().equals(name)) &#123; //shiro底层会抛出UnknownAccountException return null; &#125; //密码不需要判断。返回AuthenticationInfo的子类 return new SimpleAuthenticationInfo(&quot;&quot;,password,&quot;&quot;);//提交给login方法的，数据库密码(shiro会自动判断)，shiro的名字 &#125; 第五章 整合mybits实现用户登录认证 MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。 导入mybits相关依赖12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.9&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt; &lt;/dependency&gt; 在mysql sqlyog客户端中建一个数据库springboot_shiro，添加user表 写配置文件12345678910spring.datasource.driverClassName=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost/springboot_shiro?serverTimezone=UTC //url这里不用写主机ip,不用写3306（3306加上也可以成功运行）spring.datasource.username=root //用户名在sqlyog的客户端里数据库上面写的root@localhost,@前面的就是用户名spring.datasource.password= //密码记在手机里了spring.datasource.type=com.alibaba.druid.pool.DruidDataSourcemybatis.type-aliases-package=com.example.demo.domain //扫描包下的实体类 写com.example.demo.domain下的实体类User不加注解,与数据库数据中对应 name,id,password,getter,setter 写com.example.demo.mapper包下两个文件 写Dao: interface UserMapper接口 1234567import com.example.demo.domain.User;public interface UserMapper &#123; //查询 public User findByName(String name);&#125; 写映射文件： UserMapper.xml (一定要和上面的java文件名字一样)。这个文件里放CURD的sql语句,对应着上面接口中的函数实现 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapperPUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.example.demo.mapper.UserMapper&quot;&gt; &lt;select id = &quot;findByName&quot; parameterType=&quot;string&quot; resultType=&quot;User&quot;&gt; SELECT `id`, `name`, `password` //可以随意大小写，不用加引号 FROM user where name= #&#123;value&#125; //这个是占位符 &lt;/select&gt;&lt;/mapper&gt; 业务包servise 接口类UserService 1234public interface UserService &#123; public User findByName(String name);&#125; 实现类UserServiceImpl：来实现mapper接口，要加注解@Service 123456789101112131415@Servicepublic class UserServiceImpl implements UserService&#123; //注入Mapper接口 @Autowired private UserMapper userMapper; @Override //实现UserService的函数，参数传给userMapper的函数 public User findByName(String name) &#123; return userMapper.findByName(name); &#125;&#125; 修改启动类加上注解@MapperScan(“com.example.demo.mapper”)扫描mapper接口所在的包 在controller中注入业务123//注入业务 @Autowired private UserService userService; 在realm中注入业务，修改认证逻辑（去数据库中匹配用户名和密码）12345678910111213141516171819202122232425 //注入业务 @Autowired private UserService userService; //执行认证逻辑,Authentication证明,这里接收到的就是controller中提交到shiro的token @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; System.out.println(&quot;认证&quot;);// //现在先假设数据库的用户名和密码是// String name = &quot;xyt&quot;;// String password = &quot;666&quot;; UsernamePasswordToken thistoken = (UsernamePasswordToken)token; //现在已经连接了mysql数据库，写好了查询函数。然后这里就用获取到的name去找对应的password com.example.demo.domain.User user = userService.findByName(thistoken.getUsername()); //判断用户名和密码 if(user==null) &#123; return null;//shiro底层会抛出UnknownAccountException &#125; //密码不需要判断。返回AuthenticationInfo的子类 return new SimpleAuthenticationInfo(&quot;&quot;,user.getPassword(),&quot;&quot;);//提交给login方法的，数据库密码(shiro会自动判断)，shiro的名字 &#125;&#125; 第六章 整合mybits实现用户登录授权shiroconfig添加内置授权过滤/拦截器 perms： 该资源必须得到资源权限才可以访问1234567891011121314151617181920212223242526 @Bean public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier(&quot;securityManager&quot;) DefaultWebSecurityManager securityManager ) &#123; ShiroFilterFactoryBean shiroFilterFactoryBean=new ShiroFilterFactoryBean(); //设置安全管理器 shiroFilterFactoryBean.setSecurityManager(securityManager); //添加shiro内置过滤器,将链接跳转页面和过滤器以键值对形式，加入hashmap集合 Map&lt;String,String&gt; filterMap = new LinkedHashMap&lt;String,String&gt;();// filterMap.put(&quot;/add&quot;, &quot;authc&quot;);//authc必须认证才能访问// filterMap.put(&quot;/update&quot;, &quot;authc&quot;); filterMap.put(&quot;/test&quot;, &quot;anon&quot;); filterMap.put(&quot;/login&quot;, &quot;anon&quot;); //授权过滤器，登录过的user在add页面需要拿到add页面的授权才能访问 //在登录后点击添加时，就会进入授权逻辑 filterMap.put(&quot;/add&quot;, &quot;perms[user:add]&quot;); filterMap.put(&quot;/*&quot;, &quot;authc&quot;); //修改拦截的跳转登录页面url, 每一个页面都要写一个controller，@RequestMapping对应路径 shiroFilterFactoryBean.setLoginUrl(&quot;/tologin&quot;); //设置未授权的拦截页面：没有拿到某页面授权去访问某页面会跳转到/unAuth shiroFilterFactoryBean.setUnauthorizedUrl(&quot;/unAuth&quot;); //安全管理器中添加集合，以上设置的键值对拦截功能生效 shiroFilterFactoryBean.setFilterChainDefinitionMap(filterMap); return shiroFilterFactoryBean; reaml中写资源授权逻辑 逻辑：拦截过滤器添加了perms授权拦截，点到add页面就会进入授权逻辑。在进行授权逻辑时，就拿到了这个字符串，对应config那边的规则perms[user:add]，字符串匹配，授权完成，可访问正常add页面；若在授权逻辑中没有拿到相同字符串，被拦截，跳转unAuth页面。123456789@Overrideprotected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection arg0) &#123; System.out.println(&quot;执行授权逻辑&quot;); //资源授权 SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(); //添加授权字符串,在进行授权逻辑时，就拿到了这个字符串，对应config那边perms[user:add]，字符串匹配，授权完成，可访问 info.addStringPermission(&quot;user:add&quot;); return info; &#125; 改造上面的授权编码，让perms字符串更加灵活 在数据库中添加每个用户的perms 修改了表的结构，就要修改对应的实体类User结构,添加perms属性 我们需要取出数据库中的perms，需要在mapper接口中新定义一个根据id就能查找user对象的方法，然后在映射文件中写出对应的sql查询语句（相当于写出了这个具体函数方法） 在service接口中添加相同的方法 对应的在UserServiceImpl中实现这个方法：这里是调用mapper里写的sql函数return userMapper.findById(id); 第七章 thymeleaf和shiro标签整合使用导入thymleaf扩展坐标 加入扩展依赖 123456&lt;!-- thymel对shiro的扩展坐标 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.theborakompanioni&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-shiro&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt; &lt;/dependency&gt; shiroconfig中配置shiro的dialect(方言)，用于thymeleaf和 shiro标签配合使用 1234@Bean //交给spring容器 public ShiroDialect getShiroDialect() &#123; return new ShiroDialect(); &#125; 想要对于已登录用户，test主页只显示用户拿到授权的跳转超链接 修改test.html,将超链接部分加入div包裹起来，并且加入shiro的permisson字符串但是这样在未登录情况也会判断授权字符串 1234567&lt;div shiro:hasPermission=&quot;user:add&quot;&gt;进入用户添加功能：&lt;a href=&quot;add&quot;&gt;用户添加&lt;/a&gt;&lt;br/&gt;&lt;/div&gt;&lt;div shiro:hasPermission=&quot;user:update&quot;&gt;进入用户更新功能：&lt;a href=&quot;update&quot;&gt;用户更新&lt;/a&gt;&lt;br/&gt;&lt;/div&gt; 继续加入，加在上面那些代码的上面。意思是：”url”，点登陆会超链接跳转到/tologin路径 1&lt;a href=&quot;tologin&quot;&gt;登录&lt;/a&gt; 此项目代码资源-eclipse链接：https://pan.baidu.com/s/1n8oLFCNfRk90kYmhNBAnBg提取码：o470 注：此外需要mysql中的同名数据库和表 14天黑马头条项目太难了 博客项目vueblog项目文档：https://juejin.im/post/5ecfca676fb9a04793456fb8vueblog代码仓库：https://github.com/MarkerHub/vueblog 连接数据库application.yml注意1：url: jdbc:mysql://localhost/orderingsystem?serverTimezone=UTC和url: jdbc:mysql://localhost:3306/vueblog?useUnicode=true&amp;useSSL=false&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai目前都没有问题，以前用的都是前者。注意2：代码生成器中要修改对应的数据库连接 1234567891011# DataSource Configspring: datasource: name: vueblog driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/vueblog?useUnicode=true&amp;useSSL=false&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai username: root password: zhangcaiyunmybatis-plus: mapper-locations: classpath*:/mapper/**Mapper.xml 代码生成器(mybatis plus) 运行CodeGenerator(java project),输入连接的数据库中已存在的表名。就会自动生成config,entity,mapper,service相关代码文件。 注意1:与idea不同，eclipse生成代码成功之后不会更新列表中的文件。但是本地仓库中已经生成对应路径的代码文件。需要删除项目，再重新加载。 注意2：与idea不同，eclipse项目的包名路径不同，需要修改代码生成器中的路径，如下：修改projectPath(本地项目路径)，pc.setParent(“com.example.demo”)（生成代码放在启动类的下级包中）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116package com.example.demo;import com.baomidou.mybatisplus.core.exceptions.MybatisPlusException;import com.baomidou.mybatisplus.core.toolkit.StringPool;import com.baomidou.mybatisplus.core.toolkit.StringUtils;import com.baomidou.mybatisplus.generator.AutoGenerator;import com.baomidou.mybatisplus.generator.InjectionConfig;import com.baomidou.mybatisplus.generator.config.*;import com.baomidou.mybatisplus.generator.config.po.TableInfo;import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;import com.baomidou.mybatisplus.generator.engine.FreemarkerTemplateEngine;import java.util.ArrayList;import java.util.List;import java.util.Scanner;// 演示例子，执行 main 方法控制台输入模块表名回车自动生成对应项目目录中public class CodeGenerator &#123; /** * &lt;p&gt; * 读取控制台内容 * &lt;/p&gt; */ public static String scanner(String tip) &#123; Scanner scanner = new Scanner(System.in); StringBuilder help = new StringBuilder(); help.append(&quot;请输入&quot; + tip + &quot;：&quot;); System.out.println(help.toString()); if (scanner.hasNext()) &#123; String ipt = scanner.next(); if (StringUtils.isNotEmpty(ipt)) &#123; return ipt; &#125; &#125; throw new MybatisPlusException(&quot;请输入正确的&quot; + tip + &quot;！&quot;); &#125; public static void main(String[] args) &#123; // 代码生成器 AutoGenerator mpg = new AutoGenerator(); // 全局配置 GlobalConfig gc = new GlobalConfig(); String projectPath = &quot;D:/eclipse项目/vueblog&quot;;//System.getProperty(&quot;user.dir&quot;); gc.setOutputDir(projectPath + &quot;/src/main/java&quot;);// gc.setOutputDir(&quot;D:\\\\test&quot;); gc.setAuthor(&quot;关注公众号：MarkerHub&quot;); gc.setOpen(false); // gc.setSwagger2(true); 实体属性 Swagger2 注解 gc.setServiceName(&quot;%sService&quot;); mpg.setGlobalConfig(gc); // 数据源配置 DataSourceConfig dsc = new DataSourceConfig(); dsc.setUrl(&quot;jdbc:mysql://localhost:3306/vueblog?serverTimezone=UTC&quot;); // dsc.setSchemaName(&quot;public&quot;); dsc.setDriverName(&quot;com.mysql.cj.jdbc.Driver&quot;); dsc.setUsername(&quot;root&quot;); dsc.setPassword(&quot;zhangcaiyun&quot;); mpg.setDataSource(dsc); // 包配置 PackageConfig pc = new PackageConfig(); pc.setModuleName(null); pc.setParent(&quot;com.example.demo&quot;); mpg.setPackageInfo(pc); // 自定义配置 InjectionConfig cfg = new InjectionConfig() &#123; @Override public void initMap() &#123; // to do nothing &#125; &#125;; // 如果模板引擎是 freemarker String templatePath = &quot;/templates/mapper.xml.ftl&quot;; // 如果模板引擎是 velocity // String templatePath = &quot;/templates/mapper.xml.vm&quot;; // 自定义输出配置 List&lt;FileOutConfig&gt; focList = new ArrayList&lt;&gt;(); // 自定义配置会被优先输出 focList.add(new FileOutConfig(templatePath) &#123; @Override public String outputFile(TableInfo tableInfo) &#123; // 自定义输出文件名 ， 如果你 Entity 设置了前后缀、此处注意 xml 的名称会跟着发生变化！！ return projectPath + &quot;/src/main/resources/mapper/&quot; + &quot;/&quot; + tableInfo.getEntityName() + &quot;Mapper&quot; + StringPool.DOT_XML; &#125; &#125;); cfg.setFileOutConfigList(focList); mpg.setCfg(cfg); // 配置模板 TemplateConfig templateConfig = new TemplateConfig(); templateConfig.setXml(null); mpg.setTemplate(templateConfig); // 策略配置 StrategyConfig strategy = new StrategyConfig(); strategy.setNaming(NamingStrategy.underline_to_camel); strategy.setColumnNaming(NamingStrategy.underline_to_camel); strategy.setEntityLombokModel(true); strategy.setRestControllerStyle(true); strategy.setInclude(scanner(&quot;表名，多个英文逗号分割&quot;).split(&quot;,&quot;)); strategy.setControllerMappingHyphenStyle(true); strategy.setTablePrefix(&quot;m_&quot;); mpg.setStrategy(strategy); mpg.setTemplateEngine(new FreemarkerTemplateEngine()); mpg.execute(); &#125;&#125; Error creating bean with name ‘UserController’https://blog.csdn.net/qq_38701478/article/details/88808628?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase 我的问题是/vueblog/src/main/java/com/example/demo/config/MybatisPlusConfig.java复制过来没有改@MapperScan(“com.example.demo.mapper”) 教训：不要质疑代码生成器给的类的注解。 另外注意：UserService类上不加注解；UserServiceImpl类上加@Service注解 还有一个问题是application.yml中dataSource不应该加之前写的type http://localhost:8080/user/index 查询出来空白{}他的有id=1的信息格式。这个项目里没找到index.html AccountRealm.java里的爆红 user.getstatus()爆红：the method is not defined for the type User. 首先user类中是没有这个函数的。这个东西是应该在lombok里面。 在eclipse和，maven仓库里搜索lombok,找到文件夹中的jar包，安装路径选择eclipse.exe所在的文件夹路径。 重要的是安装之后eclipse.exe所在的文件夹的ini文件最后一行自动添加了一行，这时候eclipse直接打不开了。 删除最后一行换成这两行 javaagent:lombok.jar Xbootclasspath/a:lombok.jar log.info()爆红：这是日志输出的函数，需要导入import lombok.extern.slf4j.Slf4j;，在类名上面加@Slf4j注解。 特别恶心的是eclipse有时候爆红消不掉，明明没有错/已经改好了。比如log爆红，需要剪切导入的包再粘贴一遍就好了。 他妈的，今天eclipse又卡不开了 ，删掉了昨天加的两行 打开eclipse之后又出现爆红，关掉再开运行出错 选中当前项目，右击“项目”→选择Properties，在弹出的对话框左侧列表中选择Java Build Path，如下图所示：选择Add External JARs，就可以逐个添加第三方引用jar包。 加了最新的jar没用 那些get()set()方法其实就是gettersetter,手动在User类中添加；lombok就是简化这些简单的函数 无法启动因为路径有中文 安装之后再次启动依旧爆红！ 因为eclipse不能自动刷新import的包，必须手动刷新！ 删除import的lombok保存，再粘贴保存！ 有些本身函数是调用另外一个类的，需要在另外那个类中刷新 第二天eclipse又打不开。ini文件删掉最后两行在保存在粘贴在保存就能打开 要认证后才能访问 在UserController的index页面上面添加注解@RequiresAuthentication(要认证后才能访问的接口)再启动项目，就会看到页面上的全局异常抛出的信息1&#123;&quot;code&quot;:401,&quot;msg&quot;:&quot;The current Subject is not authenticated. Access denied.&quot;,&quot;data&quot;:null&#125; 注解/包cannot resoloved to a type 因为eclipse没有下载相关maven包。 点fix project set up选择然后ok 就会下载了包然后import进来 启动失败a bean BlogService could not be found. 就是BlogService找不到 找不到因为没找到这个bean. 说明注解有问题：我的BlogServiceIpl实现类上面没加@Service 另外注意@Service只加在实现类上面，service类加这个注解没有用，不用加任何注解。 当前文件夹中打开windows powershellc窗口 注意 只是邮件是看不到这个的，要用shift+右键 但是直接这样就报错：无法加载文件 C:\\Users\\A\\AppData\\Roaming\\npm\\vue.ps1，因为在此系统上禁止运行脚本 需要修改权限。搜素powershell,然后执行：set-ExecutionPolicy RemoteSigned；查看执行策略：get-ExecutionPolicy vue ui没反应 查看vue的命令列表中没有ui这个命令 vue -h 必须要安装3.0以上的，老师给的代码安装的是2.9 1.$npm uninstall vue-cli -g //卸载vue-cli旧版本2.$npm install -g @vue/cli //安装新版本3.$npm vue -V //查看版本3.vue -h //查看vue cli安装的版本中有什么命令 解决博客https://blog.csdn.net/Demo__/article/details/89404235 eclipse中加入vue插件 安装报错Unable to read repository at http://downloads.genuitec.com/downloads/products/codemix/updates/cm20200407/plugins/pack.core.win_3.6.0.202001241725.jar 原因：网络不稳定 问题的解决方法是：直接把上面的连接放入浏览器直接下载，或放入下载工具进行下载好。 再把下载好的文件放入eclipse的安装目录下的plugins文件夹下。再重新安装，问题就解决了。 eclipse导入已经创建好的vue项目 file-openproject 然后看看能不能识别vue(可以) vue主要写的东西是些什么 components 页面html 公共区域需要抽取出来的 router 路由/网址路径 跳转到哪个组件/页面 views 页面开发 store-xxx.js 数据管理的地方所有组件都监听store中的内容，通过这里面的内容更新之后会通知每一个组件，达到每个组件数据之间的同步(更新)。 app.vue 入口组件这个里面的Home About按钮点击时没有刷新页面，只是将router-view里的标签切换了。比如说点击home按钮时， 1&lt;router-link to=&quot;/&quot;&gt;Home&lt;/router-link&gt; | 会在router-index.js找到path: ‘/‘， 123456 const routes = [&#123; path: &apos;/&apos;, name: &apos;Home&apos;, component: Home&#125;, 然后把对应的组件Home添加展示到app.vue中的这个标签里。 1&lt;router-view/&gt; element-ui安装 控制台vue项目文件夹路径下cnpm install element-ui –save 项目中main.js 导入依赖之后就可以在项目中全局复制使用elementui的组件代码 启动vue项目 eclipse里添加的cmd不能跳转中文路径 run npm serve报错启动不了 直接cmd到项目路径然后 npm run serve神他妈奇的eclipse,下次绝壁换idea 安装axios axios是一个基于 promise 的 HTTP 库，这样我们进行前后端对接的时候，使用这个工具可以提高我们的开发效率。 axios是在这个vueblog根目录下面进行安装的 写组件 编写页面，新建vue文件：new-other-codeMix-vue file 不需要home和about，删掉 vuelog博客思路技术栈 后端： SpringBoot Mybatis Plus shiro redis hibernate validator jwt 前端：vue element-ui axios 博客功能 用户登录 用户退出 blog主页列表(element-ui样式) blog详情页(md格式展示) blog编辑/发表(markdown格式mavon-editor编辑器) 技术对应作用 SpringBoot：基础框架，在未来易拓展，适合微服务化体系 Mybatis Plus：让项目能完成基本的增删改查操作，节省大量时间 Shiro：作为权限(验证)，使用简单配置简单 Redis: 会话等信息需要共享,Redis是现在主流的缓存中间件，适合项目 jwt: json web token因为前后端分离，所以使用jwt作为用户身份凭证 devtools：项目的热加载重启插件 lombok：简化代码的插件工具 vueelement-uiaxiosmavon-editormarkdown-itgithub-markdown-css 开发步奏java后端 SpringBoot整合Mybatis Plus(导入mybatis-plus-boot-starter依赖) 利用Mybatis Plus进行代码生成. (导入mybatis-plus-generator依赖)涉及到代码生成，导入freemarker页面模板引擎依赖：spring-boot-starter-freemarker。运行CodeGenerator(java project),输入连接的数据库中已存在的表名。就会自动生成config,entity,mapper,service相关代码文件。 整合shiro+redis(导入shiro-redis-spring-boot-starter依赖)整合shiro框架权限会话控制,整合redis会话分享 shiro整合jwt,身份校验前后端分离，，用token jwt身份校验 结果封装Result 实体校验 解决跨域问题(前后端) 开发登录接口(登录退出/login/logout) 开发博客接口(列表发表编辑) vue前端 vue整合element-ui axios(命令行安装) 页面：登录页面，博客列表页面，博客详情页面，博客编辑页面 整合 导依赖 写application.yml配置文件 链接mysql数据库 导包mysql-connector-java 配置文件mysql链接数据库 整合mybatis-plus 导包mybatis-plus-generator,spring-boot-starter-freemarker 配置文件配置myabtis plus的mapper的xml文件的扫描路径 mybatisplus的Config类中开启mapper接口扫描，添加分页插件 mybatis plus官方给我们提供了一个代码生成器，然后我写上自己的参数之后，就可以直接根据数据库表信息生成entity、service、mapper等接口和实现类。 通过@mapperScan注解指定要变成实现类(serviece.impl)的接口所在的包(mapper)，然后包下面的所有接口在编译之后都会生成相应的实现类。PaginationInterceptor是一个分页插件。 mapper.java接口里应该是要写对表格的增删改查，然后返回实体类对象的函数。mapper.xml里应该是写对应mapper.java中函数的sql语句 Service.java接口里应该封装了mapper.java里写的函数ServiceImpl.java类中应该是implements Service接口，重写接口中函数。注入Mapper接口@Autowired private UserMapper userMapper;函数重写中的实现调用mapper.java中的函数return userMapper.findByName(name); 注意只有ServiceImpl.java上面要写注解@Service 而现在整合了mybatisplus之后，以下的类/接口只需要继承mybatisplus中的接口，完全不需要自己写函数。 xxxmapper.java接口里只需要继承Mybayisplus中的接口，导入实体类blogpublic interface BlogMapper extends BaseMapper{} xxxmapper.xml里只需要对应xxxmapper.java的路径名字 xxxService.java接口里只需要继承mybatisplus接口，导入实体类blogpublic interface BlogService extends IService {} xxxServiceImpl.java类里实现接口xxxService，继承mybatisplus接口,导入实体类blog(不写自动注入的注解)public class BlogServiceImpl extends ServiceImpl&lt;BlogMapper, Blog&gt; implements BlogService {} shiro整合jwt考虑到后面可能需要做集群、负载均衡等，所以就需要会话共享，而shiro的缓存和会话信息，我们一般考虑使用redis来存储这些数据，所以，我们不仅仅需要整合shiro，同时也需要整合redis。在开源的项目中，我们找到了一个starter可以快速整合shiro-redis，配置简单，这里也推荐大家使用。而因为我们需要做的是前后端分离项目的骨架，所以一般我们会采用token或者jwt作为跨域身份验证解决方案。所以整合shiro的过程中，我们需要引入jwt的身份验证过程。 登录逻辑分析： 用户用用户名 密码登录 后端进行校验密码，如果正常 就生成jwt-&gt;然后返回给用户，那么用户就能拿到Jwt的身份凭证。 后端进行校验密码，如果异常 就抛出异常-&gt;全局异常捕获 登录成功的用户去访问其他资源受限的接口(链接)时，要带上jwt身份凭证，才知道访问接口的用户是谁。 用户访问后端接口逻辑分析: 访问之前经过jwt的过滤器JwtFilter有jwt:交给shiro登录处理，使用shiro的securityManager进行登录处理。shiro处理过程中,如果异常(过期、秘钥不对)-&gt;抛出异常-&gt;全局异常处理器捕获异常进行拦截-&gt;返回json数据给前端。shiro处理过程中,如果正常-&gt;访问接口xxxController 无jwt:注解过滤(有权限才能用，权限是交给这个注解处理)：接口xxxController中函数头上的@RequiresAuthentication访问接口xxxController无权限-&gt;抛出异常-&gt;全局异常捕获有权限-&gt;访问接口xxxController 导包shiro-redis-spring-boot-starter hutool-all(工具) jjwt ShiroConfig中重写sessionManager securityManager AccountRealm中执行资源授权逻辑和认证逻辑(用户名/密码判断)，获取他的一个权限信息封装成AuthorizationInfo返回给shiroConfigsupports：为了让realm支持jwt的凭证校验doGetAuthorizationInfo：权限校验doGetAuthenticationInfo：登录认证校验 ShiroConfig中：在ShiroFilterChainDefinition中，我们不再通过编码形式拦截Controller访问路径，所有的路由都需要经过JwtFilter这个过滤器，然后判断请求头中是否含有jwt的信息，有就登录，没有就跳过。跳过之后，有Controller中的shiro注解进行再次拦截，比如@RequiresAuthentication，这样控制权限访问。 JwtUtils是个生成和校验jwt的工具类，其中有些jwt相关的密钥信息是从项目配置文件中配置的 AccountProfile：这是为了登录成功之后返回的一个用户信息的载体， JwtFilter:createToken：实现登录，我们需要生成我们自定义支持的JwtTokenonAccessDenied：拦截校验，当头部没有Authorization时候，我们直接通过，不需要自动登录；当带有的时候，首先我们校验jwt的有效性，没问题我们就直接执行executeLogin方法实现自动登录onLoginFailure：登录异常时候进入的方法，我们直接把异常信息封装然后抛出preHandle：拦截器的前置拦截，因为我们是前后端分析项目，项目中除了需要跨域全局配置之外，我们再拦截器中也需要提供跨域支持。这样，拦截器才不会在进入Controller之前就被限制了。 统一结果封装Result @Data 序列化(implements Serilizable)为了前后端对接数据方便。后端返回数据给前端要有一个统一的格式，前端就能知道后端返回的结果数据是正常的还是异常的。如果获取到的是异常的数据，前端就可以弹窗给用户。 code(200/400)，结果消息(操作成功/操作失败)，结果数据 静态方法：接口访问成功会吧数据字段封装成result(new Result对象，吧数据填到对象里)return给前端 全局异常处理捕获异常，返回统一格式的json数据@ExceptionHandler(value = RuntimeException.class)来指定捕获的Exception各个类型异常 ，这个异常的处理，是全局的，所有类似的异常，都会跑到这个地方处理。@ControllerAdvice表示定义全局控制器异常处理，@ExceptionHandler表示针对性异常处理，可对每种异常针对性处理。@Validated 校验错误异常处理 ShiroException：shiro抛出的异常，比如没有权限，用户登录异常IllegalArgumentException：处理Assert的异常MethodArgumentNotValidException：处理实体校验的异常RuntimeException：捕捉其他异常 实体校验entity当我们表单数据提交的时候，前端的校验我们可以使用一些类似于jQuery Validate等js插件实现，而后端我们可以使用Hibernate validatior来做校验。我们使用springboot框架作为基础，那么就已经自动集成了Hibernate validatior。@NotBlank(message = “昵称不能为空”)private String username;@NotBlank(message = “邮箱不能为空”)@Email(message = “邮箱格式不正确”)private String email; UserController:使用@Validated注解方式，如果实体不符合要求，系统会抛出异常，那么我们的异常处理中就捕获到MethodArgumentNotValidException。 跨域问题JwtFilter: 在进入逻辑之前跨域处理preHandle直接在后台进行全局跨域处理CorsConfig 登录/退出接口/login /logout登录的逻辑其实很简答，只需要接受账号密码，然后把用户的id生成jwt，返回给前端，吧jwt放在header里面，在jwt需要延期的时候，不需要再调用另外的接口，而是判断如果header里存在jwt的话，就进行刷新就行了根据用户名去查找密码再匹配 （DTO就是数据传输对象(Data Transfer Object)的缩写。 DTO模式，是指将数据封装成普通的JavaBeans，在J2EE多个层次之间传输。 DTO类似信使，是同步系统中的Message。 该JavaBeans可以是一个数据模型Model。 ） 博客接口/blogs /blog/{id} /blog/edit(@RequiresAuthentication)博客编辑页面是添加和编辑都在这里，根据传过来的id判断，有id就是编辑，无id就是添加 前端路由权限拦截 判断哪些路由需要权限（/add /edit）meta: { requireAuth: true}, 路由前置拦截axios在发起请求之前有一个前置拦截判断该路由的meta里信息如果是true的话就需要权限，然后判定有无token。如果有Token就跳转到下一个路由 next（）；如果没有token-&gt;跳转到login界面 但是项目中没有用跳转用的是禁止，直接访问没有跳转到login 为了让这个错误弹窗能运用到所有的地方，所以我对axios做了个后置拦截器，就是返回数据时候，如果结果的code或者status不正常，那么就有对应的弹窗提示。 登录页面-登录逻辑 前端页面提示需要输入用户名和密码 前端页面提交时axios发起请求(axios发起请求的时候都会有一个域名/当前页面url) 后端进行密码校验，如果正常，生成jwt，返回给用户 从返回的结果请求头中获取到token的信息，然后使用store提交token和用户信息的状态。完成操作之后，我们跳转到到了/blogs路由，即博客列表页面。 存储token，用的是localStorage; 存储用户信息，我们用的是sessionStorage。 博客列表页面 页面头部我们需要把用户的信息展示出来，因为很多地方都用到这个模块，所以我们把页面头部的用户信息单独抽取出来作为一个组件。 头部的用户信息，应该包含三部分信息：id，头像、用户名，而这些信息我们是在登录之后就已经存在了sessionStorage。因此，我们可以通过store的getters获取到用户信息。 上面代码created()中初始化用户的信息，通过hasLogin的状态来控制登录和退出按钮的切换，以及发表文章链接的disabled，这样用户的信息就能展示出来了。 退出逻辑：在methods中有个logout()方法，逻辑比较简单，直接访问/logout，因为之前axios.js中我们已经设置axios请求的baseURL，所以这里我们不再需要链接的前缀了哈。因为是登录之后才能访问的受限资源，所以在header中带上了Authorization。返回结果清除store中的用户信息和token信息，跳转到登录页面。 项目综述SpringBoot+vue的博客项目基本功能：用户登录页面，用户退出，blog主页列表(element-ui样式)， blog详情页(markdown格式展示)，blog编辑/发表(markdown格式mavon-editor编辑器)使用技术：SpringBoot作为基础框架，Mybatis Plus：让项目能完成基本的增删改查操作，省去自己写mapper、service, Shiro：权限校验、登录认证，Redis: 储存shiro的权限数据和会话信息，jwt: 作为前后端分离的用户身份凭证；vue项目使用：element-ui，axios，mavon-editor，markdown-it，github-markdown-css功能逻辑：使用用户名密码登录axios发起请求，后端进行密码校验，如果正常，生成jwt，返回给用户。从返回的结果请求头中获取并提交token的信息跳转到blog主页列表。如果异常，全局异常捕获，页面弹窗异常信息。Blog主页做了页面头部将用户的信息展示出来，element-ui时间线样式做列表，还有分页。Blog详情页使用插件markdown-it将markdown格式的内容渲染展示出来。使用mavon-editor编辑器进行blog的编辑，点击按钮提交表单。 学习经历您好，我2018年进入西交利物浦大学信息与计算科学专业学习至今两年。主要在学校中学习了java,数据结构，算法，mysql数据库，操作系统，离散数学。在项目中使用的springboot，shiro,mybatis，mybatisplus的框架技术和vue和html都是通过看视频看博客自学的 项目项目的话是完整的做过一个springboot和vue的前后端分离的简易博客系统。目前是完成了用户登录页面，用户退出，blog主页列表页面(element-ui样式)， blog详情页(markdown格式展示)，博客的发表和编辑页面。博客详情页面里可以进行blog的编辑，在博客主页列表页面可以进行博客的发表以及用户的退出或者登陆。 后端java的项目里面完成登录接口和博客接口的开发，具体整合了mybatis plus让项目能完成基本的增删改查操作。整合shiro实现用户登录验证和授权，整合redis用来储存shiro的权限数据和会话信息jwt: 作为前后端分离的用户身份凭证；前端的vue项目做了用户登录页面，blog主页列表页面，blog详情页，和博客的发表和编辑页面。具体整合了element-ui和axios,博客的发表编辑页面用的是mavon-editor编辑器，可以让用户在编辑过程中看到发表之后的markdown样式的展示出来的样子。 擅长和主要使用的技术栈有Java编程语言，还熟悉SpringBoot，MyBatis和MyBatisPlus的框架技术，熟练使用mysl的增删改查。掌握html vue的前端开发技术。现在是用的eclipse作为开发工具。","categories":[{"name":"springboot","slug":"springboot","permalink":"https://lucifinil-x.github.io/categories/springboot/"}],"tags":[]},{"title":"java考试复习总结","slug":"java考试复习总结","date":"2019-12-24T13:23:07.000Z","updated":"2020-04-30T09:54:28.087Z","comments":true,"path":"2019/12/24/java考试复习总结/","link":"","permalink":"https://lucifinil-x.github.io/2019/12/24/java考试复习总结/","excerpt":"单词提取 encapsulation 封装 length 有g //另：数组求长度 xxx.length; 字符串求长度 xxx.length(); mantissa 小数部分","text":"单词提取 encapsulation 封装 length 有g //另：数组求长度 xxx.length; 字符串求长度 xxx.length(); mantissa 小数部分 基础知识数据类型（整数都有一位是表示正负符号位） byte:1byte; short:2byte; int:4byte; long:8byte float:4byte(整数1byte,小数点后最多7位); double:8byte(整数10位，小数点后最多15位) char:2byte boolean:至少1byte 去年考试题目1.1 Message:Variables: messageText, sender, sendTime, readprivate String messageText; private String sender; private LocalDateTime sendTime; private boolean read;Constructor: Message(String messageText, String sender, LocalDateTime sendTime, boolean read ){ this.messageText = messageText; this.sender = sender; this.sendTime = sendTime; this.read = read; }Encapsulation：public void setMessageText(String messageText) //set，get,小写，后面第一个字母大写{ this.messageText = messageText; } public String getMessageText() { return this.messageText; } public String toString() { //if() return sender + &quot;send&quot; + messageText + &quot;at&quot; + sendTime.toString() + &quot;read or not:&quot; + read; } 1.2 public static void main(String[] args) { double[] numbers= new double[10]; fillArray( numbers); printArray( numbers); System.out.println(“The minimum value is:”+ findMinimum(numbers)); reverseArray( numbers); printArray( numbers); } //fill the array with double values / /use a Scanner to get input from the keyboard public static void fillArray ( double[] toFill) { Scanner s = new Scanner(System.in); //double temp; for(int i= 0; i&lt; toFill.length; i++) { toFill[i] = Double.parseDouble(s.nextLine()); //重点：String转成其他类型不能直接（double）xxx转换； 只能用Xxx.parseXxx(String); 注意Integer.parseInt(String); } } //print the contents of the array to the console, showing the index and value of //each element on a new line public static void printArray(double[] toPrint) { for(int i= 0; i&lt; toPrint.length; i++) { System.out.println(toPrint[i]); } } ///reverse the array. Do not need to display public static void reverseArray(double[] toReverse) { double [] temp = new double[toReverse.length]; //重点:新建数组不确定长度时 xxx.length //double [] temp = toReverse; //重点:建立和传入参数相同的数组时 不能用次方法（这种方法会让新建的副本数组跟随原数组变化而变化(后面要将原数组翻转，会改变源数组的值),只能先遍历出原数组的内容赋值到新数组中，再进行原数组改变值） int j = toReverse.length -1; for(int i= 0; i&lt; toReverse.length; i++) { temp[i]= toReverse[i]; } for(int i= 0; i&lt; toReverse.length; i++) { toReverse[i]= temp[j]; j--; } } //return the minimum value of the array public static double findMinimum(double[] array) { double minimum = 0 ; double temp; for(int i= 0; i&lt; array.length -1; i++) { temp = array[i]; if(temp &gt; array[i+1]) { minimum = array[i+1]; } else if(i==0) //重点：只需要考虑第一次 { minimum =temp; } } return minimum; }","categories":[{"name":"java","slug":"java","permalink":"https://lucifinil-x.github.io/categories/java/"}],"tags":[]},{"title":"计算机系统","slug":"计算机系统","date":"2019-12-22T06:50:35.000Z","updated":"2020-04-30T09:56:21.962Z","comments":true,"path":"2019/12/22/计算机系统/","link":"","permalink":"https://lucifinil-x.github.io/2019/12/22/计算机系统/","excerpt":"CSE101 Q and A 内容###计算机系统4层体系结构 用户代码，软件，操作系统，硬件 （前二为程序员，用户层面）","text":"CSE101 Q and A 内容###计算机系统4层体系结构 用户代码，软件，操作系统，硬件 （前二为程序员，用户层面） 硬件 硬件举例： CPU，内存，硬盘hard disk, 键盘， 屏幕display screen 操作系统 将硬件系统的功能带出来 操作系统包围住硬件系统的好处： 易于编程，保护系统，公平和效率使用系统 组成成分 输入，输出，内存，CPU CPU ALU 中央处理器 central processing unit 进行计算和其他操作 运算器 arithmetic logical unit ALU 和 control unit 是CPU两个主要元件 处理器processor（CPU）遵循软件的指令处理数据 CPU只能执行加载进内存的指令 内存 系统内存 储存着CPU处理，存取的数据 次要存储： 硬盘hard disk, CD, DVD 系统内存中存储着 程序和数据 program and data ，由二进制表示的 接上，其中计算机知道哪里读取指令，哪里读取数据，虽然指令和数据都是二进制 输入输出设备 输入设备： 鼠标，键盘，扫描器Scanner 另：输入硬件设备将数据翻译成计算机能处理的形式 输出设备： 显示器Monitor, 扬声器Speaker, 打印机Printer WIMP 和 OS 主要是输入和输出设备： window, icon, menu, pointer （大概是电脑界面点击图标的意思） WIMP是操作系统OS在四十年中最重要的革新 操作系统OS需要分配公平的被保护的资源： 因为多线程容易死结deadlock, 同时保护硬件（用户不合理操作时） OS支持多任务操作时的功能： 内存管理，安全，分配CPU给每个程序 OS提供访问给网络设备facility: 通过API应用程序界面 ，例如socket interface 普通用途机器有OS特殊用途机器没有OS，只能高效率的做特定的事情 学习层面 程序运行时，计算机内部和程序底层–汇编 分层分区的好处 易于理解，易于设计，易于改变 服务器 Servers 通过 web-network-cloud 服务器是专门用于存储大量PC上数据和程序的工作平台 Dumb terminal:哑终端，一切程序交给主机做，主机不能做任何处理 向下兼容 Downward Compatibility 新软件能在旧硬件上运行 高速集成电路硬件描述语言- VHDL摩尔律 电路大小缩减一半 几个不同的注重 科学计算—Computation 计算 商业计算—Data 数据 个人计算机—Interaction 交互 Input-Process-Output模型 是数字电脑的基础结构 软件编程控制着Process 硬件，软件，（被操作的）数据 ，这三个原件实施Input-Process-Output模型 和 von Neumann 模型 其中von Neumann 模型是 Input-Process-Output模型 中的Process部分Process部分: Processor（应该是CPU） 和 Memory 互相连接传递数据interconnect CPU的读取速度快于主内存，也就是说主内存的速度不快，会拖慢整体交换链接数据的速度，CPU读取速度再快也没有用 von Neumann的机器中 数据和指令 共享同一内存 混合存放 Harvard结构 将数据和程序分离开存储提高了传输速率transfer rate 和生产力throughput但是数据和指令需要单独的存储器single reservoir像是指令缓存instruction cache 数据缓存data cache 指令集instruction set 没有指令标准 standard instruction 对于特殊用途的机器，指令集instruction set通常是固定的 高级编程语言HLL 优势： 用户友好， 编程方便 举例： java c c++ python 程序编译过程 Edit 变成HLL — Compile变成二进制对象文件 —-Link 变成可执行文件 —- Load 最后运行 Compiler编译器: HLL变成机成机器码 Assembler汇编器： 机器指令助记符变成二进制 另：汇编器将标签和内存地址链接在一起 Interpreter解释器： HLL指令解码decode变成中间代码Intermediate code,还是会变成机器码解释器在程序切换快，程序运行快，程序转移到另外平台上时比编译器更好用 Inline assembler内联汇编器： 可以在汇编段中调用c程序库中的函数 用户使用计算机时内部的工作流程 用户使用计算机系统算题的一般流程: ①通过系统操作员建立帐号，取得使用权。帐号既用于识别并保护用户的文件(程序和数据)，也用于系统自动统计用户使用资源的情况(记帐，付款)。 ②根据要解决的问题，研究算法，选用合适的语言，编写源程序，同时提供需处理的数据和有关控制信息。 ③把②的结果在脱机的专用设备上放入软磁盘，建立用户文件(也可在联机终端上进行，直接在辅助存储器中建立文件，此时第四步省去)。 ④借助软盘机把软盘上用户文件输入计算机，经加工处理，作为一个作业，登记并存入辅助存储器。 ⑤是要求编译。操作系统把该作业调入主存储器，并调用所选语言的编译程序，进行编译和连接(含所调用的子程序)，产生机器可执行的目标程序，存入辅助存储器。 ⑥要求运算处理。操作系统把目标程序调入主存储器，由中央处理器运算处理，结果再存入辅助存储器。 ⑦运算结果由操作系统按用户要求的格式送外部设备输出。 计算机内部工作(④~⑦)是在操作系统控制下的一个复杂过程。通常，一台计算机中有多个用户作业同时输入，它们由操作系统统一调度，交错运行。但这种调度对用户是透明的，一般用户无需了解其内部细节。 用户可用一台终端，交互式的控制③⑦的进行(分时方式);也可委托操作员完成③⑦，其中④~⑦是计算机自动进行的(批处理方式)。批处理方式的自动化程度高，但用户不直观，无中间干预。分时方式用户直观控制，可随时干预纠错，但自动化程度低。现代计算机系统大多提供两种方式，由用户选用。 代码分享方法 资源水平的子程序， 宏程序库macro libraries（问题： 谁维护，谁拥有） 预先翻译，可再定址的二进制库 动态库，动态link 库library 库可以link到程序代码，但不能修改 对于动态库，动态link有一个事实标准de-facto standard : Microsoft active 数据单位 bit,byte encode编码ASCII表用了7bit = 2的七次方大小表示一位，第一位表示正负 256bytes数据 可以存入 8bit system 内存地址从0000到00FF ： 1byte* (F16+F1)= 1516+151=256 bytes可以存入16bit system 内存地址从0000到007F ：2byte（716+F1）= 2（716+151）=256 bytes 编码表 ASCII表一位=1byte=8bit;1010 0101 1111 1000 = 16bytes 二进制文件一位=1bit; 1010 0101 1111 1000 = 16bits = 2bytes ASCII表最常用，EBCDIC现在已经不用了，被替代了 ASCII表不能编码除了英语和一些欧洲国家语言之外的字符 ASCII表分为字符和指令字符 printing and control characters 对于不同的表，编码速度没有差异 IEEE754 标准是最广泛使用的浮点转换二进制计算的标准 octal notation 是八进制声明变量时 告诉编译器预留内存空间 告诉编译器变量类型 线 bus 地址线，数据线，控制线 bus线的速度达不到（不匹配）CPU和内存交换的速度,就会让整体速度拖慢 bus一次一条线只能传一项item数据 协处理器coprocessor math, graphic 数学和图像应用程序 微处理器microprocessor 处理接收到的大量信息 存在于计算器，手机，平板，手表，MP3，照相机中 系统时钟system clock 系统时钟控制了所有计算机操作的执行速度 文件系统执行任务时的资源消耗 CPU时间资源，内存，硬盘空间 CPU time, memory, disk space 机器循环machine cycle 重要，注意是指令 过程： 获取指令–解码指令–执行–存储结果 main steps: fetch instruction–decode instruction–execute–store RISE CISE RISE的指令描述简单， CISE指令描述字多 processors that support fewer instructions than do SISC chips 指令执行寄存器 IP,IR,MAR,MBR 不同指令的获取fetch语句是相同的 不同指令的执行execute语句不同 CPU状态标志符Flag Zero flag： 为0，zf=1 Sign flag: 为负数 首位1， sf=1 Carry flag： 产生进位或退位为，cf=1 Overflow flag: 溢出， of=1 EFlage: CMP AL,BL (AL-BL) D flag: direction of processing O flag: Arithmetic overflow error 这些flag在指令执行之后才标记 CMP 后会改变flag，不是check 指令 Pentium奔腾指令集的指令从1到15字节的宽度（不确定），来加速指令解码 指令包含三个： 操作指令，操作数的数据类型，操作数的地址和结果 机器指令用不同的字段Distinct bit field来编码所需的操作内容 寄存器和寄存器之间的运算是最快的 函数 printf: 先进栈的最后打印出来 push顺序：先数字-再占位符-最后句子 call函数时：把EIP（指令指针）中的地址push到栈中， 再把函数地址放进EIP ret时： pop出最后存入栈的地址，放入EIP中 栈的框架下储存的数据类型： 子程序的参数，ret地址，EBP栈指针，局部变量 BCD码：将十进制的每一位0-9的数字转换成四位的二进制码 BCD码：将十进制的每一位0-9的数字转换成四位的二进制码 321的BCD码： 0011 0010 0001 321的二进制码： 101000001 1 byte(8bit)只能表示0-99（99就是 1111 1111） BCD的经济性不如二进制码binary（位数更多）， BCD计算更复杂， 但BCD和字符见的转换更加容易； 二进制表示更容易理解，BCD更容易理解用于某些业务应用程序 2’s complement 补码 正数补码不改变 负数（符号位1）补码： 符号位不变，其余位取反后加一 2’s complement会有溢出的情况： 两个整数相加变成负数 赞成者Pros: 基于two-state technology 易于实现 反对者Cons: 对于人难以理解 带符号整数相加会发生溢出怎么办： 用of sign检测:相加前后的of应该相同，如果不同就溢出了（不太清楚，可能是相加后同为负数或整数） 带符号整数减法是加法的另一种形式，同样也会溢出。加法溢出，减法溢出 10’s complementary convention十进制补充约定 n位数字表示为10’s complementary convention 是基于模module 10 十进制的互补表示: 0到499表示0到499， 500到999表示-500到-1 （-一千减x） 同样有溢出： 347+230= 577大于499溢出 ，577= -（1000-577）=-423 基础类型的bit大小: -2^(x-1 bit次方) 到 2^(x-1 bit次方)-1, 都要去掉符号位 byte: 8bit ,1byte short: 16bit ,2byte , -2^15到2^15 -1 long: 64bit ,8byte int: 32bit ,4byte IEEE754 1bit正负 8bit指数 23bit小数有效位数 ，不存小数点 把二进制小数 变成十进制小数：指数8位- 128+1 = 8位-10000000（2^7，8位）+1 = 整数 ，Excess-127格式小数23位： 1.xxxxxxxx （不用转换）计算 2^指数*1.xxxxxx NaN规范：指数位127，小数位不是0，此时NaN(not a number) 其他看不懂：单精度指数过剩excess notation 127;双精度指数过剩excess notation 1023 数据存储器 寄存器register（8bit,在CPU中） 到 缓存cache 到 内部内存main memory（RAM,ROM） 到 硬盘disk 越来越慢，空间越来越大，价格越来越便宜； 寄存器最快最小最贵 数据获取access的方法：顺序存储sequential storage会减慢数据检索retrieval的进程 Main memory 计算机内部，断电消失 RAM随时存取储存器：分两个DRAM动态，SRAM静态 ROM只读存储器 Cache高速缓存存储器 独立保存，断电不消失 硬盘 : 检索硬盘副本显示到屏幕上，如果检索之后不被修改，源文件不会被覆盖 光盘 ： 读道track U盘 电路combinational组合 sequential数列 logic circuits 组合逻辑电路没有记忆区memory ，数列逻辑电路有记忆区 卷子中的待解决问题 —今年只有选择题和汇编无问答 What is the mechanism being used to pass parameters to the C library function Answer the following questions based on IEEE 754 standard.(4marks each)a) What is the largest positive number represented by IEEE 754 single-precision format?b) What is the encoding of the number -123.625 in IEEE 754 single-precision format?c) What is the smallest normalisedpositive number represented by IEEE 754 single-precision format? 内联汇编 _asm{} 记住：push一次esp+4; 每次call完结算前面push次数， add esp,4n xchg交换值指令： xchg eax, [sei+4] 至少要有一个寄存器 调用： call printf ,call scanf_s 遍历数组存首地址 lea esi, intArray循环中 add eax, [esi]add esi, 4 mov esi, 0循环中 add eax, intArray[esi]inc esi","categories":[{"name":"记忆性学习","slug":"记忆性学习","permalink":"https://lucifinil-x.github.io/categories/记忆性学习/"}],"tags":[]},{"title":"游戏和开源项目学习","slug":"游戏和开源项目学习","date":"2019-11-27T06:20:48.000Z","updated":"2020-04-15T21:15:08.867Z","comments":true,"path":"2019/11/27/游戏和开源项目学习/","link":"","permalink":"https://lucifinil-x.github.io/2019/11/27/游戏和开源项目学习/","excerpt":"","text":"初心 想先做像页游那样的游戏，任务在家园里移动。感觉是可以实现的。","categories":[],"tags":[]},{"title":"mySQL","slug":"mySQL","date":"2019-09-14T05:26:06.000Z","updated":"2020-04-15T21:15:17.040Z","comments":true,"path":"2019/09/14/mySQL/","link":"","permalink":"https://lucifinil-x.github.io/2019/09/14/mySQL/","excerpt":"19.9.14安装 mysql5.7安装以及配置环境（注意：官网安装非常慢，打开迅雷复制官网下载网址链接下载安装）https://www.bilibili.com/video/av66542221","text":"19.9.14安装 mysql5.7安装以及配置环境（注意：官网安装非常慢，打开迅雷复制官网下载网址链接下载安装）https://www.bilibili.com/video/av66542221 19.9.15 语句超级容易输错单词,有无s什么的….. 19.9.16 感觉有点枯燥呢，加油","categories":[{"name":"数据库sql","slug":"数据库sql","permalink":"https://lucifinil-x.github.io/categories/数据库sql/"}],"tags":[]},{"title":"学习计划与心得","slug":"学习计划与心得","date":"2019-09-14T05:20:49.000Z","updated":"2020-04-15T21:15:18.905Z","comments":true,"path":"2019/09/14/学习计划与心得/","link":"","permalink":"https://lucifinil-x.github.io/2019/09/14/学习计划与心得/","excerpt":"19.9.14 希望每天保持八小时的有效学习时间，坚持记录笔记，多任务学习 英语老老实实背单词 文件要装好","text":"19.9.14 希望每天保持八小时的有效学习时间，坚持记录笔记，多任务学习 英语老老实实背单词 文件要装好 19.9.16 效率挺低的完全没办法做到做任务学习 19.9.17 备考雅思单词：会认与会写。 A4纸折八列，写单词和意思 ，折起来背 19.9.29 很久没有记录了，平时真的没什么时间，英语也很差，代码经常出问题，还是缺少练习 20.2.23 小匠笔记：学东西一定要先看官方网址文档。最开始学东西先用起来，不要死磕，之后多用就会了 创建包来隔离不同的业务 参数多于两个就要把他封装成对象 全部文件/包放在启动类所在包下面 初了解一个应用，一定去看它的官方文档","categories":[{"name":"学习计划","slug":"学习计划","permalink":"https://lucifinil-x.github.io/categories/学习计划/"}],"tags":[]},{"title":"java基础记录的笔记","slug":"java笔记","date":"2019-09-12T16:35:58.000Z","updated":"2020-07-01T20:06:06.098Z","comments":true,"path":"2019/09/13/java笔记/","link":"","permalink":"https://lucifinil-x.github.io/2019/09/13/java笔记/","excerpt":"安装 安装netbeans8.2 IDE 和jdk1.8.0 百度云传不了，放在u盘里的 注意如果netbeans出错了就把相关文件夹删干净（360强力删除）之后重装，会省时省力很多。","text":"安装 安装netbeans8.2 IDE 和jdk1.8.0 百度云传不了，放在u盘里的 注意如果netbeans出错了就把相关文件夹删干净（360强力删除）之后重装，会省时省力很多。 19.9.13数组定义数组 int [] arr = new int []{1,2,3,4,5};int [] arr = {1,2,3,4,5};int [] arr = new int [8] 自定义函数要写在主类class Main里，public static void main 的下面；数组作为自定义函数的参数时要写括号：public static int add(arr[])；main函数里调用自定义函数时参数只用写数组名（此时调用数组第一个数据的地址）： add(arr) ；而且调用函数的返回值用一个变量装载一下 ：int b = add(arr) 各种功能都写成函数再调用，不要写在主函数里 改变数组的自定义函数：返回类型为void（改变指针） 表 数组可以作为表： 当数据之间存在对应关系时，通过一方可以查询到另外一方。ex: 通过数组的索引查表（查找数组中的内容）,(这样比switch if 条件判断方便) 数组选择排序 从第一个依次向后比较，替换第一个；在从第二个依次向后比较，替换第二个….（小数向前挪动）12345678910111213141516171819202122232425262728293031323334353637 public class Main &#123; public static void main(String[] args) &#123; int arr[] =&#123;12,9,23,77,12,34&#125;; rank(arr); printArr(arr); &#125; public static void rank(int []arr ) &#123; for(int a =0; a&lt;arr.length-1; a++) &#123; for(int b = a+1; b&lt;=arr.length -1; b++) &#123; if(arr[a]&gt; arr[b]) &#123; int temp= arr[a]; arr[a]= arr[b]; arr[b]= temp; &#125; &#125; &#125; return ; &#125; public static void printArr( int arr[]) &#123; for(int x=0; x&lt; arr.length; x++) &#123; if(x == arr.length -1) System.out.println(arr[x]); else System.out.print(arr[x] + &quot;,&quot;); &#125; return; &#125;&#125; 数组冒泡排序 1-2比，2-3比，3-4比…(将每次比较的大值放在后面再和下一个数比较)，再重复1-2比，2-3比..1234567891011121314public static void rank(int []arr ) &#123; for(int a = 0; a&lt; arr.length-1; a++) &#123; for(int b = 0; b&lt;arr.length-1-a; b++) //【-a】这里为了实现每一次横向比较时，比较的次数都会随着横向比较次数的增加而递减（因为每次横向排序的末尾最后一个一定是最大的数，所以下一次横向比较时不再比较最后一个数） &#123; if(arr[b]&gt;arr[b+1]) &#123; int temp = arr[b]; arr[b]=arr[b+1]; arr[b+1]=temp; &#125; &#125; return ; &#125; &#125; 代码抽取 以上两个排序中的交换数组中数字位置部分的代码块重复，可自定义一个新功能，再调用（如冒泡排序中： swap(arr, b, b+1);）,方便使用提高复用性123456public static void swap(int arr[], int a, int b) //注意未知的都是参数： 数组不知道，交换位的角标不知道 &#123; int temp = arr[a]; arr[a]= arr[b]; arr[b] = temp; &#125; 使用程序包 以上数组排序功能都可在程序包内（需要自己下载），开发时直接import程序包，再调用就可以，不要自己写功能 19.9.14数组普遍查找 普遍查找数组中元素(遍历数组)，返回值为int(角标):return x；如果没有此元素，return -1 (代表不存在的情况) 二分查找 1、定义min、max、mid角标；2、比较mid和查找数据大小： 数据大，min=mid+1;数据小, max=mid-1; 3、循环；4、循环中判断查找的数据是否存在(存在条件max min之间有距离：min &lt;= max) 或者判断存在条件作为while循环条件，会更加简洁1234567891011121314151617181920212223242526272829public static void main(String[] args) &#123; int arr[] =&#123;9,12,15,24,36,41,59,68&#125;; rank(arr); int a =binarySearch(arr, 41); System.out.println(&quot;第&quot;+(a+1)+&quot;个是:&quot;+arr[a]); &#125; public static int binarySearch(int arr[], int key) &#123; int min, max, mid; min=0; max = arr.length -1; mid = (min + max)/2; while(arr[mid] != key) &#123; if(arr[mid]&lt; key) &#123; min = mid +1; mid = (min + max)/2; &#125; else if(arr[mid]&gt; key) &#123; max = mid -1; mid = (min + max)/2; &#125; //判断查找元素是否存在 if(max&lt;min) return -1; &#125; return mid; &#125; 19.9.18面向对象 对象：属性（数值，是变量）+ 行为（功能，是函数） 19.9.29数组 创建功能：传入数组参数，返回数组参数主函数中 &gt; + String arr[] = new String[6];public static String[] change (String [] arr) //定义中类型和参数都有括号 return arr; //返回值无括号主函数中接收返回值时直接 &gt; + String name [] = change(arr) //调用传值无括号 Scanner 首先在package 下面加上 import java.util.Scanner; Scanner a = new Scanner(System.in);int num = a.nextInt(); Scanner b = new Scanner(System.in);String name = b.nextLine();可见： 先用一个创建的对象接收输入的值，再定义一个新的变量 接收输入对象 改变类型之后的值 2019.10.5private static private不可以和static同时用 private：对象的属性，构造函数； 对象的行为(功能函数)一般用public让调用者调用？ static:静态不能访问非静态（静态随类先加载） 单例模式———创建本类中对象饿汉式：一上来就创建对象 class Teacher{ private String name; private static Teacher single = new Teacher(“xx”);//创建本类中对象 private Teacher(String name) //private构造函数以及函数都不可以被调用，只能在类中调用，也就是说当private 属性和行为和构造函数时，都要设置相应的public函数 {this.name = name;} //记得加this. 表示此对象中的属性 public static Teacher build() { return single;} //主函数中调用此public函数完成对象a的指向 本类中创建的对象（单例） public String getname() {return single.name;} } public static void main(String[] args) {Teacher a = Teacher.build(); System.out.println(a.getname()); } 懒汉式：先创建对象指针，再在创建单例函数中创建对象（开辟空间），使用构造函数 class Teacher{ private String name; private Teacher(String name) {this.name = name;} private static Teacher single = null; //一定注意指针先赋值为空指针 public static Teacher build(String name) { single = new Teacher(name);return single; //返回已经构建好的对象指针？ } public String getname() {return single.name;}} public static void main(String[] args) {Teacher a = Teacher.build(&quot;xx&quot;); System.out.println(a.getname()); }","categories":[{"name":"java","slug":"java","permalink":"https://lucifinil-x.github.io/categories/java/"}],"tags":[{"name":"bug","slug":"bug","permalink":"https://lucifinil-x.github.io/tags/bug/"},{"name":"java","slug":"java","permalink":"https://lucifinil-x.github.io/tags/java/"}]},{"title":"博客文章编辑格式","slug":"博客文章编辑格式","date":"2019-09-09T06:47:58.000Z","updated":"2019-09-11T06:54:10.000Z","comments":true,"path":"2019/09/09/博客文章编辑格式/","link":"","permalink":"https://lucifinil-x.github.io/2019/09/09/博客文章编辑格式/","excerpt":"插入格式插入链接 超链接： []链接名+()网址Lucifinil’s blog 自动链接： &lt;&gt;网页地址Lucifinil’s blog https://lucifinil-x.github.io/ 插入图片 本地图片：!+[]图片名+()网址 或()/next主题文件夹下/images/图片名 url链接图片： ！名","text":"插入格式插入链接 超链接： []链接名+()网址Lucifinil’s blog 自动链接： &lt;&gt;网页地址Lucifinil’s blog https://lucifinil-x.github.io/ 插入图片 本地图片：!+[]图片名+()网址 或()/next主题文件夹下/images/图片名 url链接图片： ！名 字体效果 斜体字体: * * 中添加文字 加粗字体: ** ** 中添加文字 斜体加粗字体： * * 中添加文字 横线分行 加上横线 : 三个 - 再回车后加内容 引用 单行引用: ``中加内容 多行引用： 三个点中加内容或代码块 123456多行引用： &lt;html&gt; &lt;head&gt; &lt;title&gt;我是标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt; &lt;/html&gt; 引用文章 : &gt; +内容 隐藏 隐藏内容需阅读全文: ““（自由设置）或在主题config里 设置123auto_excerpt:enable: truelength: 50 sublime 和 typora都可以同时编辑文章，typora加图片方便","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://lucifinil-x.github.io/categories/博客搭建/"}],"tags":[{"name":"格式","slug":"格式","permalink":"https://lucifinil-x.github.io/tags/格式/"}]},{"title":"lucifinil的博客计划~","slug":"lucifinil的博客搭建计划","date":"2019-09-07T09:39:36.000Z","updated":"2020-04-15T21:15:01.182Z","comments":true,"path":"2019/09/07/lucifinil的博客搭建计划/","link":"","permalink":"https://lucifinil-x.github.io/2019/09/07/lucifinil的博客搭建计划/","excerpt":"搭建就做了好几天，还有一些主题优化没有成功和待完成的~~ 未成功 添加背景图片 背景及点击动态 添加字数检索和阅读时间","text":"搭建就做了好几天，还有一些主题优化没有成功和待完成的~~ 未成功 添加背景图片 背景及点击动态 添加字数检索和阅读时间 待完成 添加live 2d看板娘 改变字体 添加扫码关注的公众号图片 在github上备份博客 注意事项 每周将博客文章上传更新至百度云备份 每天坚持把心得学习内容总结成笔记更新博客文章 写博客用的软件 sublime text, 在d盘","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://lucifinil-x.github.io/categories/博客搭建/"}],"tags":[]},{"title":"搭建博客","slug":"博客搭建问题解决办法","date":"2019-09-07T09:28:07.000Z","updated":"2020-06-30T20:24:13.584Z","comments":true,"path":"2019/09/07/博客搭建问题解决办法/","link":"","permalink":"https://lucifinil-x.github.io/2019/09/07/博客搭建问题解决办法/","excerpt":"404问题和网页加载出来没有框架的问题 删除blog主文件下的第一个xxx.git文件夹（可用360强力删除） 修改回上一步之前修改的内容： 比如在config里本来是有#隐藏的文件路径， 实际上next主题并没有生成这个路径。 那么把自己新建的文件删除 把#在config里加回去 blog主文件夹下右键打开 git bash here hexo clean,hexo g,hexo s 三部曲","text":"404问题和网页加载出来没有框架的问题 删除blog主文件下的第一个xxx.git文件夹（可用360强力删除） 修改回上一步之前修改的内容： 比如在config里本来是有#隐藏的文件路径， 实际上next主题并没有生成这个路径。 那么把自己新建的文件删除 把#在config里加回去 blog主文件夹下右键打开 git bash here hexo clean,hexo g,hexo s 三部曲 /c/Users/A/AppData/Roaming/npm/hexo: line 12: node: command not found 环境变量是在操作系统中一个具有特定名字的对象，它包含了一个或者多个应用程序所将使用到的信息。例如Windows和DOS操作系统中的path环境变量，当要求系统运行一个程序而没有告诉它程序所在的完整路径时，系统除了在当前目录下面寻找此程序外，还应到path中指定的路径去找。用户通过设置环境变量，来更好的运行进程。环境变量一般是指在操作系统中用来指定操作系统运行环境的一些参数，比如临时文件夹位置和系统文件夹位置等。 搜索控制面板 ——&gt; 系统 ——&gt; 高级系统设置 ——&gt; 环境变量 ——&gt; 下面的框系统变量里 Path编辑： 本机系统自带的：%SystemRoot%\\system32;%SystemRoot%;%SystemRoot%\\System32\\Wbem; 自己需要添加的：D:\\blog\\node_modules\\hexo\\binD:\\MinGW\\MinGW\\binC:\\Program Files\\nodejsD:\\blog\\node_modules\\hexo\\binC:\\Program Files\\MySQL\\MySQL Server 5.7\\bin （mysql的与hexo无关） 千万不能自己写一个path将系统自带的覆盖掉，覆盖了就自己先添加系统的。 4000端口占用 打开cmd 查询占用：netstat -aon|findstr “4000” 查看对应占用进程：tasklist|findstr “xxxx” 杀掉对应进程：taskkill /f /t /im node.exe 然后关掉cmd会出现git bash hexo s虽然搭建成功 但是无法用ctrl+c退出 右上角关闭之后再hexo s虽然报错端口占用 但是本地网页已经更新 本地页面更新，但部署的网页不更新？ 可能原因1（不用）：4000 端口占用 localhost:4000 端口被占用，可执行 hexo s -p 5000 修改成5000 端口 可能原因2（基本都是这个）： 刷新问题 网页输入网址或f5刷新，hexo g, hexo s, hexo d多来几遍 解决步奏【高亮！】： hexo g, hexo s生成本地4000页面，右上角关闭，hexo d，进入网页，没有刷新，按F5刷新，就出来了 YAMLException: end of the stream or a document separator is expected at line 4, column 13: 更新失败，博客上直接没有这篇文章 原因：hexo博客规则改了，之前catpgories可以放几个，选择只能写一个了；catogories: xxx 之间要加空格，而且不能用 -xxx 修改了所有没更新出来的文章分类那里，都只分一个类了 文章点进去加载不出来 因为文章中图片太大，导致整个文章完全加载不出来。 windows文件路径与hexo部署链接不同导致网页和本地图片不能同时显示 windows路径是’&#39; hexo部署路径是’/‘ 解决：用路过图床生成的url链接替换图片路径 https://imgchr.com/lucifinil/albums路过图床网址 TypeError [ERR_INVALID_ARG_TYPE]: The “mode” argument must be integer.https://blog.csdn.net/qq_42138454/article/details/106210421 原因 node.js版本太高(14.4) 解决 电脑上搜索node，卸载，下载12.18并安装 注意 window上node不支持命令行操作，所以用软件自带的卸载。而且安装新版本之后不用再配环境。","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://lucifinil-x.github.io/categories/博客搭建/"}],"tags":[{"name":"bug","slug":"bug","permalink":"https://lucifinil-x.github.io/tags/bug/"},{"name":"解决办法","slug":"解决办法","permalink":"https://lucifinil-x.github.io/tags/解决办法/"},{"name":"搭建","slug":"搭建","permalink":"https://lucifinil-x.github.io/tags/搭建/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-09-07T09:19:30.799Z","updated":"2019-09-07T09:19:30.799Z","comments":true,"path":"2019/09/07/hello-world/","link":"","permalink":"https://lucifinil-x.github.io/2019/09/07/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}