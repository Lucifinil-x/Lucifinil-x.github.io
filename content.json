{"meta":{"title":"Sanctuary","subtitle":null,"description":null,"author":"Lucifinil","url":"https://lucifinil-x.github.io","root":"/"},"pages":[{"title":"分类","date":"2019-09-08T10:05:38.000Z","updated":"2019-09-08T10:07:01.665Z","comments":true,"path":"categories/index.html","permalink":"https://lucifinil-x.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-09-08T09:54:57.000Z","updated":"2019-09-08T09:59:47.090Z","comments":true,"path":"tags/index.html","permalink":"https://lucifinil-x.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"springboot学习","slug":"springboot学习","date":"2020-02-19T09:04:25.000Z","updated":"2020-04-15T21:15:28.237Z","comments":true,"path":"2020/02/19/springboot学习/","link":"","permalink":"https://lucifinil-x.github.io/2020/02/19/springboot学习/","excerpt":"注解@XXX的理解 spring引入注解，让注解与java bean紧密结合，减少了配置文件（.xml文件）的体积，增加了java bean的可读性和内聚性。","text":"注解@XXX的理解 spring引入注解，让注解与java bean紧密结合，减少了配置文件（.xml文件）的体积，增加了java bean的可读性和内聚性。 @Autowired注解：自动找和注入组件类、接口实现类，接着就能用他们了 1.自动注入java类，@Autowired注解回去寻找一个java bean组件（@Bean是给spring容器中添加组件，函数返回值添加进容器中） @Autowired private UserRepository userRepository; 如果bean定义给去掉了，spring容器找不到就会抛出异常。如果不想抛出异常，找不到就认为这个属性为null的话：required值设置 false @Autowired（required = false） private UserRepository userRepository; 但其实没有@Bean也能找到并且注入一个接口，而且直接可以调用实现接口的子类的方法 2.自动注入java接口的实现类： 比如：接口Car;实现类A implements Car;实现类B implements Car; @Service public class CarFactory { @Autowired @Qualifier(&quot;B&quot;) //两个实现类，指明调用B类的carName方法 private Car car; //多态 public String toString() { return car.carName(); } } @Resource注解：根据name和type找和注入组件类、接口实现类，接着就能用他们了 @Servicepublic class Zoo{ @Resource(name = &quot;tiger&quot;) private Tiger tiger; @Resource(type = Monkey.class) private Monkey monkey; public String toString() { return tiger + monkey; }} @Service注解： 声明Zoo.java是一个bean容器，其他类就能够@Autowired把zoo类当做是成员变量来使用; Zoo.java在bean中的id为”zoo”.(类名小写)Thymeleaf模板 Spring Boot 推荐使用 Thymeleaf 来代替 Jsp Thymeleaf 是一款用于渲染 XML/XHTML/HTML5 内容的模板引擎。类似 JSP,它也可以轻易的与 Spring MVC 等 Web 框架进行集成作为 Web 应用的模板引擎。能够直接在浏览器中打开并正确显示模板页面，而不需要启动整个 Web 应用。 页面即原型,整个页面直接作为 HTML 文件用浏览器打开，几乎就可以看到最终的效果，这大大解放了前端工程师的生产力，它们的最终交付物就是纯的 HTML/CSS/JavaScript 文件。 从springboot官方文档学习做helloXXX html页面 效果：运行后打开localhost:8080/greeting?name=xyt 这个网页页面就会显示出Hello, xyt! 官方文档https://spring.io/guides/gs/serving-web-content/ resources文件夹下放置静态文件，其中templates里放web文件 目前能够想到的组件，在spring官方文档里都是有的。复制粘贴。 pom.xml里加thymeleaf依赖 12345678910111213141516171819@Controller //允许这个类接收前端的请求public class GreetingController &#123; @GetMapping(&quot;/greeting&quot;) //网址的路径 public String greeting( @RequestParam(name=&quot;name&quot;, //@RequestParam()定义接收参数是什么，网址那里？name=xxx ,这个&quot;name&quot;就会以键值对的方式传到服务端，这样我们就会接收到这个value值。 required=false,没有接收到值也不会报错，默认值为world. required=false, defaultValue=&quot;World&quot;) String name, Model //接收到的值是String类型。这里逗号之前都是第一个参数 model) &#123; model.addAttribute(&quot;name&quot;, name); //model添加&quot;键&quot;值对的属性。Model则将获取到的值传递到这个页面上去显示，spring帮我们注入进去了。 return &quot;greeting&quot;; //return值&quot;greeting&quot;会去template中找同名的html文件:greeting.html，把他渲染成网页。这个需要自己去template中添加。 &#125;&#125; 在application.java的同一级或下一级的@Bean组件都能自动加载入容器中。 eclipse里创建的html文件编辑内容要右键openwith。12345678910&lt;!DOCTYPE HTML&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;title&gt;Getting Started: Serving Web Content&lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;&lt;/head&gt;&lt;body&gt; &lt;p th:text=&quot;&apos;Hello, &apos; + $&#123;name&#125; + &apos;!&apos;&quot; /&gt; //网页显示出Hello,XXX!&lt;/body&gt;&lt;/html&gt; 做社区网站项目第一章 网站网页的功能划分 导航（菜单栏），有很多功能分类：搜索，登录按钮 标签tag列表 话题列表，排序方式：时间倒序、推荐、热门、消灭零回复话题列表元素：发布人、发布时间、评论数、浏览数、回复数、关注数、 热门话题 热门用户 分页 第二章 做社区的菜单栏导航条 用UI框架Bootstrap快速搭建前端的站点。Bootstrap介绍：简洁、直观、强悍的前端开发框架，让web开发更迅速、简单 第一步 下载Bootstrap https://v3.bootcss.com/getting-started/#download下载并将文件粘贴到static文件夹下 第二步 写index.html 写入css,js文件 1234567891011&lt;!DOCTYPE HTML&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;title&gt;路西斐尔的尼伯龙根&lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/bootstrap.min.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/bootstrap-theme.min.css&quot;/&gt; &lt;script src=&quot;js/bootstrap.min.js&quot; type=&quot;application/javascript&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt; 在Bootstrap网页上找到组件页面，找导航条，将代码复制粘贴到index.html中的body中 根据实例中每个框框中的单词，将body中对应的单词改成自己的。 删掉不要的url，icon代码块 第三步 写IndexController.java12345678@Controllerpublic class IndexController &#123; @GetMapping(&quot;/&quot;) //根路径，代表8080就是index.html渲染出来的页面 public String index() &#123; return &quot;index&quot;; &#125;&#125; 第三章 申请github app登录授权 授权登记页面 https://github.com/settings/applications/1228484 第四章 做登录callback，拿到参数第一步 做登录按钮的github授权登录输账号密码页面 GitHub需要的内容文档 https://developer.github.com/apps/building-oauth-apps/authorizing-oauth-apps/ index.html登录那一行加入自己申请过的授权信息 1&lt;li&gt;&lt;a href=&quot;https://github.com/login/oauth/authorize?client_id=51a87c000499eea9d39a&amp;redirect_uri=http://localhost:8080/callback&amp;scope=user&amp;state=1&amp;&quot;&gt;登录&lt;/a&gt;&lt;/li&gt; 在输入密码之后会到callback页面，这时候显示404，因为还没做callback页面。http://localhost:8080/callback?code=57679f8624ad1ef794bd&amp;state=1网址上会显示一串code,之后就需要接收到这个参数code和参数state，用@RequestParam 第二步 做callback页面，接收到callback的code 新建AuthorizeController.java1234@GetMapping(&quot;/callback&quot;) //当他登录后到callback时，就让他跳转回index页面 public String callback( @RequestParam(name=&quot;code&quot;) String code , //第一个参数name为code，第二个为state @RequestParam(name=&quot;state&quot;) String state) &#123; return &quot;index&quot;; 第三步第五章 写配置文件，分离变量数据和固定代码第一步 将文件中的数据值用参数占位，在配置文件中赋值1234@Value(&quot;$&#123;github.client.id&#125;&quot;) //value中为键，他会去配置文件中找对应键的值，且赋值给参数clientId private String clientId;配置文件： github.client.id=51a87c000499eea9d39a //键值对 第六章 登录成功保持登录状态Session 和 Cookie Session:银行账户，账户所有信息都在银行数据库中（服务器就相当于银行） Cookie:银行卡，要操作账户中信息比如余额，需要知道银行卡 第七章 callback页面404，控制台不打印原因高亮！ 所有的文件和包一定要放在启动类/包下面，否则run时是不可能启动这些类的，控制台也不会打印。 springboot和shiro整合-权限管理实战第一章 Controller类1234567891011121314151617181920212223// 第一种getmapping注解 @GetMapping(&quot;/hello&quot;) public String hello() &#123; System.out.println(&quot;UserController.hello()&quot;); return &quot;ok&quot;; &#125; @GetMapping(&quot;/testThymeleaf&quot;) public String testThymeleaf(Model model) &#123; model.addAttribute(&quot;name&quot;,&quot;xyt&quot;); return &quot;test&quot;; &#125;//第二章requestmapping+requestbody @RequestMapping(&quot;/hello&quot;) @ResponseBody public String hello() &#123; System.out.println(&quot;UserController.hello()&quot;); return &quot;ok&quot;; &#125; @RequestMapping(&quot;/testThymeleaf&quot;) public String testThymeleaf(Model model) &#123; model.addAttribute(&quot;name&quot;,&quot;xyt&quot;); return &quot;test&quot;; &#125; @RequestMapping(“/hello”)@ResponseBody是返回字体（将实体类转化为json） @RequestMapping(“/hello”)是返回html 12345@RequestMapping(&quot;/update&quot;) public String update() &#123; System.out.println(&quot;UserController.hello()&quot;); return &quot;/user/update&quot;; &#125; 返回到update.html要加前面的路径。如：return “index”; index.html在trmplates包直接下面如：return “/user/update”;update.html在trmplates包下面user包下面 第二章shiro 核心APISubject: 用户主体 (把操作交给SecurityManager,要关联它)SecurityManager: 安全管理器 （关联Reaml）Realm: Shiro连接数据的桥梁,执行认证和授权。认证中具体实现用户名和密码匹配 第三章 springboot和shiro整合导入shiro和spring整合依赖12345&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt;&lt;/dependency&gt; 编写shiro配置类 @Configurartion 放在启动类子包Shiro子包Shiro中自定义Realm类，继承AuthorizingRealm类，实现认证和授权方法写shiro配置类 创建ShiroFilterFactoryBean对象，@Bean放入spring的环境，上面的方法就可以使用 创建DefaultWebSecurityManager对象，@Bean放入spring的环境 创建Realm对象，@Bean放入spring的环境 1234567891011121314151617181920212223@Configurationpublic class ShiroConfig &#123; @Bean //过滤拦截器 public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier(&quot;securityManager&quot;) DefaultWebSecurityManager securityManager ) &#123; ShiroFilterFactoryBean shiroFilterFactoryBean=new ShiroFilterFactoryBean(); shiroFilterFactoryBean.setSecurityManager(securityManager);//设置关联安全管理器 return shiroFilterFactoryBean; &#125; @Bean(name=&quot;securityManager&quot;) //安全管理器 public DefaultWebSecurityManager getDefaultWebSecurityManager(@Qualifier(&quot;userRealm&quot;)UserRealm userRealm) &#123; //@Qualifier合格者，去根据bean名字查找userRealm对象，拿一个 DefaultWebSecurityManager securityManager =new DefaultWebSecurityManager(); securityManager.setRealm(userRealm); //设置关联realm return securityManager; &#125; @Bean(name= &quot;userRealm&quot;) //执行授权器 public UserRealm getRealm() &#123; return new UserRealm(); &#125;&#125; 使用shiro内置过滤器，可实现页面权限相关的资源拦截 资源拦截逻辑：以键值对集合形式添加各个页面和对应的拦截规则。不同的拦截规则会跳转到（修改过的）不同的页面。authc：跳转到登录页面tologin(tologgin路径是login的html)，点击登录按钮后执行认证逻辑perms：进行授权逻辑，是否匹配perms字符串，不匹配跳转到拦截页面 在过滤拦截器中使用shiro内置过滤器，可以实现页面的拦截，和跳转页面。也可以用不同的过滤器放行一些页面。 常用的过滤器： anon:无需认证（登录）可以访问 authc:必须认证才可以访问 user:如果使用了rememberme的功能可以访问 perms:该资源必须授权资源权限才可以访问 role:该资源必须得到角色授权才可以访问 12345678910111213141516@Bean public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier(&quot;securityManager&quot;) DefaultWebSecurityManager securityManager ) &#123; ShiroFilterFactoryBean shiroFilterFactoryBean=new ShiroFilterFactoryBean(); //设置安全管理器 shiroFilterFactoryBean.setSecurityManager(securityManager); //添加shiro内置过滤器,将链接跳转页面和过滤器以键值对形式，加入hashmap集合 Map&lt;String,String&gt; filterMap = new LinkedHashMap&lt;String,String&gt;(); filterMap.put(&quot;/add&quot;, &quot;authc&quot;);//authc必须认证才能访问 filterMap.put(&quot;/update&quot;, &quot;authc&quot;); //修改跳转登录页面url, 每一个页面都要写一个controller，@RequestMapping对应路径 shiroFilterFactoryBean.setLoginUrl(&quot;/tologin&quot;); //安全管理器中添加集合的拦截，集合中添加的路径会按照键值对设置对应的拦截 shiroFilterFactoryBean.setFilterChainDefinitionMap(filterMap); return shiroFilterFactoryBean; 那么拦截成功就会自动跳转到http://localhost:8080/login，可自己修改跳转登录链接url如上，并且在controller类中写对应的@RequestMapping对应路径，并且写路径的页面html文件。（login.html） filterMap.put(“/test”, “anon”);让首页链接放行，无需认证（登录）可以访问，要注意顺序，这个在前面 filterMap.put(“/*”, “authc”); 这里可以让templates下面的全部资源使用过滤器，虽然他们都是user包下的，但是用根目录 超链接是写在首页test.html中,超链接点过去的跳转链接是写在Controller类中，并且写了return的html文件 12345678910111213&lt;!DOCTYPE HTML&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt; &lt;/meta&gt;&lt;title&gt;测试&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3 th:text=&quot;$&#123;name&#125;&quot;&gt;&lt;/h3&gt;&lt;hr/&gt;进入用户添加功能：&lt;a href=&quot;add&quot;&gt;用户添加&lt;/a&gt;&lt;br/&gt;进入用户更新功能：&lt;a href=&quot;update&quot;&gt;用户更新&lt;/a&gt;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt; 第四章 编写用户登录功能简单设计了一个登录页面login.html（之前的过滤拦截后的跳转页面，也是登录失败的返回页面）1234567891011121314151617&lt;!DOCTYPE HTML&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt; &lt;/meta&gt;&lt;title&gt;登录页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;这是拦截登录页面&lt;h3&gt;登录&lt;/h3&gt;&lt;h3 th:text=&quot;$&#123;msg&#125;&quot; style=&quot;color:red&quot;&gt;&lt;/h3&gt;&lt;form method = &quot;post&quot; action=&quot;login&quot;&gt; 用户名:&lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt;&lt;br/&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 为什么登录前后都用login.html?因为登录失败时model携带的msg信息才会与html中的msg匹配显示出来 点击登录按钮后跳转到login页面,编写login Controller的登录逻辑 接收 输入到login页面的用户名和密码，封装（添加）到token对象，吧token对象发给shiro。try catch判断登录成功或失败；成功返回test首页；失败 用model存储失败信息返回login页面。1234567891011121314151617181920212223//登录按钮后的跳转页面，实现逻辑处理 @RequestMapping(&quot;/login&quot;) //model中存入我们要return回login.html的信息,会吧存在里面的消息带回去，会在msg对应地方打印出错误消息 public String login(String name, String password, Model model) &#123; //使用shiro编写认证操作 //1.获取subject用户主体 Subject subject = SecurityUtils.getSubject(); //2.用token封装用户数据 UsernamePasswordToken token = new UsernamePasswordToken(name,password); //3.执行登录方法,执行过程中要传递用户的token给subject(就是传递给shiro) //如何判断是否信息无误：这段代码无任何异常 //shiro将异常/登录失败分的很清楚：UnknownAccountException e用户名不存在;IncorrectCredentialException密码错误 try &#123; subject.login(token); //无异常，登录成功跳转回首页test.html return &quot;test&quot;; &#125; catch (UnknownAccountException e) &#123; model.addAttribute(&quot;msg&quot;,&quot;用户名不存在&quot;); return &quot;redirect:/tologin&quot;;//重定向，请求到tologin路径,会执行tologin的controller,还是回到login.html &#125;catch(IncorrectCredentialsException e) &#123; model.addAttribute(&quot;msg&quot;, &quot;密码错误&quot;); return &quot;login&quot;;//所以直接回去也可以的 &#125; 编写realm的认证函数中：判断登录信息逻辑12345678910111213141516//执行认证逻辑,Authentication证明,这里接收到的就是controller中提交到shiro的token @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; System.out.println(&quot;认证&quot;); //现在先假设数据库的用户名和密码是 String name = &quot;xyt&quot;; String password = &quot;666&quot;; UsernamePasswordToken thistoken = (UsernamePasswordToken)token; //判断用户名和密码 if(!thistoken.getUsername().equals(name)) &#123; //shiro底层会抛出UnknownAccountException return null; &#125; //密码不需要判断。返回AuthenticationInfo的子类 return new SimpleAuthenticationInfo(&quot;&quot;,password,&quot;&quot;);//提交给login方法的，数据库密码(shiro会自动判断)，shiro的名字 &#125; 第五章 整合mybits实现用户登录认证 MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。 导入mybits相关依赖12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.9&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt; &lt;/dependency&gt; 在mysql sqlyog客户端中建一个数据库springboot_shiro，添加user表 写配置文件12345678910spring.datasource.driverClassName=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost/springboot_shiro?serverTimezone=UTC //url这里不用写主机ip,不用写3306（3306加上也可以成功运行）spring.datasource.username=root //用户名在sqlyog的客户端里数据库上面写的root@localhost,@前面的就是用户名spring.datasource.password= //密码记在手机里了spring.datasource.type=com.alibaba.druid.pool.DruidDataSourcemybatis.type-aliases-package=com.example.demo.domain //扫描包下的实体类 写com.example.demo.domain下的实体类User不加注解,与数据库数据中对应 name,id,password,getter,setter 写com.example.demo.mapper包下两个文件 写Dao: interface UserMapper接口 1234567import com.example.demo.domain.User;public interface UserMapper &#123; //查询 public User findByName(String name);&#125; 写映射文件： UserMapper.xml (一定要和上面的java文件名字一样)。这个文件里放CURD的sql语句,对应着上面接口中的函数实现 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapperPUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.example.demo.mapper.UserMapper&quot;&gt; &lt;select id = &quot;findByName&quot; parameterType=&quot;string&quot; resultType=&quot;User&quot;&gt; SELECT `id`, `name`, `password` //可以随意大小写，不用加引号 FROM user where name= #&#123;value&#125; //这个是占位符 &lt;/select&gt;&lt;/mapper&gt; 业务包servise 接口类UserService 1234public interface UserService &#123; public User findByName(String name);&#125; 实现类UserServiceImpl：来实现mapper接口，要加注解@Service 123456789101112131415@Servicepublic class UserServiceImpl implements UserService&#123; //注入Mapper接口 @Autowired private UserMapper userMapper; @Override //实现UserService的函数，参数传给userMapper的函数 public User findByName(String name) &#123; return userMapper.findByName(name); &#125;&#125; 修改启动类加上注解@MapperScan(“com.example.demo.mapper”)扫描mapper接口所在的包 在controller中注入业务123//注入业务 @Autowired private UserService userService; 在realm中注入业务，修改认证逻辑（去数据库中匹配用户名和密码）12345678910111213141516171819202122232425 //注入业务 @Autowired private UserService userService; //执行认证逻辑,Authentication证明,这里接收到的就是controller中提交到shiro的token @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; System.out.println(&quot;认证&quot;);// //现在先假设数据库的用户名和密码是// String name = &quot;xyt&quot;;// String password = &quot;666&quot;; UsernamePasswordToken thistoken = (UsernamePasswordToken)token; //现在已经连接了mysql数据库，写好了查询函数。然后这里就用获取到的name去找对应的password com.example.demo.domain.User user = userService.findByName(thistoken.getUsername()); //判断用户名和密码 if(user==null) &#123; return null;//shiro底层会抛出UnknownAccountException &#125; //密码不需要判断。返回AuthenticationInfo的子类 return new SimpleAuthenticationInfo(&quot;&quot;,user.getPassword(),&quot;&quot;);//提交给login方法的，数据库密码(shiro会自动判断)，shiro的名字 &#125;&#125; 第六章 整合mybits实现用户登录授权shiroconfig添加内置授权过滤/拦截器 perms： 该资源必须得到资源权限才可以访问1234567891011121314151617181920212223242526 @Bean public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier(&quot;securityManager&quot;) DefaultWebSecurityManager securityManager ) &#123; ShiroFilterFactoryBean shiroFilterFactoryBean=new ShiroFilterFactoryBean(); //设置安全管理器 shiroFilterFactoryBean.setSecurityManager(securityManager); //添加shiro内置过滤器,将链接跳转页面和过滤器以键值对形式，加入hashmap集合 Map&lt;String,String&gt; filterMap = new LinkedHashMap&lt;String,String&gt;();// filterMap.put(&quot;/add&quot;, &quot;authc&quot;);//authc必须认证才能访问// filterMap.put(&quot;/update&quot;, &quot;authc&quot;); filterMap.put(&quot;/test&quot;, &quot;anon&quot;); filterMap.put(&quot;/login&quot;, &quot;anon&quot;); //授权过滤器，登录过的user在add页面需要拿到add页面的授权才能访问 //在登录后点击添加时，就会进入授权逻辑 filterMap.put(&quot;/add&quot;, &quot;perms[user:add]&quot;); filterMap.put(&quot;/*&quot;, &quot;authc&quot;); //修改拦截的跳转登录页面url, 每一个页面都要写一个controller，@RequestMapping对应路径 shiroFilterFactoryBean.setLoginUrl(&quot;/tologin&quot;); //设置未授权的拦截页面：没有拿到某页面授权去访问某页面会跳转到/unAuth shiroFilterFactoryBean.setUnauthorizedUrl(&quot;/unAuth&quot;); //安全管理器中添加集合，以上设置的键值对拦截功能生效 shiroFilterFactoryBean.setFilterChainDefinitionMap(filterMap); return shiroFilterFactoryBean; reaml中写资源授权逻辑 逻辑：拦截过滤器添加了perms授权拦截，点到add页面就会进入授权逻辑。在进行授权逻辑时，就拿到了这个字符串，对应config那边的规则perms[user:add]，字符串匹配，授权完成，可访问正常add页面；若在授权逻辑中没有拿到相同字符串，被拦截，跳转unAuth页面。123456789@Overrideprotected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection arg0) &#123; System.out.println(&quot;执行授权逻辑&quot;); //资源授权 SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(); //添加授权字符串,在进行授权逻辑时，就拿到了这个字符串，对应config那边perms[user:add]，字符串匹配，授权完成，可访问 info.addStringPermission(&quot;user:add&quot;); return info; &#125; 改造上面的授权编码，让perms字符串更加灵活 在数据库中添加每个用户的perms 修改了表的结构，就要修改对应的实体类User结构,添加perms属性 我们需要取出数据库中的perms，需要在mapper接口中新定义一个根据id就能查找user对象的方法，然后在映射文件中写出对应的sql查询语句（相当于写出了这个具体函数方法） 在service接口中添加相同的方法 对应的在UserServiceImpl中实现这个方法：这里是调用mapper里写的sql函数return userMapper.findById(id); 第七章 thymeleaf和shiro标签整合使用导入thymleaf扩展坐标 加入扩展依赖 123456&lt;!-- thymel对shiro的扩展坐标 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.theborakompanioni&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-shiro&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt; &lt;/dependency&gt; shiroconfig中配置shiro的dialect(方言)，用于thymeleaf和 shiro标签配合使用 1234@Bean //交给spring容器 public ShiroDialect getShiroDialect() &#123; return new ShiroDialect(); &#125; 想要对于已登录用户，test主页只显示用户拿到授权的跳转超链接 修改test.html,将超链接部分加入包裹起来，并且加入shiro的permisson字符串但是这样在未登录情况也会判断授权字符串 1234567&lt;div shiro:hasPermission=&quot;user:add&quot;&gt;进入用户添加功能：&lt;a href=&quot;add&quot;&gt;用户添加&lt;/a&gt;&lt;br/&gt;&lt;/div&gt;&lt;div shiro:hasPermission=&quot;user:update&quot;&gt;进入用户更新功能：&lt;a href=&quot;update&quot;&gt;用户更新&lt;/a&gt;&lt;br/&gt;&lt;/div&gt; 继续加入，加在上面那些代码的上面。意思是：”url”，点登陆会超链接跳转到/tologin路径 1&lt;a href=&quot;tologin&quot;&gt;登录&lt;/a&gt; 此项目代码资源-eclipse链接：https://pan.baidu.com/s/1n8oLFCNfRk90kYmhNBAnBg提取码：o470 注：此外需要mysql中的同名数据库和表 14天黑马头条项目###","categories":[{"name":"springboot","slug":"springboot","permalink":"https://lucifinil-x.github.io/categories/springboot/"}],"tags":[]},{"title":"计算机系统","slug":"计算机系统","date":"2019-12-22T06:50:35.000Z","updated":"2020-04-15T21:20:18.792Z","comments":true,"path":"2019/12/22/计算机系统/","link":"","permalink":"https://lucifinil-x.github.io/2019/12/22/计算机系统/","excerpt":"CSE101 Q and A 内容###计算机系统4层体系结构 用户代码，软件，操作系统，硬件 （前二为程序员，用户层面）","text":"CSE101 Q and A 内容###计算机系统4层体系结构 用户代码，软件，操作系统，硬件 （前二为程序员，用户层面） 硬件 硬件举例： CPU，内存，硬盘hard disk, 键盘， 屏幕display screen 操作系统 将硬件系统的功能带出来 操作系统包围住硬件系统的好处： 易于编程，保护系统，公平和效率使用系统 组成成分 输入，输出，内存，CPU CPU ALU 中央处理器 central processing unit 进行计算和其他操作 运算器 arithmetic logical unit ALU 和 control unit 是CPU两个主要元件 处理器processor（CPU）遵循软件的指令处理数据 CPU只能执行加载进内存的指令 内存 系统内存 储存着CPU处理，存取的数据 次要存储： 硬盘hard disk, CD, DVD 系统内存中存储着 程序和数据 program and data ，由二进制表示的 接上，其中计算机知道哪里读取指令，哪里读取数据，虽然指令和数据都是二进制 输入输出设备 输入设备： 鼠标，键盘，扫描器Scanner 另：输入硬件设备将数据翻译成计算机能处理的形式 输出设备： 显示器Monitor, 扬声器Speaker, 打印机Printer WIMP 和 OS 主要是输入和输出设备： window, icon, menu, pointer （大概是电脑界面点击图标的意思） WIMP是操作系统OS在四十年中最重要的革新 操作系统OS需要分配公平的被保护的资源： 因为多线程容易死结deadlock, 同时保护硬件（用户不合理操作时） OS支持多任务操作时的功能： 内存管理，安全，分配CPU给每个程序 OS提供访问给网络设备facility: 通过API应用程序界面 ，例如socket interface 普通用途机器有OS特殊用途机器没有OS，只能高效率的做特定的事情 学习层面 程序运行时，计算机内部和程序底层–汇编 分层分区的好处 易于理解，易于设计，易于改变 服务器 Servers 通过 web-network-cloud 服务器是专门用于存储大量PC上数据和程序的工作平台 Dumb terminal:哑终端，一切程序交给主机做，主机不能做任何处理 向下兼容 Downward Compatibility 新软件能在旧硬件上运行 高速集成电路硬件描述语言- VHDL摩尔律 电路大小缩减一半 几个不同的注重 科学计算—Computation 计算 商业计算—Data 数据 个人计算机—Interaction 交互 Input-Process-Output模型 是数字电脑的基础结构 软件编程控制着Process 硬件，软件，（被操作的）数据 ，这三个原件实施Input-Process-Output模型 和 von Neumann 模型 其中von Neumann 模型是 Input-Process-Output模型 中的Process部分Process部分: Processor（应该是CPU） 和 Memory 互相连接传递数据interconnect CPU的读取速度快于主内存，也就是说主内存的速度不快，会拖慢整体交换链接数据的速度，CPU读取速度再快也没有用 von Neumann的机器中 数据和指令 共享同一内存 混合存放 Harvard结构 将数据和程序分离开存储提高了传输速率transfer rate 和生产力throughput但是数据和指令需要单独的存储器single reservoir像是指令缓存instruction cache 数据缓存data cache 指令集instruction set 没有指令标准 standard instruction 对于特殊用途的机器，指令集instruction set通常是固定的 高级编程语言HLL 优势： 用户友好， 编程方便 举例： java c c++ python 程序编译过程 Edit 变成HLL — Compile变成二进制对象文件 —-Link 变成可执行文件 —- Load 最后运行 Compiler编译器: HLL变成机成机器码 Assembler汇编器： 机器指令助记符变成二进制 另：汇编器将标签和内存地址链接在一起 Interpreter解释器： HLL指令解码decode变成中间代码Intermediate code,还是会变成机器码解释器在程序切换快，程序运行快，程序转移到另外平台上时比编译器更好用 Inline assembler内联汇编器： 可以在汇编段中调用c程序库中的函数 用户使用计算机时内部的工作流程 用户使用计算机系统算题的一般流程: ①通过系统操作员建立帐号，取得使用权。帐号既用于识别并保护用户的文件(程序和数据)，也用于系统自动统计用户使用资源的情况(记帐，付款)。 ②根据要解决的问题，研究算法，选用合适的语言，编写源程序，同时提供需处理的数据和有关控制信息。 ③把②的结果在脱机的专用设备上放入软磁盘，建立用户文件(也可在联机终端上进行，直接在辅助存储器中建立文件，此时第四步省去)。 ④借助软盘机把软盘上用户文件输入计算机，经加工处理，作为一个作业，登记并存入辅助存储器。 ⑤是要求编译。操作系统把该作业调入主存储器，并调用所选语言的编译程序，进行编译和连接(含所调用的子程序)，产生机器可执行的目标程序，存入辅助存储器。 ⑥要求运算处理。操作系统把目标程序调入主存储器，由中央处理器运算处理，结果再存入辅助存储器。 ⑦运算结果由操作系统按用户要求的格式送外部设备输出。 计算机内部工作(④~⑦)是在操作系统控制下的一个复杂过程。通常，一台计算机中有多个用户作业同时输入，它们由操作系统统一调度，交错运行。但这种调度对用户是透明的，一般用户无需了解其内部细节。 用户可用一台终端，交互式的控制③⑦的进行(分时方式);也可委托操作员完成③⑦，其中④~⑦是计算机自动进行的(批处理方式)。批处理方式的自动化程度高，但用户不直观，无中间干预。分时方式用户直观控制，可随时干预纠错，但自动化程度低。现代计算机系统大多提供两种方式，由用户选用。 代码分享方法 资源水平的子程序， 宏程序库macro libraries（问题： 谁维护，谁拥有） 预先翻译，可再定址的二进制库 动态库，动态link 库library 库可以link到程序代码，但不能修改 对于动态库，动态link有一个事实标准de-facto standard : Microsoft active 数据单位 bit,byte encode编码ASCII表用了7bit = 2的七次方大小表示一位，第一位表示正负 256bytes数据 可以存入 8bit system 内存地址从0000到00FF ： 1byte* (F16+F1)= 1516+151=256 bytes可以存入16bit system 内存地址从0000到007F ：2byte（716+F1）= 2（716+151）=256 bytes 编码表 ASCII表一位=1byte=8bit;1010 0101 1111 1000 = 16bytes 二进制文件一位=1bit; 1010 0101 1111 1000 = 16bits = 2bytes ASCII表最常用，EBCDIC现在已经不用了，被替代了 ASCII表不能编码除了英语和一些欧洲国家语言之外的字符 ASCII表分为字符和指令字符 printing and control characters 对于不同的表，编码速度没有差异 IEEE754 标准是最广泛使用的浮点转换二进制计算的标准 octal notation 是八进制声明变量时 告诉编译器预留内存空间 告诉编译器变量类型 线 bus 地址线，数据线，控制线 bus线的速度达不到（不匹配）CPU和内存交换的速度,就会让整体速度拖慢 bus一次一条线只能传一项item数据 协处理器coprocessor math, graphic 数学和图像应用程序 微处理器microprocessor 处理接收到的大量信息 存在于计算器，手机，平板，手表，MP3，照相机中 系统时钟system clock 系统时钟控制了所有计算机操作的执行速度 文件系统执行任务时的资源消耗 CPU时间资源，内存，硬盘空间 CPU time, memory, disk space 机器循环machine cycle 重要，注意是指令 过程： 获取指令–解码指令–执行–存储结果 main steps: fetch instruction–decode instruction–execute–store RISE CISE RISE的指令描述简单， CISE指令描述字多 processors that support fewer instructions than do SISC chips 指令执行寄存器 IP,IR,MAR,MBR 不同指令的获取fetch语句是相同的 不同指令的执行execute语句不同 CPU状态标志符Flag Zero flag： 为0，zf=1 Sign flag: 为负数 首位1， sf=1 Carry flag： 产生进位或退位为，cf=1 Overflow flag: 溢出， of=1 EFlage: CMP AL,BL (AL-BL) D flag: direction of processing O flag: Arithmetic overflow error 这些flag在指令执行之后才标记 CMP 后会改变flag，不是check 指令 Pentium奔腾指令集的指令从1到15字节的宽度（不确定），来加速指令解码 指令包含三个： 操作指令，操作数的数据类型，操作数的地址和结果 机器指令用不同的字段Distinct bit field来编码所需的操作内容 寄存器和寄存器之间的运算是最快的 函数 printf: 先进栈的最后打印出来 push顺序：先数字-再占位符-最后句子 call函数时：把EIP（指令指针）中的地址push到栈中， 再把函数地址放进EIP ret时： pop出最后存入栈的地址，放入EIP中 栈的框架下储存的数据类型： 子程序的参数，ret地址，EBP栈指针，局部变量 BCD码：将十进制的每一位0-9的数字转换成四位的二进制码 BCD码：将十进制的每一位0-9的数字转换成四位的二进制码 321的BCD码： 0011 0010 0001 321的二进制码： 101000001 1 byte(8bit)只能表示0-99（99就是 1111 1111） BCD的经济性不如二进制码binary（位数更多）， BCD计算更复杂， 但BCD和字符见的转换更加容易； 二进制表示更容易理解，BCD更容易理解用于某些业务应用程序 2’s complement 补码 正数补码不改变 负数（符号位1）补码： 符号位不变，其余位取反后加一 2’s complement会有溢出的情况： 两个整数相加变成负数 赞成者Pros: 基于two-state technology 易于实现 反对者Cons: 对于人难以理解 带符号整数相加会发生溢出怎么办： 用of sign检测:相加前后的of应该相同，如果不同就溢出了（不太清楚，可能是相加后同为负数或整数） 带符号整数减法是加法的另一种形式，同样也会溢出。加法溢出，减法溢出 10’s complementary convention十进制补充约定 n位数字表示为10’s complementary convention 是基于模module 10 十进制的互补表示: 0到499表示0到499， 500到999表示-500到-1 （-一千减x） 同样有溢出： 347+230= 577大于499溢出 ，577= -（1000-577）=-423 基础类型的bit大小: -2^(x-1 bit次方) 到 2^(x-1 bit次方)-1, 都要去掉符号位 byte: 8bit ,1byte short: 16bit ,2byte , -2^15到2^15 -1 long: 64bit ,8byte int: 32bit ,4byte IEEE754 1bit正负 8bit指数 23bit小数有效位数 ，不存小数点 把二进制小数 变成十进制小数：指数8位- 128+1 = 8位-10000000（2^7，8位）+1 = 整数 ，Excess-127格式小数23位： 1.xxxxxxxx （不用转换）计算 2^指数*1.xxxxxx NaN规范：指数位127，小数位不是0，此时NaN(not a number) 其他看不懂：单精度指数过剩excess notation 127;双精度指数过剩excess notation 1023 数据存储器 寄存器register（8bit,在CPU中） 到 缓存cache 到 内部内存main memory（RAM,ROM） 到 硬盘disk 越来越慢，空间越来越大，价格越来越便宜； 寄存器最快最小最贵 数据获取access的方法：顺序存储sequential storage会减慢数据检索retrieval的进程 Main memory 计算机内部，断电消失 RAM随时存取储存器：分两个DRAM动态，SRAM静态 ROM只读存储器 Cache高速缓存存储器 独立保存，断电不消失 硬盘 : 检索硬盘副本显示到屏幕上，如果检索之后不被修改，源文件不会被覆盖 光盘 ： 读道track U盘 电路combinational组合 sequential数列 logic circuits 组合逻辑电路没有记忆区memory ，数列逻辑电路有记忆区 卷子中的待解决问题 —今年只有选择题和汇编无问答 What is the mechanism being used to pass parameters to the C library function Answer the following questions based on IEEE 754 standard.(4marks each)a) What is the largest positive number represented by IEEE 754 single-precision format?b) What is the encoding of the number -123.625 in IEEE 754 single-precision format?c) What is the smallest normalisedpositive number represented by IEEE 754 single-precision format? 内联汇编 _asm{} 记住：push一次esp+4; 每次call完结算前面push次数， add esp,4n xchg交换值指令： xchg eax, [sei+4] 至少要有一个寄存器 调用： call printf ,call scanf_s 遍历数组存首地址 lea esi, intArray循环中 add eax, [esi]add esi, 4 mov esi, 0循环中 add eax, intArray[esi]inc esi","categories":[{"name":"记忆性学习","slug":"记忆性学习","permalink":"https://lucifinil-x.github.io/categories/记忆性学习/"}],"tags":[]},{"title":"游戏和开源项目学习","slug":"游戏和开源项目学习","date":"2019-11-27T06:20:48.000Z","updated":"2020-04-15T21:15:08.867Z","comments":true,"path":"2019/11/27/游戏和开源项目学习/","link":"","permalink":"https://lucifinil-x.github.io/2019/11/27/游戏和开源项目学习/","excerpt":"","text":"初心 想先做像页游那样的游戏，任务在家园里移动。感觉是可以实现的。","categories":[],"tags":[]},{"title":"mySQL","slug":"mySQL","date":"2019-09-14T05:26:06.000Z","updated":"2020-04-15T21:15:17.040Z","comments":true,"path":"2019/09/14/mySQL/","link":"","permalink":"https://lucifinil-x.github.io/2019/09/14/mySQL/","excerpt":"19.9.14安装 mysql5.7安装以及配置环境（注意：官网安装非常慢，打开迅雷复制官网下载网址链接下载安装）https://www.bilibili.com/video/av66542221","text":"19.9.14安装 mysql5.7安装以及配置环境（注意：官网安装非常慢，打开迅雷复制官网下载网址链接下载安装）https://www.bilibili.com/video/av66542221 19.9.15 语句超级容易输错单词,有无s什么的….. 19.9.16 感觉有点枯燥呢，加油","categories":[{"name":"数据库sql","slug":"数据库sql","permalink":"https://lucifinil-x.github.io/categories/数据库sql/"}],"tags":[]},{"title":"学习计划与心得","slug":"学习计划与心得","date":"2019-09-14T05:20:49.000Z","updated":"2020-04-15T21:15:18.905Z","comments":true,"path":"2019/09/14/学习计划与心得/","link":"","permalink":"https://lucifinil-x.github.io/2019/09/14/学习计划与心得/","excerpt":"19.9.14 希望每天保持八小时的有效学习时间，坚持记录笔记，多任务学习 英语老老实实背单词 文件要装好","text":"19.9.14 希望每天保持八小时的有效学习时间，坚持记录笔记，多任务学习 英语老老实实背单词 文件要装好 19.9.16 效率挺低的完全没办法做到做任务学习 19.9.17 备考雅思单词：会认与会写。 A4纸折八列，写单词和意思 ，折起来背 19.9.29 很久没有记录了，平时真的没什么时间，英语也很差，代码经常出问题，还是缺少练习 20.2.23 小匠笔记：学东西一定要先看官方网址文档。最开始学东西先用起来，不要死磕，之后多用就会了 创建包来隔离不同的业务 参数多于两个就要把他封装成对象 全部文件/包放在启动类所在包下面 初了解一个应用，一定去看它的官方文档","categories":[{"name":"学习计划","slug":"学习计划","permalink":"https://lucifinil-x.github.io/categories/学习计划/"}],"tags":[]},{"title":"java基础记录；java全栈开发（从入门到入坟）的笔记","slug":"java笔记","date":"2019-09-12T16:35:58.000Z","updated":"2020-04-15T21:15:04.415Z","comments":true,"path":"2019/09/13/java笔记/","link":"","permalink":"https://lucifinil-x.github.io/2019/09/13/java笔记/","excerpt":"安装 安装netbeans8.2 IDE 和jdk1.8.0 百度云传不了，放在u盘里的 注意如果netbeans出错了就把相关文件夹删干净（360强力删除）之后重装，会省时省力很多。","text":"安装 安装netbeans8.2 IDE 和jdk1.8.0 百度云传不了，放在u盘里的 注意如果netbeans出错了就把相关文件夹删干净（360强力删除）之后重装，会省时省力很多。 19.9.13数组定义数组 int [] arr = new int []{1,2,3,4,5};int [] arr = {1,2,3,4,5}; 自定义函数要写在主类class Main里，public static void main 的下面；数组作为自定义函数的参数时要写括号：public static int add(arr[])；main函数里调用自定义函数时参数只用写数组名（此时调用数组第一个数据的地址）： add(arr) ；而且调用函数的返回值用一个变量装载一下 ：int b = add(arr) 各种功能都写成函数再调用，不要写在主函数里 改变数组的自定义函数：返回类型为void（改变指针） 表 数组可以作为表： 当数据之间存在对应关系时，通过一方可以查询到另外一方。ex: 通过数组的索引查表（查找数组中的内容）,(这样比switch if 条件判断方便) 数组选择排序 从第一个依次向后比较，替换第一个；在从第二个依次向后比较，替换第二个….（小数向前挪动）12345678910111213141516171819202122232425262728293031323334353637 public class Main &#123; public static void main(String[] args) &#123; int arr[] =&#123;12,9,23,77,12,34&#125;; rank(arr); printArr(arr); &#125; public static void rank(int []arr ) &#123; for(int a =0; a&lt;arr.length-1; a++) &#123; for(int b = a+1; b&lt;=arr.length -1; b++) &#123; if(arr[a]&gt; arr[b]) &#123; int temp= arr[a]; arr[a]= arr[b]; arr[b]= temp; &#125; &#125; &#125; return ; &#125; public static void printArr( int arr[]) &#123; for(int x=0; x&lt; arr.length; x++) &#123; if(x == arr.length -1) System.out.println(arr[x]); else System.out.print(arr[x] + &quot;,&quot;); &#125; return; &#125;&#125; 数组冒泡排序 1-2比，2-3比，3-4比…(将每次比较的大值放在后面再和下一个数比较)，再重复1-2比，2-3比..1234567891011121314public static void rank(int []arr ) &#123; for(int a = 0; a&lt; arr.length-1; a++) &#123; for(int b = 0; b&lt;arr.length-1-a; b++) //【-a】这里为了实现每一次横向比较时，比较的次数都会随着横向比较次数的增加而递减（因为每次横向排序的末尾最后一个一定是最大的数，所以下一次横向比较时不再比较最后一个数） &#123; if(arr[b]&gt;arr[b+1]) &#123; int temp = arr[b]; arr[b]=arr[b+1]; arr[b+1]=temp; &#125; &#125; return ; &#125; &#125; 代码抽取 以上两个排序中的交换数组中数字位置部分的代码块重复，可自定义一个新功能，再调用（如冒泡排序中： swap(arr, b, b+1);）,方便使用提高复用性123456public static void swap(int arr[], int a, int b) //注意未知的都是参数： 数组不知道，交换位的角标不知道 &#123; int temp = arr[a]; arr[a]= arr[b]; arr[b] = temp; &#125; 使用程序包 以上数组排序功能都可在程序包内（需要自己下载），开发时直接import程序包，再调用就可以，不要自己写功能 19.9.14数组普遍查找 普遍查找数组中元素(遍历数组)，返回值为int(角标):return x；如果没有此元素，return -1 (代表不存在的情况) 二分查找 1、定义min、max、mid角标；2、比较mid和查找数据大小： 数据大，min=mid+1;数据小, max=mid-1; 3、循环；4、循环中判断查找的数据是否存在(存在条件max min之间有距离：min &lt;= max) 或者判断存在条件作为while循环条件，会更加简洁1234567891011121314151617181920212223242526272829public static void main(String[] args) &#123; int arr[] =&#123;9,12,15,24,36,41,59,68&#125;; rank(arr); int a =binarySearch(arr, 41); System.out.println(&quot;第&quot;+(a+1)+&quot;个是:&quot;+arr[a]); &#125; public static int binarySearch(int arr[], int key) &#123; int min, max, mid; min=0; max = arr.length -1; mid = (min + max)/2; while(arr[mid] != key) &#123; if(arr[mid]&lt; key) &#123; min = mid +1; mid = (min + max)/2; &#125; else if(arr[mid]&gt; key) &#123; max = mid -1; mid = (min + max)/2; &#125; //判断查找元素是否存在 if(max&lt;min) return -1; &#125; return mid; &#125; 19.9.18面向对象 对象：属性（数值，是变量）+ 行为（功能，是函数） 19.9.29数组 创建功能：传入数组参数，返回数组参数主函数中 &gt; + String arr[] = new String[6];public static String[] change (String [] arr) //定义中类型和参数都有括号 return arr; //返回值无括号主函数中接收返回值时直接 &gt; + String name [] = change(arr) //调用传值无括号 Scanner 首先在package 下面加上 import java.util.Scanner; Scanner a = new Scanner(System.in);int num = a.nextInt(); Scanner b = new Scanner(System.in);String name = b.nextLine();可见： 先用一个创建的对象接收输入的值，再定义一个新的变量 接收输入对象 改变类型之后的值 2019.10.5private static private不可以和static同时用 private：对象的属性，构造函数； 对象的行为(功能函数)一般用public让调用者调用？ static:静态不能访问非静态（静态随类先加载） 单例模式———创建本类中对象饿汉式：一上来就创建对象 class Teacher{ private String name; private static Teacher single = new Teacher(“xx”);//创建本类中对象 private Teacher(String name) //private构造函数以及函数都不可以被调用，只能在类中调用，也就是说当private 属性和行为和构造函数时，都要设置相应的public函数 {this.name = name;} //记得加this. 表示此对象中的属性 public static Teacher build() { return single;} //主函数中调用此public函数完成对象a的指向 本类中创建的对象（单例） public String getname() {return single.name;} } public static void main(String[] args) {Teacher a = Teacher.build(); System.out.println(a.getname()); } 懒汉式：先创建对象指针，再在创建单例函数中创建对象（开辟空间），使用构造函数 class Teacher{ private String name; private Teacher(String name) {this.name = name;} private static Teacher single = null; //一定注意指针先赋值为空指针 public static Teacher build(String name) { single = new Teacher(name);return single; //返回已经构建好的对象指针？ } public String getname() {return single.name;}} public static void main(String[] args) {Teacher a = Teacher.build(&quot;xx&quot;); System.out.println(a.getname()); }","categories":[{"name":"java","slug":"java","permalink":"https://lucifinil-x.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://lucifinil-x.github.io/tags/java/"},{"name":"bug","slug":"bug","permalink":"https://lucifinil-x.github.io/tags/bug/"}]},{"title":"lucifinil的博客计划~","slug":"lucifinil的博客搭建计划","date":"2019-09-07T09:39:36.000Z","updated":"2020-04-15T21:15:01.182Z","comments":true,"path":"2019/09/07/lucifinil的博客搭建计划/","link":"","permalink":"https://lucifinil-x.github.io/2019/09/07/lucifinil的博客搭建计划/","excerpt":"搭建就做了好几天，还有一些主题优化没有成功和待完成的~~ 未成功 添加背景图片 背景及点击动态 添加字数检索和阅读时间","text":"搭建就做了好几天，还有一些主题优化没有成功和待完成的~~ 未成功 添加背景图片 背景及点击动态 添加字数检索和阅读时间 待完成 添加live 2d看板娘 改变字体 添加扫码关注的公众号图片 在github上备份博客 注意事项 每周将博客文章上传更新至百度云备份 每天坚持把心得学习内容总结成笔记更新博客文章 写博客用的软件 sublime text, 在d盘","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://lucifinil-x.github.io/categories/博客搭建/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-09-07T09:19:30.799Z","updated":"2019-09-07T09:19:30.799Z","comments":true,"path":"2019/09/07/hello-world/","link":"","permalink":"https://lucifinil-x.github.io/2019/09/07/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}