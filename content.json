{"meta":{"title":"Sanctuary","subtitle":null,"description":null,"author":"Lucifinil","url":"https://lucifinil-x.github.io","root":"/"},"pages":[{"title":"分类","date":"2019-09-08T10:05:38.000Z","updated":"2019-09-08T10:07:01.665Z","comments":true,"path":"categories/index.html","permalink":"https://lucifinil-x.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-09-08T09:54:57.000Z","updated":"2019-09-08T09:59:47.090Z","comments":true,"path":"tags/index.html","permalink":"https://lucifinil-x.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"SpringBoot踩坑记录","slug":"SpringBoot踩坑记录","date":"2020-02-29T18:51:25.000Z","updated":"2020-02-29T22:32:25.087Z","comments":true,"path":"2020/03/01/SpringBoot踩坑记录/","link":"","permalink":"https://lucifinil-x.github.io/2020/03/01/SpringBoot踩坑记录/","excerpt":"代码对比完全一致，callback页面404，且控制台不打印 血的教训：所有java包和类放在启动类所在的包里，否则run不运行这些类，但控制台不报错。","text":"代码对比完全一致，callback页面404，且控制台不打印 血的教训：所有java包和类放在启动类所在的包里，否则run不运行这些类，但控制台不报错。 报错 BeanFactory 和bean一点关系也没有，原因： mapper映射文件中映射的mapper类的包名少写了一个mapper。而且这是最初没有写错的，是在试着改bug的时候改掉的。 1&lt;mapper namespace=&quot;com.example.demo.mapper.UserMapper&quot;&gt; 一定要先对照代码，特别是xml配置文件！写错没提示。 local网页自动跳转到我印象中没有写的页面toLogin 原本以为是之前运行的项目没关干净，测试了其他项目可以运行，网页跳转没有问题。那么一定是这个项目的代码哪里写错了。 发现并不是controller中的问题，是ShiroConfig类中粘贴代码没删掉拦截和自动跳转toLogin. 整合mybits实现用户登录，连接sql数据库。网页输入时控制台报错 目前正确配置文件的代码：12345678910spring.datasource.driverClassName=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost/springboot_shiro?serverTimezone=UTC //url这里不用写主机ip,不用写3306（3306加上也可以成功运行）spring.datasource.username=root //用户名在sqlyog的客户端里数据库上面写的root@localhost,@前面的就是用户名spring.datasource.password= //密码记在手机里了spring.datasource.type=com.alibaba.druid.pool.DruidDataSourcemybatis.type-aliases-package=com.example.demo.domain 报错 mysql access deny for 找了很久的报错 原因：spring.datasource.url=jdbc:mysql://localhost:3306/test 粘贴代码的时候没有改成自己的数据库名字，改回来就继续报错下面的问题，不过下面的问题都能百度到。 一定要检查代码每个字，在配置文件中写错是没有提示的而且很难发现，昨天的错误就是配置文件中少写了一个包名，报错提示完全和配置文件不沾边。 不知道是不是原因:之前没有添加jdbc的依赖 测试mysql数据库密码：搜索mysql会出来mysql的命令行打开就是要输入password控制台提示：Loading class com.mysql.jdbc.Driver&#39;. This is deprecated. The new driver class iscom.mysql.cj.jdbc.Driver’. 不会影响运行 在总配置文件中修改 报错com.alibaba.druid.pool.DruidDataSource: create connection error druid依赖版本/数据库连接池的包版本需要改成新版本 1234567&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.9&lt;/version&gt;&lt;/dependency&gt;``` 版本修改为： com.alibaba druid 1.1.10 1234- 以后报错还得改成更新版本### 报错The server time zone value &apos;�й���׼ʱ��&apos; is unrecogni- 在MySQL的URL后面加上“?serverTimezone=UTC” ，如下所示： spring.datasource.url=jdbc:mysql://localhost/springboot_shiro?serverTimezone=UTC 123## shiro授权过滤器没用- 键值对集合中只能一个key一个value，具体为什么不行我不知道。 filterMap.put(&quot;/add&quot;, &quot;authc&quot;);//authc必须认证才能访问 filterMap.put(&quot;/update&quot;, &quot;authc&quot;); //授权过滤器，登录过的user在add页面需要拿到add页面的授权才能访问 //在登录后点击添加时，就会进入授权逻辑 filterMap.put(&quot;/add&quot;, &quot;perms[user:add]&quot;);1修改为 filterMap.put(“/test”, “anon”); filterMap.put(“/login”, “anon”); //授权过滤器，登录过的user在add页面需要拿到add页面的授权才能访问 //在登录后点击添加时，就会进入授权逻辑 filterMap.put(“/add”, “perms[user:add]”); filterMap.put(“/*”, “authc”);``` 一直标红其他代码没有问题 删掉，重新自动添加方法就不红了。 还是爆红，运行了没报错，不报红了 报错 sql syntax error sql语句 select xx from 中间没有逗号 其他的部分大小写 整数类型写int","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://lucifinil-x.github.io/categories/博客搭建/"}],"tags":[{"name":"bug","slug":"bug","permalink":"https://lucifinil-x.github.io/tags/bug/"},{"name":"解决办法","slug":"解决办法","permalink":"https://lucifinil-x.github.io/tags/解决办法/"}]},{"title":"人工智能入门学习","slug":"人工智能入门学习","date":"2020-02-23T18:21:16.000Z","updated":"2020-02-24T11:28:24.577Z","comments":true,"path":"2020/02/24/人工智能入门学习/","link":"","permalink":"https://lucifinil-x.github.io/2020/02/24/人工智能入门学习/","excerpt":"CSE112 鸡肋，过时，繁杂，背书30% 两次课上考试，80%是以前原题，一个个人assignment，去年是prolog解决算法问题70% 期末，概念和大题，背书只有这个文件夹里有题的资料，概念总结和当堂测试题目","text":"CSE112 鸡肋，过时，繁杂，背书30% 两次课上考试，80%是以前原题，一个个人assignment，去年是prolog解决算法问题70% 期末，概念和大题，背书只有这个文件夹里有题的资料，概念总结和当堂测试题目 introduction机器学习和AI技术的功能 Machine learning and Artificial intelligence will be used to analyze the data and provide a better service to human activities. AI covers a wide range of technologies including: image/speech recognization, language processing, user profiling剖析(data visualization), recommandation system. The boundaries between cloud computing and big data becomes blurred.变模糊 intelligent image captioning智能给图片加文字注解 It is evolving to learn from data. 什么是AI AI is the activity that is related to people’s thinking,such as decision making,problem solving, learning. 电脑语音合成 computer speech synthesis translate text to phonetic form","categories":[{"name":"学习","slug":"学习","permalink":"https://lucifinil-x.github.io/categories/学习/"}],"tags":[]},{"title":"操作系统原理","slug":"操作系统原理","date":"2020-02-23T17:45:15.000Z","updated":"2020-02-27T11:04:26.602Z","comments":true,"path":"2020/02/24/操作系统原理/","link":"","permalink":"https://lucifinil-x.github.io/2020/02/24/操作系统原理/","excerpt":"","text":"抽象难学20%80% 期末考，没有选择，全是大题：概念复述和计算","categories":[{"name":"学习","slug":"学习","permalink":"https://lucifinil-x.github.io/categories/学习/"}],"tags":[]},{"title":"数据结构学习","slug":"数据结构学习","date":"2020-02-23T15:39:52.000Z","updated":"2020-02-23T17:25:59.062Z","comments":true,"path":"2020/02/23/数据结构学习/","link":"","permalink":"https://lucifinil-x.github.io/2020/02/23/数据结构学习/","excerpt":"","text":"CSE104 数据结构，介绍基本的数据结构和性质和用法。?% 两个assignment写java代码，一定要尽可能的细致，对于每一个可能的样本输入情况都要考虑周全。?% 期末考试，四分之三30道选择题和一道数据结构的大题，大题每年相似度很高。背书课：lecture slides, Q&amp;As, in-class &amp; take-home exercises, assignments","categories":[{"name":"学习","slug":"学习","permalink":"https://lucifinil-x.github.io/categories/学习/"}],"tags":[]},{"title":"算法学习","slug":"算法学习","date":"2020-02-23T15:22:57.000Z","updated":"2020-02-23T17:42:56.287Z","comments":true,"path":"2020/02/23/算法学习/","link":"","permalink":"https://lucifinil-x.github.io/2020/02/23/算法学习/","excerpt":"CSE102 算法基础，介绍基础排序算法、查询算法、图论、p与np问题、算法思想（分治、动规、贪心）。20% 两个assignment算法题6-7周，11-12周，基本是套路题目，只要按照一些固定的步奏就能写出来，越详细越好。80% 期末考试，四分之三选择题和四分之一两道算法大题。分治和动规的思想必考。可能会考前几年的原题。","text":"CSE102 算法基础，介绍基础排序算法、查询算法、图论、p与np问题、算法思想（分治、动规、贪心）。20% 两个assignment算法题6-7周，11-12周，基本是套路题目，只要按照一些固定的步奏就能写出来，越详细越好。80% 期末考试，四分之三选择题和四分之一两道算法大题。分治和动规的思想必考。可能会考前几年的原题。 思想###Divide and Conquer 分治思想把难以解决的大问题分解成几个子问题，找到求出这几个子问题的解法后，再找到合适的方法，把它们组合成求整个问题的解法。 EfficiencyBig-O 大O标记法 指worse-case下的时间复杂度。比如f(n)=13n^3+7nlogn的复杂度是O(n^3)，或者O(n^k)（k&gt;=3） Ω(n)和Θ(n)：前者是best-case下的时间复杂度。比如，f(n)=13n^3+7nlogn的复杂度是Ω(n^3)，或者Ω(n^2)，Ω(n)，Ω(1)等；后者是average-case下的时间复杂度，是O标记法与Ω标记法的结合：比如，f(n)=13n^3+7nlogn的复杂度是Θ(n^3)。 什么是algorithm 有限时间内完成一个task的一系列步骤 算法分析：对于一个算法，我们首要关注的是它的时间复杂度，其次是空间复杂度，以及输出是否为最优或是否接近最优。 算法分析：对于一个算法，我们首要关注的是它的时间复杂度，其次是空间复杂度，以及输出是否为最优或是否接近最优。 Sorting 排序Selection/Bubble/insertion 选择排序/冒泡排序/插入排序Merge-sort 并归排序 分治思想的典型应用 先把数组对半拆分到最小，而后两两比较排序后合并，重复这一步骤直至整个数组排序完成 在每个递归步骤中，划分每个子列表最多需要O(n)时间；合并每个级别中的所有列表最多也需要O(n)时间；递归需要的次数最多为O(log n)次。因此，MergeSort的运行时间为O(n log n)。 Count sorting 计数排序 步奏: 1.一串数字中max-min+1取得这串整数的范围k2.遍历一串数字，遍历到的数字-min的值对应到数组count[k]的下标，其值加一。 3.遍历数组count[k]，输出每个的值，重复值数次。123456789101112131415161718192021222324252627282930313233public static int[] countSort(int[] array) &#123; //1.得到数列的最大值与最小值，并算出差值d int max = array[0]; int min = array[0]; for (int i = 1; i &lt; array.length; i++) &#123; if (array[i] &gt; max) &#123; max = array[i]; &#125; if(array[i] &lt; min) &#123; min = array[i]; &#125; &#125; //2.创建统计数组并计算统计对应元素个数 int d = max - min; int[] countArray = new int[d + 1]; for (int i = 0; i &lt; array.length; i++) &#123; countArray[array[i] - min]++; //厉害.. &#125; //3.统计数组变形，后面的元素等于前面的元素之和 //看不懂要干嘛 int sum = 0; for (int i = 0; i &lt; countArray.length; i++) &#123; sum += countArray[i]; countArray[i] = sum; &#125; //4.倒序遍历原始数组，从统计数组找到正确位置，输出到结果数组 int[] sortedArray = new int[array.length]; for (int i = array.length - 1; i &gt; 0; i--) &#123; sortedArray[countArray[array[i] - min] - 1] = array[i]; countArray[array[i] - min]--; &#125; return sortedArray; &#125; https://www.cnblogs.com/kyoner/p/10604781.html 如果原始数列的规模是N，最大最小整数的差值是M，由于代码中第1、2、4步都涉及到遍历原始数列，运算量都是N，第3步遍历统计数列，运算量是M，所以总体运算量是3N+M，去掉系数，时间复杂度是O(N+M)。 至于空间复杂度，如果不考虑结果数组，只考虑统计数组的话，空间复杂度是O(M)。 -两大局限性：1.当数列最大最小值差距过大时，并不适用于计数排序比如给定20个随机整数，范围在0到1亿之间，此时如果使用计数排序的话，就需要创建长度为1亿的数组，不但严重浪费了空间，而且时间复杂度也随之升高。 2.当数列元素不是整数时，并不适用于计数排序正是由于这两大局限性，才使得计数排序不像快速排序、归并排序那样被人们广泛适用。 它的复杂度为Ο(n+k)（其中k是整数的范围），它适用于一定范围的整数排序。在取值范围不是很大的情况下，它的性能在某些情况甚至快于任何比较排序算法O(nlogn)，例如快速排序、归并排序。 QuickSort 快速排序分治思想的另一种应用 遍历整个数组，将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小。然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 ricky总结（2,4）Tree 最少两个子代，最多四个子代 每个子代最多三个key 储存了n个item的(2,4) tree的高度是Θ(logn) Search、insertion和deletion的复杂度都是O(logn)，其中search是从上向下(top-down)，insertion和deletion是自底向上(bottom-up) Priority Queue 优先队列 和普通的队列相比，是最高级先出 通过堆实现优先级的筛选 Heap 堆 可以理解为用数组实现的二叉树 除了根节点，每个节点的key值都大于等于父代的key值 堆的插入：新节点首先加入到该二叉堆最后的一个节点，依据最小堆的定义，自底向上，递归调整。 堆的删除：二叉堆的删除一般只讨论如何删除堆顶元素。方法是最后一个节点替换到根节点，然后自顶向下，递归调整。 Heap-Sorting：堆排序算法对有着n个可比较项的序列S进行排序，所需时间为O(nlogn)。自底向上构建具有n个元素的堆需要O(nlogn)时间，并且从堆中提取n个元素（以递增顺序）需要O(nlogn)时间。 Experimental analysis：运行时间对输入大小的依赖性，需要对样本输入适当选择，并进行适当数量的测试。缺陷在于必须先实现算法、必须在有限的输入和同一硬件软件的条件下进行实验。 Theoretical analysis：相比上一种分析方法，可以考虑所有的输入；可以比较多个算法的效率（与硬件环境无关）；可以通过伪代码来研究算法。 伪代码： high-level description 更结构化的描述 自然语言与编程语言的混合 Computational Model 计算模型：通过计算primitive operations的数量来估计算法的复杂度。 primitive operations：比如赋值、比较大小、条件判断、返回值等。 SearchingBinary- searching 二分查找StringsearchingAlignment/LCS 校准Graph/CombinatoryComplexity","categories":[{"name":"学习","slug":"学习","permalink":"https://lucifinil-x.github.io/categories/学习/"}],"tags":[]},{"title":"常见问题&解决办法&小技巧","slug":"常见问题-解决办法-小技巧","date":"2020-02-20T19:05:22.000Z","updated":"2020-02-25T08:32:11.546Z","comments":true,"path":"2020/02/21/常见问题-解决办法-小技巧/","link":"","permalink":"https://lucifinil-x.github.io/2020/02/21/常见问题-解决办法-小技巧/","excerpt":"杀端口占用 输入win+R快捷键，输入cmd，打开命令行窗口 netstat -ano|findstr 8080 taskkill /f /t /im 监听号","text":"杀端口占用 输入win+R快捷键，输入cmd，打开命令行窗口 netstat -ano|findstr 8080 taskkill /f /t /im 监听号 eclipse使用 eclipse里创建的html文件编辑内容要右键openwith。 重启springboot项目前要在控制台那里点红色方框关闭上一次的启动，不然就会出现端口占用，启动失败。 窗口文件右键close可以全部关掉 快捷键：alt shift s 添加getter setter toStringctrl shift o 添加删除包Ctrl+Shift+f 自动对齐 怎么没用alt / 补全代码 github仓库托管代码 教程https://blog.csdn.net/hc_ttxs/article/details/79375788 ssh密匙之前blog的时候就有了，不用再添加。在本地文件夹git-repo为本地仓库，将代码添加进这个文件夹，右键git bush here,按照git命令提交。 我用的是http: https://github.com/Lucifinil-x/community-sringboot.git 提交本地代码命令 不认识的单词 Toggle navigation：切换导航Toggle navigation 替换成名字 路西斐尔的尼伯龙根 placeholder：占位符搜索框里的灰体字","categories":[],"tags":[{"name":"bug","slug":"bug","permalink":"https://lucifinil-x.github.io/tags/bug/"},{"name":"解决办法","slug":"解决办法","permalink":"https://lucifinil-x.github.io/tags/解决办法/"}]},{"title":"springboot学习","slug":"springboot学习","date":"2020-02-19T09:04:25.000Z","updated":"2020-02-29T22:17:17.756Z","comments":true,"path":"2020/02/19/springboot学习/","link":"","permalink":"https://lucifinil-x.github.io/2020/02/19/springboot学习/","excerpt":"注解@XXX的理解 spring引入注解，让注解与java bean紧密结合，减少了配置文件（.xml文件）的体积，增加了java bean的可读性和内聚性。","text":"注解@XXX的理解 spring引入注解，让注解与java bean紧密结合，减少了配置文件（.xml文件）的体积，增加了java bean的可读性和内聚性。 @Autowired注解：自动找和注入组件类、接口实现类，接着就能用他们了 1.自动注入java类，@Autowired注解回去寻找一个java bean组件（@Bean是给spring容器中添加组件，函数返回值添加进容器中） @Autowired private UserRepository userRepository; 如果bean定义给去掉了，spring容器找不到就会抛出异常。如果不想抛出异常，找不到就认为这个属性为null的话：required值设置 false @Autowired（required = false） private UserRepository userRepository; 2.自动注入java接口的实现类： 比如：接口Car;实现类A implements Car;实现类B implements Car; @Service public class CarFactory { @Autowired @Qualifier(&quot;B&quot;) //两个实现类，指明调用B类的carName方法 private Car car; //多态 public String toString() { return car.carName(); } } @Resource注解：根据name和type找和注入组件类、接口实现类，接着就能用他们了 @Servicepublic class Zoo{ @Resource(name = &quot;tiger&quot;) private Tiger tiger; @Resource(type = Monkey.class) private Monkey monkey; public String toString() { return tiger + monkey; }} @Service注解： 声明Zoo.java是一个bean容器，其他类就能够@Autowired把zoo类当做是成员变量来使用; Zoo.java在bean中的id为”zoo”.(类名小写)Thymeleaf模板 Spring Boot 推荐使用 Thymeleaf 来代替 Jsp Thymeleaf 是一款用于渲染 XML/XHTML/HTML5 内容的模板引擎。类似 JSP,它也可以轻易的与 Spring MVC 等 Web 框架进行集成作为 Web 应用的模板引擎。能够直接在浏览器中打开并正确显示模板页面，而不需要启动整个 Web 应用。 页面即原型,整个页面直接作为 HTML 文件用浏览器打开，几乎就可以看到最终的效果，这大大解放了前端工程师的生产力，它们的最终交付物就是纯的 HTML/CSS/JavaScript 文件。 从springboot官方文档学习第一章 做helloXXX html页面 效果：运行后打开localhost:8080/greeting?name=xyt 这个网页页面就会显示出Hello, xyt! 官方文档https://spring.io/guides/gs/serving-web-content/ resources文件夹下放置静态文件，其中templates里放web文件 目前能够想到的组件，在spring官方文档里都是有的。复制粘贴。 pom.xml里加thymeleaf依赖 12345678910111213141516171819@Controller //允许这个类接收前端的请求public class GreetingController &#123; @GetMapping(&quot;/greeting&quot;) //网址的路径 public String greeting( @RequestParam(name=&quot;name&quot;, //@RequestParam()定义接收参数是什么，网址那里？name=xxx ,这个&quot;name&quot;就会以键值对的方式传到服务端，这样我们就会接收到这个value值。 required=false,没有接收到值也不会报错，默认值为world. required=false, defaultValue=&quot;World&quot;) String name, Model //接收到的值是String类型。这里逗号之前都是第一个参数 model) &#123; model.addAttribute(&quot;name&quot;, name); //model添加&quot;键&quot;值对的属性。Model则将获取到的值传递到这个页面上去显示，spring帮我们注入进去了。 return &quot;greeting&quot;; //return值&quot;greeting&quot;会去template中找同名的html文件:greeting.html，把他渲染成网页。这个需要自己去template中添加。 &#125;&#125; 在application.java的同一级或下一级的@Bean组件都能自动加载入容器中。 eclipse里创建的html文件编辑内容要右键openwith。12345678910&lt;!DOCTYPE HTML&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;title&gt;Getting Started: Serving Web Content&lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;&lt;/head&gt;&lt;body&gt; &lt;p th:text=&quot;&apos;Hello, &apos; + $&#123;name&#125; + &apos;!&apos;&quot; /&gt; //网页显示出Hello,XXX!&lt;/body&gt;&lt;/html&gt; 做社区网站项目第一章 网站网页的功能划分 导航（菜单栏），有很多功能分类：搜索，登录按钮 标签tag列表 话题列表，排序方式：时间倒序、推荐、热门、消灭零回复话题列表元素：发布人、发布时间、评论数、浏览数、回复数、关注数、 热门话题 热门用户 分页 第二章 做社区的菜单栏导航条 用UI框架Bootstrap快速搭建前端的站点。Bootstrap介绍：简洁、直观、强悍的前端开发框架，让web开发更迅速、简单 第一步 下载Bootstrap https://v3.bootcss.com/getting-started/#download下载并将文件粘贴到static文件夹下 第二步 写index.html 写入css,js文件 1234567891011&lt;!DOCTYPE HTML&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;title&gt;路西斐尔的尼伯龙根&lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/bootstrap.min.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/bootstrap-theme.min.css&quot;/&gt; &lt;script src=&quot;js/bootstrap.min.js&quot; type=&quot;application/javascript&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt; 在Bootstrap网页上找到组件页面，找导航条，将代码复制粘贴到index.html中的body中 根据实例中每个框框中的单词，将body中对应的单词改成自己的。 删掉不要的url，icon代码块 第三步 写IndexController.java12345678@Controllerpublic class IndexController &#123; @GetMapping(&quot;/&quot;) //根路径，代表8080就是index.html渲染出来的页面 public String index() &#123; return &quot;index&quot;; &#125;&#125; 第三章 申请github app登录授权 授权登记页面 https://github.com/settings/applications/1228484 第四章 做登录callback，拿到参数第一步 做登录按钮的github授权登录输账号密码页面 GitHub需要的内容文档 https://developer.github.com/apps/building-oauth-apps/authorizing-oauth-apps/ index.html登录那一行加入自己申请过的授权信息 1&lt;li&gt;&lt;a href=&quot;https://github.com/login/oauth/authorize?client_id=51a87c000499eea9d39a&amp;redirect_uri=http://localhost:8080/callback&amp;scope=user&amp;state=1&amp;&quot;&gt;登录&lt;/a&gt;&lt;/li&gt; 在输入密码之后会到callback页面，这时候显示404，因为还没做callback页面。http://localhost:8080/callback?code=57679f8624ad1ef794bd&amp;state=1网址上会显示一串code,之后就需要接收到这个参数code和参数state，用@RequestParam 第二步 做callback页面，接收到callback的code 新建AuthorizeController.java1234@GetMapping(&quot;/callback&quot;) //当他登录后到callback时，就让他跳转回index页面 public String callback( @RequestParam(name=&quot;code&quot;) String code , //第一个参数name为code，第二个为state @RequestParam(name=&quot;state&quot;) String state) &#123; return &quot;index&quot;; 第三步第五章 写配置文件，分离变量数据和固定代码第一步 将文件中的数据值用参数占位，在配置文件中赋值1234@Value(&quot;$&#123;github.client.id&#125;&quot;) //value中为键，他会去配置文件中找对应键的值，且赋值给参数clientId private String clientId;配置文件： github.client.id=51a87c000499eea9d39a //键值对 第六章 登录成功保持登录状态Session 和 Cookie Session:银行账户，账户所有信息都在银行数据库中（服务器就相当于银行） Cookie:银行卡，要操作账户中信息比如余额，需要知道银行卡 第七章 callback页面404，控制台不打印原因高亮！ 所有的文件和包一定要放在启动类/包下面，否则run时是不可能启动这些类的，控制台也不会打印。 springboot和shiro整合-权限管理实战第一章 Controller类1234567891011121314151617181920212223// 第一种getmapping注解 @GetMapping(&quot;/hello&quot;) public String hello() &#123; System.out.println(&quot;UserController.hello()&quot;); return &quot;ok&quot;; &#125; @GetMapping(&quot;/testThymeleaf&quot;) public String testThymeleaf(Model model) &#123; model.addAttribute(&quot;name&quot;,&quot;xyt&quot;); return &quot;test&quot;; &#125;//第二章requestmapping+requestbody @RequestMapping(&quot;/hello&quot;) @ResponseBody public String hello() &#123; System.out.println(&quot;UserController.hello()&quot;); return &quot;ok&quot;; &#125; @RequestMapping(&quot;/testThymeleaf&quot;) public String testThymeleaf(Model model) &#123; model.addAttribute(&quot;name&quot;,&quot;xyt&quot;); return &quot;test&quot;; &#125; @RequestMapping(“/hello”)@ResponseBody是返回字体（将实体类转化为json） @RequestMapping(“/hello”)是返回html 12345@RequestMapping(&quot;/update&quot;) public String update() &#123; System.out.println(&quot;UserController.hello()&quot;); return &quot;/user/update&quot;; &#125; 返回到update.html要加前面的路径。如：return “index”; index.html在trmplates包直接下面如：return “/user/update”;update.html在trmplates包下面user包下面 第二章shiro 核心APISubject: 用户主体 (把操作交给SecurityManager,要关联它)SecurityManager: 安全管理器 （关联Reaml）Realm: Shiro连接数据的桥梁,执行认证和授权。认证中具体实现用户名和密码匹配 第三章 springboot和shiro整合导入shiro和spring整合依赖12345&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt;&lt;/dependency&gt; 编写shiro配置类 @Configurartion 放在启动类子包Shiro子包Shiro中自定义Realm类，继承AuthorizingRealm类，实现认证和授权方法写shiro配置类 创建ShiroFilterFactoryBean对象，@Bean放入spring的环境，上面的方法就可以使用 创建DefaultWebSecurityManager对象，@Bean放入spring的环境 创建Realm对象，@Bean放入spring的环境 1234567891011121314151617181920212223@Configurationpublic class ShiroConfig &#123; @Bean //过滤拦截器 public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier(&quot;securityManager&quot;) DefaultWebSecurityManager securityManager ) &#123; ShiroFilterFactoryBean shiroFilterFactoryBean=new ShiroFilterFactoryBean(); shiroFilterFactoryBean.setSecurityManager(securityManager);//设置关联安全管理器 return shiroFilterFactoryBean; &#125; @Bean(name=&quot;securityManager&quot;) //安全管理器 public DefaultWebSecurityManager getDefaultWebSecurityManager(@Qualifier(&quot;userRealm&quot;)UserRealm userRealm) &#123; //@Qualifier合格者，去根据bean名字查找userRealm对象，拿一个 DefaultWebSecurityManager securityManager =new DefaultWebSecurityManager(); securityManager.setRealm(userRealm); //设置关联realm return securityManager; &#125; @Bean(name= &quot;userRealm&quot;) //执行授权器 public UserRealm getRealm() &#123; return new UserRealm(); &#125;&#125; 使用shiro内置过滤器，可实现页面权限相关的资源拦截 资源拦截逻辑：以键值对集合形式添加各个页面和对应的拦截规则。不同的拦截规则会跳转到（修改过的）不同的页面。authc：跳转到登录页面tologin(tologgin路径是login的html)，点击登录按钮后执行认证逻辑perms：进行授权逻辑，是否匹配perms字符串，不匹配跳转到拦截页面 在过滤拦截器中使用shiro内置过滤器，可以实现页面的拦截，和跳转页面。也可以用不同的过滤器放行一些页面。 常用的过滤器： anon:无需认证（登录）可以访问 authc:必须认证才可以访问 user:如果使用了rememberme的功能可以访问 perms:该资源必须授权资源权限才可以访问 role:该资源必须得到角色授权才可以访问 12345678910111213141516@Bean public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier(&quot;securityManager&quot;) DefaultWebSecurityManager securityManager ) &#123; ShiroFilterFactoryBean shiroFilterFactoryBean=new ShiroFilterFactoryBean(); //设置安全管理器 shiroFilterFactoryBean.setSecurityManager(securityManager); //添加shiro内置过滤器,将链接跳转页面和过滤器以键值对形式，加入hashmap集合 Map&lt;String,String&gt; filterMap = new LinkedHashMap&lt;String,String&gt;(); filterMap.put(&quot;/add&quot;, &quot;authc&quot;);//authc必须认证才能访问 filterMap.put(&quot;/update&quot;, &quot;authc&quot;); //修改跳转登录页面url, 每一个页面都要写一个controller，@RequestMapping对应路径 shiroFilterFactoryBean.setLoginUrl(&quot;/tologin&quot;); //安全管理器中添加集合的拦截，集合中添加的路径会按照键值对设置对应的拦截 shiroFilterFactoryBean.setFilterChainDefinitionMap(filterMap); return shiroFilterFactoryBean; 那么拦截成功就会自动跳转到http://localhost:8080/login，可自己修改跳转登录链接url如上，并且在controller类中写对应的@RequestMapping对应路径，并且写路径的页面html文件。（login.html） filterMap.put(“/test”, “anon”);让首页链接放行，无需认证（登录）可以访问，要注意顺序，这个在前面 filterMap.put(“/*”, “authc”); 这里可以让templates下面的全部资源使用过滤器，虽然他们都是user包下的，但是用根目录 超链接是写在首页test.html中,超链接点过去的跳转链接是写在Controller类中，并且写了return的html文件 12345678910111213&lt;!DOCTYPE HTML&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt; &lt;/meta&gt;&lt;title&gt;测试&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3 th:text=&quot;$&#123;name&#125;&quot;&gt;&lt;/h3&gt;&lt;hr/&gt;进入用户添加功能：&lt;a href=&quot;add&quot;&gt;用户添加&lt;/a&gt;&lt;br/&gt;进入用户更新功能：&lt;a href=&quot;update&quot;&gt;用户更新&lt;/a&gt;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt; 第四章 编写用户登录功能简单设计了一个登录页面login.html（之前的过滤拦截后的跳转页面，也是登录失败的返回页面）1234567891011121314151617&lt;!DOCTYPE HTML&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt; &lt;/meta&gt;&lt;title&gt;登录页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;这是拦截登录页面&lt;h3&gt;登录&lt;/h3&gt;&lt;h3 th:text=&quot;$&#123;msg&#125;&quot; style=&quot;color:red&quot;&gt;&lt;/h3&gt;&lt;form method = &quot;post&quot; action=&quot;login&quot;&gt; 用户名:&lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt;&lt;br/&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 为什么登录前后都用login.html?因为登录失败时model携带的msg信息才会与html中的msg匹配显示出来 点击登录按钮后跳转到login页面,编写login Controller的登录逻辑 接收 输入到login页面的用户名和密码，封装（添加）到token对象，吧token对象发给shiro。try catch判断登录成功或失败；成功返回test首页；失败 用model存储失败信息返回login页面。1234567891011121314151617181920212223//登录按钮后的跳转页面，实现逻辑处理 @RequestMapping(&quot;/login&quot;) //model中存入我们要return回login.html的信息,会吧存在里面的消息带回去，会在msg对应地方打印出错误消息 public String login(String name, String password, Model model) &#123; //使用shiro编写认证操作 //1.获取subject用户主体 Subject subject = SecurityUtils.getSubject(); //2.用token封装用户数据 UsernamePasswordToken token = new UsernamePasswordToken(name,password); //3.执行登录方法,执行过程中要传递用户的token给subject(就是传递给shiro) //如何判断是否信息无误：这段代码无任何异常 //shiro将异常/登录失败分的很清楚：UnknownAccountException e用户名不存在;IncorrectCredentialException密码错误 try &#123; subject.login(token); //无异常，登录成功跳转回首页test.html return &quot;test&quot;; &#125; catch (UnknownAccountException e) &#123; model.addAttribute(&quot;msg&quot;,&quot;用户名不存在&quot;); return &quot;redirect:/tologin&quot;;//重定向，请求到tologin路径,会执行tologin的controller,还是回到login.html &#125;catch(IncorrectCredentialsException e) &#123; model.addAttribute(&quot;msg&quot;, &quot;密码错误&quot;); return &quot;login&quot;;//所以直接回去也可以的 &#125; 编写realm的认证函数中：判断登录信息逻辑12345678910111213141516//执行认证逻辑,Authentication证明,这里接收到的就是controller中提交到shiro的token @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; System.out.println(&quot;认证&quot;); //现在先假设数据库的用户名和密码是 String name = &quot;xyt&quot;; String password = &quot;666&quot;; UsernamePasswordToken thistoken = (UsernamePasswordToken)token; //判断用户名和密码 if(!thistoken.getUsername().equals(name)) &#123; //shiro底层会抛出UnknownAccountException return null; &#125; //密码不需要判断。返回AuthenticationInfo的子类 return new SimpleAuthenticationInfo(&quot;&quot;,password,&quot;&quot;);//提交给login方法的，数据库密码(shiro会自动判断)，shiro的名字 &#125; 第五章 整合mybits实现用户登录认证 MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。 导入mybits相关依赖12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.9&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt; &lt;/dependency&gt; 在mysql sqlyog客户端中建一个数据库springboot_shiro，添加user表 写配置文件12345678910spring.datasource.driverClassName=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost/springboot_shiro?serverTimezone=UTC //url这里不用写主机ip,不用写3306（3306加上也可以成功运行）spring.datasource.username=root //用户名在sqlyog的客户端里数据库上面写的root@localhost,@前面的就是用户名spring.datasource.password= //密码记在手机里了spring.datasource.type=com.alibaba.druid.pool.DruidDataSourcemybatis.type-aliases-package=com.example.demo.domain //扫描包下的实体类 写com.example.demo.domain下的实体类User不加注解,与数据库数据中对应 name,id,password,getter,setter 写com.example.demo.mapper包下两个文件 写Dao: interface UserMapper接口 1234567import com.example.demo.domain.User;public interface UserMapper &#123; //查询 public User findByName(String name);&#125; 写映射文件： UserMapper.xml (一定要和上面的java文件名字一样)。这个文件里放CURD的sql语句,对应着上面接口中的函数实现 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapperPUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.example.demo.mapper.UserMapper&quot;&gt; &lt;select id = &quot;findByName&quot; parameterType=&quot;string&quot; resultType=&quot;User&quot;&gt; SELECT `id`, `name`, `password` //可以随意大小写，不用加引号 FROM user where name= #&#123;value&#125; //这个是占位符 &lt;/select&gt;&lt;/mapper&gt; 业务包servise 接口类UserService 1234public interface UserService &#123; public User findByName(String name);&#125; 实现类UserServiceImpl：来实现mapper接口，要加注解@Service 123456789101112131415@Servicepublic class UserServiceImpl implements UserService&#123; //注入Mapper接口 @Autowired private UserMapper userMapper; @Override //实现UserService的函数，参数传给userMapper的函数 public User findByName(String name) &#123; return userMapper.findByName(name); &#125;&#125; 修改启动类加上注解@MapperScan(“com.example.demo.mapper”)扫描mapper接口所在的包 在controller中注入业务123//注入业务 @Autowired private UserService userService; 在realm中注入业务，修改认证逻辑（去数据库中匹配用户名和密码）12345678910111213141516171819202122232425 //注入业务 @Autowired private UserService userService; //执行认证逻辑,Authentication证明,这里接收到的就是controller中提交到shiro的token @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; System.out.println(&quot;认证&quot;);// //现在先假设数据库的用户名和密码是// String name = &quot;xyt&quot;;// String password = &quot;666&quot;; UsernamePasswordToken thistoken = (UsernamePasswordToken)token; //现在已经连接了mysql数据库，写好了查询函数。然后这里就用获取到的name去找对应的password com.example.demo.domain.User user = userService.findByName(thistoken.getUsername()); //判断用户名和密码 if(user==null) &#123; return null;//shiro底层会抛出UnknownAccountException &#125; //密码不需要判断。返回AuthenticationInfo的子类 return new SimpleAuthenticationInfo(&quot;&quot;,user.getPassword(),&quot;&quot;);//提交给login方法的，数据库密码(shiro会自动判断)，shiro的名字 &#125;&#125; 第六章 整合mybits实现用户登录授权shiroconfig添加内置授权过滤/拦截器 perms： 该资源必须得到资源权限才可以访问1234567891011121314151617181920212223242526 @Bean public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier(&quot;securityManager&quot;) DefaultWebSecurityManager securityManager ) &#123; ShiroFilterFactoryBean shiroFilterFactoryBean=new ShiroFilterFactoryBean(); //设置安全管理器 shiroFilterFactoryBean.setSecurityManager(securityManager); //添加shiro内置过滤器,将链接跳转页面和过滤器以键值对形式，加入hashmap集合 Map&lt;String,String&gt; filterMap = new LinkedHashMap&lt;String,String&gt;();// filterMap.put(&quot;/add&quot;, &quot;authc&quot;);//authc必须认证才能访问// filterMap.put(&quot;/update&quot;, &quot;authc&quot;); filterMap.put(&quot;/test&quot;, &quot;anon&quot;); filterMap.put(&quot;/login&quot;, &quot;anon&quot;); //授权过滤器，登录过的user在add页面需要拿到add页面的授权才能访问 //在登录后点击添加时，就会进入授权逻辑 filterMap.put(&quot;/add&quot;, &quot;perms[user:add]&quot;); filterMap.put(&quot;/*&quot;, &quot;authc&quot;); //修改拦截的跳转登录页面url, 每一个页面都要写一个controller，@RequestMapping对应路径 shiroFilterFactoryBean.setLoginUrl(&quot;/tologin&quot;); //设置未授权的拦截页面：没有拿到某页面授权去访问某页面会跳转到/unAuth shiroFilterFactoryBean.setUnauthorizedUrl(&quot;/unAuth&quot;); //安全管理器中添加集合，以上设置的键值对拦截功能生效 shiroFilterFactoryBean.setFilterChainDefinitionMap(filterMap); return shiroFilterFactoryBean; reaml中写资源授权逻辑 逻辑：拦截过滤器添加了perms授权拦截，点到add页面就会进入授权逻辑。在进行授权逻辑时，就拿到了这个字符串，对应config那边的规则perms[user:add]，字符串匹配，授权完成，可访问正常add页面；若在授权逻辑中没有拿到相同字符串，被拦截，跳转unAuth页面。123456789@Overrideprotected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection arg0) &#123; System.out.println(&quot;执行授权逻辑&quot;); //资源授权 SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(); //添加授权字符串,在进行授权逻辑时，就拿到了这个字符串，对应config那边perms[user:add]，字符串匹配，授权完成，可访问 info.addStringPermission(&quot;user:add&quot;); return info; &#125; 改造上面的授权编码，让perms字符串更加灵活 在数据库中添加每个用户的perms 修改了表的结构，就要修改对应的实体类User结构,添加perms属性 我们需要取出数据库中的perms，需要在mapper接口中新定义一个根据id就能查找user对象的方法，然后在映射文件中写出对应的sql查询语句（相当于写出了这个具体函数方法） 在service接口中添加相同的方法 对应的在UserServiceImpl中实现这个方法：这里是调用mapper里写的sql函数return userMapper.findById(id);","categories":[{"name":"学习","slug":"学习","permalink":"https://lucifinil-x.github.io/categories/学习/"}],"tags":[]},{"title":"java考试复习总结","slug":"java考试复习总结","date":"2019-12-24T13:23:07.000Z","updated":"2019-12-29T07:35:39.511Z","comments":true,"path":"2019/12/24/java考试复习总结/","link":"","permalink":"https://lucifinil-x.github.io/2019/12/24/java考试复习总结/","excerpt":"单词提取 encapsulation 封装 length 有g //另：数组求长度 xxx.length; 字符串求长度 xxx.length(); mantissa 小数部分","text":"单词提取 encapsulation 封装 length 有g //另：数组求长度 xxx.length; 字符串求长度 xxx.length(); mantissa 小数部分 基础知识数据类型（整数都有一位是表示正负符号位） byte:1byte; short:2byte; int:4byte; long:8byte float:4byte(整数1byte,小数点后最多7位); double:8byte(整数10位，小数点后最多15位) char:2byte boolean:至少1byte 去年考试题目1.1 Message:Variables: messageText, sender, sendTime, readprivate String messageText; private String sender; private LocalDateTime sendTime; private boolean read;Constructor: Message(String messageText, String sender, LocalDateTime sendTime, boolean read ){ this.messageText = messageText; this.sender = sender; this.sendTime = sendTime; this.read = read; }Encapsulation：public void setMessageText(String messageText) //set，get,小写，后面第一个字母大写{ this.messageText = messageText; } public String getMessageText() { return this.messageText; } public String toString() { //if() return sender + &quot;send&quot; + messageText + &quot;at&quot; + sendTime.toString() + &quot;read or not:&quot; + read; } 1.2 public static void main(String[] args) { double[] numbers= new double[10]; fillArray( numbers); printArray( numbers); System.out.println(“The minimum value is:”+ findMinimum(numbers)); reverseArray( numbers); printArray( numbers); } //fill the array with double values / /use a Scanner to get input from the keyboard public static void fillArray ( double[] toFill) { Scanner s = new Scanner(System.in); //double temp; for(int i= 0; i&lt; toFill.length; i++) { toFill[i] = Double.parseDouble(s.nextLine()); //重点：String转成其他类型不能直接（double）xxx转换； 只能用Xxx.parseXxx(String); 注意Integer.parseInt(String); } } //print the contents of the array to the console, showing the index and value of //each element on a new line public static void printArray(double[] toPrint) { for(int i= 0; i&lt; toPrint.length; i++) { System.out.println(toPrint[i]); } } ///reverse the array. Do not need to display public static void reverseArray(double[] toReverse) { double [] temp = new double[toReverse.length]; //重点:新建数组不确定长度时 xxx.length //double [] temp = toReverse; //重点:建立和传入参数相同的数组时 不能用次方法（这种方法会让新建的副本数组跟随原数组变化而变化(后面要将原数组翻转，会改变源数组的值),只能先遍历出原数组的内容赋值到新数组中，再进行原数组改变值） int j = toReverse.length -1; for(int i= 0; i&lt; toReverse.length; i++) { temp[i]= toReverse[i]; } for(int i= 0; i&lt; toReverse.length; i++) { toReverse[i]= temp[j]; j--; } } //return the minimum value of the array public static double findMinimum(double[] array) { double minimum = 0 ; double temp; for(int i= 0; i&lt; array.length -1; i++) { temp = array[i]; if(temp &gt; array[i+1]) { minimum = array[i+1]; } else if(i==0) //重点：只需要考虑第一次 { minimum =temp; } } return minimum; }","categories":[{"name":"学习","slug":"学习","permalink":"https://lucifinil-x.github.io/categories/学习/"}],"tags":[]},{"title":"计算机系统","slug":"计算机系统","date":"2019-12-22T06:50:35.000Z","updated":"2020-01-04T13:16:51.929Z","comments":true,"path":"2019/12/22/计算机系统/","link":"","permalink":"https://lucifinil-x.github.io/2019/12/22/计算机系统/","excerpt":"CSE101 Q and A 内容###计算机系统4层体系结构 用户代码，软件，操作系统，硬件 （前二为程序员，用户层面）","text":"CSE101 Q and A 内容###计算机系统4层体系结构 用户代码，软件，操作系统，硬件 （前二为程序员，用户层面） 硬件 硬件举例： CPU，内存，硬盘hard disk, 键盘， 屏幕display screen 操作系统 将硬件系统的功能带出来 操作系统包围住硬件系统的好处： 易于编程，保护系统，公平和效率使用系统 组成成分 输入，输出，内存，CPU CPU ALU 中央处理器 central processing unit 进行计算和其他操作 运算器 arithmetic logical unit ALU 和 control unit 是CPU两个主要元件 处理器processor（CPU）遵循软件的指令处理数据 CPU只能执行加载进内存的指令 内存 系统内存 储存着CPU处理，存取的数据 次要存储： 硬盘hard disk, CD, DVD 系统内存中存储着 程序和数据 program and data ，由二进制表示的 接上，其中计算机知道哪里读取指令，哪里读取数据，虽然指令和数据都是二进制 输入输出设备 输入设备： 鼠标，键盘，扫描器Scanner 另：输入硬件设备将数据翻译成计算机能处理的形式 输出设备： 显示器Monitor, 扬声器Speaker, 打印机Printer WIMP 和 OS 主要是输入和输出设备： window, icon, menu, pointer （大概是电脑界面点击图标的意思） WIMP是操作系统OS在四十年中最重要的革新 操作系统OS需要分配公平的被保护的资源： 因为多线程容易死结deadlock, 同时保护硬件（用户不合理操作时） OS支持多任务操作时的功能： 内存管理，安全，分配CPU给每个程序 OS提供访问给网络设备facility: 通过API应用程序界面 ，例如socket interface 普通用途机器有OS特殊用途机器没有OS，只能高效率的做特定的事情 学习层面 程序运行时，计算机内部和程序底层–汇编 分层分区的好处 易于理解，易于设计，易于改变 服务器 Servers 通过 web-network-cloud 服务器是专门用于存储大量PC上数据和程序的工作平台 Dumb terminal:哑终端，一切程序交给主机做，主机不能做任何处理 向下兼容 Downward Compatibility 新软件能在旧硬件上运行 高速集成电路硬件描述语言- VHDL摩尔律 电路大小缩减一半 几个不同的注重 科学计算—Computation 计算 商业计算—Data 数据 个人计算机—Interaction 交互 Input-Process-Output模型 是数字电脑的基础结构 软件编程控制着Process 硬件，软件，（被操作的）数据 ，这三个原件实施Input-Process-Output模型 和 von Neumann 模型 其中von Neumann 模型是 Input-Process-Output模型 中的Process部分Process部分: Processor（应该是CPU） 和 Memory 互相连接传递数据interconnect CPU的读取速度快于主内存，也就是说主内存的速度不快，会拖慢整体交换链接数据的速度，CPU读取速度再快也没有用 von Neumann的机器中 数据和指令 共享同一内存 混合存放 Harvard结构 将数据和程序分离开存储提高了传输速率transfer rate 和生产力throughput但是数据和指令需要单独的存储器single reservoir像是指令缓存instruction cache 数据缓存data cache 指令集instruction set 没有指令标准 standard instruction 对于特殊用途的机器，指令集instruction set通常是固定的 高级编程语言HLL 优势： 用户友好， 编程方便 举例： java c c++ python 程序编译过程 Edit 变成HLL — Compile变成二进制对象文件 —-Link 变成可执行文件 —- Load 最后运行 Compiler编译器: HLL变成机成机器码 Assembler汇编器： 机器指令助记符变成二进制 另：汇编器将标签和内存地址链接在一起 Interpreter解释器： HLL指令解码decode变成中间代码Intermediate code,还是会变成机器码解释器在程序切换快，程序运行快，程序转移到另外平台上时比编译器更好用 Inline assembler内联汇编器： 可以在汇编段中调用c程序库中的函数 用户使用计算机时内部的工作流程 用户使用计算机系统算题的一般流程: ①通过系统操作员建立帐号，取得使用权。帐号既用于识别并保护用户的文件(程序和数据)，也用于系统自动统计用户使用资源的情况(记帐，付款)。 ②根据要解决的问题，研究算法，选用合适的语言，编写源程序，同时提供需处理的数据和有关控制信息。 ③把②的结果在脱机的专用设备上放入软磁盘，建立用户文件(也可在联机终端上进行，直接在辅助存储器中建立文件，此时第四步省去)。 ④借助软盘机把软盘上用户文件输入计算机，经加工处理，作为一个作业，登记并存入辅助存储器。 ⑤是要求编译。操作系统把该作业调入主存储器，并调用所选语言的编译程序，进行编译和连接(含所调用的子程序)，产生机器可执行的目标程序，存入辅助存储器。 ⑥要求运算处理。操作系统把目标程序调入主存储器，由中央处理器运算处理，结果再存入辅助存储器。 ⑦运算结果由操作系统按用户要求的格式送外部设备输出。 计算机内部工作(④~⑦)是在操作系统控制下的一个复杂过程。通常，一台计算机中有多个用户作业同时输入，它们由操作系统统一调度，交错运行。但这种调度对用户是透明的，一般用户无需了解其内部细节。 用户可用一台终端，交互式的控制③⑦的进行(分时方式);也可委托操作员完成③⑦，其中④~⑦是计算机自动进行的(批处理方式)。批处理方式的自动化程度高，但用户不直观，无中间干预。分时方式用户直观控制，可随时干预纠错，但自动化程度低。现代计算机系统大多提供两种方式，由用户选用。 代码分享方法 资源水平的子程序， 宏程序库macro libraries（问题： 谁维护，谁拥有） 预先翻译，可再定址的二进制库 动态库，动态link 库library 库可以link到程序代码，但不能修改 对于动态库，动态link有一个事实标准de-facto standard : Microsoft active 数据单位 bit,byte encode编码ASCII表用了7bit = 2的七次方大小表示一位，第一位表示正负 256bytes数据 可以存入 8bit system 内存地址从0000到00FF ： 1byte* (F16+F1)= 1516+151=256 bytes可以存入16bit system 内存地址从0000到007F ：2byte（716+F1）= 2（716+151）=256 bytes 编码表 ASCII表一位=1byte=8bit;1010 0101 1111 1000 = 16bytes 二进制文件一位=1bit; 1010 0101 1111 1000 = 16bits = 2bytes ASCII表最常用，EBCDIC现在已经不用了，被替代了 ASCII表不能编码除了英语和一些欧洲国家语言之外的字符 ASCII表分为字符和指令字符 printing and control characters 对于不同的表，编码速度没有差异 IEEE754 标准是最广泛使用的浮点转换二进制计算的标准 octal notation 是八进制声明变量时 告诉编译器预留内存空间 告诉编译器变量类型 线 bus 地址线，数据线，控制线 bus线的速度达不到（不匹配）CPU和内存交换的速度,就会让整体速度拖慢 bus一次一条线只能传一项item数据 协处理器coprocessor math, graphic 数学和图像应用程序 微处理器microprocessor 处理接收到的大量信息 存在于计算器，手机，平板，手表，MP3，照相机中 系统时钟system clock 系统时钟控制了所有计算机操作的执行速度 文件系统执行任务时的资源消耗 CPU时间资源，内存，硬盘空间 CPU time, memory, disk space 机器循环machine cycle 重要，注意是指令 过程： 获取指令–解码指令–执行–存储结果 main steps: fetch instruction–decode instruction–execute–store RISE CISE RISE的指令描述简单， CISE指令描述字多 processors that support fewer instructions than do SISC chips 指令执行寄存器 IP,IR,MAR,MBR 不同指令的获取fetch语句是相同的 不同指令的执行execute语句不同 CPU状态标志符Flag Zero flag： 为0，zf=1 Sign flag: 为负数 首位1， sf=1 Carry flag： 产生进位或退位为，cf=1 Overflow flag: 溢出， of=1 EFlage: CMP AL,BL (AL-BL) D flag: direction of processing O flag: Arithmetic overflow error 这些flag在指令执行之后才标记 CMP 后会改变flag，不是check 指令 Pentium奔腾指令集的指令从1到15字节的宽度（不确定），来加速指令解码 指令包含三个： 操作指令，操作数的数据类型，操作数的地址和结果 机器指令用不同的字段Distinct bit field来编码所需的操作内容 寄存器和寄存器之间的运算是最快的 函数 printf: 先进栈的最后打印出来 push顺序：先数字-再占位符-最后句子 call函数时：把EIP（指令指针）中的地址push到栈中， 再把函数地址放进EIP ret时： pop出最后存入栈的地址，放入EIP中 栈的框架下储存的数据类型： 子程序的参数，ret地址，EBP栈指针，局部变量 BCD码：将十进制的每一位0-9的数字转换成四位的二进制码 BCD码：将十进制的每一位0-9的数字转换成四位的二进制码 321的BCD码： 0011 0010 0001 321的二进制码： 101000001 1 byte(8bit)只能表示0-99（99就是 1111 1111） BCD的经济性不如二进制码binary（位数更多）， BCD计算更复杂， 但BCD和字符见的转换更加容易； 二进制表示更容易理解，BCD更容易理解用于某些业务应用程序 2’s complement 补码 正数补码不改变 负数（符号位1）补码： 符号位不变，其余位取反后加一 2’s complement会有溢出的情况： 两个整数相加变成负数 赞成者Pros: 基于two-state technology 易于实现 反对者Cons: 对于人难以理解 带符号整数相加会发生溢出怎么办： 用of sign检测:相加前后的of应该相同，如果不同就溢出了（不太清楚，可能是相加后同为负数或整数） 带符号整数减法是加法的另一种形式，同样也会溢出。加法溢出，减法溢出 10’s complementary convention十进制补充约定 n位数字表示为10’s complementary convention 是基于模module 10 十进制的互补表示: 0到499表示0到499， 500到999表示-500到-1 （-一千减x） 同样有溢出： 347+230= 577大于499溢出 ，577= -（1000-577）=-423 基础类型的bit大小: -2^(x-1 bit次方) 到 2^(x-1 bit次方)-1, 都要去掉符号位 byte: 8bit ,1byte short: 16bit ,2byte , -2^15到2^15 -1 long: 64bit ,8byte int: 32bit ,4byte IEEE754 1bit正负 8bit指数 23bit小数有效位数 ，不存小数点 把二进制小数 变成十进制小数：指数8位- 128+1 = 8位-10000000（2^7，8位）+1 = 整数 ，Excess-127格式小数23位： 1.xxxxxxxx （不用转换）计算 2^指数*1.xxxxxx NaN规范：指数位127，小数位不是0，此时NaN(not a number) 其他看不懂：单精度指数过剩excess notation 127;双精度指数过剩excess notation 1023 数据存储器 寄存器register（8bit,在CPU中） 到 缓存cache 到 内部内存main memory（RAM,ROM） 到 硬盘disk 越来越慢，空间越来越大，价格越来越便宜； 寄存器最快最小最贵 数据获取access的方法：顺序存储sequential storage会减慢数据检索retrieval的进程 Main memory 计算机内部，断电消失 RAM随时存取储存器：分两个DRAM动态，SRAM静态 ROM只读存储器 Cache高速缓存存储器 独立保存，断电不消失 硬盘 : 检索硬盘副本显示到屏幕上，如果检索之后不被修改，源文件不会被覆盖 光盘 ： 读道track U盘 电路combinational组合 sequential数列 logic circuits 组合逻辑电路没有记忆区memory ，数列逻辑电路有记忆区 卷子中的待解决问题 —今年只有选择题和汇编无问答 What is the mechanism being used to pass parameters to the C library function Answer the following questions based on IEEE 754 standard.(4marks each)a) What is the largest positive number represented by IEEE 754 single-precision format?b) What is the encoding of the number -123.625 in IEEE 754 single-precision format?c) What is the smallest normalisedpositive number represented by IEEE 754 single-precision format? 内联汇编 _asm{} 记住：push一次esp+4; 每次call完结算前面push次数， add esp,4n xchg交换值指令： xchg eax, [sei+4] 至少要有一个寄存器 调用： call printf ,call scanf_s 遍历数组存首地址 lea esi, intArray循环中 add eax, [esi]add esi, 4 mov esi, 0循环中 add eax, intArray[esi]inc esi","categories":[{"name":"学习","slug":"学习","permalink":"https://lucifinil-x.github.io/categories/学习/"}],"tags":[]},{"title":"游戏和开源项目学习","slug":"游戏和开源项目学习","date":"2019-11-27T06:20:48.000Z","updated":"2019-11-27T06:22:18.092Z","comments":true,"path":"2019/11/27/游戏和开源项目学习/","link":"","permalink":"https://lucifinil-x.github.io/2019/11/27/游戏和开源项目学习/","excerpt":"","text":"初心 想先做像页游那样的游戏，任务在家园里移动。感觉是可以实现的。","categories":[{"name":"学习","slug":"学习","permalink":"https://lucifinil-x.github.io/categories/学习/"}],"tags":[]},{"title":"mySQL","slug":"mySQL","date":"2019-09-14T05:26:06.000Z","updated":"2019-09-29T06:50:36.966Z","comments":true,"path":"2019/09/14/mySQL/","link":"","permalink":"https://lucifinil-x.github.io/2019/09/14/mySQL/","excerpt":"19.9.14安装 mysql5.7安装以及配置环境（注意：官网安装非常慢，打开迅雷复制官网下载网址链接下载安装）https://www.bilibili.com/video/av66542221","text":"19.9.14安装 mysql5.7安装以及配置环境（注意：官网安装非常慢，打开迅雷复制官网下载网址链接下载安装）https://www.bilibili.com/video/av66542221 19.9.15 语句超级容易输错单词,有无s什么的….. 19.9.16 感觉有点枯燥呢，加油 19.9.29 很久没上mysql了","categories":[{"name":"学习","slug":"学习","permalink":"https://lucifinil-x.github.io/categories/学习/"}],"tags":[]},{"title":"学习计划与心得","slug":"学习计划与心得","date":"2019-09-14T05:20:49.000Z","updated":"2020-02-28T19:25:36.239Z","comments":true,"path":"2019/09/14/学习计划与心得/","link":"","permalink":"https://lucifinil-x.github.io/2019/09/14/学习计划与心得/","excerpt":"19.9.14 希望每天保持八小时的有效学习时间，坚持记录笔记，多任务学习 英语老老实实背单词 文件要装好","text":"19.9.14 希望每天保持八小时的有效学习时间，坚持记录笔记，多任务学习 英语老老实实背单词 文件要装好 19.9.16 效率挺低的完全没办法做到做任务学习 19.9.17 备考雅思单词：会认与会写。 A4纸折八列，写单词和意思 ，折起来背 强扭的瓜不甜但是解渴，要解渴就继续纠缠，要甜就找新的 19.9.29 很久没有记录了，平时真的没什么时间，英语也很差，代码经常出问题，还是缺少练习 20.2.23 小匠笔记：学东西一定要先看官方网址文档。最开始学东西先用起来，不要死磕，之后多用就会了 创建包来隔离不同的业务 参数多于两个就要把他封装成对象 全部文件/包放在启动类所在包下面 初了解一个应用，一定去看它的官方文档","categories":[{"name":"学习","slug":"学习","permalink":"https://lucifinil-x.github.io/categories/学习/"}],"tags":[]},{"title":"java基础记录；java全栈开发（从入门到入坟）的笔记","slug":"java笔记","date":"2019-09-12T16:35:58.000Z","updated":"2019-10-05T07:34:03.006Z","comments":true,"path":"2019/09/13/java笔记/","link":"","permalink":"https://lucifinil-x.github.io/2019/09/13/java笔记/","excerpt":"安装 安装netbeans8.2 IDE 和jdk1.8.0 百度云传不了，放在u盘里的 注意如果netbeans出错了就把相关文件夹删干净（360强力删除）之后重装，会省时省力很多。","text":"安装 安装netbeans8.2 IDE 和jdk1.8.0 百度云传不了，放在u盘里的 注意如果netbeans出错了就把相关文件夹删干净（360强力删除）之后重装，会省时省力很多。 19.9.13数组定义数组 int [] arr = new int []{1,2,3,4,5};int [] arr = {1,2,3,4,5}; 自定义函数要写在主类class Main里，public static void main 的下面；数组作为自定义函数的参数时要写括号：public static int add(arr[])；main函数里调用自定义函数时参数只用写数组名（此时调用数组第一个数据的地址）： add(arr) ；而且调用函数的返回值用一个变量装载一下 ：int b = add(arr) 各种功能都写成函数再调用，不要写在主函数里 改变数组的自定义函数：返回类型为void（改变指针） 表 数组可以作为表： 当数据之间存在对应关系时，通过一方可以查询到另外一方。ex: 通过数组的索引查表（查找数组中的内容）,(这样比switch if 条件判断方便) 数组选择排序 从第一个依次向后比较，替换第一个；在从第二个依次向后比较，替换第二个….（小数向前挪动）12345678910111213141516171819202122232425262728293031323334353637 public class Main &#123; public static void main(String[] args) &#123; int arr[] =&#123;12,9,23,77,12,34&#125;; rank(arr); printArr(arr); &#125; public static void rank(int []arr ) &#123; for(int a =0; a&lt;arr.length-1; a++) &#123; for(int b = a+1; b&lt;=arr.length -1; b++) &#123; if(arr[a]&gt; arr[b]) &#123; int temp= arr[a]; arr[a]= arr[b]; arr[b]= temp; &#125; &#125; &#125; return ; &#125; public static void printArr( int arr[]) &#123; for(int x=0; x&lt; arr.length; x++) &#123; if(x == arr.length -1) System.out.println(arr[x]); else System.out.print(arr[x] + &quot;,&quot;); &#125; return; &#125;&#125; 数组冒泡排序 1-2比，2-3比，3-4比…(将每次比较的大值放在后面再和下一个数比较)，再重复1-2比，2-3比..1234567891011121314public static void rank(int []arr ) &#123; for(int a = 0; a&lt; arr.length-1; a++) &#123; for(int b = 0; b&lt;arr.length-1-a; b++) //【-a】这里为了实现每一次横向比较时，比较的次数都会随着横向比较次数的增加而递减（因为每次横向排序的末尾最后一个一定是最大的数，所以下一次横向比较时不再比较最后一个数） &#123; if(arr[b]&gt;arr[b+1]) &#123; int temp = arr[b]; arr[b]=arr[b+1]; arr[b+1]=temp; &#125; &#125; return ; &#125; &#125; 代码抽取 以上两个排序中的交换数组中数字位置部分的代码块重复，可自定义一个新功能，再调用（如冒泡排序中： swap(arr, b, b+1);）,方便使用提高复用性123456public static void swap(int arr[], int a, int b) //注意未知的都是参数： 数组不知道，交换位的角标不知道 &#123; int temp = arr[a]; arr[a]= arr[b]; arr[b] = temp; &#125; 使用程序包 以上数组排序功能都可在程序包内（需要自己下载），开发时直接import程序包，再调用就可以，不要自己写功能 19.9.14数组普遍查找 普遍查找数组中元素(遍历数组)，返回值为int(角标):return x；如果没有此元素，return -1 (代表不存在的情况) 二分查找 1、定义min、max、mid角标；2、比较mid和查找数据大小： 数据大，min=mid+1;数据小, max=mid-1; 3、循环；4、循环中判断查找的数据是否存在(存在条件max min之间有距离：min &lt;= max) 或者判断存在条件作为while循环条件，会更加简洁1234567891011121314151617181920212223242526272829public static void main(String[] args) &#123; int arr[] =&#123;9,12,15,24,36,41,59,68&#125;; rank(arr); int a =binarySearch(arr, 41); System.out.println(&quot;第&quot;+(a+1)+&quot;个是:&quot;+arr[a]); &#125; public static int binarySearch(int arr[], int key) &#123; int min, max, mid; min=0; max = arr.length -1; mid = (min + max)/2; while(arr[mid] != key) &#123; if(arr[mid]&lt; key) &#123; min = mid +1; mid = (min + max)/2; &#125; else if(arr[mid]&gt; key) &#123; max = mid -1; mid = (min + max)/2; &#125; //判断查找元素是否存在 if(max&lt;min) return -1; &#125; return mid; &#125; 19.9.18面向对象 对象：属性（数值，是变量）+ 行为（功能，是函数） 19.9.29数组 创建功能：传入数组参数，返回数组参数主函数中 &gt; + String arr[] = new String[6];public static String[] change (String [] arr) //定义中类型和参数都有括号 return arr; //返回值无括号主函数中接收返回值时直接 &gt; + String name [] = change(arr) //调用传值无括号 Scanner 首先在package 下面加上 import java.util.Scanner; Scanner a = new Scanner(System.in);int num = a.nextInt(); Scanner b = new Scanner(System.in);String name = b.nextLine();可见： 先用一个创建的对象接收输入的值，再定义一个新的变量 接收输入对象 改变类型之后的值 2019.10.5private static private不可以和static同时用 private：对象的属性，构造函数； 对象的行为(功能函数)一般用public让调用者调用？ static:静态不能访问非静态（静态随类先加载） 单例模式———创建本类中对象饿汉式：一上来就创建对象 class Teacher{ private String name; private static Teacher single = new Teacher(“xx”);//创建本类中对象 private Teacher(String name) //private构造函数以及函数都不可以被调用，只能在类中调用，也就是说当private 属性和行为和构造函数时，都要设置相应的public函数 {this.name = name;} //记得加this. 表示此对象中的属性 public static Teacher build() { return single;} //主函数中调用此public函数完成对象a的指向 本类中创建的对象（单例） public String getname() {return single.name;} } public static void main(String[] args) {Teacher a = Teacher.build(); System.out.println(a.getname()); } 懒汉式：先创建对象指针，再在创建单例函数中创建对象（开辟空间），使用构造函数 class Teacher{ private String name; private Teacher(String name) {this.name = name;} private static Teacher single = null; //一定注意指针先赋值为空指针 public static Teacher build(String name) { single = new Teacher(name);return single; //返回已经构建好的对象指针？ } public String getname() {return single.name;}} public static void main(String[] args) {Teacher a = Teacher.build(&quot;xx&quot;); System.out.println(a.getname()); }","categories":[{"name":"学习","slug":"学习","permalink":"https://lucifinil-x.github.io/categories/学习/"}],"tags":[{"name":"bug","slug":"bug","permalink":"https://lucifinil-x.github.io/tags/bug/"},{"name":"java","slug":"java","permalink":"https://lucifinil-x.github.io/tags/java/"}]},{"title":"博客文章编辑格式","slug":"博客文章编辑格式","date":"2019-09-09T06:47:58.000Z","updated":"2019-09-11T06:54:10.000Z","comments":true,"path":"2019/09/09/博客文章编辑格式/","link":"","permalink":"https://lucifinil-x.github.io/2019/09/09/博客文章编辑格式/","excerpt":"插入格式插入链接 超链接： []链接名+()网址Lucifinil’s blog 自动链接： &lt;&gt;网页地址Lucifinil’s blog https://lucifinil-x.github.io/ 插入图片 !+[]图片名+()网址 或()/next主题文件夹下/images/图片名","text":"插入格式插入链接 超链接： []链接名+()网址Lucifinil’s blog 自动链接： &lt;&gt;网页地址Lucifinil’s blog https://lucifinil-x.github.io/ 插入图片 !+[]图片名+()网址 或()/next主题文件夹下/images/图片名 字体效果 斜体字体: * * 中添加文字 加粗字体: ** ** 中添加文字 斜体加粗字体： * * 中添加文字 横线分行 加上横线 : 三个 - 再回车后加内容 引用 单行引用: ``中加内容 多行引用： 三个点中加内容或代码块 123456多行引用： &lt;html&gt; &lt;head&gt; &lt;title&gt;我是标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt; &lt;/html&gt; 引用文章 : &gt; +内容 隐藏 隐藏内容需阅读全文: ““（自由设置）或在主题config里 设置123auto_excerpt:enable: truelength: 50","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://lucifinil-x.github.io/categories/博客搭建/"}],"tags":[{"name":"格式","slug":"格式","permalink":"https://lucifinil-x.github.io/tags/格式/"}]},{"title":"lucifinil的博客计划~","slug":"lucifinil的博客搭建计划","date":"2019-09-07T09:39:36.000Z","updated":"2019-11-27T06:18:05.382Z","comments":true,"path":"2019/09/07/lucifinil的博客搭建计划/","link":"","permalink":"https://lucifinil-x.github.io/2019/09/07/lucifinil的博客搭建计划/","excerpt":"搭建就做了好几天，还有一些主题优化没有成功和待完成的~~ 未成功 添加背景图片 背景及点击动态 添加字数检索和阅读时间","text":"搭建就做了好几天，还有一些主题优化没有成功和待完成的~~ 未成功 添加背景图片 背景及点击动态 添加字数检索和阅读时间 待完成 添加live 2d看板娘 改变字体 添加扫码关注的公众号图片 在github上备份博客 注意事项 每周将博客文章上传更新至百度云备份 每天坚持把心得学习内容总结成笔记更新博客文章 写博客用的软件 sublime text, 在d盘","categories":[],"tags":[]},{"title":"搭建博客","slug":"博客搭建问题解决办法","date":"2019-09-07T09:28:07.000Z","updated":"2020-02-27T20:28:00.364Z","comments":true,"path":"2019/09/07/博客搭建问题解决办法/","link":"","permalink":"https://lucifinil-x.github.io/2019/09/07/博客搭建问题解决办法/","excerpt":"404问题和网页加载出来没有框架的问题 删除blog主文件下的第一个xxx.git文件夹（可用360强力删除） 修改回上一步之前修改的内容： 比如在config里本来是有#隐藏的文件路径， 实际上next主题并没有生成这个路径。 那么把自己新建的文件删除 把#在config里加回去 blog主文件夹下右键打开 git bash here hexo clean,hexo g,hexo s 三部曲","text":"404问题和网页加载出来没有框架的问题 删除blog主文件下的第一个xxx.git文件夹（可用360强力删除） 修改回上一步之前修改的内容： 比如在config里本来是有#隐藏的文件路径， 实际上next主题并没有生成这个路径。 那么把自己新建的文件删除 把#在config里加回去 blog主文件夹下右键打开 git bash here hexo clean,hexo g,hexo s 三部曲 /c/Users/A/AppData/Roaming/npm/hexo: line 12: node: command not found 环境变量是在操作系统中一个具有特定名字的对象，它包含了一个或者多个应用程序所将使用到的信息。例如Windows和DOS操作系统中的path环境变量，当要求系统运行一个程序而没有告诉它程序所在的完整路径时，系统除了在当前目录下面寻找此程序外，还应到path中指定的路径去找。用户通过设置环境变量，来更好的运行进程。环境变量一般是指在操作系统中用来指定操作系统运行环境的一些参数，比如临时文件夹位置和系统文件夹位置等。 搜索控制面板 ——&gt; 系统 ——&gt; 高级系统设置 ——&gt; 环境变量 ——&gt; 下面的框系统变量里 Path编辑： 本机系统自带的：%SystemRoot%\\system32;%SystemRoot%;%SystemRoot%\\System32\\Wbem; 自己需要添加的：D:\\blog\\node_modules\\hexo\\binD:\\MinGW\\MinGW\\binC:\\Program Files\\nodejsD:\\blog\\node_modules\\hexo\\binC:\\Program Files\\MySQL\\MySQL Server 5.7\\bin （mysql的与hexo无关） 千万不能自己写一个path将系统自带的覆盖掉，覆盖了就自己先添加系统的。 4000端口占用 打开cmd 查询占用：netstat -aon|findstr “4000” 查看对应占用进程：tasklist|findstr “xxxx” 杀掉对应进程：taskkill /f /t /im node.exe 然后关掉cmd会出现git bash hexo s虽然搭建成功 但是无法用ctrl+c退出 右上角关闭之后再hexo s虽然报错端口占用 但是本地网页已经更新 本地页面更新，但部署的网页不更新？ 可能原因1：4000 端口占用 localhost:4000 端口被占用，可执行 hexo s -p 5000 修改成5000 端口 可能原因2： 刷新问题 网页输入网址或f5刷新，hexo g, hexo s, hexo d多来几遍 解决步奏【高亮！】： hexo g, hexo s生成本地4000页面，右上角关闭，hexo d，进入网页，没有刷新，按F5刷新，就出来了","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://lucifinil-x.github.io/categories/博客搭建/"}],"tags":[{"name":"bug","slug":"bug","permalink":"https://lucifinil-x.github.io/tags/bug/"},{"name":"解决办法","slug":"解决办法","permalink":"https://lucifinil-x.github.io/tags/解决办法/"},{"name":"搭建","slug":"搭建","permalink":"https://lucifinil-x.github.io/tags/搭建/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-09-07T09:19:30.799Z","updated":"2019-09-07T09:19:30.799Z","comments":true,"path":"2019/09/07/hello-world/","link":"","permalink":"https://lucifinil-x.github.io/2019/09/07/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}