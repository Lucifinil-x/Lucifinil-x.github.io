<!DOCTYPE html>





<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.4.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">
  <link rel="stylesheet" href="/lib/pace/pace-theme-corner-indicator.min.css?v=1.0.2">
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":true,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="数据结构，介绍基本的数据结构和性质和用法。20% 不是考试，两个assignment写java代码，一定要尽可能的细致，对于每一个可能的样本输入情况都要考虑周全。80% 期末考试，四分之三25道选择题和一道数据结构的大题，大题每年相似度很高。背书课：lecture slides, Q&amp;amp;As, in-class &amp;amp; take-home exercises, assignments">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构学习">
<meta property="og:url" content="https://lucifinil-x.github.io/2020/02/23/数据结构学习/index.html">
<meta property="og:site_name" content="Sanctuary">
<meta property="og:description" content="数据结构，介绍基本的数据结构和性质和用法。20% 不是考试，两个assignment写java代码，一定要尽可能的细致，对于每一个可能的样本输入情况都要考虑周全。80% 期末考试，四分之三25道选择题和一道数据结构的大题，大题每年相似度很高。背书课：lecture slides, Q&amp;amp;As, in-class &amp;amp; take-home exercises, assignments">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://s1.ax1x.com/2020/06/19/NKsf7q.png">
<meta property="og:image" content="https://lucifinil-x.github.io/.io//D:%5Cblog%E5%A4%87%E4%BB%BD%E8%B5%84%E6%96%99%5C%E5%9B%BE%E7%89%87%5C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%5C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%5C%E6%95%B0%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E9%81%8D%E5%8E%86.png">
<meta property="og:image" content="https://lucifinil-x.github.io/images/2020-4-9-bianli2.png">
<meta property="og:updated_time" content="2021-05-29T15:21:45.965Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="数据结构学习">
<meta name="twitter:description" content="数据结构，介绍基本的数据结构和性质和用法。20% 不是考试，两个assignment写java代码，一定要尽可能的细致，对于每一个可能的样本输入情况都要考虑周全。80% 期末考试，四分之三25道选择题和一道数据结构的大题，大题每年相似度很高。背书课：lecture slides, Q&amp;amp;As, in-class &amp;amp; take-home exercises, assignments">
<meta name="twitter:image" content="https://s1.ax1x.com/2020/06/19/NKsf7q.png">
  <link rel="canonical" href="https://lucifinil-x.github.io/2020/02/23/数据结构学习/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>数据结构学习 | Sanctuary</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Sanctuary</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger">
        
          <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
      </li>
    
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
      <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block post">
    <link itemprop="mainEntityOfPage" href="https://lucifinil-x.github.io/2020/02/23/数据结构学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lucifinil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/touxiang1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sanctuary">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">数据结构学习

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-02-23 23:39:52" itemprop="dateCreated datePublished" datetime="2020-02-23T23:39:52+08:00">2020-02-23</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-29 23:21:45" itemprop="dateModified" datetime="2021-05-29T23:21:45+08:00">2021-05-29</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/记忆性学习/" itemprop="url" rel="index"><span itemprop="name">记忆性学习</span></a></span>

                
                
              
            </span>
          

          
            <span class="post-meta-item" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
        
      
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/02/23/数据结构学习/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2020/02/23/数据结构学习/" itemprop="commentCount"></span></a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>数据结构，介绍基本的数据结构和性质和用法。<br>20% 不是考试，两个assignment写java代码，一定要尽可能的细致，对于每一个可能的样本输入情况都要考虑周全。<br>80% 期末考试，四分之三25道选择题和一道数据结构的大题，大题每年相似度很高。<br>背书课：lecture slides, Q&amp;As, in-class &amp; take-home exercises, assignments</p><a id="more"></a>
<h2 id="认识数据结构：用来组织和存储数据的集合"><a href="#认识数据结构：用来组织和存储数据的集合" class="headerlink" title="认识数据结构：用来组织和存储数据的集合"></a>认识数据结构：用来组织和存储数据的集合</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li>1.逻辑结构分类: 按照数据元素之间的关系分类 抽象<br>  集合结构：元素之间没有关系<br>  线性结构 ：元素之间一对一的关系，如链表<br>  树形结构：一对多的关系，<br>  图形结构：多对多的关系</li>
<li>2.物理结构分类： 逻辑结构真正在计算机上存储的方式<br>  顺序结构： 连续的内存地址带着索引<pre><code>查找容易 用索引，插入删除难</code></pre>  链式结构： 内存单元可以是不连续的，数据单元之间用指针指向链接<pre><code>查找难 用遍历， 插入删除容易</code></pre></li>
</ul>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h3><p>head空结点-第一个节点(index0)-第二个结点(index1)</p>
<p>单向链表元素：头结点，链表长度(结点个数)</p>
<p>内部类Node:值，指向下一节点的指针</p>
<p>单链表构造函数:初始化空头结点</p>
<p>清空链表：头结点的next指针断开;个数=0</p>
<p>获取链表长度：N</p>
<p>判断链表是否为空：判断长度为0</p>
<p>获取指定位置i处的结构:循环i次，找到第i个结点</p>
<p>向链表末尾插入元素i:遍历找到最后一个结点，插入,元素个数+1</p>
<p>向指定的i个结点位置插入新节点:把新节点放在第i个结点位置，新节点指向下一个，上一个指向新节点,个数+1</p>
<p>删除i位置的节点,返回被删除的节点：遍历到i-1位置结点，让他指向i+1位置结点</p>
<p>查找元素t在链表中第一次出现的位置：循环，判断当前是否相等，相等就结束</p>
<p>查找元素t在链表中第一次出现的位置：从头遍历，不为null</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Iterator;</span><br><span class="line"></span><br><span class="line">public class LinkList&lt;T&gt; implements Iterable&#123;</span><br><span class="line">    //空的头结点，链表长度</span><br><span class="line">    private Node head;</span><br><span class="line">    private int N;</span><br><span class="line"></span><br><span class="line">    //内部类Node</span><br><span class="line">    private class Node&#123;</span><br><span class="line">        //值，下一个指针</span><br><span class="line">        T item;</span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        //构造函数</span><br><span class="line">        public Node(T item, Node next)&#123;</span><br><span class="line">            this.item = item;</span><br><span class="line">            this.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //单链表构造函数:初始化空头结点</span><br><span class="line">    LinkList()&#123;</span><br><span class="line">        this.head = new Node(null,null);</span><br><span class="line">        this.N = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns an iterator over elements of type &#123;@code T&#125;.</span><br><span class="line">     *</span><br><span class="line">     * @return an Iterator.</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public Iterator&lt;T&gt; iterator() &#123;</span><br><span class="line">        return new LIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private class LIterator implements Iterator&#123;</span><br><span class="line">        private Node n;</span><br><span class="line"></span><br><span class="line">        public LIterator()&#123;</span><br><span class="line">            this.n = head;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public boolean hasNext() &#123;</span><br><span class="line">            return n.next != null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public Object next() &#123;</span><br><span class="line">            n = n.next;</span><br><span class="line">            return n.item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //清空链表：头结点的next指针断开;个数=0</span><br><span class="line">    public void clear()&#123;</span><br><span class="line">        head.next = null;</span><br><span class="line">        this.N = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取链表长度：N</span><br><span class="line">    public int length()&#123;</span><br><span class="line">        return N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断链表是否为空：判断长度为0</span><br><span class="line">    public boolean isEmpty()&#123;</span><br><span class="line">        return N == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取指定位置i处的结构:循环i次，找到第i个结点</span><br><span class="line">    public T get(int i)&#123;</span><br><span class="line">        //第一个节点</span><br><span class="line">        Node n = head.next;</span><br><span class="line">        for(int index= 0; index &lt; i; index++)&#123;</span><br><span class="line">            n=n.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return n.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //向链表末尾插入元素i:遍历找到最后一个结点，插入,元素个数+1</span><br><span class="line">    public void insert(T t)&#123;</span><br><span class="line"></span><br><span class="line">        //为什么不能Node n = head.next; 当第一个结点没有时候，head.next就是null pointer</span><br><span class="line">        Node n = head;</span><br><span class="line">        //跳出循环时，n为最后的节点</span><br><span class="line">        while(n.next !=null)&#123;</span><br><span class="line">            n = n.next;</span><br><span class="line">        &#125;</span><br><span class="line">        n.next = new Node(t,null);</span><br><span class="line">        N += 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //向指定的i个结点位置插入新节点:把新节点放在第i个结点位置，新节点指向下一个，上一个指向新节点,个数+1</span><br><span class="line">    public void insert(int i, T t)&#123;</span><br><span class="line">        //第一个结点</span><br><span class="line">        Node n = head.next;</span><br><span class="line">        //拿到i-1位置的节点</span><br><span class="line">        for(int index = 0; index&lt;i-1;index++)&#123;</span><br><span class="line">            n = n.next;</span><br><span class="line">        &#125;</span><br><span class="line">        Node insertnode = new Node(t,n.next);</span><br><span class="line">        n.next = insertnode;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //删除i位置的节点,返回被删除的节点：遍历到i-1位置结点，让他指向i+1位置结点</span><br><span class="line">    public T delete(int i)&#123;</span><br><span class="line">        //头结点</span><br><span class="line">        Node n = head;</span><br><span class="line">        for (int index = 0; index &lt;i-1 ; index++) &#123;</span><br><span class="line">            n = n.next;</span><br><span class="line">        &#125;</span><br><span class="line">        Node deleted = n.next;</span><br><span class="line">        n.next = n.next.next;</span><br><span class="line">        N--;</span><br><span class="line">        return deleted.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //查找元素t在链表中第一次出现的位置：循环，判断当前是否相等，相等就结束</span><br><span class="line">    public int indexof(T t)&#123;</span><br><span class="line">        //头结点</span><br><span class="line">        Node n = head.next;</span><br><span class="line">        for (int index = 0; index &lt; this.N; index++) &#123;</span><br><span class="line">            if(n.item.equals(t))&#123;</span><br><span class="line">                return index;</span><br><span class="line">            &#125;</span><br><span class="line">            n=n.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //查找元素t在链表中第一次出现的位置：从头遍历，不为null</span><br><span class="line">    public int indexof2(T t)&#123;</span><br><span class="line">        //第头节点</span><br><span class="line">        Node n = head;</span><br><span class="line">        for (int index = 0; n.next!=null; index++) &#123;</span><br><span class="line">            n=n.next;</span><br><span class="line">            if(n.item.equals(t))&#123;</span><br><span class="line">                return index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><ul>
<li>学到的：</li>
</ul>
<p>1.java里的插入和c不一样，简单，创建新节点时做好指针，改旧节点指针<br>2.遍历从head开始，head 0 1 2 … n<br>从head到n就要next n+1次噢！</p>
<p>内部类结构和单链表一致</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Iterator;</span><br><span class="line"></span><br><span class="line">public class TwoWayLinkList&lt;T&gt; implements Iterable&lt;T&gt;&#123;</span><br><span class="line">    //头/尾空节点，个数</span><br><span class="line">    private Node head;</span><br><span class="line">    private Node last;</span><br><span class="line">    private int N;</span><br><span class="line"></span><br><span class="line">    //数据，前后指针</span><br><span class="line">    private class Node&#123;</span><br><span class="line">        T item;</span><br><span class="line">        Node pre;</span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        public Node(T item, Node pre, Node next) &#123;</span><br><span class="line">            this.item = item;</span><br><span class="line">            this.pre = pre;</span><br><span class="line">            this.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public TwoWayLinkList() &#123;</span><br><span class="line">        this.head = new Node(null,null,null);</span><br><span class="line">        this.last = null; //尾结点拿来存数据</span><br><span class="line">        N = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public TwoWayLinkList(Node head, Node last, int n) &#123;</span><br><span class="line">        this.head = head;</span><br><span class="line">        this.last = last;</span><br><span class="line">        N = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //清空链表：头结点断开，尾结点为null,N=0</span><br><span class="line">    public void clear()&#123;</span><br><span class="line">        this.head.next = null;</span><br><span class="line">        this.last = null;</span><br><span class="line">        N=0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int length()&#123;</span><br><span class="line">        return N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isEmpty()&#123;</span><br><span class="line">        return N==0;</span><br><span class="line">    &#125;</span><br><span class="line">    //获取第一个节点：第一个节点为空(长度为0)/不为空，为空返回null,不为空,里用头取下一个里的值</span><br><span class="line">    public T getFirst()&#123;</span><br><span class="line">        if(isEmpty()) return null;</span><br><span class="line">        return head.next.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取最后一个结点：是last.分为链表为空/不为空</span><br><span class="line">    public T getLast()&#123;</span><br><span class="line">        if(isEmpty()) return null;</span><br><span class="line">        return last.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //插入元素T: 当前链表为空：让尾结点=新节点，让头结点指向尾结点；当前链表不为空：把尾结点指向新节点，尾结点指向新节点（尾结点是实际的节点）</span><br><span class="line">    //都要个数+1</span><br><span class="line">    public void insert(T t)&#123;</span><br><span class="line">        if(isEmpty())&#123;</span><br><span class="line">            Node newnode = new Node(t,head,null);</span><br><span class="line">            this.last = newnode;</span><br><span class="line">            this.head.next = newnode;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            Node newnode = new Node(t,last,null);</span><br><span class="line">            last.next = newnode;</span><br><span class="line">            last = newnode;</span><br><span class="line">        &#125;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //向指定位置i处插入元素t:找到i-1位置的节点,找到i位置结点，创建新节点插入到i-1和i之间，元素个数+1</span><br><span class="line">    //java里的插入和c不一样，简单，创建新节点时做好指针，改旧节点指针</span><br><span class="line">    public void insert(int i, T t)&#123;</span><br><span class="line">        //找i-1结点</span><br><span class="line">        Node beforei = head;</span><br><span class="line">        for (int index = 0; index &lt;=i-1 ; index++) &#123;</span><br><span class="line">            beforei = beforei.next;</span><br><span class="line">        &#125;</span><br><span class="line">        //找i结点</span><br><span class="line">        Node curi = beforei.next;</span><br><span class="line">        //创建新节点时做好指针</span><br><span class="line">        Node newnode = new Node(t,beforei,curi);</span><br><span class="line">        //改旧节点指针</span><br><span class="line">        beforei.next = newnode;</span><br><span class="line">        curi.pre = newnode;</span><br><span class="line"></span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取第i个位置的元素</span><br><span class="line">    public T get(int i)&#123;</span><br><span class="line">        Node n = head;</span><br><span class="line">        for (int index = 0; index &lt;=i; index++) &#123;</span><br><span class="line">            n = n.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return n.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //找元素t 在链表中第一次出现的位置：遍历，取值比较，返回</span><br><span class="line">    public int indexOf(T t)&#123;</span><br><span class="line">        Node n = head;</span><br><span class="line">        for (int index = 0; n.next != null; index++) &#123;</span><br><span class="line">            n = n.next;</span><br><span class="line">            if(n.item.equals(t))&#123;</span><br><span class="line">                return index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //删除i位置的元素,返回它：找i-1,找i+1,i-1指向i+1,i+1指向i-1,个数-1</span><br><span class="line">    public T remove(int i)&#123;</span><br><span class="line">        Node beforei = head;</span><br><span class="line">        for (int index = 0; index &lt;=i-1 ; index++) &#123;</span><br><span class="line">            beforei = beforei.next;</span><br><span class="line">        &#125;</span><br><span class="line">        Node n = beforei.next;</span><br><span class="line">        Node afteri = n.next;</span><br><span class="line">        beforei.next = afteri;</span><br><span class="line">        afteri.pre = beforei;</span><br><span class="line"></span><br><span class="line">        N--;</span><br><span class="line">        return n.item;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //implements的重写方法，也是一个接口</span><br><span class="line">    public Iterator&lt;T&gt; iterator()&#123;</span><br><span class="line">        return new TIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    //定义类 实现接口Iterable&lt;T&gt;，重写两个方法之后就可以用了</span><br><span class="line">    private class TIterator implements Iterator&lt;T&gt;&#123;</span><br><span class="line">        private Node n;</span><br><span class="line">        public TIterator()&#123;</span><br><span class="line">            this.n  = head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Returns &#123;@code true&#125; if the iteration has more elements.</span><br><span class="line">         * (In other words, returns &#123;@code true&#125; if &#123;@link #next&#125; would</span><br><span class="line">         * return an element rather than throwing an exception.)</span><br><span class="line">         *</span><br><span class="line">         * @return &#123;@code true&#125; if the iteration has more elements</span><br><span class="line">         */</span><br><span class="line">        @Override</span><br><span class="line">        public boolean hasNext() &#123;</span><br><span class="line">            return n.next != null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Returns the next element in the iteration.</span><br><span class="line">         *</span><br><span class="line">         * @return the next element in the iteration</span><br><span class="line">         * @throws NoSuchElementException if the iteration has no more elements</span><br><span class="line">         */</span><br><span class="line">        @Override</span><br><span class="line">        public T next() &#123;</span><br><span class="line">            n = n.next;</span><br><span class="line">            return n.item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="java中的LinkedList集合"><a href="#java中的LinkedList集合" class="headerlink" title="java中的LinkedList集合"></a>java中的LinkedList集合</h3><p>LinkedList集合是用双向链表实现，并提供了增删改查的方法。<br>源码中的first是第一个节点，last是尾结点</p>
<ul>
<li>LinkedList的时间复杂度：</li>
</ul>
<p>1.get(int index): 从头开始向后找，O(n)<br>2.insert(int i,T t):找，O(n)<br>3.remove(int i):找，O(n)</p>
<p>虽然因为要找的n的节点，时间复杂度会是O(n)<br>但是，增删动作会比线性表快很多。因为链表的内存地址是不连续的，都只需要任意找一块内存，再连上，而线性表的增删会让后续的内存地址都改变。</p>
<p>查询用顺序表，增删用链表。</p>
<h3 id="单链表的反转"><a href="#单链表的反转" class="headerlink" title="单链表的反转"></a>单链表的反转</h3><p>递归顺序理解体会：<br>链表的递归是一节拼一节的,并且是从头开始顺序拼接。<br>每个结点只处理自己的next指向null和自己上一个的next指向自己。<br>自己的上一个结点(原始的自己的next)就是递归调用reversehelp(cur.next)的返回值，他是整理好他前面关系的一个结点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//反转整个单链表：整体来看就是把head-1-2-3-4 从1开始后面的连接的next指针全部反向，全部结点反转完成 最后把head.next指向最后一个结点</span><br><span class="line">    public void reverse()&#123;</span><br><span class="line">        //判断当前链表是否为空链表，如果是空链表，就结束</span><br><span class="line">        //不是空链表，就调用重载的reverse方法完成单个结点的指针反转</span><br><span class="line">        if(isEmpty())&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        reversehelp(head.next);//从第一个节点开始递归</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //反转指定某个结点后的全部链表:</span><br><span class="line">    // 递归结束标志：当前结点为尾结点;把head.next指向尾结点</span><br><span class="line">    //链表的递归是一节拼一节的,每个结点只处理自己的next指向null和自己上一个的next指向自己，自己的上一个结点(原始的next)就是递归调用的返回值，他是整理好的一个结点</span><br><span class="line">    </span><br><span class="line">    public Node reversehelp(Node cur)&#123;</span><br><span class="line">        //base：把head.next指向尾结点,把反转后的结点返回(这样就是head-4-null)</span><br><span class="line">        if(cur.next == null)&#123;</span><br><span class="line">            head.next = cur;</span><br><span class="line">            return cur;</span><br><span class="line">        &#125;</span><br><span class="line">        //</span><br><span class="line">        //返回值是链表反转之后，当前结点的前一个结点</span><br><span class="line">        Node pre = reversehelp(cur.next);</span><br><span class="line">        //让返回的结点的下一个结点变成当前结点cur: </span><br><span class="line">        //本来是head-1-2-3, 2=cur,3=pre</span><br><span class="line">        //要让他变成 3pre-2cur-null</span><br><span class="line">        pre.next = cur;</span><br><span class="line">        //把当前结点的下一个结点变成null ; </span><br><span class="line">        cur.next = null;</span><br><span class="line">        </span><br><span class="line">        return cur;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="队列实现"><a href="#队列实现" class="headerlink" title="队列实现"></a>队列实现</h3><p>先进先出，用单链表实现进队出队 by node的添加删除改变连接</p>
<h3 id="优先队列-priority-queue"><a href="#优先队列-priority-queue" class="headerlink" title="优先队列(priority queue)"></a>优先队列(priority queue)</h3><ul>
<li><p>可以将优先级队列想象为已修改的队列，但是当一个人从队列中获取下一个元素时，将首先检索优先级最高的元素。</p>
</li>
<li><p>最小优先队列(min priority queue)中,查找操作用来搜索优先权最小的元素,删除操作用来删除该元素;对于最大优先队列(max priority queue),查找操作用来搜索优先权最大的元素,删除操作用来删除该元素.优先权队列中的元素可以有相同的优先权,查找与删除操作可根据任意优先权进行.</p>
</li>
<li><p>通常用堆实现</p>
</li>
<li><p>优先队列插入和删除元素的复杂度都是O(log2n)，所以很快</p>
</li>
</ul>
<h2 id="Graph-Combinatory"><a href="#Graph-Combinatory" class="headerlink" title="Graph/Combinatory"></a>Graph/Combinatory</h2><h3 id="图的术语"><a href="#图的术语" class="headerlink" title="图的术语"></a>图的术语</h3><p><img src="https://s1.ax1x.com/2020/06/19/NKsf7q.png" alt="图的术语">有向图的所有路径有向，无向图的所有路径无向。</p>
<p>自循环的边对那个顶点来说算一个度。</p>
<p>(path/simple path 不考)</p>
<p>path: 从点到点的路径中，有顶点和边重复出现。U,W,X,Y,W,V.</p>
<p>simple path: 从点到点的路径中，无顶点 且 无边 重复出现。U，V.</p>
<p>walk: path差不多。</p>
<p>trail: 无重复的边。</p>
<p>circuit：起点和终点是同一个点的walk.</p>
<p>cycle: 起点和终点是同一个点, 但路径中的其他点都不能重复，除了起点和终点。</p>
<p>directed walk：所有边都有方向，并沿着它们的方向进行遍历。</p>
<p>subgraph：图的一部分点和边。</p>
<p>spanning subgraph：包含图的所有点，但是边可以少一些，甚至可以无边，不需要保证点都由边连接在一起。</p>
<p>A graph is connected ：对任意两点都有path连接他们。</p>
<p>If a graph G is not connected, its maximal connected subgraphs are called the connected components of G.</p>
<p>Cyclic graph: 循环图，包含循环。</p>
<p>acyclic graph：非循环图。不包含任何循环。</p>
<p>Directed acyclic graphs（DAG）：有向无环图。通过遍历边不可能回到同一个节点。（调度问题，（x，y））</p>
<p>图的边m:</p>
<p>m≤n(n-1)/2（m条边，n个顶点，deg(v)对于点v他的度）</p>
<p>证：所有顶点的度加起来=2m.(因为每条边在算度时，算了两个点的度，因为一条边连两个点)。</p>
<p>n(n-1)&gt;=2m. (一个点连接n-1个点，连n-1条边，一共n个点。所以一共计算n(n-1)条边&gt;=所有顶点的度加起来=2m)</p>
<p>If G is connected, then m ≥ n − 1; (任意两点都有path连接他们，可能有循环)</p>
<p>If G is a tree, then m = n − 1; (树无循环，两点之间有一条边)</p>
<p>If G is a forest, then m ≤ n − 1.（无循环，森林有落单的点，落单的树没有连在一起，比树的边更少）</p>
<h3 id="图的DFS-BFS"><a href="#图的DFS-BFS" class="headerlink" title="图的DFS,BFS"></a>图的DFS,BFS</h3><p>DFS： 先扩展字母小的，一直扩展，每个结点只写一次，如果当前结点的扩展出来的结点已经写出来了，则不扩展当前结点。<br>BFS： 一样的，每个结点不重复写<br>construct tree: 按照原来的图来画DFS BFS的路径。</p>
<h3 id="图的最小生成树"><a href="#图的最小生成树" class="headerlink" title="图的最小生成树"></a>图的最小生成树</h3><p>图的生成树： 是一棵含有其所有顶点的无环联通子图。<br>图的最小生成树： 这棵树的边的权重的和最小。</p>
<h3 id="Minimum-Spanning-Tree（最小生成树-）"><a href="#Minimum-Spanning-Tree（最小生成树-）" class="headerlink" title="Minimum Spanning Tree（最小生成树)）"></a>Minimum Spanning Tree（最小生成树)）</h3><p>定义：For an undirected graph G，is a tree formed from graph edges that：<br>① connects all the vertices of G ② at lowest total cost.</p>
<p>存在性：MST exists iff G is connected.</p>
<h4 id="生成树的性质"><a href="#生成树的性质" class="headerlink" title="生成树的性质"></a>生成树的性质</h4><ol>
<li>一棵生成树中，连接任意两个顶点都会产生一个环。</li>
<li>从生成树中删除任意一条边，都会得到两颗独立的树。</li>
</ol>
<h4 id="切分定理Boruvka’s-algorithm"><a href="#切分定理Boruvka’s-algorithm" class="headerlink" title="切分定理Borůvka’s algorithm"></a>切分定理Borůvka’s algorithm</h4><ul>
<li><p>切分： 按照某些规则，把图的所有顶点分成两个非空且没有交集的集合。（两个独立的树）</p>
</li>
<li><p>横切边： 连接两个不同集合的边。</p>
</li>
<li><p>切分定理：连接两个独立树的横切边权重最小者必然属于图中的最小生成树。</p>
</li>
<li><p>过程：把所有点全部独立出来，</p>
<p>先选图里最短的边连起来(两点)，再选次短的边连起来（两点），直到分离了整个图变成几个离散的树（&gt;=两个点）</p>
<p>在旁边的两点/三点这样连成一个树。一共几个没有连接的树他们包含了图中的所有顶点。</p>
<p>把这几个零散的树，用最短的边连接起来，就是图的MST。</p>
</li>
</ul>
<h4 id="贪心算法-–计算图的最小生成树算法"><a href="#贪心算法-–计算图的最小生成树算法" class="headerlink" title="贪心算法 –计算图的最小生成树算法"></a>贪心算法 –计算图的最小生成树算法</h4><ul>
<li><p>用贪心算法找最小生成树的过程：<br>把所有顶点分成两个集合，找相连接两个集合的横切边中最小的； 再分成不同的集合再找最小横切边；直到选出来的最小横切边连接了所有顶点。</p>
</li>
<li><p>无序的切分找横切边，直到连接完。</p>
</li>
</ul>
<h4 id="prim算法-–贪心算法的一种特殊情况"><a href="#prim算法-–贪心算法的一种特殊情况" class="headerlink" title="prim算法 –贪心算法的一种特殊情况"></a>prim算法 –贪心算法的一种特殊情况</h4><ul>
<li><p>用prim算法找最小生成树的过程：<br>先任意拿一个顶点加入“已选集合” ，其他顶点组成另一个集合；选这两个集合的最小横切边；这个最小横切边连接的顶点放进“已选集合” ； 再继续重复选横切边、加入顶点。</p>
</li>
<li><p>有序的一个一个找顶点之间的横切边。 有可能横切边长度一样的时候，就会有不只一个最小生成树。</p>
</li>
</ul>
<h4 id="Kruskal算法-–贪心算法的一种特殊情况"><a href="#Kruskal算法-–贪心算法的一种特殊情况" class="headerlink" title="Kruskal算法 –贪心算法的一种特殊情况"></a>Kruskal算法 –贪心算法的一种特殊情况</h4><ul>
<li>用kruskal算法找最小生成树的过程：<br>先把图中所有的边存储进最小优先队列，按照大小排序；选第一小的边，连接边的两个顶点；选第二小的边，连接边的两个顶点；直到连接完所有顶点。<br>不能成环，有环就跳过，找下一条边。</li>
</ul>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h3><ul>
<li>树是n个有限结点组成的一个具有层次关系的集合</li>
<li>术语：<br>1.结点的度：结点下面一排上有几个子节点<br>2.叶/终端结点： 无子节点的节点<br>3.节点的层次：节点在第几排<br>4.树的度：树的度=节点的度的最大值（子节点最多的节点的度）<br>5.森林：去掉根节点<br>6.子节点：A的直接前驱是B，A是B的子节点<br>7.父节点：A的直接前驱是B，B是A的父/双亲节点<br>8.双亲节点：两个节点的父节点相同</li>
<li>节点的深度：(从上数到该节点)从根节点到该节点的最长简单路径边的条数</li>
<li>节点的高度：(从该节点数到自己最下面的叶结点)从该节点到叶子节点的最长简单路径边的条数</li>
<li>二叉树的高度和深度：(对某个节点来说) 深度是指从根节点到该节点的最长简单路径边的条数。<br>所以根节点，树的depth为0</li>
<li>三层的都放了结点的的每一层结点的个数加起来：2^0 + 2^1 + 2^2</li>
</ul>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><ul>
<li>二叉树中每个节点最多两个子节点；两个分叉</li>
</ul>
<h4 id="二叉树分类"><a href="#二叉树分类" class="headerlink" title="二叉树分类"></a>二叉树分类</h4><ul>
<li><p>满二叉树： （每个节点都有两个子节点或者0个结点，不能只有一个子节点），</p>
</li>
<li><p>完全二叉树： 每一层结点放满再放下一层；也就是说叶节点只会出现在最后一层或次下层。而且最后一层的子节点是从左到右依次放的，两个节点之间不能出现没有放结点的情况。(最后一层子节点从左开始依次放)</p>
</li>
<li><p>二叉搜索树：n(logn).规律：左子树的所有结点&lt;中间结点，右子树的所有结点&gt;中间结点.对于节点的分布无要求，只对数据大小有要求。</p>
</li>
<li><p>平衡二叉搜索树：|左子树高度-右子树高度|&lt;= 1，加上二叉搜索树的基础要求。<br>(map,set底层是平衡二叉搜索树实现，那么元素是按照大小排序.map的key,set中的元素都是有序的。)</p>
</li>
</ul>
<h4 id="二叉树的存储方式"><a href="#二叉树的存储方式" class="headerlink" title="二叉树的存储方式"></a>二叉树的存储方式</h4><ul>
<li><p>链式存储<br>左连下一个左节点，右连下一个右节点。</p>
</li>
<li><p>线性存储<br>用数组保存二叉树。<br>abcdefg对应数组下标<br>0123456<br>找b的左节点： 2x1 + 1 (b为1)<br>找b的右节点： 2x1 + 2</p>
</li>
</ul>
<h4 id="heap-data-structrue"><a href="#heap-data-structrue" class="headerlink" title="heap data structrue"></a>heap data structrue</h4><p>两种：最大和最小<br>最大：父节点值&gt;子节点值<br>最小：父节点值&lt;子节点值<br>不关注子节点的左右值的顺序，只关心父和子的大小</p>
<ul>
<li><p>Method insertltem(Up-heap bubbling )<br>在叶结点中插入一个结点z(the new<br>last node),向上和父节点比较大小，如果比父节点小，就和父节点交换，一直向上比较和交换，直到父节点&lt;自己。</p>
</li>
<li><p>Method removeMin (Down-heap bubbling)<br>在minheap data structrue里删除最小结点(就是删除根节点)。</p>
</li>
</ul>
<p>1.把最后一个叶结点放在根节点位置，<br>2.现在的根节点和下面的左右子节点比较，根节点更大就和子节点 换位置，直到下面的子节点都比他达，停止向下比较和交换。</p>
<h4 id="构造二叉树"><a href="#构造二叉树" class="headerlink" title="构造二叉树"></a>构造二叉树</h4><p>二叉树就是一个左链表+右链表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Node&lt;Key,Value&gt; &#123;</span><br><span class="line">    //存储键</span><br><span class="line">     public Key key; //用键找值</span><br><span class="line">    </span><br><span class="line">    private Value value;</span><br><span class="line">    </span><br><span class="line">    public Node left;</span><br><span class="line">    </span><br><span class="line">    public Node right;</span><br><span class="line">    </span><br><span class="line">    public Node(Key key, Value value, Node left, Node right) &#123;</span><br><span class="line">        this.key = key;</span><br><span class="line">        this.value = value;</span><br><span class="line">        this.left = left;</span><br><span class="line">        this.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h4><p>二叉树的遍历与图论的遍历一致<br>1.深度优先遍历<br>2.广度优先遍历</p>
<ul>
<li><p>1.深度优先遍历(前/中/后序遍历)<br>前中后顺序是指根节点(中结点)放进队列的顺序。<br>前：中左右<br>中：左中右<br>后：左右中<br>深度遍历的全用递归。<br>从开始节点向一个方向搜索达到终点，再回退到开始节点，再换另一个方向搜索达到终点，再回退到开始节点。</p>
</li>
<li><p>2.广度优先遍历(层序遍历)<br>一层一层遍历。(图论中是一圈一圈遍历)<br>用队列。</p>
</li>
</ul>
<h4 id="用链表实现-二叉查找树"><a href="#用链表实现-二叉查找树" class="headerlink" title="用链表实现 二叉查找树"></a>用链表实现 二叉查找树</h4><ul>
<li><p>结点Node类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Node&lt;Key,Value&gt; &#123;</span><br><span class="line">    //存储键</span><br><span class="line">     public Key key; //用键找值</span><br><span class="line">    </span><br><span class="line">    private Value value;</span><br><span class="line">    </span><br><span class="line">    public Node left;</span><br><span class="line">    </span><br><span class="line">    public Node right;</span><br><span class="line">    </span><br><span class="line">    public Node(Key key, Value value, Node left, Node right) &#123;</span><br><span class="line">        this.key = key;</span><br><span class="line">        this.value = value;</span><br><span class="line">        this.left = left;</span><br><span class="line">        this.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>二叉树类：添加结点；以键查找结点；以键删除结点；查找二叉树中最小键；查找二叉树中最大键</p>
</li>
</ul>
<p>[特点] 1.所有的方法都有同名重载方法：前面的是传入根节点的入口函数，后面是传入子节点的会使用递归的函数。</p>
<ol start="2">
<li>子树=结点下面所有结点<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line">public class BinaryTree&lt;Key extends Comparable&lt;Key&gt;, Value &gt; &#123; //以后要用键来排序</span><br><span class="line">    //记录根节点</span><br><span class="line">    private Node root;</span><br><span class="line">    //记录树中元素个数</span><br><span class="line">    private int N;</span><br><span class="line">    //内部类</span><br><span class="line">    private class Node&#123;</span><br><span class="line">        private Key key;</span><br><span class="line">        private Value value;</span><br><span class="line">        private Node left; //左节点</span><br><span class="line">        private Node right;//右节点</span><br><span class="line"></span><br><span class="line">        public Node(Key key, Value value, Node left, Node right) &#123;</span><br><span class="line">            this.key = key;</span><br><span class="line">            this.value = value;</span><br><span class="line">            this.left = left;</span><br><span class="line">            this.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取树中元素的个数</span><br><span class="line">    public int size()&#123;</span><br><span class="line">        return N;</span><br><span class="line">    &#125;</span><br><span class="line">    //向树中添加元素键值对,第一次添加根节点</span><br><span class="line">    public void put(Key key, Value value)&#123;</span><br><span class="line">        root = put(root, key,  value); //添加根节点，返回赋值给树 根节点;此时x=null</span><br><span class="line">    &#125;</span><br><span class="line">    //向指定的子树x添加键值对，并且返回添加元素后的新树</span><br><span class="line">    public Node put(Node x,Key key, Value value)&#123;</span><br><span class="line">        //1.如果x结点的子树为空,把添加的键值对作为x节点的子节点</span><br><span class="line">        if(x == null)&#123;</span><br><span class="line">            N++; //节点个数+1</span><br><span class="line">            return new Node(key, value, null , null); //无左右子节点</span><br><span class="line">        &#125;</span><br><span class="line">        //2.如果x节点的子树不为空</span><br><span class="line">        //2.1比较x结点的键和添加的key大小</span><br><span class="line">        //2.1.1如果key &lt; x结点的键，则继续找x结点的左子树</span><br><span class="line">        //2.1.2如果key &gt; x结点的键，则继续找x结点的右子树</span><br><span class="line">        //2.1.3如果key = x节点的键，则用添加的value替换x节点的原值.</span><br><span class="line">        int cmp = key.compareTo(x.key);</span><br><span class="line">        if(cmp&lt;0)&#123; //2.1.1</span><br><span class="line">            //这里是从x的左子节点下面插入键值对；完毕后将新的子树返回给x的左子节点</span><br><span class="line">            x.left = put(x.left, key, value); //递归调用只想它干了什么;这里会一直向下找直到找到子树为null时，创建新节点</span><br><span class="line">            </span><br><span class="line">        &#125;else if(cmp&gt;0)&#123; //2.1.2</span><br><span class="line">            //这里是从x的右子节点下面插入键值对；完毕后将新的子树返回给x的右子节点</span><br><span class="line">            x.right = put(x.right, key, value);</span><br><span class="line">            </span><br><span class="line">        &#125;else&#123; //2.1.3</span><br><span class="line">            x.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">        return x; //返回更新后的节点x信息</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //用键找值</span><br><span class="line">    public Value get(Key key)&#123;</span><br><span class="line">        return get(root, key);// 从根节点开始找</span><br><span class="line">    &#125;</span><br><span class="line">    //从指定子树x中，用键找值</span><br><span class="line">    public Value get(Node x, Key key)&#123;</span><br><span class="line">        //1.x树为null,没有找到 返回null就行</span><br><span class="line">        if(x == null)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //2.x不为null ,就要进行x树下面的键比较 （和上面添加方法的代码结构一样）</span><br><span class="line">        int cmp = key.compareTo(x.key);</span><br><span class="line">        if(cmp&lt;0)&#123; //2.1.1 键小与节点找左子树</span><br><span class="line">           return get(x.left, key); //这里是不仅要找，然后找了之后要返回找到的子树结点</span><br><span class="line">            </span><br><span class="line">        &#125;else if(cmp&gt;0)&#123; //2.1.2 键大找右子树</span><br><span class="line">           return get(x.right, key);</span><br><span class="line">           </span><br><span class="line">            </span><br><span class="line">        &#125;else&#123; //2.1.3 相等就找到了，返回键对应的值</span><br><span class="line">            return(x.value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //删除键值对结点。这是一个比较麻烦的操作，删除一个之后，要找一个结点来替换删除的节点</span><br><span class="line">    //因为左子树都小于右子树，新节点需要比左子树大，比右子树小。所以在右子树中找最左的节点（右子树中最小的节点）</span><br><span class="line">    public void delete(Key key)&#123;</span><br><span class="line">        delete(root, key); //入口，先从根节点开始判断删不删</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //删除指定节点树x的键值对，返回新子树</span><br><span class="line">    public Node delete(Node x, Key key)&#123;</span><br><span class="line">        //1.x树为null 安全检查</span><br><span class="line">        if(x ==null)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //2.x树不为null,就要进行x树下面的键比较 （和上面添加方法的代码结构一样）</span><br><span class="line">        int cmp = key.compareTo(x.key);</span><br><span class="line">        if(cmp&lt;0)&#123; //2.1键小找左子树,只是找相同的键 没有删</span><br><span class="line">           x.left = delete(x.left, key); //一直沿着左向下找</span><br><span class="line">            </span><br><span class="line">        &#125;else if(cmp&gt;0)&#123; //2.2键大找右子树</span><br><span class="line">           x.right = delete(x.right, key);  //一直沿着右向下找</span><br><span class="line">           </span><br><span class="line">        &#125;else&#123; //2.3如果key = x结点的键，做真正的删除动作，删除x结点</span><br><span class="line">            </span><br><span class="line">            N --; //元素个数-1,只要到了这一步先减个数</span><br><span class="line">            //我们要用右子树的最小结点替换x</span><br><span class="line">            </span><br><span class="line">            //1.如果x结点没有右子树,只需要让x的左子树成为x，这样是顺次，因为上一排的一定比下一排的键大</span><br><span class="line">            if(x.right == null)&#123;</span><br><span class="line">                return x.left;</span><br><span class="line">            &#125;</span><br><span class="line">            //2.如果x结点没有左子树,只需要让x的右子树成为x ,这样是顺次，因为上一排的一定比下一排的键大</span><br><span class="line">            if(x.left == null)&#123;</span><br><span class="line">                return x.right;</span><br><span class="line">            &#125;</span><br><span class="line">            //3.左右子树都不为空，找右子树的最小结点：找x右子树 左子树 左子树。。。一直到左子树的最后一个</span><br><span class="line">            Node minNode = x.right; //找到x右子树</span><br><span class="line">            while(minNode.left != null)&#123; //如果还有左子树的话，就还没有到左边的最后一个</span><br><span class="line">                minNode = minNode.left; // 找左子树</span><br><span class="line">            &#125;</span><br><span class="line">            //删除最小结点：x右子树的左子树最后一个</span><br><span class="line">            Node n = x.right;</span><br><span class="line">            while(n.left != null)&#123;</span><br><span class="line">                if(n.left.left == null)&#123; //这时候n结点是左边倒数第二个结点，那么n.left就是最后一个结点，删除它</span><br><span class="line">                    n.left = null;     </span><br><span class="line">                &#125;else&#123;//n结点没有到左边倒数第二个结点时，让n向下走一位</span><br><span class="line">                    n = n.left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 用最小结点minNode替换x: minNode连接左右结点和父结点</span><br><span class="line">            minNode.left = x.left;</span><br><span class="line">            minNode.right = x.right;</span><br><span class="line">            x = minNode; //绑定父结点，因为是递归调用。我也不懂记住就完了</span><br><span class="line">            </span><br><span class="line">            //2.3else&#123;&#125;结束</span><br><span class="line">        &#125;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //查找整个树中最小的键</span><br><span class="line">    public Key min()&#123;</span><br><span class="line">        return min(root).key;</span><br><span class="line">    &#125;</span><br><span class="line">    //找指定子树x中最小键所在的节点 = x子树的最左的那个节点</span><br><span class="line">    private Node min(Node x)&#123;</span><br><span class="line">        if(x.left != null)&#123;</span><br><span class="line">            return min(x.left); //返回更新x结点</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return x;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //查找整个树中最大的键</span><br><span class="line">    public Key max()&#123;</span><br><span class="line">        return max(root).key;</span><br><span class="line">    &#125;</span><br><span class="line">    //查找指定子树x中最大键的结点:最右边</span><br><span class="line">    private Node max(Node x)&#123;</span><br><span class="line">        if(x.right != null)&#123;</span><br><span class="line">            return max(x.right);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="二叉树的基础遍历-深度优先"><a href="#二叉树的基础遍历-深度优先" class="headerlink" title="二叉树的基础遍历 - 深度优先"></a>二叉树的基础遍历 - 深度优先</h4><p><img src="/.io//D:%5Cblog%E5%A4%87%E4%BB%BD%E8%B5%84%E6%96%99%5C%E5%9B%BE%E7%89%87%5C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%5C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%5C%E6%95%B0%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E9%81%8D%E5%8E%86.png" alt="数的前中后遍历"></p>
<ul>
<li><p>前中后顺序是指根节点放进队列的顺序</p>
</li>
<li><p>深度遍历的全用递归</p>
</li>
<li><p>算法特点在<a href="https://lucifinil-x.github.io/2020/02/24/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/#more">https://lucifinil-x.github.io/2020/02/24/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/#more</a></p>
</li>
</ul>
<h5 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h5><ul>
<li><p>步奏： 1.把当前节点key放进队列 2.找到当前节点的左子树，不为空，递归遍历左子树 3.找到当前节点的左子树，不为空，递归遍历右子树</p>
</li>
<li><p>顺序特点：一层一层的来。先加根节点，再加下一层左根节点，再加下一层右根节点。遍历以上步奏</p>
</li>
<li><p>在BinaryTree类中添加代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//前序遍历：获取整个树中的所有的键,存在队列keys中 Ergodic：遍历</span><br><span class="line">    public Queue&lt;Key&gt; preErgodic()&#123;</span><br><span class="line">        Queue&lt;Key&gt; keys = new Queue&lt;&gt;();</span><br><span class="line">        preErgodic(root, keys);</span><br><span class="line">        return keys;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    //获取指定树x的所有键，并放到keys队列中。</span><br><span class="line">    //前序遍历就是先从左树开始向下，先把左子树的键放在队列再把右子树的键放在队列。</span><br><span class="line">    //因为是递归完成，所以只需要考虑一个二叉树的小分支</span><br><span class="line">    public void preErgodic(Node x, Queue&lt;Key&gt; keys)&#123;</span><br><span class="line">        //x可能为null，代表的子树为空，直接返回</span><br><span class="line">        if(x == null)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //把x结点的键放入队列keys</span><br><span class="line">        keys.enqueue(x.key);</span><br><span class="line">        </span><br><span class="line">        //递归遍历x的左子树 </span><br><span class="line">        //递归之前先判断有没有左子树</span><br><span class="line">        if(x.left !=null)&#123;</span><br><span class="line">            preErgodic(x.left, keys);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //递归遍历x的右子树</span><br><span class="line">        //递归之前先判断有没有右子树</span><br><span class="line">        if(x.right !=null)&#123;</span><br><span class="line">            preErgodic(x.right, keys);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="中序遍历-比较重要"><a href="#中序遍历-比较重要" class="headerlink" title="中序遍历 - 比较重要"></a>中序遍历 - 比较重要</h5><ul>
<li><p>步奏： 1.找到当前节点的左子树，如果不为空，递归遍历左子树 2.把当前节点key放进队列中 3.找到当前节点的右子树，如果不为空，递归遍历左子树</p>
</li>
<li><p>顺序特点： 键从小到大排列。 先加最下面最左边（最小键），再右边最小键，再加节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//中序遍历</span><br><span class="line">    public Queue&lt;Key&gt; midErgodic()&#123;</span><br><span class="line">        Queue&lt;Key&gt; keys = new Queue&lt;&gt;();</span><br><span class="line">        midErgodic(root, keys);</span><br><span class="line">        return keys;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void midErgodic(Node x, Queue&lt;Key&gt; keys)&#123;</span><br><span class="line">        //x可能为null，代表的子树为空，直接返回</span><br><span class="line">        if(x == null)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //递归遍历x的左子树 </span><br><span class="line">        //递归之前先判断有没有左子树</span><br><span class="line">        if(x.left !=null)&#123;</span><br><span class="line">            midErgodic(x.left, keys);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //把x结点的键放入队列keys</span><br><span class="line">        keys.enqueue(x.key);</span><br><span class="line">        </span><br><span class="line">        //递归遍历x的右子树</span><br><span class="line">        //递归之前先判断有没有右子树</span><br><span class="line">        if(x.right !=null)&#123;</span><br><span class="line">            midErgodic(x.right, keys);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h5><ul>
<li>步奏： 1.找到当前节点的左子树，如果不为空，递归遍历左子树 2.找到当前节点的右子树，如果不为空，递归遍历左子树 3.把当前节点key放进队列中 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//后序遍历</span><br><span class="line">   public Queue&lt;Key&gt; afterErgodic()&#123;</span><br><span class="line">       Queue&lt;Key&gt; keys = new Queue&lt;&gt;();</span><br><span class="line">       afterErgodic(root, keys);</span><br><span class="line">       return keys;</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public void afterErgodic(Node x, Queue&lt;Key&gt; keys)&#123;</span><br><span class="line">       //x可能为null，代表的子树为空，直接返回</span><br><span class="line">       if(x == null)&#123;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       //递归遍历x的左子树 </span><br><span class="line">       //递归之前先判断有没有左子树</span><br><span class="line">       if(x.left !=null)&#123;</span><br><span class="line">           afterErgodic(x.left, keys);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       //递归遍历x的右子树</span><br><span class="line">       //递归之前先判断有没有右子树</span><br><span class="line">       if(x.right !=null)&#123;</span><br><span class="line">           afterErgodic(x.right, keys);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       //把x结点的键放入队列keys</span><br><span class="line">       keys.enqueue(x.key);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="二叉树的高级遍历-层序遍历-广度优先"><a href="#二叉树的高级遍历-层序遍历-广度优先" class="headerlink" title="二叉树的高级遍历 - 层序遍历 - 广度优先"></a>二叉树的高级遍历 - 层序遍历 - 广度优先</h4><p><img src="/images/2020-4-9-bianli2.png" alt="高级遍历"></p>
<ul>
<li><p>步奏：<br>1.定义两个队列，分别存储树中的键和树中的结点<br>2.结点队列加入根节点<br>3.while循环（当结点队列不为空）： 从结点队列中取出一个结点，将这个结点的key加入键队列； 如果当前结点的左子结点不为空，把左子结点放进结点队列；如果当前结点的右子结点不为空，把右子结点放进结点队列</p>
</li>
<li><p>顺序特点：每一层从左到右</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//层序遍历，所有键</span><br><span class="line">   public Queue&lt;Key&gt; layerErgodic() throws InterruptedException&#123;</span><br><span class="line">       //定义两个队列，分别存储树中的键和树中的结点</span><br><span class="line">       Queue&lt;Key&gt; keys = new Queue&lt;&gt;();</span><br><span class="line">       Queue&lt;Node&gt; nodes = new Queue&lt;&gt;();</span><br><span class="line">       //先放根节点</span><br><span class="line">       nodes.enqueue(root);</span><br><span class="line">       //循环，结束条件为队列中没有元素</span><br><span class="line">       while(! nodes.isEmpty())&#123;</span><br><span class="line">           //从队列中取出一个结点</span><br><span class="line">           Node n = nodes.dequeue();</span><br><span class="line">           keys.enqueue(n.key);</span><br><span class="line">           //有无左子</span><br><span class="line">           if(n.left != null)&#123;</span><br><span class="line">               nodes.enqueue(n.left);</span><br><span class="line">           &#125;</span><br><span class="line">           //有无右子</span><br><span class="line">           if(n.right != null)&#123;</span><br><span class="line">               nodes.enqueue(n.right);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return keys;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="二叉树的最大深度问题-树有几层"><a href="#二叉树的最大深度问题-树有几层" class="headerlink" title="二叉树的最大深度问题 - 树有几层"></a>二叉树的最大深度问题 - 树有几层</h4><ul>
<li>深度遍历,关于递归调用中 变量的初始化在递归调用之前，每次都是递归调用时候停顿，所以每次返回值是递归调用下面的ruturn值，所以不会再执行初始化的赋值。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//获取整个树的最大深度 - 几层</span><br><span class="line">    public int  maxDepth()&#123;</span><br><span class="line">        return maxDepth(root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int maxDepth(Node x)&#123;</span><br><span class="line">        //安全</span><br><span class="line">        if(x == null)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int max = 0;</span><br><span class="line">        int maxLeft = 0;</span><br><span class="line">        int maxRight = 0;</span><br><span class="line">        //计算x结点左子树最大深度</span><br><span class="line">        if(x.left != null)&#123;</span><br><span class="line">            maxLeft = maxDepth(x.left);</span><br><span class="line">        &#125;</span><br><span class="line">        //计算x结点左子树最大深度</span><br><span class="line">        if(x.right != null)&#123;</span><br><span class="line">            maxRight = maxDepth(x.right);</span><br><span class="line">        &#125;</span><br><span class="line">        //取上面两个中大的值+1</span><br><span class="line">        max = maxLeft&gt;maxRight ? maxLeft+1 : maxRight+1;</span><br><span class="line">        </span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="排序算法的消费"><a href="#排序算法的消费" class="headerlink" title="排序算法的消费"></a>排序算法的消费</h2><h2 id="贪婪算法的"><a href="#贪婪算法的" class="headerlink" title="贪婪算法的"></a>贪婪算法的</h2><h2 id="lectures"><a href="#lectures" class="headerlink" title="lectures"></a>lectures</h2><h3 id="L1"><a href="#L1" class="headerlink" title="L1"></a>L1</h3><ul>
<li>abstraction</li>
<li>Huffman编码<a href="https://blog.csdn.net/qinglongzhan/article/details/80983492" target="_blank" rel="noopener">https://blog.csdn.net/qinglongzhan/article/details/80983492</a></li>
<li>encapsulation</li>
<li>空间效率</li>
<li>时间效率</li>
<li>静态数据结构：创建的时候就固定了大小/内存空间，如:数组<br>不会内存分配溢出，不能添加空间。<br>必须保证有足够大的容量，可能装不下，可能浪费空间<br>时间效率好</li>
<li>动态数据结构：在运行中可以删减大小/内存空间，如:集合、链表<br>不需要知道具体大小，合理运用内存空间，添加内存会浪费时间<br>空间效率好</li>
</ul>
<h3 id="L2-使用java-集合库"><a href="#L2-使用java-集合库" class="headerlink" title="L2 使用java 集合库"></a>L2 使用java 集合库</h3><ul>
<li>线性collection 层次collection 有哪些</li>
<li>有哪些库： util(集合的，数组的) io swing/awt</li>
<li>Collection子类接口：<br>List 有序集合  子类：ArrayList LinkedList vector<br>Set 无序无重复集合  子类： HashSet  TreeSet<br>Queue 有序集合 队列尾添加，队列头出<br>Map 键值对  子类： HashMap TreeMap</li>
<li>接口特征，怎么样使用接口</li>
<li>parameterised typr泛型</li>
<li>ArrayList 的方法： 增删改查和属性 都是在本子上有的</li>
</ul>
<h3 id="L3-使用集合Collection-和list-和-迭代器-和泛型"><a href="#L3-使用集合Collection-和list-和-迭代器-和泛型" class="headerlink" title="L3 使用集合Collection 和list 和 迭代器 和泛型"></a>L3 使用集合Collection 和list 和 迭代器 和泛型</h3><h3 id="L4-Bag-Set-Stack-Map"><a href="#L4-Bag-Set-Stack-Map" class="headerlink" title="L4 Bag? Set Stack Map"></a>L4 Bag? Set Stack Map</h3><h3 id="L5-使用Map-队列和优先队列"><a href="#L5-使用Map-队列和优先队列" class="headerlink" title="L5 使用Map, 队列和优先队列"></a>L5 使用Map, 队列和优先队列</h3>
    </div>

    
    
    
        
      
        <div id="reward-container">
  <div>我这么可爱不给我投个币嘛~~ 有帮助的话可以打赏路路噢~~</div>
  <button id="reward-button" disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
        
      
      <div style="display: inline-block">
        <img src="/images/wechatpay.jpg" alt="Lucifinil 微信支付">
        <p>微信支付</p>
      </div>
        
      
      <div style="display: inline-block">
        <img src="/images/alipay.jpg" alt="Lucifinil 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

      

      <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2020/02/23/算法学习/" rel="next" title="算法学习">
                  <i class="fa fa-chevron-left"></i> 算法学习
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2020/02/24/操作系统原理/" rel="prev" title="操作系统原理">
                  操作系统原理 <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          
    
    <div class="comments" id="comments"></div>
  

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#认识数据结构：用来组织和存储数据的集合"><span class="nav-number">1.</span> <span class="nav-text">认识数据结构：用来组织和存储数据的集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#分类"><span class="nav-number">1.1.</span> <span class="nav-text">分类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#链表"><span class="nav-number">2.</span> <span class="nav-text">链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#单向链表"><span class="nav-number">2.1.</span> <span class="nav-text">单向链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#双向链表"><span class="nav-number">2.2.</span> <span class="nav-text">双向链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java中的LinkedList集合"><span class="nav-number">2.3.</span> <span class="nav-text">java中的LinkedList集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#单链表的反转"><span class="nav-number">2.4.</span> <span class="nav-text">单链表的反转</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#队列"><span class="nav-number">3.</span> <span class="nav-text">队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#队列实现"><span class="nav-number">3.1.</span> <span class="nav-text">队列实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优先队列-priority-queue"><span class="nav-number">3.2.</span> <span class="nav-text">优先队列(priority queue)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Graph-Combinatory"><span class="nav-number">4.</span> <span class="nav-text">Graph/Combinatory</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#图的术语"><span class="nav-number">4.1.</span> <span class="nav-text">图的术语</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#图的DFS-BFS"><span class="nav-number">4.2.</span> <span class="nav-text">图的DFS,BFS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#图的最小生成树"><span class="nav-number">4.3.</span> <span class="nav-text">图的最小生成树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Minimum-Spanning-Tree（最小生成树-）"><span class="nav-number">4.4.</span> <span class="nav-text">Minimum Spanning Tree（最小生成树)）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#生成树的性质"><span class="nav-number">4.4.1.</span> <span class="nav-text">生成树的性质</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#切分定理Boruvka’s-algorithm"><span class="nav-number">4.4.2.</span> <span class="nav-text">切分定理Borůvka’s algorithm</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#贪心算法-–计算图的最小生成树算法"><span class="nav-number">4.4.3.</span> <span class="nav-text">贪心算法 –计算图的最小生成树算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#prim算法-–贪心算法的一种特殊情况"><span class="nav-number">4.4.4.</span> <span class="nav-text">prim算法 –贪心算法的一种特殊情况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Kruskal算法-–贪心算法的一种特殊情况"><span class="nav-number">4.4.5.</span> <span class="nav-text">Kruskal算法 –贪心算法的一种特殊情况</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#树"><span class="nav-number">5.</span> <span class="nav-text">树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#树的定义"><span class="nav-number">5.1.</span> <span class="nav-text">树的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉树"><span class="nav-number">5.2.</span> <span class="nav-text">二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#二叉树分类"><span class="nav-number">5.2.1.</span> <span class="nav-text">二叉树分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二叉树的存储方式"><span class="nav-number">5.2.2.</span> <span class="nav-text">二叉树的存储方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#heap-data-structrue"><span class="nav-number">5.2.3.</span> <span class="nav-text">heap data structrue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#构造二叉树"><span class="nav-number">5.2.4.</span> <span class="nav-text">构造二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二叉树的遍历"><span class="nav-number">5.2.5.</span> <span class="nav-text">二叉树的遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#用链表实现-二叉查找树"><span class="nav-number">5.2.6.</span> <span class="nav-text">用链表实现 二叉查找树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二叉树的基础遍历-深度优先"><span class="nav-number">5.2.7.</span> <span class="nav-text">二叉树的基础遍历 - 深度优先</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#前序遍历"><span class="nav-number">5.2.7.1.</span> <span class="nav-text">前序遍历</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#中序遍历-比较重要"><span class="nav-number">5.2.7.2.</span> <span class="nav-text">中序遍历 - 比较重要</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#后序遍历"><span class="nav-number">5.2.7.3.</span> <span class="nav-text">后序遍历</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二叉树的高级遍历-层序遍历-广度优先"><span class="nav-number">5.2.8.</span> <span class="nav-text">二叉树的高级遍历 - 层序遍历 - 广度优先</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二叉树的最大深度问题-树有几层"><span class="nav-number">5.2.9.</span> <span class="nav-text">二叉树的最大深度问题 - 树有几层</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#排序算法的消费"><span class="nav-number">6.</span> <span class="nav-text">排序算法的消费</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#贪婪算法的"><span class="nav-number">7.</span> <span class="nav-text">贪婪算法的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lectures"><span class="nav-number">8.</span> <span class="nav-text">lectures</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#L1"><span class="nav-number">8.1.</span> <span class="nav-text">L1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#L2-使用java-集合库"><span class="nav-number">8.2.</span> <span class="nav-text">L2 使用java 集合库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#L3-使用集合Collection-和list-和-迭代器-和泛型"><span class="nav-number">8.3.</span> <span class="nav-text">L3 使用集合Collection 和list 和 迭代器 和泛型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#L4-Bag-Set-Stack-Map"><span class="nav-number">8.4.</span> <span class="nav-text">L4 Bag? Set Stack Map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#L5-使用Map-队列和优先队列"><span class="nav-number">8.5.</span> <span class="nav-text">L5 使用Map, 队列和优先队列</span></a></li></ol></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/touxiang1.jpg"
      alt="Lucifinil">
  <p class="site-author-name" itemprop="name">Lucifinil</p>
  <div class="site-description" itemprop="description"></div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">67</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/Lucifinil-x" title="GitHub &rarr; https://github.com/Lucifinil-x" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://weibo.com/2890499315/profile?rightmod=1&wvr=6&mod=personinfo&is_all=1" title="weibo &rarr; https://weibo.com/2890499315/profile?rightmod=1&wvr=6&mod=personinfo&is_all=1" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>weibo</a>
      </span>
    
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://Lucifinil.com/" title="http://Lucifinil.com/" rel="noopener" target="_blank">Lucifinil</a>
        </li>
      
    </ul>
  </div>

      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lucifinil</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.4.0</div>-->

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  
    <span class="post-meta-divider">|</span>
  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>












        
      </div>
    </footer>
  </div>

  


  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.0"></script><script src="/js/motion.js?v=7.4.0"></script>
<script src="/js/schemes/pisces.js?v=7.4.0"></script>
<script src="/js/next-boot.js?v=7.4.0"></script>

    
  
    
  

  <script>
  (function() {
    window.addEventListener('DOMContentLoaded', () => {
      let script = document.createElement('script');
      script.src = '/lib/three/three.min.js';
      document.body.appendChild(script);
    });
    let styles = ['/lib/three/three-waves.min.js', '', '/lib/three/canvas_sphere.min.js'];
    window.addEventListener('load', () => {
      styles.forEach(item => {
        if (item !== '') {
          let script = document.createElement('script');
          script.src = item;
          document.body.appendChild(script);
        }
      });
    });
  })();
  </script>


  








  <script src="/js/local-search.js?v=7.4.0"></script>














  

  

  


<script>
NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.includes(item);
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'oDY3PgVcs4KquzU5ExfpRIvL-gzGzoHsz',
    appKey: 'TfeAqOOA3dvfY8DgjnBCdFUI',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: '' || 'zh-cn',
    path: location.pathname
  });
}, window.Valine);
</script>

</body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>