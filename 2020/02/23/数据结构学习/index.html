<!DOCTYPE html>





<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.4.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">
  <link rel="stylesheet" href="/lib/pace/pace-theme-corner-indicator.min.css?v=1.0.2">
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":true,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="CSE104 数据结构，介绍基本的数据结构和性质和用法。20% 不是考试，两个assignment写java代码，一定要尽可能的细致，对于每一个可能的样本输入情况都要考虑周全。80% 期末考试，四分之三25道选择题和一道数据结构的大题，大题每年相似度很高。背书课：lecture slides, Q&amp;amp;As, in-class &amp;amp; take-home exercises, assign">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构学习">
<meta property="og:url" content="https://lucifinil-x.github.io/2020/02/23/数据结构学习/index.html">
<meta property="og:site_name" content="Sanctuary">
<meta property="og:description" content="CSE104 数据结构，介绍基本的数据结构和性质和用法。20% 不是考试，两个assignment写java代码，一定要尽可能的细致，对于每一个可能的样本输入情况都要考虑周全。80% 期末考试，四分之三25道选择题和一道数据结构的大题，大题每年相似度很高。背书课：lecture slides, Q&amp;amp;As, in-class &amp;amp; take-home exercises, assign">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://lucifinil-x.github.io/.io//D:%5Cblog%E5%A4%87%E4%BB%BD%E8%B5%84%E6%96%99%5C%E5%9B%BE%E7%89%87%5C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%5C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%5C%E6%95%B0%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E9%81%8D%E5%8E%86.png">
<meta property="og:image" content="https://lucifinil-x.github.io/images/2020-4-9-bianli2.png">
<meta property="og:updated_time" content="2020-06-19T09:09:50.918Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="数据结构学习">
<meta name="twitter:description" content="CSE104 数据结构，介绍基本的数据结构和性质和用法。20% 不是考试，两个assignment写java代码，一定要尽可能的细致，对于每一个可能的样本输入情况都要考虑周全。80% 期末考试，四分之三25道选择题和一道数据结构的大题，大题每年相似度很高。背书课：lecture slides, Q&amp;amp;As, in-class &amp;amp; take-home exercises, assign">
<meta name="twitter:image" content="https://lucifinil-x.github.io/.io//D:%5Cblog%E5%A4%87%E4%BB%BD%E8%B5%84%E6%96%99%5C%E5%9B%BE%E7%89%87%5C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%5C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%5C%E6%95%B0%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E9%81%8D%E5%8E%86.png">
  <link rel="canonical" href="https://lucifinil-x.github.io/2020/02/23/数据结构学习/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>数据结构学习 | Sanctuary</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Sanctuary</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger">
        
          <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
      </li>
    
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
      <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block post">
    <link itemprop="mainEntityOfPage" href="https://lucifinil-x.github.io/2020/02/23/数据结构学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lucifinil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/touxiang1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sanctuary">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">数据结构学习

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-02-23 23:39:52" itemprop="dateCreated datePublished" datetime="2020-02-23T23:39:52+08:00">2020-02-23</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-19 17:09:50" itemprop="dateModified" datetime="2020-06-19T17:09:50+08:00">2020-06-19</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/记忆性学习/" itemprop="url" rel="index"><span itemprop="name">记忆性学习</span></a></span>

                
                
              
            </span>
          

          
            <span class="post-meta-item" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
        
      
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/02/23/数据结构学习/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2020/02/23/数据结构学习/" itemprop="commentCount"></span></a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>CSE104 数据结构，介绍基本的数据结构和性质和用法。<br>20% 不是考试，两个assignment写java代码，一定要尽可能的细致，对于每一个可能的样本输入情况都要考虑周全。<br>80% 期末考试，四分之三25道选择题和一道数据结构的大题，大题每年相似度很高。<br>背书课：lecture slides, Q&amp;As, in-class &amp; take-home exercises, assignments</p><a id="more"></a>
<h2 id="认识数据结构：用来组织和存储数据的集合"><a href="#认识数据结构：用来组织和存储数据的集合" class="headerlink" title="认识数据结构：用来组织和存储数据的集合"></a>认识数据结构：用来组织和存储数据的集合</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li>1.逻辑结构分类: 按照数据元素之间的关系分类 抽象<br>  集合结构：元素之间没有关系<br>  线性结构 ：元素之间一对一的关系，如链表<br>  树形结构：一对多的关系，<br>  图形结构：多对多的关系</li>
<li>2.物理结构分类： 逻辑结构真正在计算机上存储的方式<br>  顺序结构： 连续的内存地址带着索引<pre><code>查找容易 用索引，插入删除难</code></pre>  链式结构： 内存单元可以是不连续的，数据单元之间用指针指向链接<pre><code>查找难 用遍历， 插入删除容易</code></pre></li>
</ul>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="队列实现"><a href="#队列实现" class="headerlink" title="队列实现"></a>队列实现</h3><p>先进先出，用单链表实现进队出队 by node的添加删除改变连接</p>
<h3 id="优先队列-priority-queue"><a href="#优先队列-priority-queue" class="headerlink" title="优先队列(priority queue)"></a>优先队列(priority queue)</h3><ul>
<li><p>可以将优先级队列想象为已修改的队列，但是当一个人从队列中获取下一个元素时，将首先检索优先级最高的元素。</p>
</li>
<li><p>最小优先队列(min priority queue)中,查找操作用来搜索优先权最小的元素,删除操作用来删除该元素;对于最大优先队列(max priority queue),查找操作用来搜索优先权最大的元素,删除操作用来删除该元素.优先权队列中的元素可以有相同的优先权,查找与删除操作可根据任意优先权进行.</p>
</li>
<li><p>通常用堆实现</p>
</li>
<li><p>优先队列插入和删除元素的复杂度都是O(log2n)，所以很快</p>
</li>
</ul>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h3><ul>
<li>树是n个有限结点组成的一个具有层次关系的集合</li>
<li>术语：<br>1.结点的度：结点下面一排上有几个子节点<br>2.叶/终端结点： 无子节点的节点<br>3.节点的层次：节点在第几排<br>4.树的度：树的度=节点的度的最大值（子节点最多的节点的度）<br>5.森林：去掉根节点<br>6.子节点：A的直接前驱是B，A是B的子节点<br>7.父节点：A的直接前驱是B，B是A的父/双亲节点<br>8.双亲节点：两个节点的父节点相同</li>
</ul>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><ul>
<li>二叉树中每个节点最多两个子节点；两个分叉</li>
<li>满二叉树： 每一层的节点数达到最大值（每个节点都有两个子节点）</li>
<li>完全二叉树： 每一层结点放满再放下一层；也就是说叶节点只会出现在最后一层或次下层。</li>
</ul>
<h4 id="用链表实现-二叉查找树"><a href="#用链表实现-二叉查找树" class="headerlink" title="用链表实现 二叉查找树"></a>用链表实现 二叉查找树</h4><ul>
<li><p>结点Node类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Node&lt;Key,Value&gt; &#123;</span><br><span class="line">    //存储键</span><br><span class="line">     public Key key; //用键找值</span><br><span class="line">    </span><br><span class="line">    private Value value;</span><br><span class="line">    </span><br><span class="line">    public Node left;</span><br><span class="line">    </span><br><span class="line">    public Node right;</span><br><span class="line">    </span><br><span class="line">    public Node(Key key, Value value, Node left, Node right) &#123;</span><br><span class="line">        this.key = key;</span><br><span class="line">        this.value = value;</span><br><span class="line">        this.left = left;</span><br><span class="line">        this.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>二叉树类：添加结点；以键查找结点；以键删除结点；查找二叉树中最小键；查找二叉树中最大键</p>
</li>
</ul>
<p>[特点] 1.所有的方法都有同名重载方法：前面的是传入根节点的入口函数，后面是传入子节点的会使用递归的函数。</p>
<ol start="2">
<li>子树=结点下面所有结点<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line">public class BinaryTree&lt;Key extends Comparable&lt;Key&gt;, Value &gt; &#123; //以后要用键来排序</span><br><span class="line">    //记录根节点</span><br><span class="line">    private Node root;</span><br><span class="line">    //记录树中元素个数</span><br><span class="line">    private int N;</span><br><span class="line">    //内部类</span><br><span class="line">    private class Node&#123;</span><br><span class="line">        private Key key;</span><br><span class="line">        private Value value;</span><br><span class="line">        private Node left; //左节点</span><br><span class="line">        private Node right;//右节点</span><br><span class="line"></span><br><span class="line">        public Node(Key key, Value value, Node left, Node right) &#123;</span><br><span class="line">            this.key = key;</span><br><span class="line">            this.value = value;</span><br><span class="line">            this.left = left;</span><br><span class="line">            this.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取树中元素的个数</span><br><span class="line">    public int size()&#123;</span><br><span class="line">        return N;</span><br><span class="line">    &#125;</span><br><span class="line">    //向树中添加元素键值对,第一次添加根节点</span><br><span class="line">    public void put(Key key, Value value)&#123;</span><br><span class="line">        root = put(root, key,  value); //添加根节点，返回赋值给树 根节点;此时x=null</span><br><span class="line">    &#125;</span><br><span class="line">    //向指定的子树x添加键值对，并且返回添加元素后的新树</span><br><span class="line">    public Node put(Node x,Key key, Value value)&#123;</span><br><span class="line">        //1.如果x结点的子树为空,把添加的键值对作为x节点的子节点</span><br><span class="line">        if(x == null)&#123;</span><br><span class="line">            N++; //节点个数+1</span><br><span class="line">            return new Node(key, value, null , null); //无左右子节点</span><br><span class="line">        &#125;</span><br><span class="line">        //2.如果x节点的子树不为空</span><br><span class="line">        //2.1比较x结点的键和添加的key大小</span><br><span class="line">        //2.1.1如果key &lt; x结点的键，则继续找x结点的左子树</span><br><span class="line">        //2.1.2如果key &gt; x结点的键，则继续找x结点的右子树</span><br><span class="line">        //2.1.3如果key = x节点的键，则用添加的value替换x节点的原值.</span><br><span class="line">        int cmp = key.compareTo(x.key);</span><br><span class="line">        if(cmp&lt;0)&#123; //2.1.1</span><br><span class="line">            //这里是从x的左子节点下面插入键值对；完毕后将新的子树返回给x的左子节点</span><br><span class="line">            x.left = put(x.left, key, value); //递归调用只想它干了什么;这里会一直向下找直到找到子树为null时，创建新节点</span><br><span class="line">            </span><br><span class="line">        &#125;else if(cmp&gt;0)&#123; //2.1.2</span><br><span class="line">            //这里是从x的右子节点下面插入键值对；完毕后将新的子树返回给x的右子节点</span><br><span class="line">            x.right = put(x.right, key, value);</span><br><span class="line">            </span><br><span class="line">        &#125;else&#123; //2.1.3</span><br><span class="line">            x.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">        return x; //返回更新后的节点x信息</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //用键找值</span><br><span class="line">    public Value get(Key key)&#123;</span><br><span class="line">        return get(root, key);// 从根节点开始找</span><br><span class="line">    &#125;</span><br><span class="line">    //从指定子树x中，用键找值</span><br><span class="line">    public Value get(Node x, Key key)&#123;</span><br><span class="line">        //1.x树为null,没有找到 返回null就行</span><br><span class="line">        if(x == null)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //2.x不为null ,就要进行x树下面的键比较 （和上面添加方法的代码结构一样）</span><br><span class="line">        int cmp = key.compareTo(x.key);</span><br><span class="line">        if(cmp&lt;0)&#123; //2.1.1 键小与节点找左子树</span><br><span class="line">           return get(x.left, key); //这里是不仅要找，然后找了之后要返回找到的子树结点</span><br><span class="line">            </span><br><span class="line">        &#125;else if(cmp&gt;0)&#123; //2.1.2 键大找右子树</span><br><span class="line">           return get(x.right, key);</span><br><span class="line">           </span><br><span class="line">            </span><br><span class="line">        &#125;else&#123; //2.1.3 相等就找到了，返回键对应的值</span><br><span class="line">            return(x.value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //删除键值对结点。这是一个比较麻烦的操作，删除一个之后，要找一个结点来替换删除的节点</span><br><span class="line">    //因为左子树都小于右子树，新节点需要比左子树大，比右子树小。所以在右子树中找最左的节点（右子树中最小的节点）</span><br><span class="line">    public void delete(Key key)&#123;</span><br><span class="line">        delete(root, key); //入口，先从根节点开始判断删不删</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //删除指定节点树x的键值对，返回新子树</span><br><span class="line">    public Node delete(Node x, Key key)&#123;</span><br><span class="line">        //1.x树为null 安全检查</span><br><span class="line">        if(x ==null)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //2.x树不为null,就要进行x树下面的键比较 （和上面添加方法的代码结构一样）</span><br><span class="line">        int cmp = key.compareTo(x.key);</span><br><span class="line">        if(cmp&lt;0)&#123; //2.1键小找左子树,只是找相同的键 没有删</span><br><span class="line">           x.left = delete(x.left, key); //一直沿着左向下找</span><br><span class="line">            </span><br><span class="line">        &#125;else if(cmp&gt;0)&#123; //2.2键大找右子树</span><br><span class="line">           x.right = delete(x.right, key);  //一直沿着右向下找</span><br><span class="line">           </span><br><span class="line">        &#125;else&#123; //2.3如果key = x结点的键，做真正的删除动作，删除x结点</span><br><span class="line">            </span><br><span class="line">            N --; //元素个数-1,只要到了这一步先减个数</span><br><span class="line">            //我们要用右子树的最小结点替换x</span><br><span class="line">            </span><br><span class="line">            //1.如果x结点没有右子树,只需要让x的左子树成为x，这样是顺次，因为上一排的一定比下一排的键大</span><br><span class="line">            if(x.right == null)&#123;</span><br><span class="line">                return x.left;</span><br><span class="line">            &#125;</span><br><span class="line">            //2.如果x结点没有左子树,只需要让x的右子树成为x ,这样是顺次，因为上一排的一定比下一排的键大</span><br><span class="line">            if(x.left == null)&#123;</span><br><span class="line">                return x.right;</span><br><span class="line">            &#125;</span><br><span class="line">            //3.左右子树都不为空，找右子树的最小结点：找x右子树 左子树 左子树。。。一直到左子树的最后一个</span><br><span class="line">            Node minNode = x.right; //找到x右子树</span><br><span class="line">            while(minNode.left != null)&#123; //如果还有左子树的话，就还没有到左边的最后一个</span><br><span class="line">                minNode = minNode.left; // 找左子树</span><br><span class="line">            &#125;</span><br><span class="line">            //删除最小结点：x右子树的左子树最后一个</span><br><span class="line">            Node n = x.right;</span><br><span class="line">            while(n.left != null)&#123;</span><br><span class="line">                if(n.left.left == null)&#123; //这时候n结点是左边倒数第二个结点，那么n.left就是最后一个结点，删除它</span><br><span class="line">                    n.left = null;     </span><br><span class="line">                &#125;else&#123;//n结点没有到左边倒数第二个结点时，让n向下走一位</span><br><span class="line">                    n = n.left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 用最小结点minNode替换x: minNode连接左右结点和父结点</span><br><span class="line">            minNode.left = x.left;</span><br><span class="line">            minNode.right = x.right;</span><br><span class="line">            x = minNode; //绑定父结点，因为是递归调用。我也不懂记住就完了</span><br><span class="line">            </span><br><span class="line">            //2.3else&#123;&#125;结束</span><br><span class="line">        &#125;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //查找整个树中最小的键</span><br><span class="line">    public Key min()&#123;</span><br><span class="line">        return min(root).key;</span><br><span class="line">    &#125;</span><br><span class="line">    //找指定子树x中最小键所在的节点 = x子树的最左的那个节点</span><br><span class="line">    private Node min(Node x)&#123;</span><br><span class="line">        if(x.left != null)&#123;</span><br><span class="line">            return min(x.left); //返回更新x结点</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return x;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //查找整个树中最大的键</span><br><span class="line">    public Key max()&#123;</span><br><span class="line">        return max(root).key;</span><br><span class="line">    &#125;</span><br><span class="line">    //查找指定子树x中最大键的结点:最右边</span><br><span class="line">    private Node max(Node x)&#123;</span><br><span class="line">        if(x.right != null)&#123;</span><br><span class="line">            return max(x.right);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="二叉树的基础遍历-深度优先"><a href="#二叉树的基础遍历-深度优先" class="headerlink" title="二叉树的基础遍历 - 深度优先"></a>二叉树的基础遍历 - 深度优先</h4><p><img src="/.io//D:%5Cblog%E5%A4%87%E4%BB%BD%E8%B5%84%E6%96%99%5C%E5%9B%BE%E7%89%87%5C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%5C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%5C%E6%95%B0%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E9%81%8D%E5%8E%86.png" alt="数的前中后遍历"></p>
<ul>
<li><p>前中后顺序是指根节点放进队列的顺序</p>
</li>
<li><p>深度遍历的全用递归</p>
</li>
<li><p>算法特点在<a href="https://lucifinil-x.github.io/2020/02/24/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/#more">https://lucifinil-x.github.io/2020/02/24/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/#more</a></p>
</li>
</ul>
<h5 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h5><ul>
<li><p>步奏： 1.把当前节点key放进队列 2.找到当前节点的左子树，不为空，递归遍历左子树 3.找到当前节点的左子树，不为空，递归遍历右子树</p>
</li>
<li><p>顺序特点：一层一层的来。先加根节点，再加下一层左根节点，再加下一层右根节点。遍历以上步奏</p>
</li>
<li><p>在BinaryTree类中添加代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//前序遍历：获取整个树中的所有的键,存在队列keys中 Ergodic：遍历</span><br><span class="line">    public Queue&lt;Key&gt; preErgodic()&#123;</span><br><span class="line">        Queue&lt;Key&gt; keys = new Queue&lt;&gt;();</span><br><span class="line">        preErgodic(root, keys);</span><br><span class="line">        return keys;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    //获取指定树x的所有键，并放到keys队列中。</span><br><span class="line">    //前序遍历就是先从左树开始向下，先把左子树的键放在队列再把右子树的键放在队列。</span><br><span class="line">    //因为是递归完成，所以只需要考虑一个二叉树的小分支</span><br><span class="line">    public void preErgodic(Node x, Queue&lt;Key&gt; keys)&#123;</span><br><span class="line">        //x可能为null，代表的子树为空，直接返回</span><br><span class="line">        if(x == null)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //把x结点的键放入队列keys</span><br><span class="line">        keys.enqueue(x.key);</span><br><span class="line">        </span><br><span class="line">        //递归遍历x的左子树 </span><br><span class="line">        //递归之前先判断有没有左子树</span><br><span class="line">        if(x.left !=null)&#123;</span><br><span class="line">            preErgodic(x.left, keys);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //递归遍历x的右子树</span><br><span class="line">        //递归之前先判断有没有右子树</span><br><span class="line">        if(x.right !=null)&#123;</span><br><span class="line">            preErgodic(x.right, keys);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="中序遍历-比较重要"><a href="#中序遍历-比较重要" class="headerlink" title="中序遍历 - 比较重要"></a>中序遍历 - 比较重要</h5><ul>
<li><p>步奏： 1.找到当前节点的左子树，如果不为空，递归遍历左子树 2.把当前节点key放进队列中 3.找到当前节点的右子树，如果不为空，递归遍历左子树</p>
</li>
<li><p>顺序特点： 键从小到大排列。 先加最下面最左边（最小键），再右边最小键，再加节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//中序遍历</span><br><span class="line">    public Queue&lt;Key&gt; midErgodic()&#123;</span><br><span class="line">        Queue&lt;Key&gt; keys = new Queue&lt;&gt;();</span><br><span class="line">        midErgodic(root, keys);</span><br><span class="line">        return keys;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void midErgodic(Node x, Queue&lt;Key&gt; keys)&#123;</span><br><span class="line">        //x可能为null，代表的子树为空，直接返回</span><br><span class="line">        if(x == null)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //递归遍历x的左子树 </span><br><span class="line">        //递归之前先判断有没有左子树</span><br><span class="line">        if(x.left !=null)&#123;</span><br><span class="line">            midErgodic(x.left, keys);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //把x结点的键放入队列keys</span><br><span class="line">        keys.enqueue(x.key);</span><br><span class="line">        </span><br><span class="line">        //递归遍历x的右子树</span><br><span class="line">        //递归之前先判断有没有右子树</span><br><span class="line">        if(x.right !=null)&#123;</span><br><span class="line">            midErgodic(x.right, keys);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h5><ul>
<li>步奏： 1.找到当前节点的左子树，如果不为空，递归遍历左子树 2.找到当前节点的右子树，如果不为空，递归遍历左子树 3.把当前节点key放进队列中 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//后序遍历</span><br><span class="line">   public Queue&lt;Key&gt; afterErgodic()&#123;</span><br><span class="line">       Queue&lt;Key&gt; keys = new Queue&lt;&gt;();</span><br><span class="line">       afterErgodic(root, keys);</span><br><span class="line">       return keys;</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public void afterErgodic(Node x, Queue&lt;Key&gt; keys)&#123;</span><br><span class="line">       //x可能为null，代表的子树为空，直接返回</span><br><span class="line">       if(x == null)&#123;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       //递归遍历x的左子树 </span><br><span class="line">       //递归之前先判断有没有左子树</span><br><span class="line">       if(x.left !=null)&#123;</span><br><span class="line">           afterErgodic(x.left, keys);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       //递归遍历x的右子树</span><br><span class="line">       //递归之前先判断有没有右子树</span><br><span class="line">       if(x.right !=null)&#123;</span><br><span class="line">           afterErgodic(x.right, keys);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       //把x结点的键放入队列keys</span><br><span class="line">       keys.enqueue(x.key);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="二叉树的高级遍历-层序遍历-广度优先"><a href="#二叉树的高级遍历-层序遍历-广度优先" class="headerlink" title="二叉树的高级遍历 - 层序遍历 - 广度优先"></a>二叉树的高级遍历 - 层序遍历 - 广度优先</h4><p><img src="/images/2020-4-9-bianli2.png" alt="高级遍历"></p>
<ul>
<li><p>步奏：<br>1.定义两个队列，分别存储树中的键和树中的结点<br>2.结点队列加入根节点<br>3.while循环（当结点队列不为空）： 从结点队列中取出一个结点，将这个结点的key加入键队列； 如果当前结点的左子结点不为空，把左子结点放进结点队列；如果当前结点的右子结点不为空，把右子结点放进结点队列</p>
</li>
<li><p>顺序特点：每一层从左到右</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//层序遍历，所有键</span><br><span class="line">   public Queue&lt;Key&gt; layerErgodic() throws InterruptedException&#123;</span><br><span class="line">       //定义两个队列，分别存储树中的键和树中的结点</span><br><span class="line">       Queue&lt;Key&gt; keys = new Queue&lt;&gt;();</span><br><span class="line">       Queue&lt;Node&gt; nodes = new Queue&lt;&gt;();</span><br><span class="line">       //先放根节点</span><br><span class="line">       nodes.enqueue(root);</span><br><span class="line">       //循环，结束条件为队列中没有元素</span><br><span class="line">       while(! nodes.isEmpty())&#123;</span><br><span class="line">           //从队列中取出一个结点</span><br><span class="line">           Node n = nodes.dequeue();</span><br><span class="line">           keys.enqueue(n.key);</span><br><span class="line">           //有无左子</span><br><span class="line">           if(n.left != null)&#123;</span><br><span class="line">               nodes.enqueue(n.left);</span><br><span class="line">           &#125;</span><br><span class="line">           //有无右子</span><br><span class="line">           if(n.right != null)&#123;</span><br><span class="line">               nodes.enqueue(n.right);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return keys;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="二叉树的最大深度问题-树有几层"><a href="#二叉树的最大深度问题-树有几层" class="headerlink" title="二叉树的最大深度问题 - 树有几层"></a>二叉树的最大深度问题 - 树有几层</h4><ul>
<li>深度遍历,关于递归调用中 变量的初始化在递归调用之前，每次都是递归调用时候停顿，所以每次返回值是递归调用下面的ruturn值，所以不会再执行初始化的赋值。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//获取整个树的最大深度 - 几层</span><br><span class="line">    public int  maxDepth()&#123;</span><br><span class="line">        return maxDepth(root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int maxDepth(Node x)&#123;</span><br><span class="line">        //安全</span><br><span class="line">        if(x == null)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int max = 0;</span><br><span class="line">        int maxLeft = 0;</span><br><span class="line">        int maxRight = 0;</span><br><span class="line">        //计算x结点左子树最大深度</span><br><span class="line">        if(x.left != null)&#123;</span><br><span class="line">            maxLeft = maxDepth(x.left);</span><br><span class="line">        &#125;</span><br><span class="line">        //计算x结点左子树最大深度</span><br><span class="line">        if(x.right != null)&#123;</span><br><span class="line">            maxRight = maxDepth(x.right);</span><br><span class="line">        &#125;</span><br><span class="line">        //取上面两个中大的值+1</span><br><span class="line">        max = maxLeft&gt;maxRight ? maxLeft+1 : maxRight+1;</span><br><span class="line">        </span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="排序算法的消费"><a href="#排序算法的消费" class="headerlink" title="排序算法的消费"></a>排序算法的消费</h2><h2 id="贪婪算法的"><a href="#贪婪算法的" class="headerlink" title="贪婪算法的"></a>贪婪算法的</h2><h2 id="lectures"><a href="#lectures" class="headerlink" title="lectures"></a>lectures</h2><h3 id="L1"><a href="#L1" class="headerlink" title="L1"></a>L1</h3><ul>
<li>abstraction</li>
<li>Huffman编码<a href="https://blog.csdn.net/qinglongzhan/article/details/80983492" target="_blank" rel="noopener">https://blog.csdn.net/qinglongzhan/article/details/80983492</a></li>
<li>encapsulation</li>
<li>空间效率</li>
<li>时间效率</li>
<li>静态数据结构：创建的时候就固定了大小/内存空间，如:数组<br>不会内存分配溢出，不能添加空间。<br>必须保证有足够大的容量，可能装不下，可能浪费空间<br>时间效率好</li>
<li>动态数据结构：在运行中可以删减大小/内存空间，如:集合、链表<br>不需要知道具体大小，合理运用内存空间，添加内存会浪费时间<br>空间效率好</li>
</ul>
<h3 id="L2-使用java-集合库"><a href="#L2-使用java-集合库" class="headerlink" title="L2 使用java 集合库"></a>L2 使用java 集合库</h3><ul>
<li>线性collection 层次collection 有哪些</li>
<li>有哪些库： util(集合的，数组的) io swing/awt</li>
<li>Collection子类接口：<br>List 有序集合  子类：ArrayList LinkedList vector<br>Set 无序无重复集合  子类： HashSet  TreeSet<br>Queue 有序集合 队列尾添加，队列头出<br>Map 键值对  子类： HashMap TreeMap</li>
<li>接口特征，怎么样使用接口</li>
<li>parameterised typr泛型</li>
<li>ArrayList 的方法： 增删改查和属性 都是在本子上有的</li>
</ul>
<h3 id="L3-使用集合Collection-和list-和-迭代器-和泛型"><a href="#L3-使用集合Collection-和list-和-迭代器-和泛型" class="headerlink" title="L3 使用集合Collection 和list 和 迭代器 和泛型"></a>L3 使用集合Collection 和list 和 迭代器 和泛型</h3><h3 id="L4-Bag-Set-Stack-Map"><a href="#L4-Bag-Set-Stack-Map" class="headerlink" title="L4 Bag? Set Stack Map"></a>L4 Bag? Set Stack Map</h3><h3 id="L5-使用Map-队列和优先队列"><a href="#L5-使用Map-队列和优先队列" class="headerlink" title="L5 使用Map, 队列和优先队列"></a>L5 使用Map, 队列和优先队列</h3>
    </div>

    
    
    
        
      
        <div id="reward-container">
  <div>我这么可爱不给我投个币嘛~~ 有帮助的话可以打赏路路噢~~</div>
  <button id="reward-button" disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
        
      
      <div style="display: inline-block">
        <img src="/images/wechatpay.jpg" alt="Lucifinil 微信支付">
        <p>微信支付</p>
      </div>
        
      
      <div style="display: inline-block">
        <img src="/images/alipay.jpg" alt="Lucifinil 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

      

      <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2020/02/23/算法学习/" rel="next" title="算法学习">
                  <i class="fa fa-chevron-left"></i> 算法学习
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2020/02/24/操作系统原理/" rel="prev" title="操作系统原理">
                  操作系统原理 <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          
    
    <div class="comments" id="comments"></div>
  

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#认识数据结构：用来组织和存储数据的集合"><span class="nav-number">1.</span> <span class="nav-text">认识数据结构：用来组织和存储数据的集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#分类"><span class="nav-number">1.1.</span> <span class="nav-text">分类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#链表"><span class="nav-number">2.</span> <span class="nav-text">链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#队列"><span class="nav-number">3.</span> <span class="nav-text">队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#队列实现"><span class="nav-number">3.1.</span> <span class="nav-text">队列实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优先队列-priority-queue"><span class="nav-number">3.2.</span> <span class="nav-text">优先队列(priority queue)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#异常"><span class="nav-number">4.</span> <span class="nav-text">异常</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#图论"><span class="nav-number">5.</span> <span class="nav-text">图论</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#树"><span class="nav-number">6.</span> <span class="nav-text">树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#树的定义"><span class="nav-number">6.1.</span> <span class="nav-text">树的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉树"><span class="nav-number">6.2.</span> <span class="nav-text">二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#用链表实现-二叉查找树"><span class="nav-number">6.2.1.</span> <span class="nav-text">用链表实现 二叉查找树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二叉树的基础遍历-深度优先"><span class="nav-number">6.2.2.</span> <span class="nav-text">二叉树的基础遍历 - 深度优先</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#前序遍历"><span class="nav-number">6.2.2.1.</span> <span class="nav-text">前序遍历</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#中序遍历-比较重要"><span class="nav-number">6.2.2.2.</span> <span class="nav-text">中序遍历 - 比较重要</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#后序遍历"><span class="nav-number">6.2.2.3.</span> <span class="nav-text">后序遍历</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二叉树的高级遍历-层序遍历-广度优先"><span class="nav-number">6.2.3.</span> <span class="nav-text">二叉树的高级遍历 - 层序遍历 - 广度优先</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二叉树的最大深度问题-树有几层"><span class="nav-number">6.2.4.</span> <span class="nav-text">二叉树的最大深度问题 - 树有几层</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#排序算法的消费"><span class="nav-number">7.</span> <span class="nav-text">排序算法的消费</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#贪婪算法的"><span class="nav-number">8.</span> <span class="nav-text">贪婪算法的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lectures"><span class="nav-number">9.</span> <span class="nav-text">lectures</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#L1"><span class="nav-number">9.1.</span> <span class="nav-text">L1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#L2-使用java-集合库"><span class="nav-number">9.2.</span> <span class="nav-text">L2 使用java 集合库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#L3-使用集合Collection-和list-和-迭代器-和泛型"><span class="nav-number">9.3.</span> <span class="nav-text">L3 使用集合Collection 和list 和 迭代器 和泛型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#L4-Bag-Set-Stack-Map"><span class="nav-number">9.4.</span> <span class="nav-text">L4 Bag? Set Stack Map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#L5-使用Map-队列和优先队列"><span class="nav-number">9.5.</span> <span class="nav-text">L5 使用Map, 队列和优先队列</span></a></li></ol></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/touxiang1.jpg"
      alt="Lucifinil">
  <p class="site-author-name" itemprop="name">Lucifinil</p>
  <div class="site-description" itemprop="description"></div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">64</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/Lucifinil-x" title="GitHub &rarr; https://github.com/Lucifinil-x" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://weibo.com/2890499315/profile?rightmod=1&wvr=6&mod=personinfo&is_all=1" title="weibo &rarr; https://weibo.com/2890499315/profile?rightmod=1&wvr=6&mod=personinfo&is_all=1" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>weibo</a>
      </span>
    
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://Lucifinil.com/" title="http://Lucifinil.com/" rel="noopener" target="_blank">Lucifinil</a>
        </li>
      
    </ul>
  </div>

      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lucifinil</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.4.0</div>-->

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  
    <span class="post-meta-divider">|</span>
  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>












        
      </div>
    </footer>
  </div>

  


  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.0"></script><script src="/js/motion.js?v=7.4.0"></script>
<script src="/js/schemes/pisces.js?v=7.4.0"></script>
<script src="/js/next-boot.js?v=7.4.0"></script>

    
  
    
  

  <script>
  (function() {
    window.addEventListener('DOMContentLoaded', () => {
      let script = document.createElement('script');
      script.src = '/lib/three/three.min.js';
      document.body.appendChild(script);
    });
    let styles = ['/lib/three/three-waves.min.js', '', '/lib/three/canvas_sphere.min.js'];
    window.addEventListener('load', () => {
      styles.forEach(item => {
        if (item !== '') {
          let script = document.createElement('script');
          script.src = item;
          document.body.appendChild(script);
        }
      });
    });
  })();
  </script>


  








  <script src="/js/local-search.js?v=7.4.0"></script>














  

  

  


<script>
NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.includes(item);
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'oDY3PgVcs4KquzU5ExfpRIvL-gzGzoHsz',
    appKey: 'TfeAqOOA3dvfY8DgjnBCdFUI',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: '' || 'zh-cn',
    path: location.pathname
  });
}, window.Valine);
</script>

</body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>